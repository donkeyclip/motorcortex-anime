/******/ (function(modules) { // webpackBootstrap
/******/ 	function hotDisposeChunk(chunkId) {
/******/ 		delete installedChunks[chunkId];
/******/ 	}
/******/ 	var parentHotUpdateCallback = window["webpackHotUpdate"];
/******/ 	window["webpackHotUpdate"] = // eslint-disable-next-line no-unused-vars
/******/ 	function webpackHotUpdateCallback(chunkId, moreModules) {
/******/ 		hotAddUpdateChunk(chunkId, moreModules);
/******/ 		if (parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
/******/ 	} ;
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotDownloadUpdateChunk(chunkId) {
/******/ 		var script = document.createElement("script");
/******/ 		script.charset = "utf-8";
/******/ 		script.src = __webpack_require__.p + "" + chunkId + "." + hotCurrentHash + ".hot-update.js";
/******/ 		if (null) script.crossOrigin = null;
/******/ 		document.head.appendChild(script);
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotDownloadManifest(requestTimeout) {
/******/ 		requestTimeout = requestTimeout || 10000;
/******/ 		return new Promise(function(resolve, reject) {
/******/ 			if (typeof XMLHttpRequest === "undefined") {
/******/ 				return reject(new Error("No browser support"));
/******/ 			}
/******/ 			try {
/******/ 				var request = new XMLHttpRequest();
/******/ 				var requestPath = __webpack_require__.p + "" + hotCurrentHash + ".hot-update.json";
/******/ 				request.open("GET", requestPath, true);
/******/ 				request.timeout = requestTimeout;
/******/ 				request.send(null);
/******/ 			} catch (err) {
/******/ 				return reject(err);
/******/ 			}
/******/ 			request.onreadystatechange = function() {
/******/ 				if (request.readyState !== 4) return;
/******/ 				if (request.status === 0) {
/******/ 					// timeout
/******/ 					reject(
/******/ 						new Error("Manifest request to " + requestPath + " timed out.")
/******/ 					);
/******/ 				} else if (request.status === 404) {
/******/ 					// no update available
/******/ 					resolve();
/******/ 				} else if (request.status !== 200 && request.status !== 304) {
/******/ 					// other failure
/******/ 					reject(new Error("Manifest request to " + requestPath + " failed."));
/******/ 				} else {
/******/ 					// success
/******/ 					try {
/******/ 						var update = JSON.parse(request.responseText);
/******/ 					} catch (e) {
/******/ 						reject(e);
/******/ 						return;
/******/ 					}
/******/ 					resolve(update);
/******/ 				}
/******/ 			};
/******/ 		});
/******/ 	}
/******/
/******/ 	var hotApplyOnUpdate = true;
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	var hotCurrentHash = "a7636eeba81bac0693a5";
/******/ 	var hotRequestTimeout = 10000;
/******/ 	var hotCurrentModuleData = {};
/******/ 	var hotCurrentChildModule;
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	var hotCurrentParents = [];
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	var hotCurrentParentsTemp = [];
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotCreateRequire(moduleId) {
/******/ 		var me = installedModules[moduleId];
/******/ 		if (!me) return __webpack_require__;
/******/ 		var fn = function(request) {
/******/ 			if (me.hot.active) {
/******/ 				if (installedModules[request]) {
/******/ 					if (installedModules[request].parents.indexOf(moduleId) === -1) {
/******/ 						installedModules[request].parents.push(moduleId);
/******/ 					}
/******/ 				} else {
/******/ 					hotCurrentParents = [moduleId];
/******/ 					hotCurrentChildModule = request;
/******/ 				}
/******/ 				if (me.children.indexOf(request) === -1) {
/******/ 					me.children.push(request);
/******/ 				}
/******/ 			} else {
/******/ 				console.warn(
/******/ 					"[HMR] unexpected require(" +
/******/ 						request +
/******/ 						") from disposed module " +
/******/ 						moduleId
/******/ 				);
/******/ 				hotCurrentParents = [];
/******/ 			}
/******/ 			return __webpack_require__(request);
/******/ 		};
/******/ 		var ObjectFactory = function ObjectFactory(name) {
/******/ 			return {
/******/ 				configurable: true,
/******/ 				enumerable: true,
/******/ 				get: function() {
/******/ 					return __webpack_require__[name];
/******/ 				},
/******/ 				set: function(value) {
/******/ 					__webpack_require__[name] = value;
/******/ 				}
/******/ 			};
/******/ 		};
/******/ 		for (var name in __webpack_require__) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(__webpack_require__, name) &&
/******/ 				name !== "e" &&
/******/ 				name !== "t"
/******/ 			) {
/******/ 				Object.defineProperty(fn, name, ObjectFactory(name));
/******/ 			}
/******/ 		}
/******/ 		fn.e = function(chunkId) {
/******/ 			if (hotStatus === "ready") hotSetStatus("prepare");
/******/ 			hotChunksLoading++;
/******/ 			return __webpack_require__.e(chunkId).then(finishChunkLoading, function(err) {
/******/ 				finishChunkLoading();
/******/ 				throw err;
/******/ 			});
/******/
/******/ 			function finishChunkLoading() {
/******/ 				hotChunksLoading--;
/******/ 				if (hotStatus === "prepare") {
/******/ 					if (!hotWaitingFilesMap[chunkId]) {
/******/ 						hotEnsureUpdateChunk(chunkId);
/******/ 					}
/******/ 					if (hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 						hotUpdateDownloaded();
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		fn.t = function(value, mode) {
/******/ 			if (mode & 1) value = fn(value);
/******/ 			return __webpack_require__.t(value, mode & ~1);
/******/ 		};
/******/ 		return fn;
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotCreateModule(moduleId) {
/******/ 		var hot = {
/******/ 			// private stuff
/******/ 			_acceptedDependencies: {},
/******/ 			_declinedDependencies: {},
/******/ 			_selfAccepted: false,
/******/ 			_selfDeclined: false,
/******/ 			_disposeHandlers: [],
/******/ 			_main: hotCurrentChildModule !== moduleId,
/******/
/******/ 			// Module API
/******/ 			active: true,
/******/ 			accept: function(dep, callback) {
/******/ 				if (dep === undefined) hot._selfAccepted = true;
/******/ 				else if (typeof dep === "function") hot._selfAccepted = dep;
/******/ 				else if (typeof dep === "object")
/******/ 					for (var i = 0; i < dep.length; i++)
/******/ 						hot._acceptedDependencies[dep[i]] = callback || function() {};
/******/ 				else hot._acceptedDependencies[dep] = callback || function() {};
/******/ 			},
/******/ 			decline: function(dep) {
/******/ 				if (dep === undefined) hot._selfDeclined = true;
/******/ 				else if (typeof dep === "object")
/******/ 					for (var i = 0; i < dep.length; i++)
/******/ 						hot._declinedDependencies[dep[i]] = true;
/******/ 				else hot._declinedDependencies[dep] = true;
/******/ 			},
/******/ 			dispose: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			addDisposeHandler: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			removeDisposeHandler: function(callback) {
/******/ 				var idx = hot._disposeHandlers.indexOf(callback);
/******/ 				if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 			},
/******/
/******/ 			// Management API
/******/ 			check: hotCheck,
/******/ 			apply: hotApply,
/******/ 			status: function(l) {
/******/ 				if (!l) return hotStatus;
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			addStatusHandler: function(l) {
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			removeStatusHandler: function(l) {
/******/ 				var idx = hotStatusHandlers.indexOf(l);
/******/ 				if (idx >= 0) hotStatusHandlers.splice(idx, 1);
/******/ 			},
/******/
/******/ 			//inherit from previous dispose call
/******/ 			data: hotCurrentModuleData[moduleId]
/******/ 		};
/******/ 		hotCurrentChildModule = undefined;
/******/ 		return hot;
/******/ 	}
/******/
/******/ 	var hotStatusHandlers = [];
/******/ 	var hotStatus = "idle";
/******/
/******/ 	function hotSetStatus(newStatus) {
/******/ 		hotStatus = newStatus;
/******/ 		for (var i = 0; i < hotStatusHandlers.length; i++)
/******/ 			hotStatusHandlers[i].call(null, newStatus);
/******/ 	}
/******/
/******/ 	// while downloading
/******/ 	var hotWaitingFiles = 0;
/******/ 	var hotChunksLoading = 0;
/******/ 	var hotWaitingFilesMap = {};
/******/ 	var hotRequestedFilesMap = {};
/******/ 	var hotAvailableFilesMap = {};
/******/ 	var hotDeferred;
/******/
/******/ 	// The update info
/******/ 	var hotUpdate, hotUpdateNewHash;
/******/
/******/ 	function toModuleId(id) {
/******/ 		var isNumber = +id + "" === id;
/******/ 		return isNumber ? +id : id;
/******/ 	}
/******/
/******/ 	function hotCheck(apply) {
/******/ 		if (hotStatus !== "idle") {
/******/ 			throw new Error("check() is only allowed in idle status");
/******/ 		}
/******/ 		hotApplyOnUpdate = apply;
/******/ 		hotSetStatus("check");
/******/ 		return hotDownloadManifest(hotRequestTimeout).then(function(update) {
/******/ 			if (!update) {
/******/ 				hotSetStatus("idle");
/******/ 				return null;
/******/ 			}
/******/ 			hotRequestedFilesMap = {};
/******/ 			hotWaitingFilesMap = {};
/******/ 			hotAvailableFilesMap = update.c;
/******/ 			hotUpdateNewHash = update.h;
/******/
/******/ 			hotSetStatus("prepare");
/******/ 			var promise = new Promise(function(resolve, reject) {
/******/ 				hotDeferred = {
/******/ 					resolve: resolve,
/******/ 					reject: reject
/******/ 				};
/******/ 			});
/******/ 			hotUpdate = {};
/******/ 			var chunkId = "main";
/******/ 			// eslint-disable-next-line no-lone-blocks
/******/ 			{
/******/ 				hotEnsureUpdateChunk(chunkId);
/******/ 			}
/******/ 			if (
/******/ 				hotStatus === "prepare" &&
/******/ 				hotChunksLoading === 0 &&
/******/ 				hotWaitingFiles === 0
/******/ 			) {
/******/ 				hotUpdateDownloaded();
/******/ 			}
/******/ 			return promise;
/******/ 		});
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotAddUpdateChunk(chunkId, moreModules) {
/******/ 		if (!hotAvailableFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
/******/ 			return;
/******/ 		hotRequestedFilesMap[chunkId] = false;
/******/ 		for (var moduleId in moreModules) {
/******/ 			if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				hotUpdate[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if (--hotWaitingFiles === 0 && hotChunksLoading === 0) {
/******/ 			hotUpdateDownloaded();
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotEnsureUpdateChunk(chunkId) {
/******/ 		if (!hotAvailableFilesMap[chunkId]) {
/******/ 			hotWaitingFilesMap[chunkId] = true;
/******/ 		} else {
/******/ 			hotRequestedFilesMap[chunkId] = true;
/******/ 			hotWaitingFiles++;
/******/ 			hotDownloadUpdateChunk(chunkId);
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotUpdateDownloaded() {
/******/ 		hotSetStatus("ready");
/******/ 		var deferred = hotDeferred;
/******/ 		hotDeferred = null;
/******/ 		if (!deferred) return;
/******/ 		if (hotApplyOnUpdate) {
/******/ 			// Wrap deferred object in Promise to mark it as a well-handled Promise to
/******/ 			// avoid triggering uncaught exception warning in Chrome.
/******/ 			// See https://bugs.chromium.org/p/chromium/issues/detail?id=465666
/******/ 			Promise.resolve()
/******/ 				.then(function() {
/******/ 					return hotApply(hotApplyOnUpdate);
/******/ 				})
/******/ 				.then(
/******/ 					function(result) {
/******/ 						deferred.resolve(result);
/******/ 					},
/******/ 					function(err) {
/******/ 						deferred.reject(err);
/******/ 					}
/******/ 				);
/******/ 		} else {
/******/ 			var outdatedModules = [];
/******/ 			for (var id in hotUpdate) {
/******/ 				if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 					outdatedModules.push(toModuleId(id));
/******/ 				}
/******/ 			}
/******/ 			deferred.resolve(outdatedModules);
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotApply(options) {
/******/ 		if (hotStatus !== "ready")
/******/ 			throw new Error("apply() is only allowed in ready status");
/******/ 		options = options || {};
/******/
/******/ 		var cb;
/******/ 		var i;
/******/ 		var j;
/******/ 		var module;
/******/ 		var moduleId;
/******/
/******/ 		function getAffectedStuff(updateModuleId) {
/******/ 			var outdatedModules = [updateModuleId];
/******/ 			var outdatedDependencies = {};
/******/
/******/ 			var queue = outdatedModules.map(function(id) {
/******/ 				return {
/******/ 					chain: [id],
/******/ 					id: id
/******/ 				};
/******/ 			});
/******/ 			while (queue.length > 0) {
/******/ 				var queueItem = queue.pop();
/******/ 				var moduleId = queueItem.id;
/******/ 				var chain = queueItem.chain;
/******/ 				module = installedModules[moduleId];
/******/ 				if (!module || module.hot._selfAccepted) continue;
/******/ 				if (module.hot._selfDeclined) {
/******/ 					return {
/******/ 						type: "self-declined",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				if (module.hot._main) {
/******/ 					return {
/******/ 						type: "unaccepted",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				for (var i = 0; i < module.parents.length; i++) {
/******/ 					var parentId = module.parents[i];
/******/ 					var parent = installedModules[parentId];
/******/ 					if (!parent) continue;
/******/ 					if (parent.hot._declinedDependencies[moduleId]) {
/******/ 						return {
/******/ 							type: "declined",
/******/ 							chain: chain.concat([parentId]),
/******/ 							moduleId: moduleId,
/******/ 							parentId: parentId
/******/ 						};
/******/ 					}
/******/ 					if (outdatedModules.indexOf(parentId) !== -1) continue;
/******/ 					if (parent.hot._acceptedDependencies[moduleId]) {
/******/ 						if (!outdatedDependencies[parentId])
/******/ 							outdatedDependencies[parentId] = [];
/******/ 						addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 						continue;
/******/ 					}
/******/ 					delete outdatedDependencies[parentId];
/******/ 					outdatedModules.push(parentId);
/******/ 					queue.push({
/******/ 						chain: chain.concat([parentId]),
/******/ 						id: parentId
/******/ 					});
/******/ 				}
/******/ 			}
/******/
/******/ 			return {
/******/ 				type: "accepted",
/******/ 				moduleId: updateModuleId,
/******/ 				outdatedModules: outdatedModules,
/******/ 				outdatedDependencies: outdatedDependencies
/******/ 			};
/******/ 		}
/******/
/******/ 		function addAllToSet(a, b) {
/******/ 			for (var i = 0; i < b.length; i++) {
/******/ 				var item = b[i];
/******/ 				if (a.indexOf(item) === -1) a.push(item);
/******/ 			}
/******/ 		}
/******/
/******/ 		// at begin all updates modules are outdated
/******/ 		// the "outdated" status can propagate to parents if they don't accept the children
/******/ 		var outdatedDependencies = {};
/******/ 		var outdatedModules = [];
/******/ 		var appliedUpdate = {};
/******/
/******/ 		var warnUnexpectedRequire = function warnUnexpectedRequire() {
/******/ 			console.warn(
/******/ 				"[HMR] unexpected require(" + result.moduleId + ") to disposed module"
/******/ 			);
/******/ 		};
/******/
/******/ 		for (var id in hotUpdate) {
/******/ 			if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 				moduleId = toModuleId(id);
/******/ 				/** @type {TODO} */
/******/ 				var result;
/******/ 				if (hotUpdate[id]) {
/******/ 					result = getAffectedStuff(moduleId);
/******/ 				} else {
/******/ 					result = {
/******/ 						type: "disposed",
/******/ 						moduleId: id
/******/ 					};
/******/ 				}
/******/ 				/** @type {Error|false} */
/******/ 				var abortError = false;
/******/ 				var doApply = false;
/******/ 				var doDispose = false;
/******/ 				var chainInfo = "";
/******/ 				if (result.chain) {
/******/ 					chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 				}
/******/ 				switch (result.type) {
/******/ 					case "self-declined":
/******/ 						if (options.onDeclined) options.onDeclined(result);
/******/ 						if (!options.ignoreDeclined)
/******/ 							abortError = new Error(
/******/ 								"Aborted because of self decline: " +
/******/ 									result.moduleId +
/******/ 									chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "declined":
/******/ 						if (options.onDeclined) options.onDeclined(result);
/******/ 						if (!options.ignoreDeclined)
/******/ 							abortError = new Error(
/******/ 								"Aborted because of declined dependency: " +
/******/ 									result.moduleId +
/******/ 									" in " +
/******/ 									result.parentId +
/******/ 									chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "unaccepted":
/******/ 						if (options.onUnaccepted) options.onUnaccepted(result);
/******/ 						if (!options.ignoreUnaccepted)
/******/ 							abortError = new Error(
/******/ 								"Aborted because " + moduleId + " is not accepted" + chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "accepted":
/******/ 						if (options.onAccepted) options.onAccepted(result);
/******/ 						doApply = true;
/******/ 						break;
/******/ 					case "disposed":
/******/ 						if (options.onDisposed) options.onDisposed(result);
/******/ 						doDispose = true;
/******/ 						break;
/******/ 					default:
/******/ 						throw new Error("Unexception type " + result.type);
/******/ 				}
/******/ 				if (abortError) {
/******/ 					hotSetStatus("abort");
/******/ 					return Promise.reject(abortError);
/******/ 				}
/******/ 				if (doApply) {
/******/ 					appliedUpdate[moduleId] = hotUpdate[moduleId];
/******/ 					addAllToSet(outdatedModules, result.outdatedModules);
/******/ 					for (moduleId in result.outdatedDependencies) {
/******/ 						if (
/******/ 							Object.prototype.hasOwnProperty.call(
/******/ 								result.outdatedDependencies,
/******/ 								moduleId
/******/ 							)
/******/ 						) {
/******/ 							if (!outdatedDependencies[moduleId])
/******/ 								outdatedDependencies[moduleId] = [];
/******/ 							addAllToSet(
/******/ 								outdatedDependencies[moduleId],
/******/ 								result.outdatedDependencies[moduleId]
/******/ 							);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 				if (doDispose) {
/******/ 					addAllToSet(outdatedModules, [result.moduleId]);
/******/ 					appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Store self accepted outdated modules to require them later by the module system
/******/ 		var outdatedSelfAcceptedModules = [];
/******/ 		for (i = 0; i < outdatedModules.length; i++) {
/******/ 			moduleId = outdatedModules[i];
/******/ 			if (
/******/ 				installedModules[moduleId] &&
/******/ 				installedModules[moduleId].hot._selfAccepted &&
/******/ 				// removed self-accepted modules should not be required
/******/ 				appliedUpdate[moduleId] !== warnUnexpectedRequire
/******/ 			) {
/******/ 				outdatedSelfAcceptedModules.push({
/******/ 					module: moduleId,
/******/ 					errorHandler: installedModules[moduleId].hot._selfAccepted
/******/ 				});
/******/ 			}
/******/ 		}
/******/
/******/ 		// Now in "dispose" phase
/******/ 		hotSetStatus("dispose");
/******/ 		Object.keys(hotAvailableFilesMap).forEach(function(chunkId) {
/******/ 			if (hotAvailableFilesMap[chunkId] === false) {
/******/ 				hotDisposeChunk(chunkId);
/******/ 			}
/******/ 		});
/******/
/******/ 		var idx;
/******/ 		var queue = outdatedModules.slice();
/******/ 		while (queue.length > 0) {
/******/ 			moduleId = queue.pop();
/******/ 			module = installedModules[moduleId];
/******/ 			if (!module) continue;
/******/
/******/ 			var data = {};
/******/
/******/ 			// Call dispose handlers
/******/ 			var disposeHandlers = module.hot._disposeHandlers;
/******/ 			for (j = 0; j < disposeHandlers.length; j++) {
/******/ 				cb = disposeHandlers[j];
/******/ 				cb(data);
/******/ 			}
/******/ 			hotCurrentModuleData[moduleId] = data;
/******/
/******/ 			// disable module (this disables requires from this module)
/******/ 			module.hot.active = false;
/******/
/******/ 			// remove module from cache
/******/ 			delete installedModules[moduleId];
/******/
/******/ 			// when disposing there is no need to call dispose handler
/******/ 			delete outdatedDependencies[moduleId];
/******/
/******/ 			// remove "parents" references from all children
/******/ 			for (j = 0; j < module.children.length; j++) {
/******/ 				var child = installedModules[module.children[j]];
/******/ 				if (!child) continue;
/******/ 				idx = child.parents.indexOf(moduleId);
/******/ 				if (idx >= 0) {
/******/ 					child.parents.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// remove outdated dependency from module children
/******/ 		var dependency;
/******/ 		var moduleOutdatedDependencies;
/******/ 		for (moduleId in outdatedDependencies) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)
/******/ 			) {
/******/ 				module = installedModules[moduleId];
/******/ 				if (module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					for (j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 						dependency = moduleOutdatedDependencies[j];
/******/ 						idx = module.children.indexOf(dependency);
/******/ 						if (idx >= 0) module.children.splice(idx, 1);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Now in "apply" phase
/******/ 		hotSetStatus("apply");
/******/
/******/ 		hotCurrentHash = hotUpdateNewHash;
/******/
/******/ 		// insert new code
/******/ 		for (moduleId in appliedUpdate) {
/******/ 			if (Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
/******/ 				modules[moduleId] = appliedUpdate[moduleId];
/******/ 			}
/******/ 		}
/******/
/******/ 		// call accept handlers
/******/ 		var error = null;
/******/ 		for (moduleId in outdatedDependencies) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)
/******/ 			) {
/******/ 				module = installedModules[moduleId];
/******/ 				if (module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					var callbacks = [];
/******/ 					for (i = 0; i < moduleOutdatedDependencies.length; i++) {
/******/ 						dependency = moduleOutdatedDependencies[i];
/******/ 						cb = module.hot._acceptedDependencies[dependency];
/******/ 						if (cb) {
/******/ 							if (callbacks.indexOf(cb) !== -1) continue;
/******/ 							callbacks.push(cb);
/******/ 						}
/******/ 					}
/******/ 					for (i = 0; i < callbacks.length; i++) {
/******/ 						cb = callbacks[i];
/******/ 						try {
/******/ 							cb(moduleOutdatedDependencies);
/******/ 						} catch (err) {
/******/ 							if (options.onErrored) {
/******/ 								options.onErrored({
/******/ 									type: "accept-errored",
/******/ 									moduleId: moduleId,
/******/ 									dependencyId: moduleOutdatedDependencies[i],
/******/ 									error: err
/******/ 								});
/******/ 							}
/******/ 							if (!options.ignoreErrored) {
/******/ 								if (!error) error = err;
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Load self accepted modules
/******/ 		for (i = 0; i < outdatedSelfAcceptedModules.length; i++) {
/******/ 			var item = outdatedSelfAcceptedModules[i];
/******/ 			moduleId = item.module;
/******/ 			hotCurrentParents = [moduleId];
/******/ 			try {
/******/ 				__webpack_require__(moduleId);
/******/ 			} catch (err) {
/******/ 				if (typeof item.errorHandler === "function") {
/******/ 					try {
/******/ 						item.errorHandler(err);
/******/ 					} catch (err2) {
/******/ 						if (options.onErrored) {
/******/ 							options.onErrored({
/******/ 								type: "self-accept-error-handler-errored",
/******/ 								moduleId: moduleId,
/******/ 								error: err2,
/******/ 								originalError: err
/******/ 							});
/******/ 						}
/******/ 						if (!options.ignoreErrored) {
/******/ 							if (!error) error = err2;
/******/ 						}
/******/ 						if (!error) error = err;
/******/ 					}
/******/ 				} else {
/******/ 					if (options.onErrored) {
/******/ 						options.onErrored({
/******/ 							type: "self-accept-errored",
/******/ 							moduleId: moduleId,
/******/ 							error: err
/******/ 						});
/******/ 					}
/******/ 					if (!options.ignoreErrored) {
/******/ 						if (!error) error = err;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// handle errors in accept handlers and self accepted module load
/******/ 		if (error) {
/******/ 			hotSetStatus("fail");
/******/ 			return Promise.reject(error);
/******/ 		}
/******/
/******/ 		hotSetStatus("idle");
/******/ 		return new Promise(function(resolve) {
/******/ 			resolve(outdatedModules);
/******/ 		});
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {},
/******/ 			hot: hotCreateModule(moduleId),
/******/ 			parents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),
/******/ 			children: []
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// __webpack_hash__
/******/ 	__webpack_require__.h = function() { return hotCurrentHash; };
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return hotCreateRequire("./index.js")(__webpack_require__.s = "./index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../node_modules/@kissmybutton/motorcortex-player/dist/Player.js":
/*!***********************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex-player/dist/Player.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar MC = __webpack_require__(/*! @kissmybutton/motorcortex */ \"../node_modules/@kissmybutton/motorcortex/dist/motorcortex.umd.js\");\n\nvar timeCapsule = new MC.TimeCapsule();\n\nvar _require = __webpack_require__(/*! ./helpers */ \"../node_modules/@kissmybutton/motorcortex-player/dist/helpers.js\"),\n    elid = _require.elid,\n    eltag = _require.eltag,\n    elcreate = _require.elcreate;\n\nvar svg = __webpack_require__(/*! ./html/svg */ \"../node_modules/@kissmybutton/motorcortex-player/dist/html/svg.js\");\n\nvar config = __webpack_require__(/*! ./config */ \"../node_modules/@kissmybutton/motorcortex-player/dist/config.js\");\n\nvar confStyle = __webpack_require__(/*! ./html/style */ \"../node_modules/@kissmybutton/motorcortex-player/dist/html/style.js\");\n\nvar confThemes = __webpack_require__(/*! ./html/themes */ \"../node_modules/@kissmybutton/motorcortex-player/dist/html/themes.js\");\n\nvar setElements = __webpack_require__(/*! ./html/setElements */ \"../node_modules/@kissmybutton/motorcortex-player/dist/html/setElements.js\");\n\nvar volumeListener = __webpack_require__(/*! ./listeners/volume */ \"../node_modules/@kissmybutton/motorcortex-player/dist/listeners/volume.js\");\n\nvar loopBarStartListener = __webpack_require__(/*! ./listeners/loopBarStart */ \"../node_modules/@kissmybutton/motorcortex-player/dist/listeners/loopBarStart.js\");\n\nvar loopBarEndListener = __webpack_require__(/*! ./listeners/loopBarEnd */ \"../node_modules/@kissmybutton/motorcortex-player/dist/listeners/loopBarEnd.js\");\n\nvar loopStartEndListener = __webpack_require__(/*! ./listeners/loopStartEnd */ \"../node_modules/@kissmybutton/motorcortex-player/dist/listeners/loopStartEnd.js\");\n\nvar progressBarListener = __webpack_require__(/*! ./listeners/progressBar */ \"../node_modules/@kissmybutton/motorcortex-player/dist/listeners/progressBar.js\");\n\nvar statusBtnListener = __webpack_require__(/*! ./listeners/statusBtn */ \"../node_modules/@kissmybutton/motorcortex-player/dist/listeners/statusBtn.js\");\n\nvar settingsListener = __webpack_require__(/*! ./listeners/settings */ \"../node_modules/@kissmybutton/motorcortex-player/dist/listeners/settings.js\");\n\nvar speedListener = __webpack_require__(/*! ./listeners/speed */ \"../node_modules/@kissmybutton/motorcortex-player/dist/listeners/speed.js\");\n\nvar loopBtnListener = __webpack_require__(/*! ./listeners/loopBtn */ \"../node_modules/@kissmybutton/motorcortex-player/dist/listeners/loopBtn.js\");\n\nvar controlsListener = __webpack_require__(/*! ./listeners/controls */ \"../node_modules/@kissmybutton/motorcortex-player/dist/listeners/controls.js\");\n\nvar fullscreenListener = __webpack_require__(/*! ./listeners/fullscreen */ \"../node_modules/@kissmybutton/motorcortex-player/dist/listeners/fullscreen.js\");\n\nvar donkeyclipListener = __webpack_require__(/*! ./listeners/donkeyclip */ \"../node_modules/@kissmybutton/motorcortex-player/dist/listeners/donkeyclip.js\");\n\nvar previewListener = __webpack_require__(/*! ./listeners/preview */ \"../node_modules/@kissmybutton/motorcortex-player/dist/listeners/preview.js\");\n\nvar bodyListener = __webpack_require__(/*! ./listeners/body */ \"../node_modules/@kissmybutton/motorcortex-player/dist/listeners/body.js\");\n/**\n * @classdesc\n * Timer's purpose is to provide an interface through which any TimedIncident\n * (such as a Scene or a Clip) can both privide info regarding their timing\n * state but also provide an interface for interacting/altering the timing of it\n */\n\n\nvar Player =\n/*#__PURE__*/\nfunction () {\n  function Player(options) {\n    var _this = this;\n\n    _classCallCheck(this, Player);\n\n    // set defaults\n    options.id = options.id || Date.now();\n    options.preview = options.preview || false;\n    options.showVolume = options.showVolume || false;\n    options.showIndicator = options.showIndicator || false;\n    options.theme = options.theme || \"transparent on-top\";\n    options.host = options.host || options.clip.props.host;\n    options.buttons = options.buttons || {};\n    options.timeFormat = options.timeFormat || \"ss\";\n\n    if (options.pointerEvents === undefined || options.pointerEvents === null) {\n      options.pointerEvents = true;\n    } else {\n      options.pointerEvents = Boolean(options.pointerEvents);\n    }\n\n    options.onMillisecondChange = options.onMillisecondChange || null;\n    options.speedValues = options.speedValues || [-4, -2, -1, -0.5, 0, 0.5, 1, 2, 4]; // remove strings\n\n    for (var i in options.speedValues) {\n      if (!isFinite(options.speedValues[i])) {\n        options.speedValues.splice(i, 1);\n      }\n    }\n\n    options.speedValues.sort(function (a, b) {\n      return a - b;\n    });\n    this.className = config.name;\n    config.playerName = options.id;\n    this.options = options;\n    this.id = this.options.id;\n    this.name = config.name;\n    this.previewClip = null;\n    this.clip = options.clip; // host to apply the timer\n\n    this.clipClass = options.clipClass;\n    this.state = this.clip.runTimeInfo.state;\n    this.listeners = {};\n    this.previewScale = 0.25;\n    this.settings = {\n      volume: 1,\n      journey: null,\n      previousVolume: 1,\n      volumeMute: false,\n      needsUpdate: true,\n      resizeLoop: false,\n      loopJourney: false,\n      previewJourney: null,\n      loopActivated: false,\n      requestingLoop: false,\n      playAfterResize: false,\n      loopStartMillisecond: 0,\n      loopLastPositionXPxls: 0,\n      loopLastPositionXPercentage: 0,\n      loopEndMillisecond: this.clip.duration\n    };\n    this.functions = {\n      millisecondChange: this.millisecondChange,\n      createJourney: this.createJourney\n    }; // create the timer controls main div\n\n    setElements(this);\n    this.setTheme();\n    this.setSpeed();\n    this.subscribeToTimer();\n    this.subscribeToDurationChange();\n    this.addEventListeners();\n\n    if (this.options.preview) {\n      this.createPreviewDisplay();\n    }\n\n    window.addEventListener(\"resize\", function () {\n      if (_this.options.preview) {\n        _this.setPreviewDimentions();\n      }\n    });\n  }\n\n  _createClass(Player, [{\n    key: \"createJourney\",\n    value: function createJourney(clip, millisecond) {\n      var _this2 = this;\n\n      var clipCommands = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      setTimeout(function () {\n        var def = null;\n        var _clipCommands$before = clipCommands.before,\n            before = _clipCommands$before === void 0 ? def : _clipCommands$before,\n            _clipCommands$after = clipCommands.after,\n            after = _clipCommands$after === void 0 ? def : _clipCommands$after;\n        before ? clip[before]() : null;\n        _this2.settings.journey = timeCapsule.startJourney(clip);\n\n        _this2.settings.journey.station(millisecond);\n\n        _this2.settings.journey.destination();\n\n        after ? clip[after]() : null;\n      }, 0);\n    }\n  }, {\n    key: \"millisecondChange\",\n    value: function millisecondChange(millisecond, state, roundTo, makeJouney) {\n      var executeOnMillisecondChange = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n\n      if (this.state !== state) {\n        this.state = state;\n        this.eventBroadcast(\"state-change\", state);\n      }\n\n      if (!this.settings.needsUpdate) {\n        this.clip.pause();\n        return 1;\n      }\n\n      var clip = this.clip;\n      var _this$settings = this.settings,\n          loopActivated = _this$settings.loopActivated,\n          loopEndMillisecond = _this$settings.loopEndMillisecond,\n          loopStartMillisecond = _this$settings.loopStartMillisecond;\n      var duration = this.clip.duration;\n      var _this$elements = this.elements,\n          totalBar = _this$elements.totalBar,\n          loopBar = _this$elements.loopBar;\n      var loopBarWidth = loopBar.offsetWidth;\n      var loopBarLeft = loopBar.offsetLeft / totalBar.offsetWidth;\n      var localMillisecond = millisecond - duration * loopBarLeft;\n      var localDuration = duration / totalBar.offsetWidth * loopBarWidth;\n\n      if (millisecond >= loopEndMillisecond && loopActivated && this.clip.speed >= 0) {\n        this.createJourney(clip, loopStartMillisecond + 1, {\n          after: this.settings.playAfterResize || this.clip.runTimeInfo.state == \"playing\" ? \"play\" : null\n        });\n        return 1;\n      } else if (millisecond >= loopEndMillisecond && loopActivated && this.clip.speed < 0) {\n        this.createJourney(clip, loopEndMillisecond - 1, {\n          after: this.settings.playAfterResize || this.clip.runTimeInfo.state == \"playing\" ? \"play\" : null\n        });\n        return 1;\n      } else if (millisecond <= loopStartMillisecond && loopActivated && this.clip.speed >= 0) {\n        this.createJourney(clip, loopStartMillisecond + 1, {\n          after: this.settings.playAfterResize || this.clip.runTimeInfo.state == \"playing\" ? \"play\" : null\n        });\n        return 1;\n      } else if (millisecond <= loopStartMillisecond && loopActivated && this.clip.speed < 0) {\n        this.createJourney(clip, loopEndMillisecond - 1, {\n          after: this.settings.playAfterResize || this.clip.runTimeInfo.state == \"playing\" ? \"play\" : null\n        });\n        return 1;\n      }\n\n      if (makeJouney) {\n        this.createJourney(clip, millisecond, {\n          after: this.settings.playAfterResize ? \"play\" : null\n        });\n      }\n\n      this.elements.runningBar.style.width = localMillisecond / localDuration * 100 + \"%\";\n      this.elements.currentTime.innerHTML = this.timeFormat(millisecond);\n\n      if (this.options.onMillisecondChange && executeOnMillisecondChange) {\n        this.options.onMillisecondChange(millisecond);\n      }\n    }\n  }, {\n    key: \"eventBroadcast\",\n    value: function eventBroadcast(eventName, state) {\n      if (eventName === \"state-change\") {\n        if (state === \"paused\" || state === \"idle\" || state === \"transitional\" || state === \"armed\" || state === \"blocked\") {\n          this.elements.statusButton.innerHTML = svg.playSVG;\n          this.elements.statusButton.appendChild(this.elements.indicator);\n          this.elements.indicator.innerHTML = \"\".concat(state.charAt(0).toUpperCase() + state.slice(1));\n\n          if (state === \"blocked\") {\n            this.elements.pointerEventPanel.innerHTML = \"\\n            <div style=\\\"width:100%;height:100%;background:rgba(0,0,0,0.5);display:flex;justify-content:center;align-items:center;\\\">\".concat(svg.loadingSVG, \"</div>\");\n          }\n        } else {\n          this.elements.statusButton.innerHTML = svg.pauseSVG;\n          this.elements.statusButton.appendChild(this.elements.indicator);\n          this.elements.indicator.innerHTML = \"Playing\";\n          this.elements.pointerEventPanel.innerHTML = \"\";\n\n          if (state === \"playing\" && this.clip.runTimeInfo.currentMillisecond === this.clip.duration && this.clip.speed >= 0) {\n            this.createJourney(this.clip, 1, {\n              after: \"play\"\n            });\n          } else if (state === \"playing\" && this.clip.runTimeInfo.currentMillisecond === 0 && this.clip.speed < 0) {\n            this.createJourney(this.clip, this.clip.duration - 1, {\n              after: \"play\"\n            });\n          } else if (state === \"playing\" && this.clip.runTimeInfo.currentMillisecond === this.clip.duration && this.clip.speed < 0) {\n            this.createJourney(this.clip, this.clip.duration - 1, {\n              after: \"play\"\n            });\n          }\n        }\n      } else if (eventName === \"duration-change\") {\n        this.elements.totalTime.innerHTML = this.timeFormat(this.clip.duration);\n        this.settings.loopEndMillisecond = this.clip.duration;\n        this.elements.pointerEventPanel.innerHTML = \"\";\n        this.millisecondChange(this.clip.runTimeInfo.currentMillisecond);\n      }\n    }\n  }, {\n    key: \"subscribeToDurationChange\",\n    value: function subscribeToDurationChange() {\n      this.clip.subscribeToDurationChange(this.subscribeToDurationChangeCallback.bind(this));\n    }\n  }, {\n    key: \"subscribeToDurationChangeCallback\",\n    value: function subscribeToDurationChangeCallback()\n    /*newDuration*/\n    {\n      this.eventBroadcast(\"duration-change\");\n    }\n  }, {\n    key: \"subscribeToTimer\",\n    value: function subscribeToTimer() {\n      this.clip.subscribe(this.id, this.millisecondChange.bind(this));\n    }\n  }, {\n    key: \"handleDragStart\",\n    value: function handleDragStart() {\n      this.settings.needsUpdate = true;\n      this.settings.journey = timeCapsule.startJourney(this.clip);\n    }\n  }, {\n    key: \"timeFormat\",\n    value: function timeFormat(ms) {\n      if (this.options.timeFormat === \"ss\") {\n        var hours = ms / 1000 / 60 / 60;\n        var minutes = hours % 1 * 60;\n        var seconds = minutes % 1 * 60;\n        var h = (\"0\" + parseInt(hours)).slice(-2);\n        var m = (\"0\" + parseInt(minutes)).slice(-2);\n        var s = (\"0\" + parseInt(seconds)).slice(-2);\n        return \"\".concat(h === \"00\" ? \"\" : h + \":\").concat(m, \":\").concat(s);\n      } else {\n        return ms;\n      }\n    }\n  }, {\n    key: \"handleDrag\",\n    value: function handleDrag(loopBarPositionX) {\n      var executeOnMillisecondChange = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (!isFinite(loopBarPositionX)) {\n        loopBarPositionX = 0;\n      }\n\n      var duration = this.clip.duration;\n      var journey = this.settings.journey;\n      var _this$elements2 = this.elements,\n          loopBar = _this$elements2.loopBar,\n          totalBar = _this$elements2.totalBar,\n          runningBar = _this$elements2.runningBar,\n          currentTime = _this$elements2.currentTime;\n      var totalBarPositionX = loopBarPositionX + loopBar.offsetLeft;\n      var millisecond = Math.round(duration * totalBarPositionX / totalBar.offsetWidth);\n      currentTime.innerHTML = this.timeFormat(millisecond);\n      runningBar.style.width = loopBarPositionX / loopBar.offsetWidth * 100 + \"%\";\n      journey.station(millisecond);\n\n      if (this.options.onMillisecondChange && executeOnMillisecondChange) {\n        this.options.onMillisecondChange(millisecond);\n      }\n    }\n  }, {\n    key: \"handleDragEnd\",\n    value: function handleDragEnd() {\n      this.settings.journey.destination();\n    }\n  }, {\n    key: \"createProgressDrag\",\n    value: function createProgressDrag(loopBarPositionX) {\n      this.handleDragStart();\n      this.handleDrag(loopBarPositionX);\n      this.handleDragEnd();\n    }\n  }, {\n    key: \"addEventListeners\",\n    value: function addEventListeners() {\n      loopBarEndListener(this);\n      progressBarListener(this);\n      loopBarStartListener(this);\n      loopStartEndListener(this);\n      volumeListener(this);\n      statusBtnListener(this);\n      settingsListener(this);\n      speedListener(this);\n      loopBtnListener(this);\n      controlsListener(this);\n      fullscreenListener(this);\n      donkeyclipListener(this);\n      previewListener(this);\n      bodyListener(this);\n    }\n  }, {\n    key: \"launchIntoFullscreen\",\n    value: function launchIntoFullscreen(element) {\n      if (this.options.preview) {\n        this.setPreviewDimentions();\n      }\n\n      this.elements.mcPlayer.classList.toggle(\"full-screen\");\n\n      if (element.requestFullscreen) {\n        element.requestFullscreen();\n      } else if (element.mozRequestFullScreen) {\n        element.mozRequestFullScreen();\n      } else if (element.webkitRequestFullscreen) {\n        element.webkitRequestFullscreen();\n      } else if (element.msRequestFullscreen) {\n        element.msRequestFullscreen();\n      }\n    }\n  }, {\n    key: \"exitFullscreen\",\n    value: function exitFullscreen() {\n      if (this.options.preview) {\n        this.setPreviewDimentions();\n      }\n\n      this.elements.mcPlayer.classList.toggle(\"full-screen\");\n\n      if (document.exitFullscreen) {\n        document.exitFullscreen();\n      } else if (document.mozCancelFullScreen) {\n        document.mozCancelFullScreen();\n      } else if (document.webkitExitFullscreen) {\n        document.webkitExitFullscreen();\n      }\n    }\n  }, {\n    key: \"setTheme\",\n    value: function setTheme() {\n      // replace multiple spaces with one space\n      this.options.theme.replace(/\\s\\s+/g, \" \");\n      this.options.theme.trim();\n\n      if (!this.options.theme.includes(\"on-top\") && !this.options.theme.includes(\"position-default\")) {\n        this.options.theme += \" position-default\";\n      }\n\n      var theme = {};\n\n      for (var i in this.options.theme.split(\" \")) {\n        var confTheme = confThemes(this.options.theme.split(\" \")[i], this.name);\n\n        for (var q in confTheme || {}) {\n          theme[q] = confTheme[q];\n        }\n      }\n\n      var css = confStyle(theme, this.name, this.options);\n      var style = elcreate(\"style\");\n      style.styleSheet ? style.styleSheet.cssText = css : style.appendChild(document.createTextNode(css)); // append player style to document\n\n      eltag(\"head\")[0].appendChild(style);\n    }\n  }, {\n    key: \"setSpeed\",\n    value: function setSpeed() {\n      var _this3 = this;\n\n      var currentSpeed;\n      this.clip.speed == 1 ? currentSpeed = \"Normal\" : currentSpeed = this.clip.speed;\n      this.elements.speedCurrent.innerHTML = currentSpeed;\n\n      var targetZone = function () {\n        for (var i = 0; i < _this3.options.speedValues.length - 1; i++) {\n          if (_this3.options.speedValues[i] <= _this3.clip.speed && _this3.options.speedValues[i + 1] > _this3.clip.speed) {\n            return i + Math.abs((_this3.clip.speed - _this3.options.speedValues[i]) / (_this3.options.speedValues[i] - _this3.options.speedValues[i + 1]));\n          }\n        }\n      }();\n\n      var step = 1 / (this.options.speedValues.length - 1);\n      var positionY = (targetZone * step - 1) * -1 * (this.options.speedValues.length - 1) * 16;\n      elid(\"\".concat(this.name, \"-speed-cursor\")).style.top = positionY + \"px\";\n    }\n  }, {\n    key: \"calculateSpeed\",\n    value: function calculateSpeed(step, arrayOfValues, currentPercentage) {\n      var botLimitIndex = Math.floor(currentPercentage / step);\n\n      if (botLimitIndex === arrayOfValues.length - 1) {\n        return arrayOfValues[botLimitIndex].toFixed(1);\n      }\n\n      var limitZonePercentage = currentPercentage / step % 1;\n      var limitZoneLength = Math.abs(arrayOfValues[botLimitIndex] - arrayOfValues[botLimitIndex + 1]);\n      var realZoneSpeed = limitZonePercentage * limitZoneLength;\n      var realSpeed = (realZoneSpeed + arrayOfValues[botLimitIndex]).toFixed(1);\n\n      if (realSpeed == 0) {\n        return \"0.0\";\n      }\n\n      return realSpeed;\n    }\n  }, {\n    key: \"createPreviewDisplay\",\n    value: function createPreviewDisplay() {\n      this.previewClip = this.clip.paste(elid(\"\".concat(this.name, \"-hover-display\")));\n      var previewClip = elid(\"\".concat(this.name, \"-hover-display\"));\n      window.previewClip = this.previewClip;\n      previewClip.style.position = \"absolute\";\n      previewClip.style.zIndex = 1;\n      this.setPreviewDimentions();\n    }\n  }, {\n    key: \"setPreviewDimentions\",\n    value: function setPreviewDimentions() {\n      var clip = this.clip.props.host;\n      var previewClip = this.previewClip.ownClip.props.host;\n      var clipWidth = clip.offsetWidth;\n      var clipHeight = clip.offsetHeight;\n      var previewWidth = clipWidth * this.previewScale; // max width is 300\n\n      if (previewWidth > 300) {\n        // previewWidth = parseFloat(\n        //   elid(`${this.name}-hover-display`).style.maxWidth\n        // );\n        previewWidth = 300;\n        this.previewScale = previewWidth / clipWidth;\n      }\n\n      elid(\"\".concat(this.name, \"-hover-display\")).style.width = clipWidth + \"px\";\n      elid(\"\".concat(this.name, \"-hover-display\")).style.height = clipHeight + \"px\";\n      previewClip.style.transform = \"scale(\".concat(this.previewScale, \")\");\n      previewClip.style.transformOrigin = \"center bottom\";\n      previewClip.style.boxSizing = \"border-box\";\n    }\n  }]);\n\n  return Player;\n}();\n\nmodule.exports = Player;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgtcGxheWVyL2Rpc3QvUGxheWVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4LXBsYXllci9kaXN0L1BsYXllci5qcz8zNGQ0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbnZhciBNQyA9IHJlcXVpcmUoXCJAa2lzc215YnV0dG9uL21vdG9yY29ydGV4XCIpO1xuXG52YXIgdGltZUNhcHN1bGUgPSBuZXcgTUMuVGltZUNhcHN1bGUoKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4vaGVscGVyc1wiKSxcbiAgICBlbGlkID0gX3JlcXVpcmUuZWxpZCxcbiAgICBlbHRhZyA9IF9yZXF1aXJlLmVsdGFnLFxuICAgIGVsY3JlYXRlID0gX3JlcXVpcmUuZWxjcmVhdGU7XG5cbnZhciBzdmcgPSByZXF1aXJlKFwiLi9odG1sL3N2Z1wiKTtcblxudmFyIGNvbmZpZyA9IHJlcXVpcmUoXCIuL2NvbmZpZ1wiKTtcblxudmFyIGNvbmZTdHlsZSA9IHJlcXVpcmUoXCIuL2h0bWwvc3R5bGVcIik7XG5cbnZhciBjb25mVGhlbWVzID0gcmVxdWlyZShcIi4vaHRtbC90aGVtZXNcIik7XG5cbnZhciBzZXRFbGVtZW50cyA9IHJlcXVpcmUoXCIuL2h0bWwvc2V0RWxlbWVudHNcIik7XG5cbnZhciB2b2x1bWVMaXN0ZW5lciA9IHJlcXVpcmUoXCIuL2xpc3RlbmVycy92b2x1bWVcIik7XG5cbnZhciBsb29wQmFyU3RhcnRMaXN0ZW5lciA9IHJlcXVpcmUoXCIuL2xpc3RlbmVycy9sb29wQmFyU3RhcnRcIik7XG5cbnZhciBsb29wQmFyRW5kTGlzdGVuZXIgPSByZXF1aXJlKFwiLi9saXN0ZW5lcnMvbG9vcEJhckVuZFwiKTtcblxudmFyIGxvb3BTdGFydEVuZExpc3RlbmVyID0gcmVxdWlyZShcIi4vbGlzdGVuZXJzL2xvb3BTdGFydEVuZFwiKTtcblxudmFyIHByb2dyZXNzQmFyTGlzdGVuZXIgPSByZXF1aXJlKFwiLi9saXN0ZW5lcnMvcHJvZ3Jlc3NCYXJcIik7XG5cbnZhciBzdGF0dXNCdG5MaXN0ZW5lciA9IHJlcXVpcmUoXCIuL2xpc3RlbmVycy9zdGF0dXNCdG5cIik7XG5cbnZhciBzZXR0aW5nc0xpc3RlbmVyID0gcmVxdWlyZShcIi4vbGlzdGVuZXJzL3NldHRpbmdzXCIpO1xuXG52YXIgc3BlZWRMaXN0ZW5lciA9IHJlcXVpcmUoXCIuL2xpc3RlbmVycy9zcGVlZFwiKTtcblxudmFyIGxvb3BCdG5MaXN0ZW5lciA9IHJlcXVpcmUoXCIuL2xpc3RlbmVycy9sb29wQnRuXCIpO1xuXG52YXIgY29udHJvbHNMaXN0ZW5lciA9IHJlcXVpcmUoXCIuL2xpc3RlbmVycy9jb250cm9sc1wiKTtcblxudmFyIGZ1bGxzY3JlZW5MaXN0ZW5lciA9IHJlcXVpcmUoXCIuL2xpc3RlbmVycy9mdWxsc2NyZWVuXCIpO1xuXG52YXIgZG9ua2V5Y2xpcExpc3RlbmVyID0gcmVxdWlyZShcIi4vbGlzdGVuZXJzL2RvbmtleWNsaXBcIik7XG5cbnZhciBwcmV2aWV3TGlzdGVuZXIgPSByZXF1aXJlKFwiLi9saXN0ZW5lcnMvcHJldmlld1wiKTtcblxudmFyIGJvZHlMaXN0ZW5lciA9IHJlcXVpcmUoXCIuL2xpc3RlbmVycy9ib2R5XCIpO1xuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBUaW1lcidzIHB1cnBvc2UgaXMgdG8gcHJvdmlkZSBhbiBpbnRlcmZhY2UgdGhyb3VnaCB3aGljaCBhbnkgVGltZWRJbmNpZGVudFxuICogKHN1Y2ggYXMgYSBTY2VuZSBvciBhIENsaXApIGNhbiBib3RoIHByaXZpZGUgaW5mbyByZWdhcmRpbmcgdGhlaXIgdGltaW5nXG4gKiBzdGF0ZSBidXQgYWxzbyBwcm92aWRlIGFuIGludGVyZmFjZSBmb3IgaW50ZXJhY3RpbmcvYWx0ZXJpbmcgdGhlIHRpbWluZyBvZiBpdFxuICovXG5cblxudmFyIFBsYXllciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBsYXllcihvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQbGF5ZXIpO1xuXG4gICAgLy8gc2V0IGRlZmF1bHRzXG4gICAgb3B0aW9ucy5pZCA9IG9wdGlvbnMuaWQgfHwgRGF0ZS5ub3coKTtcbiAgICBvcHRpb25zLnByZXZpZXcgPSBvcHRpb25zLnByZXZpZXcgfHwgZmFsc2U7XG4gICAgb3B0aW9ucy5zaG93Vm9sdW1lID0gb3B0aW9ucy5zaG93Vm9sdW1lIHx8IGZhbHNlO1xuICAgIG9wdGlvbnMuc2hvd0luZGljYXRvciA9IG9wdGlvbnMuc2hvd0luZGljYXRvciB8fCBmYWxzZTtcbiAgICBvcHRpb25zLnRoZW1lID0gb3B0aW9ucy50aGVtZSB8fCBcInRyYW5zcGFyZW50IG9uLXRvcFwiO1xuICAgIG9wdGlvbnMuaG9zdCA9IG9wdGlvbnMuaG9zdCB8fCBvcHRpb25zLmNsaXAucHJvcHMuaG9zdDtcbiAgICBvcHRpb25zLmJ1dHRvbnMgPSBvcHRpb25zLmJ1dHRvbnMgfHwge307XG4gICAgb3B0aW9ucy50aW1lRm9ybWF0ID0gb3B0aW9ucy50aW1lRm9ybWF0IHx8IFwic3NcIjtcblxuICAgIGlmIChvcHRpb25zLnBvaW50ZXJFdmVudHMgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnBvaW50ZXJFdmVudHMgPT09IG51bGwpIHtcbiAgICAgIG9wdGlvbnMucG9pbnRlckV2ZW50cyA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMucG9pbnRlckV2ZW50cyA9IEJvb2xlYW4ob3B0aW9ucy5wb2ludGVyRXZlbnRzKTtcbiAgICB9XG5cbiAgICBvcHRpb25zLm9uTWlsbGlzZWNvbmRDaGFuZ2UgPSBvcHRpb25zLm9uTWlsbGlzZWNvbmRDaGFuZ2UgfHwgbnVsbDtcbiAgICBvcHRpb25zLnNwZWVkVmFsdWVzID0gb3B0aW9ucy5zcGVlZFZhbHVlcyB8fCBbLTQsIC0yLCAtMSwgLTAuNSwgMCwgMC41LCAxLCAyLCA0XTsgLy8gcmVtb3ZlIHN0cmluZ3NcblxuICAgIGZvciAodmFyIGkgaW4gb3B0aW9ucy5zcGVlZFZhbHVlcykge1xuICAgICAgaWYgKCFpc0Zpbml0ZShvcHRpb25zLnNwZWVkVmFsdWVzW2ldKSkge1xuICAgICAgICBvcHRpb25zLnNwZWVkVmFsdWVzLnNwbGljZShpLCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBvcHRpb25zLnNwZWVkVmFsdWVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhIC0gYjtcbiAgICB9KTtcbiAgICB0aGlzLmNsYXNzTmFtZSA9IGNvbmZpZy5uYW1lO1xuICAgIGNvbmZpZy5wbGF5ZXJOYW1lID0gb3B0aW9ucy5pZDtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuaWQgPSB0aGlzLm9wdGlvbnMuaWQ7XG4gICAgdGhpcy5uYW1lID0gY29uZmlnLm5hbWU7XG4gICAgdGhpcy5wcmV2aWV3Q2xpcCA9IG51bGw7XG4gICAgdGhpcy5jbGlwID0gb3B0aW9ucy5jbGlwOyAvLyBob3N0IHRvIGFwcGx5IHRoZSB0aW1lclxuXG4gICAgdGhpcy5jbGlwQ2xhc3MgPSBvcHRpb25zLmNsaXBDbGFzcztcbiAgICB0aGlzLnN0YXRlID0gdGhpcy5jbGlwLnJ1blRpbWVJbmZvLnN0YXRlO1xuICAgIHRoaXMubGlzdGVuZXJzID0ge307XG4gICAgdGhpcy5wcmV2aWV3U2NhbGUgPSAwLjI1O1xuICAgIHRoaXMuc2V0dGluZ3MgPSB7XG4gICAgICB2b2x1bWU6IDEsXG4gICAgICBqb3VybmV5OiBudWxsLFxuICAgICAgcHJldmlvdXNWb2x1bWU6IDEsXG4gICAgICB2b2x1bWVNdXRlOiBmYWxzZSxcbiAgICAgIG5lZWRzVXBkYXRlOiB0cnVlLFxuICAgICAgcmVzaXplTG9vcDogZmFsc2UsXG4gICAgICBsb29wSm91cm5leTogZmFsc2UsXG4gICAgICBwcmV2aWV3Sm91cm5leTogbnVsbCxcbiAgICAgIGxvb3BBY3RpdmF0ZWQ6IGZhbHNlLFxuICAgICAgcmVxdWVzdGluZ0xvb3A6IGZhbHNlLFxuICAgICAgcGxheUFmdGVyUmVzaXplOiBmYWxzZSxcbiAgICAgIGxvb3BTdGFydE1pbGxpc2Vjb25kOiAwLFxuICAgICAgbG9vcExhc3RQb3NpdGlvblhQeGxzOiAwLFxuICAgICAgbG9vcExhc3RQb3NpdGlvblhQZXJjZW50YWdlOiAwLFxuICAgICAgbG9vcEVuZE1pbGxpc2Vjb25kOiB0aGlzLmNsaXAuZHVyYXRpb25cbiAgICB9O1xuICAgIHRoaXMuZnVuY3Rpb25zID0ge1xuICAgICAgbWlsbGlzZWNvbmRDaGFuZ2U6IHRoaXMubWlsbGlzZWNvbmRDaGFuZ2UsXG4gICAgICBjcmVhdGVKb3VybmV5OiB0aGlzLmNyZWF0ZUpvdXJuZXlcbiAgICB9OyAvLyBjcmVhdGUgdGhlIHRpbWVyIGNvbnRyb2xzIG1haW4gZGl2XG5cbiAgICBzZXRFbGVtZW50cyh0aGlzKTtcbiAgICB0aGlzLnNldFRoZW1lKCk7XG4gICAgdGhpcy5zZXRTcGVlZCgpO1xuICAgIHRoaXMuc3Vic2NyaWJlVG9UaW1lcigpO1xuICAgIHRoaXMuc3Vic2NyaWJlVG9EdXJhdGlvbkNoYW5nZSgpO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMucHJldmlldykge1xuICAgICAgdGhpcy5jcmVhdGVQcmV2aWV3RGlzcGxheSgpO1xuICAgIH1cblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfdGhpcy5vcHRpb25zLnByZXZpZXcpIHtcbiAgICAgICAgX3RoaXMuc2V0UHJldmlld0RpbWVudGlvbnMoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQbGF5ZXIsIFt7XG4gICAga2V5OiBcImNyZWF0ZUpvdXJuZXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlSm91cm5leShjbGlwLCBtaWxsaXNlY29uZCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBjbGlwQ29tbWFuZHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZWYgPSBudWxsO1xuICAgICAgICB2YXIgX2NsaXBDb21tYW5kcyRiZWZvcmUgPSBjbGlwQ29tbWFuZHMuYmVmb3JlLFxuICAgICAgICAgICAgYmVmb3JlID0gX2NsaXBDb21tYW5kcyRiZWZvcmUgPT09IHZvaWQgMCA/IGRlZiA6IF9jbGlwQ29tbWFuZHMkYmVmb3JlLFxuICAgICAgICAgICAgX2NsaXBDb21tYW5kcyRhZnRlciA9IGNsaXBDb21tYW5kcy5hZnRlcixcbiAgICAgICAgICAgIGFmdGVyID0gX2NsaXBDb21tYW5kcyRhZnRlciA9PT0gdm9pZCAwID8gZGVmIDogX2NsaXBDb21tYW5kcyRhZnRlcjtcbiAgICAgICAgYmVmb3JlID8gY2xpcFtiZWZvcmVdKCkgOiBudWxsO1xuICAgICAgICBfdGhpczIuc2V0dGluZ3Muam91cm5leSA9IHRpbWVDYXBzdWxlLnN0YXJ0Sm91cm5leShjbGlwKTtcblxuICAgICAgICBfdGhpczIuc2V0dGluZ3Muam91cm5leS5zdGF0aW9uKG1pbGxpc2Vjb25kKTtcblxuICAgICAgICBfdGhpczIuc2V0dGluZ3Muam91cm5leS5kZXN0aW5hdGlvbigpO1xuXG4gICAgICAgIGFmdGVyID8gY2xpcFthZnRlcl0oKSA6IG51bGw7XG4gICAgICB9LCAwKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWlsbGlzZWNvbmRDaGFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWlsbGlzZWNvbmRDaGFuZ2UobWlsbGlzZWNvbmQsIHN0YXRlLCByb3VuZFRvLCBtYWtlSm91bmV5KSB7XG4gICAgICB2YXIgZXhlY3V0ZU9uTWlsbGlzZWNvbmRDaGFuZ2UgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHRydWU7XG5cbiAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBzdGF0ZSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMuZXZlbnRCcm9hZGNhc3QoXCJzdGF0ZS1jaGFuZ2VcIiwgc3RhdGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuc2V0dGluZ3MubmVlZHNVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5jbGlwLnBhdXNlKCk7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2xpcCA9IHRoaXMuY2xpcDtcbiAgICAgIHZhciBfdGhpcyRzZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3MsXG4gICAgICAgICAgbG9vcEFjdGl2YXRlZCA9IF90aGlzJHNldHRpbmdzLmxvb3BBY3RpdmF0ZWQsXG4gICAgICAgICAgbG9vcEVuZE1pbGxpc2Vjb25kID0gX3RoaXMkc2V0dGluZ3MubG9vcEVuZE1pbGxpc2Vjb25kLFxuICAgICAgICAgIGxvb3BTdGFydE1pbGxpc2Vjb25kID0gX3RoaXMkc2V0dGluZ3MubG9vcFN0YXJ0TWlsbGlzZWNvbmQ7XG4gICAgICB2YXIgZHVyYXRpb24gPSB0aGlzLmNsaXAuZHVyYXRpb247XG4gICAgICB2YXIgX3RoaXMkZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzLFxuICAgICAgICAgIHRvdGFsQmFyID0gX3RoaXMkZWxlbWVudHMudG90YWxCYXIsXG4gICAgICAgICAgbG9vcEJhciA9IF90aGlzJGVsZW1lbnRzLmxvb3BCYXI7XG4gICAgICB2YXIgbG9vcEJhcldpZHRoID0gbG9vcEJhci5vZmZzZXRXaWR0aDtcbiAgICAgIHZhciBsb29wQmFyTGVmdCA9IGxvb3BCYXIub2Zmc2V0TGVmdCAvIHRvdGFsQmFyLm9mZnNldFdpZHRoO1xuICAgICAgdmFyIGxvY2FsTWlsbGlzZWNvbmQgPSBtaWxsaXNlY29uZCAtIGR1cmF0aW9uICogbG9vcEJhckxlZnQ7XG4gICAgICB2YXIgbG9jYWxEdXJhdGlvbiA9IGR1cmF0aW9uIC8gdG90YWxCYXIub2Zmc2V0V2lkdGggKiBsb29wQmFyV2lkdGg7XG5cbiAgICAgIGlmIChtaWxsaXNlY29uZCA+PSBsb29wRW5kTWlsbGlzZWNvbmQgJiYgbG9vcEFjdGl2YXRlZCAmJiB0aGlzLmNsaXAuc3BlZWQgPj0gMCkge1xuICAgICAgICB0aGlzLmNyZWF0ZUpvdXJuZXkoY2xpcCwgbG9vcFN0YXJ0TWlsbGlzZWNvbmQgKyAxLCB7XG4gICAgICAgICAgYWZ0ZXI6IHRoaXMuc2V0dGluZ3MucGxheUFmdGVyUmVzaXplIHx8IHRoaXMuY2xpcC5ydW5UaW1lSW5mby5zdGF0ZSA9PSBcInBsYXlpbmdcIiA/IFwicGxheVwiIDogbnVsbFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9IGVsc2UgaWYgKG1pbGxpc2Vjb25kID49IGxvb3BFbmRNaWxsaXNlY29uZCAmJiBsb29wQWN0aXZhdGVkICYmIHRoaXMuY2xpcC5zcGVlZCA8IDApIHtcbiAgICAgICAgdGhpcy5jcmVhdGVKb3VybmV5KGNsaXAsIGxvb3BFbmRNaWxsaXNlY29uZCAtIDEsIHtcbiAgICAgICAgICBhZnRlcjogdGhpcy5zZXR0aW5ncy5wbGF5QWZ0ZXJSZXNpemUgfHwgdGhpcy5jbGlwLnJ1blRpbWVJbmZvLnN0YXRlID09IFwicGxheWluZ1wiID8gXCJwbGF5XCIgOiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0gZWxzZSBpZiAobWlsbGlzZWNvbmQgPD0gbG9vcFN0YXJ0TWlsbGlzZWNvbmQgJiYgbG9vcEFjdGl2YXRlZCAmJiB0aGlzLmNsaXAuc3BlZWQgPj0gMCkge1xuICAgICAgICB0aGlzLmNyZWF0ZUpvdXJuZXkoY2xpcCwgbG9vcFN0YXJ0TWlsbGlzZWNvbmQgKyAxLCB7XG4gICAgICAgICAgYWZ0ZXI6IHRoaXMuc2V0dGluZ3MucGxheUFmdGVyUmVzaXplIHx8IHRoaXMuY2xpcC5ydW5UaW1lSW5mby5zdGF0ZSA9PSBcInBsYXlpbmdcIiA/IFwicGxheVwiIDogbnVsbFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9IGVsc2UgaWYgKG1pbGxpc2Vjb25kIDw9IGxvb3BTdGFydE1pbGxpc2Vjb25kICYmIGxvb3BBY3RpdmF0ZWQgJiYgdGhpcy5jbGlwLnNwZWVkIDwgMCkge1xuICAgICAgICB0aGlzLmNyZWF0ZUpvdXJuZXkoY2xpcCwgbG9vcEVuZE1pbGxpc2Vjb25kIC0gMSwge1xuICAgICAgICAgIGFmdGVyOiB0aGlzLnNldHRpbmdzLnBsYXlBZnRlclJlc2l6ZSB8fCB0aGlzLmNsaXAucnVuVGltZUluZm8uc3RhdGUgPT0gXCJwbGF5aW5nXCIgPyBcInBsYXlcIiA6IG51bGxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuXG4gICAgICBpZiAobWFrZUpvdW5leSkge1xuICAgICAgICB0aGlzLmNyZWF0ZUpvdXJuZXkoY2xpcCwgbWlsbGlzZWNvbmQsIHtcbiAgICAgICAgICBhZnRlcjogdGhpcy5zZXR0aW5ncy5wbGF5QWZ0ZXJSZXNpemUgPyBcInBsYXlcIiA6IG51bGxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWxlbWVudHMucnVubmluZ0Jhci5zdHlsZS53aWR0aCA9IGxvY2FsTWlsbGlzZWNvbmQgLyBsb2NhbER1cmF0aW9uICogMTAwICsgXCIlXCI7XG4gICAgICB0aGlzLmVsZW1lbnRzLmN1cnJlbnRUaW1lLmlubmVySFRNTCA9IHRoaXMudGltZUZvcm1hdChtaWxsaXNlY29uZCk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub25NaWxsaXNlY29uZENoYW5nZSAmJiBleGVjdXRlT25NaWxsaXNlY29uZENoYW5nZSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMub25NaWxsaXNlY29uZENoYW5nZShtaWxsaXNlY29uZCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImV2ZW50QnJvYWRjYXN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV2ZW50QnJvYWRjYXN0KGV2ZW50TmFtZSwgc3RhdGUpIHtcbiAgICAgIGlmIChldmVudE5hbWUgPT09IFwic3RhdGUtY2hhbmdlXCIpIHtcbiAgICAgICAgaWYgKHN0YXRlID09PSBcInBhdXNlZFwiIHx8IHN0YXRlID09PSBcImlkbGVcIiB8fCBzdGF0ZSA9PT0gXCJ0cmFuc2l0aW9uYWxcIiB8fCBzdGF0ZSA9PT0gXCJhcm1lZFwiIHx8IHN0YXRlID09PSBcImJsb2NrZWRcIikge1xuICAgICAgICAgIHRoaXMuZWxlbWVudHMuc3RhdHVzQnV0dG9uLmlubmVySFRNTCA9IHN2Zy5wbGF5U1ZHO1xuICAgICAgICAgIHRoaXMuZWxlbWVudHMuc3RhdHVzQnV0dG9uLmFwcGVuZENoaWxkKHRoaXMuZWxlbWVudHMuaW5kaWNhdG9yKTtcbiAgICAgICAgICB0aGlzLmVsZW1lbnRzLmluZGljYXRvci5pbm5lckhUTUwgPSBcIlwiLmNvbmNhdChzdGF0ZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0YXRlLnNsaWNlKDEpKTtcblxuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gXCJibG9ja2VkXCIpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHMucG9pbnRlckV2ZW50UGFuZWwuaW5uZXJIVE1MID0gXCJcXG4gICAgICAgICAgICA8ZGl2IHN0eWxlPVxcXCJ3aWR0aDoxMDAlO2hlaWdodDoxMDAlO2JhY2tncm91bmQ6cmdiYSgwLDAsMCwwLjUpO2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjtcXFwiPlwiLmNvbmNhdChzdmcubG9hZGluZ1NWRywgXCI8L2Rpdj5cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZWxlbWVudHMuc3RhdHVzQnV0dG9uLmlubmVySFRNTCA9IHN2Zy5wYXVzZVNWRztcbiAgICAgICAgICB0aGlzLmVsZW1lbnRzLnN0YXR1c0J1dHRvbi5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnRzLmluZGljYXRvcik7XG4gICAgICAgICAgdGhpcy5lbGVtZW50cy5pbmRpY2F0b3IuaW5uZXJIVE1MID0gXCJQbGF5aW5nXCI7XG4gICAgICAgICAgdGhpcy5lbGVtZW50cy5wb2ludGVyRXZlbnRQYW5lbC5pbm5lckhUTUwgPSBcIlwiO1xuXG4gICAgICAgICAgaWYgKHN0YXRlID09PSBcInBsYXlpbmdcIiAmJiB0aGlzLmNsaXAucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kID09PSB0aGlzLmNsaXAuZHVyYXRpb24gJiYgdGhpcy5jbGlwLnNwZWVkID49IDApIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlSm91cm5leSh0aGlzLmNsaXAsIDEsIHtcbiAgICAgICAgICAgICAgYWZ0ZXI6IFwicGxheVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBcInBsYXlpbmdcIiAmJiB0aGlzLmNsaXAucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kID09PSAwICYmIHRoaXMuY2xpcC5zcGVlZCA8IDApIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlSm91cm5leSh0aGlzLmNsaXAsIHRoaXMuY2xpcC5kdXJhdGlvbiAtIDEsIHtcbiAgICAgICAgICAgICAgYWZ0ZXI6IFwicGxheVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBcInBsYXlpbmdcIiAmJiB0aGlzLmNsaXAucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kID09PSB0aGlzLmNsaXAuZHVyYXRpb24gJiYgdGhpcy5jbGlwLnNwZWVkIDwgMCkge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVKb3VybmV5KHRoaXMuY2xpcCwgdGhpcy5jbGlwLmR1cmF0aW9uIC0gMSwge1xuICAgICAgICAgICAgICBhZnRlcjogXCJwbGF5XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChldmVudE5hbWUgPT09IFwiZHVyYXRpb24tY2hhbmdlXCIpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50cy50b3RhbFRpbWUuaW5uZXJIVE1MID0gdGhpcy50aW1lRm9ybWF0KHRoaXMuY2xpcC5kdXJhdGlvbik7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MubG9vcEVuZE1pbGxpc2Vjb25kID0gdGhpcy5jbGlwLmR1cmF0aW9uO1xuICAgICAgICB0aGlzLmVsZW1lbnRzLnBvaW50ZXJFdmVudFBhbmVsLmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAgIHRoaXMubWlsbGlzZWNvbmRDaGFuZ2UodGhpcy5jbGlwLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN1YnNjcmliZVRvRHVyYXRpb25DaGFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3Vic2NyaWJlVG9EdXJhdGlvbkNoYW5nZSgpIHtcbiAgICAgIHRoaXMuY2xpcC5zdWJzY3JpYmVUb0R1cmF0aW9uQ2hhbmdlKHRoaXMuc3Vic2NyaWJlVG9EdXJhdGlvbkNoYW5nZUNhbGxiYWNrLmJpbmQodGhpcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdWJzY3JpYmVUb0R1cmF0aW9uQ2hhbmdlQ2FsbGJhY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3Vic2NyaWJlVG9EdXJhdGlvbkNoYW5nZUNhbGxiYWNrKClcbiAgICAvKm5ld0R1cmF0aW9uKi9cbiAgICB7XG4gICAgICB0aGlzLmV2ZW50QnJvYWRjYXN0KFwiZHVyYXRpb24tY2hhbmdlXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdWJzY3JpYmVUb1RpbWVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN1YnNjcmliZVRvVGltZXIoKSB7XG4gICAgICB0aGlzLmNsaXAuc3Vic2NyaWJlKHRoaXMuaWQsIHRoaXMubWlsbGlzZWNvbmRDaGFuZ2UuYmluZCh0aGlzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZURyYWdTdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVEcmFnU3RhcnQoKSB7XG4gICAgICB0aGlzLnNldHRpbmdzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2V0dGluZ3Muam91cm5leSA9IHRpbWVDYXBzdWxlLnN0YXJ0Sm91cm5leSh0aGlzLmNsaXApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0aW1lRm9ybWF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRpbWVGb3JtYXQobXMpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudGltZUZvcm1hdCA9PT0gXCJzc1wiKSB7XG4gICAgICAgIHZhciBob3VycyA9IG1zIC8gMTAwMCAvIDYwIC8gNjA7XG4gICAgICAgIHZhciBtaW51dGVzID0gaG91cnMgJSAxICogNjA7XG4gICAgICAgIHZhciBzZWNvbmRzID0gbWludXRlcyAlIDEgKiA2MDtcbiAgICAgICAgdmFyIGggPSAoXCIwXCIgKyBwYXJzZUludChob3VycykpLnNsaWNlKC0yKTtcbiAgICAgICAgdmFyIG0gPSAoXCIwXCIgKyBwYXJzZUludChtaW51dGVzKSkuc2xpY2UoLTIpO1xuICAgICAgICB2YXIgcyA9IChcIjBcIiArIHBhcnNlSW50KHNlY29uZHMpKS5zbGljZSgtMik7XG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChoID09PSBcIjAwXCIgPyBcIlwiIDogaCArIFwiOlwiKS5jb25jYXQobSwgXCI6XCIpLmNvbmNhdChzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBtcztcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlRHJhZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVEcmFnKGxvb3BCYXJQb3NpdGlvblgpIHtcbiAgICAgIHZhciBleGVjdXRlT25NaWxsaXNlY29uZENoYW5nZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcblxuICAgICAgaWYgKCFpc0Zpbml0ZShsb29wQmFyUG9zaXRpb25YKSkge1xuICAgICAgICBsb29wQmFyUG9zaXRpb25YID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIGR1cmF0aW9uID0gdGhpcy5jbGlwLmR1cmF0aW9uO1xuICAgICAgdmFyIGpvdXJuZXkgPSB0aGlzLnNldHRpbmdzLmpvdXJuZXk7XG4gICAgICB2YXIgX3RoaXMkZWxlbWVudHMyID0gdGhpcy5lbGVtZW50cyxcbiAgICAgICAgICBsb29wQmFyID0gX3RoaXMkZWxlbWVudHMyLmxvb3BCYXIsXG4gICAgICAgICAgdG90YWxCYXIgPSBfdGhpcyRlbGVtZW50czIudG90YWxCYXIsXG4gICAgICAgICAgcnVubmluZ0JhciA9IF90aGlzJGVsZW1lbnRzMi5ydW5uaW5nQmFyLFxuICAgICAgICAgIGN1cnJlbnRUaW1lID0gX3RoaXMkZWxlbWVudHMyLmN1cnJlbnRUaW1lO1xuICAgICAgdmFyIHRvdGFsQmFyUG9zaXRpb25YID0gbG9vcEJhclBvc2l0aW9uWCArIGxvb3BCYXIub2Zmc2V0TGVmdDtcbiAgICAgIHZhciBtaWxsaXNlY29uZCA9IE1hdGgucm91bmQoZHVyYXRpb24gKiB0b3RhbEJhclBvc2l0aW9uWCAvIHRvdGFsQmFyLm9mZnNldFdpZHRoKTtcbiAgICAgIGN1cnJlbnRUaW1lLmlubmVySFRNTCA9IHRoaXMudGltZUZvcm1hdChtaWxsaXNlY29uZCk7XG4gICAgICBydW5uaW5nQmFyLnN0eWxlLndpZHRoID0gbG9vcEJhclBvc2l0aW9uWCAvIGxvb3BCYXIub2Zmc2V0V2lkdGggKiAxMDAgKyBcIiVcIjtcbiAgICAgIGpvdXJuZXkuc3RhdGlvbihtaWxsaXNlY29uZCk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub25NaWxsaXNlY29uZENoYW5nZSAmJiBleGVjdXRlT25NaWxsaXNlY29uZENoYW5nZSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMub25NaWxsaXNlY29uZENoYW5nZShtaWxsaXNlY29uZCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZURyYWdFbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlRHJhZ0VuZCgpIHtcbiAgICAgIHRoaXMuc2V0dGluZ3Muam91cm5leS5kZXN0aW5hdGlvbigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVQcm9ncmVzc0RyYWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlUHJvZ3Jlc3NEcmFnKGxvb3BCYXJQb3NpdGlvblgpIHtcbiAgICAgIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0KCk7XG4gICAgICB0aGlzLmhhbmRsZURyYWcobG9vcEJhclBvc2l0aW9uWCk7XG4gICAgICB0aGlzLmhhbmRsZURyYWdFbmQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkRXZlbnRMaXN0ZW5lcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICBsb29wQmFyRW5kTGlzdGVuZXIodGhpcyk7XG4gICAgICBwcm9ncmVzc0Jhckxpc3RlbmVyKHRoaXMpO1xuICAgICAgbG9vcEJhclN0YXJ0TGlzdGVuZXIodGhpcyk7XG4gICAgICBsb29wU3RhcnRFbmRMaXN0ZW5lcih0aGlzKTtcbiAgICAgIHZvbHVtZUxpc3RlbmVyKHRoaXMpO1xuICAgICAgc3RhdHVzQnRuTGlzdGVuZXIodGhpcyk7XG4gICAgICBzZXR0aW5nc0xpc3RlbmVyKHRoaXMpO1xuICAgICAgc3BlZWRMaXN0ZW5lcih0aGlzKTtcbiAgICAgIGxvb3BCdG5MaXN0ZW5lcih0aGlzKTtcbiAgICAgIGNvbnRyb2xzTGlzdGVuZXIodGhpcyk7XG4gICAgICBmdWxsc2NyZWVuTGlzdGVuZXIodGhpcyk7XG4gICAgICBkb25rZXljbGlwTGlzdGVuZXIodGhpcyk7XG4gICAgICBwcmV2aWV3TGlzdGVuZXIodGhpcyk7XG4gICAgICBib2R5TGlzdGVuZXIodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxhdW5jaEludG9GdWxsc2NyZWVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxhdW5jaEludG9GdWxsc2NyZWVuKGVsZW1lbnQpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucHJldmlldykge1xuICAgICAgICB0aGlzLnNldFByZXZpZXdEaW1lbnRpb25zKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWxlbWVudHMubWNQbGF5ZXIuY2xhc3NMaXN0LnRvZ2dsZShcImZ1bGwtc2NyZWVuXCIpO1xuXG4gICAgICBpZiAoZWxlbWVudC5yZXF1ZXN0RnVsbHNjcmVlbikge1xuICAgICAgICBlbGVtZW50LnJlcXVlc3RGdWxsc2NyZWVuKCk7XG4gICAgICB9IGVsc2UgaWYgKGVsZW1lbnQubW96UmVxdWVzdEZ1bGxTY3JlZW4pIHtcbiAgICAgICAgZWxlbWVudC5tb3pSZXF1ZXN0RnVsbFNjcmVlbigpO1xuICAgICAgfSBlbHNlIGlmIChlbGVtZW50LndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuKSB7XG4gICAgICAgIGVsZW1lbnQud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5tc1JlcXVlc3RGdWxsc2NyZWVuKSB7XG4gICAgICAgIGVsZW1lbnQubXNSZXF1ZXN0RnVsbHNjcmVlbigpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJleGl0RnVsbHNjcmVlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleGl0RnVsbHNjcmVlbigpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucHJldmlldykge1xuICAgICAgICB0aGlzLnNldFByZXZpZXdEaW1lbnRpb25zKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWxlbWVudHMubWNQbGF5ZXIuY2xhc3NMaXN0LnRvZ2dsZShcImZ1bGwtc2NyZWVuXCIpO1xuXG4gICAgICBpZiAoZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4oKTtcbiAgICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQubW96Q2FuY2VsRnVsbFNjcmVlbikge1xuICAgICAgICBkb2N1bWVudC5tb3pDYW5jZWxGdWxsU2NyZWVuKCk7XG4gICAgICB9IGVsc2UgaWYgKGRvY3VtZW50LndlYmtpdEV4aXRGdWxsc2NyZWVuKSB7XG4gICAgICAgIGRvY3VtZW50LndlYmtpdEV4aXRGdWxsc2NyZWVuKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFRoZW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFRoZW1lKCkge1xuICAgICAgLy8gcmVwbGFjZSBtdWx0aXBsZSBzcGFjZXMgd2l0aCBvbmUgc3BhY2VcbiAgICAgIHRoaXMub3B0aW9ucy50aGVtZS5yZXBsYWNlKC9cXHNcXHMrL2csIFwiIFwiKTtcbiAgICAgIHRoaXMub3B0aW9ucy50aGVtZS50cmltKCk7XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnRoZW1lLmluY2x1ZGVzKFwib24tdG9wXCIpICYmICF0aGlzLm9wdGlvbnMudGhlbWUuaW5jbHVkZXMoXCJwb3NpdGlvbi1kZWZhdWx0XCIpKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy50aGVtZSArPSBcIiBwb3NpdGlvbi1kZWZhdWx0XCI7XG4gICAgICB9XG5cbiAgICAgIHZhciB0aGVtZSA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBpIGluIHRoaXMub3B0aW9ucy50aGVtZS5zcGxpdChcIiBcIikpIHtcbiAgICAgICAgdmFyIGNvbmZUaGVtZSA9IGNvbmZUaGVtZXModGhpcy5vcHRpb25zLnRoZW1lLnNwbGl0KFwiIFwiKVtpXSwgdGhpcy5uYW1lKTtcblxuICAgICAgICBmb3IgKHZhciBxIGluIGNvbmZUaGVtZSB8fCB7fSkge1xuICAgICAgICAgIHRoZW1lW3FdID0gY29uZlRoZW1lW3FdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjc3MgPSBjb25mU3R5bGUodGhlbWUsIHRoaXMubmFtZSwgdGhpcy5vcHRpb25zKTtcbiAgICAgIHZhciBzdHlsZSA9IGVsY3JlYXRlKFwic3R5bGVcIik7XG4gICAgICBzdHlsZS5zdHlsZVNoZWV0ID8gc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzIDogc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7IC8vIGFwcGVuZCBwbGF5ZXIgc3R5bGUgdG8gZG9jdW1lbnRcblxuICAgICAgZWx0YWcoXCJoZWFkXCIpWzBdLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0U3BlZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U3BlZWQoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIGN1cnJlbnRTcGVlZDtcbiAgICAgIHRoaXMuY2xpcC5zcGVlZCA9PSAxID8gY3VycmVudFNwZWVkID0gXCJOb3JtYWxcIiA6IGN1cnJlbnRTcGVlZCA9IHRoaXMuY2xpcC5zcGVlZDtcbiAgICAgIHRoaXMuZWxlbWVudHMuc3BlZWRDdXJyZW50LmlubmVySFRNTCA9IGN1cnJlbnRTcGVlZDtcblxuICAgICAgdmFyIHRhcmdldFpvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3RoaXMzLm9wdGlvbnMuc3BlZWRWYWx1ZXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgaWYgKF90aGlzMy5vcHRpb25zLnNwZWVkVmFsdWVzW2ldIDw9IF90aGlzMy5jbGlwLnNwZWVkICYmIF90aGlzMy5vcHRpb25zLnNwZWVkVmFsdWVzW2kgKyAxXSA+IF90aGlzMy5jbGlwLnNwZWVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaSArIE1hdGguYWJzKChfdGhpczMuY2xpcC5zcGVlZCAtIF90aGlzMy5vcHRpb25zLnNwZWVkVmFsdWVzW2ldKSAvIChfdGhpczMub3B0aW9ucy5zcGVlZFZhbHVlc1tpXSAtIF90aGlzMy5vcHRpb25zLnNwZWVkVmFsdWVzW2kgKyAxXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSgpO1xuXG4gICAgICB2YXIgc3RlcCA9IDEgLyAodGhpcy5vcHRpb25zLnNwZWVkVmFsdWVzLmxlbmd0aCAtIDEpO1xuICAgICAgdmFyIHBvc2l0aW9uWSA9ICh0YXJnZXRab25lICogc3RlcCAtIDEpICogLTEgKiAodGhpcy5vcHRpb25zLnNwZWVkVmFsdWVzLmxlbmd0aCAtIDEpICogMTY7XG4gICAgICBlbGlkKFwiXCIuY29uY2F0KHRoaXMubmFtZSwgXCItc3BlZWQtY3Vyc29yXCIpKS5zdHlsZS50b3AgPSBwb3NpdGlvblkgKyBcInB4XCI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbGN1bGF0ZVNwZWVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZVNwZWVkKHN0ZXAsIGFycmF5T2ZWYWx1ZXMsIGN1cnJlbnRQZXJjZW50YWdlKSB7XG4gICAgICB2YXIgYm90TGltaXRJbmRleCA9IE1hdGguZmxvb3IoY3VycmVudFBlcmNlbnRhZ2UgLyBzdGVwKTtcblxuICAgICAgaWYgKGJvdExpbWl0SW5kZXggPT09IGFycmF5T2ZWYWx1ZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICByZXR1cm4gYXJyYXlPZlZhbHVlc1tib3RMaW1pdEluZGV4XS50b0ZpeGVkKDEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGltaXRab25lUGVyY2VudGFnZSA9IGN1cnJlbnRQZXJjZW50YWdlIC8gc3RlcCAlIDE7XG4gICAgICB2YXIgbGltaXRab25lTGVuZ3RoID0gTWF0aC5hYnMoYXJyYXlPZlZhbHVlc1tib3RMaW1pdEluZGV4XSAtIGFycmF5T2ZWYWx1ZXNbYm90TGltaXRJbmRleCArIDFdKTtcbiAgICAgIHZhciByZWFsWm9uZVNwZWVkID0gbGltaXRab25lUGVyY2VudGFnZSAqIGxpbWl0Wm9uZUxlbmd0aDtcbiAgICAgIHZhciByZWFsU3BlZWQgPSAocmVhbFpvbmVTcGVlZCArIGFycmF5T2ZWYWx1ZXNbYm90TGltaXRJbmRleF0pLnRvRml4ZWQoMSk7XG5cbiAgICAgIGlmIChyZWFsU3BlZWQgPT0gMCkge1xuICAgICAgICByZXR1cm4gXCIwLjBcIjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlYWxTcGVlZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlUHJldmlld0Rpc3BsYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlUHJldmlld0Rpc3BsYXkoKSB7XG4gICAgICB0aGlzLnByZXZpZXdDbGlwID0gdGhpcy5jbGlwLnBhc3RlKGVsaWQoXCJcIi5jb25jYXQodGhpcy5uYW1lLCBcIi1ob3Zlci1kaXNwbGF5XCIpKSk7XG4gICAgICB2YXIgcHJldmlld0NsaXAgPSBlbGlkKFwiXCIuY29uY2F0KHRoaXMubmFtZSwgXCItaG92ZXItZGlzcGxheVwiKSk7XG4gICAgICB3aW5kb3cucHJldmlld0NsaXAgPSB0aGlzLnByZXZpZXdDbGlwO1xuICAgICAgcHJldmlld0NsaXAuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICBwcmV2aWV3Q2xpcC5zdHlsZS56SW5kZXggPSAxO1xuICAgICAgdGhpcy5zZXRQcmV2aWV3RGltZW50aW9ucygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRQcmV2aWV3RGltZW50aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQcmV2aWV3RGltZW50aW9ucygpIHtcbiAgICAgIHZhciBjbGlwID0gdGhpcy5jbGlwLnByb3BzLmhvc3Q7XG4gICAgICB2YXIgcHJldmlld0NsaXAgPSB0aGlzLnByZXZpZXdDbGlwLm93bkNsaXAucHJvcHMuaG9zdDtcbiAgICAgIHZhciBjbGlwV2lkdGggPSBjbGlwLm9mZnNldFdpZHRoO1xuICAgICAgdmFyIGNsaXBIZWlnaHQgPSBjbGlwLm9mZnNldEhlaWdodDtcbiAgICAgIHZhciBwcmV2aWV3V2lkdGggPSBjbGlwV2lkdGggKiB0aGlzLnByZXZpZXdTY2FsZTsgLy8gbWF4IHdpZHRoIGlzIDMwMFxuXG4gICAgICBpZiAocHJldmlld1dpZHRoID4gMzAwKSB7XG4gICAgICAgIC8vIHByZXZpZXdXaWR0aCA9IHBhcnNlRmxvYXQoXG4gICAgICAgIC8vICAgZWxpZChgJHt0aGlzLm5hbWV9LWhvdmVyLWRpc3BsYXlgKS5zdHlsZS5tYXhXaWR0aFxuICAgICAgICAvLyApO1xuICAgICAgICBwcmV2aWV3V2lkdGggPSAzMDA7XG4gICAgICAgIHRoaXMucHJldmlld1NjYWxlID0gcHJldmlld1dpZHRoIC8gY2xpcFdpZHRoO1xuICAgICAgfVxuXG4gICAgICBlbGlkKFwiXCIuY29uY2F0KHRoaXMubmFtZSwgXCItaG92ZXItZGlzcGxheVwiKSkuc3R5bGUud2lkdGggPSBjbGlwV2lkdGggKyBcInB4XCI7XG4gICAgICBlbGlkKFwiXCIuY29uY2F0KHRoaXMubmFtZSwgXCItaG92ZXItZGlzcGxheVwiKSkuc3R5bGUuaGVpZ2h0ID0gY2xpcEhlaWdodCArIFwicHhcIjtcbiAgICAgIHByZXZpZXdDbGlwLnN0eWxlLnRyYW5zZm9ybSA9IFwic2NhbGUoXCIuY29uY2F0KHRoaXMucHJldmlld1NjYWxlLCBcIilcIik7XG4gICAgICBwcmV2aWV3Q2xpcC5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBcImNlbnRlciBib3R0b21cIjtcbiAgICAgIHByZXZpZXdDbGlwLnN0eWxlLmJveFNpemluZyA9IFwiYm9yZGVyLWJveFwiO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQbGF5ZXI7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gUGxheWVyOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex-player/dist/Player.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex-player/dist/config.js":
/*!***********************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex-player/dist/config.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = {\n  // the players start name\n  name: \"mc-player\",\n\n  // set the players total name\n  set playerName(name) {\n    this.name += \"-\" + name;\n  }\n\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgtcGxheWVyL2Rpc3QvY29uZmlnLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4LXBsYXllci9kaXN0L2NvbmZpZy5qcz8xYWNmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gdGhlIHBsYXllcnMgc3RhcnQgbmFtZVxuICBuYW1lOiBcIm1jLXBsYXllclwiLFxuXG4gIC8vIHNldCB0aGUgcGxheWVycyB0b3RhbCBuYW1lXG4gIHNldCBwbGF5ZXJOYW1lKG5hbWUpIHtcbiAgICB0aGlzLm5hbWUgKz0gXCItXCIgKyBuYW1lO1xuICB9XG5cbn07Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex-player/dist/config.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex-player/dist/helpers.js":
/*!************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex-player/dist/helpers.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = {\n  el: function el(selector) {\n    return document.querySelectorAll(selector);\n  },\n  elid: function elid(id) {\n    return document.getElementById(id);\n  },\n  eltag: function eltag(tag) {\n    return document.getElementsByTagName(tag);\n  },\n  elcreate: function elcreate(tag) {\n    return document.createElement(tag);\n  },\n  addListener: function addListener() {\n    var _document;\n\n    return (_document = document).addEventListener.apply(_document, arguments);\n  },\n  removeListener: function removeListener() {\n    var _document2;\n\n    return (_document2 = document).removeEventListener.apply(_document2, arguments);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgtcGxheWVyL2Rpc3QvaGVscGVycy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC1wbGF5ZXIvZGlzdC9oZWxwZXJzLmpzPzVmZmQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBlbDogZnVuY3Rpb24gZWwoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gIH0sXG4gIGVsaWQ6IGZ1bmN0aW9uIGVsaWQoaWQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICB9LFxuICBlbHRhZzogZnVuY3Rpb24gZWx0YWcodGFnKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZyk7XG4gIH0sXG4gIGVsY3JlYXRlOiBmdW5jdGlvbiBlbGNyZWF0ZSh0YWcpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICB9LFxuICBhZGRMaXN0ZW5lcjogZnVuY3Rpb24gYWRkTGlzdGVuZXIoKSB7XG4gICAgdmFyIF9kb2N1bWVudDtcblxuICAgIHJldHVybiAoX2RvY3VtZW50ID0gZG9jdW1lbnQpLmFkZEV2ZW50TGlzdGVuZXIuYXBwbHkoX2RvY3VtZW50LCBhcmd1bWVudHMpO1xuICB9LFxuICByZW1vdmVMaXN0ZW5lcjogZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoKSB7XG4gICAgdmFyIF9kb2N1bWVudDI7XG5cbiAgICByZXR1cm4gKF9kb2N1bWVudDIgPSBkb2N1bWVudCkucmVtb3ZlRXZlbnRMaXN0ZW5lci5hcHBseShfZG9jdW1lbnQyLCBhcmd1bWVudHMpO1xuICB9XG59OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex-player/dist/helpers.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex-player/dist/html/playerHTML.js":
/*!********************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex-player/dist/html/playerHTML.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function (config) {\n  return \"\\n  <div\\n    class=\\\"pointer-event-panel\\\"\\n    id=\\\"\".concat(config.name, \"-pointer-event-panel\\\"\\n  ></div>\\n  <div\\n    class=\\\"pointer-event-panel\\\"\\n    id=\\\"\").concat(config.name, \"-listener-helper\\\"\\n  ></div>\\n  <div class=\\\"grad\\\"></div>\\n  <div class=\\\"background\\\"></div>\\n  <div id=\\\"\").concat(config.name, \"-controls\\\">\\n    <div id=\\\"\").concat(config.name, \"-totalbar\\\">\\n      <div id=\\\"\").concat(config.name, \"-hover-display\\\">\\n        <div id=\\\"\").concat(config.name, \"-hover-millisecond\\\"></div>\\n      </div>\\n      <div id=\\\"\").concat(config.name, \"-loopbar\\\">\\n        <div\\n          class=\\\"\").concat(config.name, \"-loop-boundaries\\\"\\n          id=\\\"\").concat(config.name, \"-loopbar-start\\\"\\n        ></div>\\n        <div\\n          class=\\\"\").concat(config.name, \"-loop-boundaries\\\"\\n          id=\\\"\").concat(config.name, \"-loopbar-end\\\"\\n        ></div>\\n        <div id=\\\"\").concat(config.name, \"-helperbar\\\"></div>\\n        <div id=\\\"\").concat(config.name, \"-runningbar\\\">\\n          <div id=\\\"\").concat(config.name, \"-cursor\\\"></div>\\n        </div>\\n      </div>\\n    </div>\\n    <div id=\\\"\").concat(config.name, \"-left-controls\\\">\\n      <div id=\\\"\").concat(config.name, \"-status-btn\\\">\\n        \").concat(config.svg.playSVG, \"\\n        <span id=\\\"\").concat(config.name, \"-indicator\\\"></span>\\n      </div>\\n      <div id=\\\"\").concat(config.name, \"-volume\\\">\\n        <div id=\\\"\").concat(config.name, \"-volume-btn\\\">\\n          \").concat(config.svg.volumeSVG, \"\\n        </div>\\n        <div id=\\\"\").concat(config.name, \"-volumebar-helper\\\"></div>\\n        <div id=\\\"\").concat(config.name, \"-volumebar\\\">\\n            <div id=\\\"\").concat(config.name, \"-volumebar-active\\\">\\n              <div id=\\\"\").concat(config.name, \"-volume-cursor\\\"></div>\\n            </div>\\n        </div>\\n      </div>\\n      <div id=\\\"\").concat(config.name, \"-time-display\\\">\\n        <span id=\\\"\").concat(config.name, \"-time-current\\\"></span>\\n        <span id=\\\"\").concat(config.name, \"-time-separator\\\"></span>\\n        <span id=\\\"\").concat(config.name, \"-time-total\\\"></span>\\n      </div>\\n    </div>\\n    <div id=\\\"\").concat(config.name, \"-right-controls\\\">\\n      <div\\n        id=\\\"\").concat(config.name, \"-loop-btn-container\\\"\\n      >\\n        <div\\n          id=\\\"\").concat(config.name, \"-loop-btn\\\"\\n        >\").concat(config.svg.loopSVG, \"</div>\\n        <div\\n          id=\\\"\").concat(config.name, \"-loop-time\\\"\\n        >\\n          <span\\n            id=\\\"\").concat(config.name, \"-loopbar-start-time\\\"\\n            class=\\\"\").concat(config.name, \"-loopbar-time\\\"\\n          ></span>\\n          <span>:</span>\\n          <span\\n            id=\\\"\").concat(config.name, \"-loopbar-end-time\\\"\\n            class=\\\"\").concat(config.name, \"-loopbar-time\\\"\\n          ></span>\\n        </div>\\n      </div>\\n      <div\\n        id=\\\"\").concat(config.name, \"-settings-btn\\\"\\n      >\").concat(config.svg.settingsSVG, \"</div>\\n      <div\\n        id=\\\"\").concat(config.name, \"-dc-btn\\\"\\n      >\\n        \").concat(config.svg.dcSVG, \"\\n      </div>\\n      \\n      <div\\n        id=\\\"\").concat(config.name, \"-full-screen-btn\\\"\\n      >\").concat(config.svg.fullScreenSVG, \"</div>\\n    </div>\\n    \\n\\n  </div>\\n  <div id=\\\"\").concat(config.name, \"-settings-panel\\\">\\n    <ul id=\\\"\").concat(config.name, \"-main-settings\\\">\\n      <li id=\\\"\").concat(config.name, \"-settings-pointer-events\\\">\\n        <label>Pointer Events</label>\\n        <label class=\\\"switch settings-switch\\\">\\n          <input id=\\\"\").concat(config.name, \"-pointer-events-checkbox\\\" type=\\\"checkbox\\\">\\n          <span class=\\\"slider round\\\"></span>\\n        </label>\\n      </li>\\n      <li id=\\\"\").concat(config.name, \"-settings-preview\\\">\\n        <label>Show Preview</label>\\n        <label class=\\\"switch settings-switch\\\">\\n          <input id=\\\"\").concat(config.name, \"-show-preview-checkbox\\\" type=\\\"checkbox\\\">\\n          <span class=\\\"slider round\\\"></span>\\n        </label>\\n      </li>\\n      <li id=\\\"\").concat(config.name, \"-settings-indicator\\\">\\n        <label>Show Indicator</label>\\n        <label class=\\\"switch settings-switch\\\">\\n          <input id=\\\"\").concat(config.name, \"-show-indicator-checkbox\\\" type=\\\"checkbox\\\">\\n          <span class=\\\"slider round\\\"></span>\\n        </label>\\n      </li>\\n      <li id=\\\"\").concat(config.name, \"-settings-volume\\\">\\n        <label>Show Volume</label>\\n        <label class=\\\"switch settings-switch\\\">\\n          <input id=\\\"\").concat(config.name, \"-show-volume-checkbox\\\" type=\\\"checkbox\\\">\\n          <span class=\\\"slider round\\\"></span>\\n        </label>\\n      </li>\\n      <li id=\\\"\").concat(config.name, \"-settings-speed-show\\\">\\n        <label>Speed</label>\\n        <div class=\\\"\").concat(config.name, \"-speed-btn\\\">\").concat(config.svg.arrowRightSVG, \"</div>\\n        <span id=\\\"\").concat(config.name, \"-speed-current\\\"></span>\\n      </li>\\n    </ul>\\n    <ul id=\\\"\").concat(config.name, \"-speed-settings\\\">\\n      <li id=\\\"\").concat(config.name, \"-settings-speed-hide\\\">\\n        <div class=\\\"\").concat(config.name, \"-speed-btn\\\">\").concat(config.svg.arrowLeftSVG, \"</div>\\n        <label id=\").concat(config.name, \"-speed-runtime>Speed</label>\\n      </li>\\n      <li>\\n        <div id=\\\"\").concat(config.name, \"-speed-value-helperbar\\\"></div>\\n        <div id=\\\"\").concat(config.name, \"-speed-value-bar\\\">\\n          <div\\n            class=\\\"\").concat(config.name, \"-speed-value-step\\\"\\n            id=\\\"\").concat(config.name, \"-speed-cursor\\\"\\n          >\\n            <div></div>\\n          </div>\\n        </div>\\n        <div id=\\\"\").concat(config.name, \"-speed-value\\\">\\n        </div>\\n      </li>\\n    </ul>\\n  </div>\\n\");\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgtcGxheWVyL2Rpc3QvaHRtbC9wbGF5ZXJIVE1MLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4LXBsYXllci9kaXN0L2h0bWwvcGxheWVySFRNTC5qcz80NmNhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgcmV0dXJuIFwiXFxuICA8ZGl2XFxuICAgIGNsYXNzPVxcXCJwb2ludGVyLWV2ZW50LXBhbmVsXFxcIlxcbiAgICBpZD1cXFwiXCIuY29uY2F0KGNvbmZpZy5uYW1lLCBcIi1wb2ludGVyLWV2ZW50LXBhbmVsXFxcIlxcbiAgPjwvZGl2PlxcbiAgPGRpdlxcbiAgICBjbGFzcz1cXFwicG9pbnRlci1ldmVudC1wYW5lbFxcXCJcXG4gICAgaWQ9XFxcIlwiKS5jb25jYXQoY29uZmlnLm5hbWUsIFwiLWxpc3RlbmVyLWhlbHBlclxcXCJcXG4gID48L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XFxcImdyYWRcXFwiPjwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwiYmFja2dyb3VuZFxcXCI+PC9kaXY+XFxuICA8ZGl2IGlkPVxcXCJcIikuY29uY2F0KGNvbmZpZy5uYW1lLCBcIi1jb250cm9sc1xcXCI+XFxuICAgIDxkaXYgaWQ9XFxcIlwiKS5jb25jYXQoY29uZmlnLm5hbWUsIFwiLXRvdGFsYmFyXFxcIj5cXG4gICAgICA8ZGl2IGlkPVxcXCJcIikuY29uY2F0KGNvbmZpZy5uYW1lLCBcIi1ob3Zlci1kaXNwbGF5XFxcIj5cXG4gICAgICAgIDxkaXYgaWQ9XFxcIlwiKS5jb25jYXQoY29uZmlnLm5hbWUsIFwiLWhvdmVyLW1pbGxpc2Vjb25kXFxcIj48L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IGlkPVxcXCJcIikuY29uY2F0KGNvbmZpZy5uYW1lLCBcIi1sb29wYmFyXFxcIj5cXG4gICAgICAgIDxkaXZcXG4gICAgICAgICAgY2xhc3M9XFxcIlwiKS5jb25jYXQoY29uZmlnLm5hbWUsIFwiLWxvb3AtYm91bmRhcmllc1xcXCJcXG4gICAgICAgICAgaWQ9XFxcIlwiKS5jb25jYXQoY29uZmlnLm5hbWUsIFwiLWxvb3BiYXItc3RhcnRcXFwiXFxuICAgICAgICA+PC9kaXY+XFxuICAgICAgICA8ZGl2XFxuICAgICAgICAgIGNsYXNzPVxcXCJcIikuY29uY2F0KGNvbmZpZy5uYW1lLCBcIi1sb29wLWJvdW5kYXJpZXNcXFwiXFxuICAgICAgICAgIGlkPVxcXCJcIikuY29uY2F0KGNvbmZpZy5uYW1lLCBcIi1sb29wYmFyLWVuZFxcXCJcXG4gICAgICAgID48L2Rpdj5cXG4gICAgICAgIDxkaXYgaWQ9XFxcIlwiKS5jb25jYXQoY29uZmlnLm5hbWUsIFwiLWhlbHBlcmJhclxcXCI+PC9kaXY+XFxuICAgICAgICA8ZGl2IGlkPVxcXCJcIikuY29uY2F0KGNvbmZpZy5uYW1lLCBcIi1ydW5uaW5nYmFyXFxcIj5cXG4gICAgICAgICAgPGRpdiBpZD1cXFwiXCIpLmNvbmNhdChjb25maWcubmFtZSwgXCItY3Vyc29yXFxcIj48L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBpZD1cXFwiXCIpLmNvbmNhdChjb25maWcubmFtZSwgXCItbGVmdC1jb250cm9sc1xcXCI+XFxuICAgICAgPGRpdiBpZD1cXFwiXCIpLmNvbmNhdChjb25maWcubmFtZSwgXCItc3RhdHVzLWJ0blxcXCI+XFxuICAgICAgICBcIikuY29uY2F0KGNvbmZpZy5zdmcucGxheVNWRywgXCJcXG4gICAgICAgIDxzcGFuIGlkPVxcXCJcIikuY29uY2F0KGNvbmZpZy5uYW1lLCBcIi1pbmRpY2F0b3JcXFwiPjwvc3Bhbj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IGlkPVxcXCJcIikuY29uY2F0KGNvbmZpZy5uYW1lLCBcIi12b2x1bWVcXFwiPlxcbiAgICAgICAgPGRpdiBpZD1cXFwiXCIpLmNvbmNhdChjb25maWcubmFtZSwgXCItdm9sdW1lLWJ0blxcXCI+XFxuICAgICAgICAgIFwiKS5jb25jYXQoY29uZmlnLnN2Zy52b2x1bWVTVkcsIFwiXFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgaWQ9XFxcIlwiKS5jb25jYXQoY29uZmlnLm5hbWUsIFwiLXZvbHVtZWJhci1oZWxwZXJcXFwiPjwvZGl2PlxcbiAgICAgICAgPGRpdiBpZD1cXFwiXCIpLmNvbmNhdChjb25maWcubmFtZSwgXCItdm9sdW1lYmFyXFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGlkPVxcXCJcIikuY29uY2F0KGNvbmZpZy5uYW1lLCBcIi12b2x1bWViYXItYWN0aXZlXFxcIj5cXG4gICAgICAgICAgICAgIDxkaXYgaWQ9XFxcIlwiKS5jb25jYXQoY29uZmlnLm5hbWUsIFwiLXZvbHVtZS1jdXJzb3JcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBpZD1cXFwiXCIpLmNvbmNhdChjb25maWcubmFtZSwgXCItdGltZS1kaXNwbGF5XFxcIj5cXG4gICAgICAgIDxzcGFuIGlkPVxcXCJcIikuY29uY2F0KGNvbmZpZy5uYW1lLCBcIi10aW1lLWN1cnJlbnRcXFwiPjwvc3Bhbj5cXG4gICAgICAgIDxzcGFuIGlkPVxcXCJcIikuY29uY2F0KGNvbmZpZy5uYW1lLCBcIi10aW1lLXNlcGFyYXRvclxcXCI+PC9zcGFuPlxcbiAgICAgICAgPHNwYW4gaWQ9XFxcIlwiKS5jb25jYXQoY29uZmlnLm5hbWUsIFwiLXRpbWUtdG90YWxcXFwiPjwvc3Bhbj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgaWQ9XFxcIlwiKS5jb25jYXQoY29uZmlnLm5hbWUsIFwiLXJpZ2h0LWNvbnRyb2xzXFxcIj5cXG4gICAgICA8ZGl2XFxuICAgICAgICBpZD1cXFwiXCIpLmNvbmNhdChjb25maWcubmFtZSwgXCItbG9vcC1idG4tY29udGFpbmVyXFxcIlxcbiAgICAgID5cXG4gICAgICAgIDxkaXZcXG4gICAgICAgICAgaWQ9XFxcIlwiKS5jb25jYXQoY29uZmlnLm5hbWUsIFwiLWxvb3AtYnRuXFxcIlxcbiAgICAgICAgPlwiKS5jb25jYXQoY29uZmlnLnN2Zy5sb29wU1ZHLCBcIjwvZGl2PlxcbiAgICAgICAgPGRpdlxcbiAgICAgICAgICBpZD1cXFwiXCIpLmNvbmNhdChjb25maWcubmFtZSwgXCItbG9vcC10aW1lXFxcIlxcbiAgICAgICAgPlxcbiAgICAgICAgICA8c3BhblxcbiAgICAgICAgICAgIGlkPVxcXCJcIikuY29uY2F0KGNvbmZpZy5uYW1lLCBcIi1sb29wYmFyLXN0YXJ0LXRpbWVcXFwiXFxuICAgICAgICAgICAgY2xhc3M9XFxcIlwiKS5jb25jYXQoY29uZmlnLm5hbWUsIFwiLWxvb3BiYXItdGltZVxcXCJcXG4gICAgICAgICAgPjwvc3Bhbj5cXG4gICAgICAgICAgPHNwYW4+Ojwvc3Bhbj5cXG4gICAgICAgICAgPHNwYW5cXG4gICAgICAgICAgICBpZD1cXFwiXCIpLmNvbmNhdChjb25maWcubmFtZSwgXCItbG9vcGJhci1lbmQtdGltZVxcXCJcXG4gICAgICAgICAgICBjbGFzcz1cXFwiXCIpLmNvbmNhdChjb25maWcubmFtZSwgXCItbG9vcGJhci10aW1lXFxcIlxcbiAgICAgICAgICA+PC9zcGFuPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdlxcbiAgICAgICAgaWQ9XFxcIlwiKS5jb25jYXQoY29uZmlnLm5hbWUsIFwiLXNldHRpbmdzLWJ0blxcXCJcXG4gICAgICA+XCIpLmNvbmNhdChjb25maWcuc3ZnLnNldHRpbmdzU1ZHLCBcIjwvZGl2PlxcbiAgICAgIDxkaXZcXG4gICAgICAgIGlkPVxcXCJcIikuY29uY2F0KGNvbmZpZy5uYW1lLCBcIi1kYy1idG5cXFwiXFxuICAgICAgPlxcbiAgICAgICAgXCIpLmNvbmNhdChjb25maWcuc3ZnLmRjU1ZHLCBcIlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIFxcbiAgICAgIDxkaXZcXG4gICAgICAgIGlkPVxcXCJcIikuY29uY2F0KGNvbmZpZy5uYW1lLCBcIi1mdWxsLXNjcmVlbi1idG5cXFwiXFxuICAgICAgPlwiKS5jb25jYXQoY29uZmlnLnN2Zy5mdWxsU2NyZWVuU1ZHLCBcIjwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgXFxuXFxuICA8L2Rpdj5cXG4gIDxkaXYgaWQ9XFxcIlwiKS5jb25jYXQoY29uZmlnLm5hbWUsIFwiLXNldHRpbmdzLXBhbmVsXFxcIj5cXG4gICAgPHVsIGlkPVxcXCJcIikuY29uY2F0KGNvbmZpZy5uYW1lLCBcIi1tYWluLXNldHRpbmdzXFxcIj5cXG4gICAgICA8bGkgaWQ9XFxcIlwiKS5jb25jYXQoY29uZmlnLm5hbWUsIFwiLXNldHRpbmdzLXBvaW50ZXItZXZlbnRzXFxcIj5cXG4gICAgICAgIDxsYWJlbD5Qb2ludGVyIEV2ZW50czwvbGFiZWw+XFxuICAgICAgICA8bGFiZWwgY2xhc3M9XFxcInN3aXRjaCBzZXR0aW5ncy1zd2l0Y2hcXFwiPlxcbiAgICAgICAgICA8aW5wdXQgaWQ9XFxcIlwiKS5jb25jYXQoY29uZmlnLm5hbWUsIFwiLXBvaW50ZXItZXZlbnRzLWNoZWNrYm94XFxcIiB0eXBlPVxcXCJjaGVja2JveFxcXCI+XFxuICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzbGlkZXIgcm91bmRcXFwiPjwvc3Bhbj5cXG4gICAgICAgIDwvbGFiZWw+XFxuICAgICAgPC9saT5cXG4gICAgICA8bGkgaWQ9XFxcIlwiKS5jb25jYXQoY29uZmlnLm5hbWUsIFwiLXNldHRpbmdzLXByZXZpZXdcXFwiPlxcbiAgICAgICAgPGxhYmVsPlNob3cgUHJldmlldzwvbGFiZWw+XFxuICAgICAgICA8bGFiZWwgY2xhc3M9XFxcInN3aXRjaCBzZXR0aW5ncy1zd2l0Y2hcXFwiPlxcbiAgICAgICAgICA8aW5wdXQgaWQ9XFxcIlwiKS5jb25jYXQoY29uZmlnLm5hbWUsIFwiLXNob3ctcHJldmlldy1jaGVja2JveFxcXCIgdHlwZT1cXFwiY2hlY2tib3hcXFwiPlxcbiAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwic2xpZGVyIHJvdW5kXFxcIj48L3NwYW4+XFxuICAgICAgICA8L2xhYmVsPlxcbiAgICAgIDwvbGk+XFxuICAgICAgPGxpIGlkPVxcXCJcIikuY29uY2F0KGNvbmZpZy5uYW1lLCBcIi1zZXR0aW5ncy1pbmRpY2F0b3JcXFwiPlxcbiAgICAgICAgPGxhYmVsPlNob3cgSW5kaWNhdG9yPC9sYWJlbD5cXG4gICAgICAgIDxsYWJlbCBjbGFzcz1cXFwic3dpdGNoIHNldHRpbmdzLXN3aXRjaFxcXCI+XFxuICAgICAgICAgIDxpbnB1dCBpZD1cXFwiXCIpLmNvbmNhdChjb25maWcubmFtZSwgXCItc2hvdy1pbmRpY2F0b3ItY2hlY2tib3hcXFwiIHR5cGU9XFxcImNoZWNrYm94XFxcIj5cXG4gICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNsaWRlciByb3VuZFxcXCI+PC9zcGFuPlxcbiAgICAgICAgPC9sYWJlbD5cXG4gICAgICA8L2xpPlxcbiAgICAgIDxsaSBpZD1cXFwiXCIpLmNvbmNhdChjb25maWcubmFtZSwgXCItc2V0dGluZ3Mtdm9sdW1lXFxcIj5cXG4gICAgICAgIDxsYWJlbD5TaG93IFZvbHVtZTwvbGFiZWw+XFxuICAgICAgICA8bGFiZWwgY2xhc3M9XFxcInN3aXRjaCBzZXR0aW5ncy1zd2l0Y2hcXFwiPlxcbiAgICAgICAgICA8aW5wdXQgaWQ9XFxcIlwiKS5jb25jYXQoY29uZmlnLm5hbWUsIFwiLXNob3ctdm9sdW1lLWNoZWNrYm94XFxcIiB0eXBlPVxcXCJjaGVja2JveFxcXCI+XFxuICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzbGlkZXIgcm91bmRcXFwiPjwvc3Bhbj5cXG4gICAgICAgIDwvbGFiZWw+XFxuICAgICAgPC9saT5cXG4gICAgICA8bGkgaWQ9XFxcIlwiKS5jb25jYXQoY29uZmlnLm5hbWUsIFwiLXNldHRpbmdzLXNwZWVkLXNob3dcXFwiPlxcbiAgICAgICAgPGxhYmVsPlNwZWVkPC9sYWJlbD5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcIlwiKS5jb25jYXQoY29uZmlnLm5hbWUsIFwiLXNwZWVkLWJ0blxcXCI+XCIpLmNvbmNhdChjb25maWcuc3ZnLmFycm93UmlnaHRTVkcsIFwiPC9kaXY+XFxuICAgICAgICA8c3BhbiBpZD1cXFwiXCIpLmNvbmNhdChjb25maWcubmFtZSwgXCItc3BlZWQtY3VycmVudFxcXCI+PC9zcGFuPlxcbiAgICAgIDwvbGk+XFxuICAgIDwvdWw+XFxuICAgIDx1bCBpZD1cXFwiXCIpLmNvbmNhdChjb25maWcubmFtZSwgXCItc3BlZWQtc2V0dGluZ3NcXFwiPlxcbiAgICAgIDxsaSBpZD1cXFwiXCIpLmNvbmNhdChjb25maWcubmFtZSwgXCItc2V0dGluZ3Mtc3BlZWQtaGlkZVxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJcIikuY29uY2F0KGNvbmZpZy5uYW1lLCBcIi1zcGVlZC1idG5cXFwiPlwiKS5jb25jYXQoY29uZmlnLnN2Zy5hcnJvd0xlZnRTVkcsIFwiPC9kaXY+XFxuICAgICAgICA8bGFiZWwgaWQ9XCIpLmNvbmNhdChjb25maWcubmFtZSwgXCItc3BlZWQtcnVudGltZT5TcGVlZDwvbGFiZWw+XFxuICAgICAgPC9saT5cXG4gICAgICA8bGk+XFxuICAgICAgICA8ZGl2IGlkPVxcXCJcIikuY29uY2F0KGNvbmZpZy5uYW1lLCBcIi1zcGVlZC12YWx1ZS1oZWxwZXJiYXJcXFwiPjwvZGl2PlxcbiAgICAgICAgPGRpdiBpZD1cXFwiXCIpLmNvbmNhdChjb25maWcubmFtZSwgXCItc3BlZWQtdmFsdWUtYmFyXFxcIj5cXG4gICAgICAgICAgPGRpdlxcbiAgICAgICAgICAgIGNsYXNzPVxcXCJcIikuY29uY2F0KGNvbmZpZy5uYW1lLCBcIi1zcGVlZC12YWx1ZS1zdGVwXFxcIlxcbiAgICAgICAgICAgIGlkPVxcXCJcIikuY29uY2F0KGNvbmZpZy5uYW1lLCBcIi1zcGVlZC1jdXJzb3JcXFwiXFxuICAgICAgICAgID5cXG4gICAgICAgICAgICA8ZGl2PjwvZGl2PlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdiBpZD1cXFwiXCIpLmNvbmNhdChjb25maWcubmFtZSwgXCItc3BlZWQtdmFsdWVcXFwiPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9saT5cXG4gICAgPC91bD5cXG4gIDwvZGl2PlxcblwiKTtcbn07Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex-player/dist/html/playerHTML.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex-player/dist/html/setElements.js":
/*!*********************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex-player/dist/html/setElements.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _require = __webpack_require__(/*! ../helpers */ \"../node_modules/@kissmybutton/motorcortex-player/dist/helpers.js\"),\n    elid = _require.elid,\n    elcreate = _require.elcreate;\n\nvar svg = __webpack_require__(/*! ./svg */ \"../node_modules/@kissmybutton/motorcortex-player/dist/html/svg.js\");\n\nvar playerHTML = __webpack_require__(/*! ./playerHTML */ \"../node_modules/@kissmybutton/motorcortex-player/dist/html/playerHTML.js\");\n\nmodule.exports = function (_this) {\n  _this.elements = {};\n  var clipIframe = _this.clip.props.host; // console.log(_this.clip);\n  // set _this.clip position to relative\n\n  clipIframe.style.display = \"flex\";\n  clipIframe.style.justifyContent = \"center\";\n  clipIframe.style.alignItems = \"center\";\n  _this.clip.props.host.style.position = \"relative\";\n  _this.clip.props.host.style.zIndex = \"0\";\n  _this.elements.mcPlayer = elcreate(\"div\");\n  _this.elements.mcPlayer.id = \"\".concat(_this.name);\n  _this.elements.mcPlayer.className = \"\".concat(_this.className);\n  _this.elements.mcPlayer.innerHTML = playerHTML({\n    svg: svg,\n    name: _this.name\n  });\n\n  if (typeof _this.options.host === \"string\") {\n    var nodelist = document.querySelectorAll(_this.options.host);\n\n    for (var i in nodelist) {\n      if (isNaN(i)) {\n        continue;\n      }\n\n      nodelist[i].appendChild(_this.elements.mcPlayer);\n    }\n  } else {\n    _this.options.host.appendChild(_this.elements.mcPlayer);\n  }\n\n  _this.elements.pointerEventPanel = elid(\"\".concat(_this.name, \"-pointer-event-panel\"));\n  _this.elements.listenerHelper = elid(\"\".concat(_this.name, \"-listener-helper\"));\n  _this.elements.loopBar = elid(\"\".concat(_this.name, \"-loopbar\"));\n  _this.elements.totalBar = elid(\"\".concat(_this.name, \"-totalbar\"));\n  _this.elements.indicator = elid(\"\".concat(_this.name, \"-indicator\"));\n  _this.elements.loopButton = elid(\"\".concat(_this.name, \"-loop-btn\"));\n  _this.elements.volumeBar = elid(\"\".concat(_this.name, \"-volumebar\"));\n  _this.elements.totalTime = elid(\"\".concat(_this.name, \"-time-total\"));\n  _this.elements.volumeControl = elid(\"\".concat(_this.name, \"-volume\"));\n  _this.elements.volumeBtn = elid(\"\".concat(_this.name, \"-volume-btn\"));\n  _this.elements.runningBar = elid(\"\".concat(_this.name, \"-runningbar\"));\n  _this.elements.loopBarEnd = elid(\"\".concat(_this.name, \"-loopbar-end\"));\n  _this.elements.statusButton = elid(\"\".concat(_this.name, \"-status-btn\"));\n  _this.elements.speedBar = elid(\"\".concat(_this.name, \"-speed-value-bar\"));\n  _this.elements.currentTime = elid(\"\".concat(_this.name, \"-time-current\"));\n  _this.elements.timeDisplay = elid(\"\".concat(_this.name, \"-time-display\"));\n  _this.elements.speedCurrent = elid(\"\".concat(_this.name, \"-speed-current\"));\n  _this.elements.loopBarStart = elid(\"\".concat(_this.name, \"-loopbar-start\"));\n  _this.elements.volumeCursor = elid(\"\".concat(_this.name, \"-volume-cursor\"));\n  _this.elements.settingsButton = elid(\"\".concat(_this.name, \"-settings-btn\"));\n  _this.elements.donkeyclipButton = elid(\"\".concat(_this.name, \"-dc-btn\"));\n  _this.elements.timeSeparator = elid(\"\".concat(_this.name, \"-time-separator\"));\n  _this.elements.settingsPanel = elid(\"\".concat(_this.name, \"-settings-panel\"));\n  _this.elements.settingsMainPanel = elid(\"\".concat(_this.name, \"-main-settings\"));\n  _this.elements.fullScreenButton = elid(\"\".concat(_this.name, \"-full-screen-btn\"));\n  _this.elements.volumeBarHelper = elid(\"\".concat(_this.name, \"-volumebar-helper\"));\n  _this.elements.volumeBarActive = elid(\"\".concat(_this.name, \"-volumebar-active\"));\n  _this.elements.settingsSpeedPanel = elid(\"\".concat(_this.name, \"-speed-settings\"));\n  _this.elements.settingsShowVolume = elid(\"\".concat(_this.name, \"-settings-volume\"));\n  _this.elements.settingsShowPreview = elid(\"\".concat(_this.name, \"-settings-preview\"));\n  _this.elements.settingsPointerEvents = elid(\"\".concat(_this.name, \"-settings-pointer-events\"));\n  _this.elements.speedBarHelper = elid(\"\".concat(_this.name, \"-speed-value-helperbar\"));\n  _this.elements.settingsShowIndicator = elid(\"\".concat(_this.name, \"-settings-indicator\"));\n  _this.elements.settingsSpeedButtonShow = elid(\"\".concat(_this.name, \"-settings-speed-show\"));\n  _this.elements.settingsSpeedButtonHide = elid(\"\".concat(_this.name, \"-settings-speed-hide\"));\n  _this.elements.volumeBarActive.style.width = _this.settings.volume * 100 + \"%\";\n  _this.elements.currentTime.innerHTML = _this.timeFormat(0);\n  _this.elements.totalTime.innerHTML = _this.timeFormat(_this.clip.duration);\n  _this.elements.timeSeparator.innerHTML = \"/\";\n\n  _this.elements.settingsPanel.classList.add(\"m-fadeOut\", \"\".concat(_this.name, \"-hide\"));\n\n  if (!_this.options.showIndicator) {\n    _this.elements.indicator.style.visibility = \"hidden\";\n  } else {\n    _this.elements.indicator.style.visibility = \"visible\";\n    _this.elements.statusButton.style.width = \"35px\";\n    _this.elements.statusButton.style.height = \"20px\";\n    _this.elements.statusButton.style.bottom = \"5px\";\n  }\n\n  _this.elements.indicator.innerHTML = _this.clip.runTimeInfo.state;\n  _this.elements.settingsSpeedPanel.style.display = \"none\";\n\n  _this.elements.settingsSpeedPanel.getElementsByTagName(\"li\")[1].classList.add(\"no-hover\");\n\n  _this.elements.loopBarStart.style.left = \"0%\";\n\n  _this.elements.loopBarStart.classList.add(\"m-fadeOut\", \"\".concat(_this.name, \"-hide\"));\n\n  _this.elements.loopBarEnd.style.left = \"100%\";\n\n  _this.elements.loopBarEnd.classList.add(\"m-fadeOut\", \"\".concat(_this.name, \"-hide\"));\n\n  _this.elements.loopStartTime = elid(\"\".concat(_this.name, \"-loopbar-start-time\"));\n  _this.elements.loopEndTime = elid(\"\".concat(_this.name, \"-loopbar-end-time\"));\n  _this.elements.editableLoopStartTime = document.createElement(\"input\");\n  _this.elements.editableLoopStartTime.type = \"text\";\n  _this.elements.editableLoopStartTime.size = elid(\"\".concat(_this.name, \"-time-total\")).innerHTML.length + 1;\n  _this.elements.editableLoopStartTime.maxLength = elid(\"\".concat(_this.name, \"-time-total\")).innerHTML.length;\n  _this.elements.editableLoopStartTime.style.height = elid(\"\".concat(_this.name, \"-time-total\")).offsetHeight;\n  _this.elements.editableLoopStartTime.value = elid(\"\".concat(_this.name, \"-loopbar-start-time\")).innerHTML;\n  _this.elements.editableLoopStartTime.style.fontSize = \"8px\";\n  _this.elements.editableLoopEndTime = document.createElement(\"input\");\n  _this.elements.editableLoopEndTime.type = \"text\";\n  _this.elements.editableLoopEndTime.size = elid(\"\".concat(_this.name, \"-time-total\")).innerHTML.length + 1;\n  _this.elements.editableLoopEndTime.maxLength = elid(\"\".concat(_this.name, \"-time-total\")).innerHTML.length;\n  _this.elements.editableLoopEndTime.style.height = elid(\"\".concat(_this.name, \"-time-total\")).offsetHeight;\n  _this.elements.editableLoopEndTime.value = elid(\"\".concat(_this.name, \"-loopbar-start-time\")).innerHTML;\n  _this.elements.editableLoopEndTime.pattern = \"d*\";\n  _this.elements.editableLoopEndTime.style.fontSize = \"8px\";\n  elid(\"\".concat(_this.name, \"-loop-time\")).classList.add(\"m-fadeOut\", \"\".concat(_this.name, \"-hide\"));\n  elid(\"\".concat(_this.name, \"-hover-display\")).classList.add(\"m-fadeOut\" // `${_this.name}-hide`\n  );\n  elid(\"\".concat(_this.name, \"-show-volume-checkbox\")).checked = _this.options.showVolume;\n  elid(\"\".concat(_this.name, \"-show-indicator-checkbox\")).checked = _this.options.showIndicator;\n  elid(\"\".concat(_this.name, \"-show-preview-checkbox\")).checked = _this.options.preview;\n  elid(\"\".concat(_this.name, \"-pointer-events-checkbox\")).checked = _this.options.pointerEvents;\n\n  if (_this.options.pointerEvents) {\n    _this.elements.mcPlayer.style.pointerEvents = \"none\";\n    _this.elements.pointerEventPanel.style.pointerEvents = \"auto\";\n    elid(\"\".concat(_this.name, \"-controls\")).style.pointerEvents = \"auto\";\n    _this.elements.settingsPanel.style.pointerEvents = \"auto\";\n  } else {\n    _this.elements.mcPlayer.style.pointerEvents = \"none\";\n    _this.elements.pointerEventPanel.style.pointerEvents = \"none\";\n    elid(\"\".concat(_this.name, \"-controls\")).style.pointerEvents = \"auto\";\n    _this.elements.settingsPanel.style.pointerEvents = \"auto\";\n  }\n\n  _this.elements.listenerHelper.style.pointerEvents = \"none\";\n\n  if (!_this.options.showVolume) {\n    _this.elements.timeDisplay.style.left = \"45px\";\n    _this.elements.volumeControl.style.visibility = \"hidden\";\n\n    _this.elements.volumeControl.classList.toggle(\"\".concat(_this.name, \"-hide\"));\n\n    _this.elements.volumeControl.classList.toggle(\"\".concat(_this.name, \"-volume-width-transition\"));\n  } else {\n    _this.elements.timeDisplay.style.left = \"\";\n    _this.elements.volumeControl.style.visibility = \"visible\";\n  }\n\n  for (var _i in _this.options.speedValues) {\n    var barDiv = elcreate(\"div\");\n    barDiv.className = \"\".concat(_this.name, \"-speed-value-step\");\n    var valueDiv = elcreate(\"div\");\n    valueDiv.className = \"\".concat(_this.name, \"-speed-value\");\n    valueDiv.dataset.speedValue = _this.options.speedValues[_i];\n    valueDiv.innerHTML = _this.options.speedValues[_i];\n    valueDiv.dataset.zone = _i;\n    elid(\"\".concat(_this.name, \"-speed-value\")).prepend(valueDiv);\n\n    _this.elements.speedBar.prepend(barDiv);\n  } // show hide buttons\n\n\n  if (_this.options.buttons.fullScreen === false) {\n    _this.elements.fullScreenButton.remove();\n  }\n\n  if (_this.options.buttons.settings === false) {\n    _this.elements.settingsButton.remove();\n  }\n\n  if (_this.options.buttons.donkeyclip === false) {\n    _this.elements.donkeyclipButton.remove();\n  }\n\n  if (_this.options.buttons.loop === false) {\n    _this.elements.loopButton.remove();\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgtcGxheWVyL2Rpc3QvaHRtbC9zZXRFbGVtZW50cy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC1wbGF5ZXIvZGlzdC9odG1sL3NldEVsZW1lbnRzLmpzPzUyMDYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzXCIpLFxuICAgIGVsaWQgPSBfcmVxdWlyZS5lbGlkLFxuICAgIGVsY3JlYXRlID0gX3JlcXVpcmUuZWxjcmVhdGU7XG5cbnZhciBzdmcgPSByZXF1aXJlKFwiLi9zdmdcIik7XG5cbnZhciBwbGF5ZXJIVE1MID0gcmVxdWlyZShcIi4vcGxheWVySFRNTFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoX3RoaXMpIHtcbiAgX3RoaXMuZWxlbWVudHMgPSB7fTtcbiAgdmFyIGNsaXBJZnJhbWUgPSBfdGhpcy5jbGlwLnByb3BzLmhvc3Q7IC8vIGNvbnNvbGUubG9nKF90aGlzLmNsaXApO1xuICAvLyBzZXQgX3RoaXMuY2xpcCBwb3NpdGlvbiB0byByZWxhdGl2ZVxuXG4gIGNsaXBJZnJhbWUuc3R5bGUuZGlzcGxheSA9IFwiZmxleFwiO1xuICBjbGlwSWZyYW1lLnN0eWxlLmp1c3RpZnlDb250ZW50ID0gXCJjZW50ZXJcIjtcbiAgY2xpcElmcmFtZS5zdHlsZS5hbGlnbkl0ZW1zID0gXCJjZW50ZXJcIjtcbiAgX3RoaXMuY2xpcC5wcm9wcy5ob3N0LnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICBfdGhpcy5jbGlwLnByb3BzLmhvc3Quc3R5bGUuekluZGV4ID0gXCIwXCI7XG4gIF90aGlzLmVsZW1lbnRzLm1jUGxheWVyID0gZWxjcmVhdGUoXCJkaXZcIik7XG4gIF90aGlzLmVsZW1lbnRzLm1jUGxheWVyLmlkID0gXCJcIi5jb25jYXQoX3RoaXMubmFtZSk7XG4gIF90aGlzLmVsZW1lbnRzLm1jUGxheWVyLmNsYXNzTmFtZSA9IFwiXCIuY29uY2F0KF90aGlzLmNsYXNzTmFtZSk7XG4gIF90aGlzLmVsZW1lbnRzLm1jUGxheWVyLmlubmVySFRNTCA9IHBsYXllckhUTUwoe1xuICAgIHN2Zzogc3ZnLFxuICAgIG5hbWU6IF90aGlzLm5hbWVcbiAgfSk7XG5cbiAgaWYgKHR5cGVvZiBfdGhpcy5vcHRpb25zLmhvc3QgPT09IFwic3RyaW5nXCIpIHtcbiAgICB2YXIgbm9kZWxpc3QgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKF90aGlzLm9wdGlvbnMuaG9zdCk7XG5cbiAgICBmb3IgKHZhciBpIGluIG5vZGVsaXN0KSB7XG4gICAgICBpZiAoaXNOYU4oaSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIG5vZGVsaXN0W2ldLmFwcGVuZENoaWxkKF90aGlzLmVsZW1lbnRzLm1jUGxheWVyKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgX3RoaXMub3B0aW9ucy5ob3N0LmFwcGVuZENoaWxkKF90aGlzLmVsZW1lbnRzLm1jUGxheWVyKTtcbiAgfVxuXG4gIF90aGlzLmVsZW1lbnRzLnBvaW50ZXJFdmVudFBhbmVsID0gZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1wb2ludGVyLWV2ZW50LXBhbmVsXCIpKTtcbiAgX3RoaXMuZWxlbWVudHMubGlzdGVuZXJIZWxwZXIgPSBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLWxpc3RlbmVyLWhlbHBlclwiKSk7XG4gIF90aGlzLmVsZW1lbnRzLmxvb3BCYXIgPSBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLWxvb3BiYXJcIikpO1xuICBfdGhpcy5lbGVtZW50cy50b3RhbEJhciA9IGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItdG90YWxiYXJcIikpO1xuICBfdGhpcy5lbGVtZW50cy5pbmRpY2F0b3IgPSBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLWluZGljYXRvclwiKSk7XG4gIF90aGlzLmVsZW1lbnRzLmxvb3BCdXR0b24gPSBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLWxvb3AtYnRuXCIpKTtcbiAgX3RoaXMuZWxlbWVudHMudm9sdW1lQmFyID0gZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi12b2x1bWViYXJcIikpO1xuICBfdGhpcy5lbGVtZW50cy50b3RhbFRpbWUgPSBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLXRpbWUtdG90YWxcIikpO1xuICBfdGhpcy5lbGVtZW50cy52b2x1bWVDb250cm9sID0gZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi12b2x1bWVcIikpO1xuICBfdGhpcy5lbGVtZW50cy52b2x1bWVCdG4gPSBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLXZvbHVtZS1idG5cIikpO1xuICBfdGhpcy5lbGVtZW50cy5ydW5uaW5nQmFyID0gZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1ydW5uaW5nYmFyXCIpKTtcbiAgX3RoaXMuZWxlbWVudHMubG9vcEJhckVuZCA9IGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItbG9vcGJhci1lbmRcIikpO1xuICBfdGhpcy5lbGVtZW50cy5zdGF0dXNCdXR0b24gPSBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLXN0YXR1cy1idG5cIikpO1xuICBfdGhpcy5lbGVtZW50cy5zcGVlZEJhciA9IGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItc3BlZWQtdmFsdWUtYmFyXCIpKTtcbiAgX3RoaXMuZWxlbWVudHMuY3VycmVudFRpbWUgPSBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLXRpbWUtY3VycmVudFwiKSk7XG4gIF90aGlzLmVsZW1lbnRzLnRpbWVEaXNwbGF5ID0gZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi10aW1lLWRpc3BsYXlcIikpO1xuICBfdGhpcy5lbGVtZW50cy5zcGVlZEN1cnJlbnQgPSBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLXNwZWVkLWN1cnJlbnRcIikpO1xuICBfdGhpcy5lbGVtZW50cy5sb29wQmFyU3RhcnQgPSBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLWxvb3BiYXItc3RhcnRcIikpO1xuICBfdGhpcy5lbGVtZW50cy52b2x1bWVDdXJzb3IgPSBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLXZvbHVtZS1jdXJzb3JcIikpO1xuICBfdGhpcy5lbGVtZW50cy5zZXR0aW5nc0J1dHRvbiA9IGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItc2V0dGluZ3MtYnRuXCIpKTtcbiAgX3RoaXMuZWxlbWVudHMuZG9ua2V5Y2xpcEJ1dHRvbiA9IGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItZGMtYnRuXCIpKTtcbiAgX3RoaXMuZWxlbWVudHMudGltZVNlcGFyYXRvciA9IGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItdGltZS1zZXBhcmF0b3JcIikpO1xuICBfdGhpcy5lbGVtZW50cy5zZXR0aW5nc1BhbmVsID0gZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1zZXR0aW5ncy1wYW5lbFwiKSk7XG4gIF90aGlzLmVsZW1lbnRzLnNldHRpbmdzTWFpblBhbmVsID0gZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1tYWluLXNldHRpbmdzXCIpKTtcbiAgX3RoaXMuZWxlbWVudHMuZnVsbFNjcmVlbkJ1dHRvbiA9IGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItZnVsbC1zY3JlZW4tYnRuXCIpKTtcbiAgX3RoaXMuZWxlbWVudHMudm9sdW1lQmFySGVscGVyID0gZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi12b2x1bWViYXItaGVscGVyXCIpKTtcbiAgX3RoaXMuZWxlbWVudHMudm9sdW1lQmFyQWN0aXZlID0gZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi12b2x1bWViYXItYWN0aXZlXCIpKTtcbiAgX3RoaXMuZWxlbWVudHMuc2V0dGluZ3NTcGVlZFBhbmVsID0gZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1zcGVlZC1zZXR0aW5nc1wiKSk7XG4gIF90aGlzLmVsZW1lbnRzLnNldHRpbmdzU2hvd1ZvbHVtZSA9IGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItc2V0dGluZ3Mtdm9sdW1lXCIpKTtcbiAgX3RoaXMuZWxlbWVudHMuc2V0dGluZ3NTaG93UHJldmlldyA9IGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItc2V0dGluZ3MtcHJldmlld1wiKSk7XG4gIF90aGlzLmVsZW1lbnRzLnNldHRpbmdzUG9pbnRlckV2ZW50cyA9IGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItc2V0dGluZ3MtcG9pbnRlci1ldmVudHNcIikpO1xuICBfdGhpcy5lbGVtZW50cy5zcGVlZEJhckhlbHBlciA9IGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItc3BlZWQtdmFsdWUtaGVscGVyYmFyXCIpKTtcbiAgX3RoaXMuZWxlbWVudHMuc2V0dGluZ3NTaG93SW5kaWNhdG9yID0gZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1zZXR0aW5ncy1pbmRpY2F0b3JcIikpO1xuICBfdGhpcy5lbGVtZW50cy5zZXR0aW5nc1NwZWVkQnV0dG9uU2hvdyA9IGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItc2V0dGluZ3Mtc3BlZWQtc2hvd1wiKSk7XG4gIF90aGlzLmVsZW1lbnRzLnNldHRpbmdzU3BlZWRCdXR0b25IaWRlID0gZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1zZXR0aW5ncy1zcGVlZC1oaWRlXCIpKTtcbiAgX3RoaXMuZWxlbWVudHMudm9sdW1lQmFyQWN0aXZlLnN0eWxlLndpZHRoID0gX3RoaXMuc2V0dGluZ3Mudm9sdW1lICogMTAwICsgXCIlXCI7XG4gIF90aGlzLmVsZW1lbnRzLmN1cnJlbnRUaW1lLmlubmVySFRNTCA9IF90aGlzLnRpbWVGb3JtYXQoMCk7XG4gIF90aGlzLmVsZW1lbnRzLnRvdGFsVGltZS5pbm5lckhUTUwgPSBfdGhpcy50aW1lRm9ybWF0KF90aGlzLmNsaXAuZHVyYXRpb24pO1xuICBfdGhpcy5lbGVtZW50cy50aW1lU2VwYXJhdG9yLmlubmVySFRNTCA9IFwiL1wiO1xuXG4gIF90aGlzLmVsZW1lbnRzLnNldHRpbmdzUGFuZWwuY2xhc3NMaXN0LmFkZChcIm0tZmFkZU91dFwiLCBcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1oaWRlXCIpKTtcblxuICBpZiAoIV90aGlzLm9wdGlvbnMuc2hvd0luZGljYXRvcikge1xuICAgIF90aGlzLmVsZW1lbnRzLmluZGljYXRvci5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgfSBlbHNlIHtcbiAgICBfdGhpcy5lbGVtZW50cy5pbmRpY2F0b3Iuc3R5bGUudmlzaWJpbGl0eSA9IFwidmlzaWJsZVwiO1xuICAgIF90aGlzLmVsZW1lbnRzLnN0YXR1c0J1dHRvbi5zdHlsZS53aWR0aCA9IFwiMzVweFwiO1xuICAgIF90aGlzLmVsZW1lbnRzLnN0YXR1c0J1dHRvbi5zdHlsZS5oZWlnaHQgPSBcIjIwcHhcIjtcbiAgICBfdGhpcy5lbGVtZW50cy5zdGF0dXNCdXR0b24uc3R5bGUuYm90dG9tID0gXCI1cHhcIjtcbiAgfVxuXG4gIF90aGlzLmVsZW1lbnRzLmluZGljYXRvci5pbm5lckhUTUwgPSBfdGhpcy5jbGlwLnJ1blRpbWVJbmZvLnN0YXRlO1xuICBfdGhpcy5lbGVtZW50cy5zZXR0aW5nc1NwZWVkUGFuZWwuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuXG4gIF90aGlzLmVsZW1lbnRzLnNldHRpbmdzU3BlZWRQYW5lbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImxpXCIpWzFdLmNsYXNzTGlzdC5hZGQoXCJuby1ob3ZlclwiKTtcblxuICBfdGhpcy5lbGVtZW50cy5sb29wQmFyU3RhcnQuc3R5bGUubGVmdCA9IFwiMCVcIjtcblxuICBfdGhpcy5lbGVtZW50cy5sb29wQmFyU3RhcnQuY2xhc3NMaXN0LmFkZChcIm0tZmFkZU91dFwiLCBcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1oaWRlXCIpKTtcblxuICBfdGhpcy5lbGVtZW50cy5sb29wQmFyRW5kLnN0eWxlLmxlZnQgPSBcIjEwMCVcIjtcblxuICBfdGhpcy5lbGVtZW50cy5sb29wQmFyRW5kLmNsYXNzTGlzdC5hZGQoXCJtLWZhZGVPdXRcIiwgXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItaGlkZVwiKSk7XG5cbiAgX3RoaXMuZWxlbWVudHMubG9vcFN0YXJ0VGltZSA9IGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItbG9vcGJhci1zdGFydC10aW1lXCIpKTtcbiAgX3RoaXMuZWxlbWVudHMubG9vcEVuZFRpbWUgPSBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLWxvb3BiYXItZW5kLXRpbWVcIikpO1xuICBfdGhpcy5lbGVtZW50cy5lZGl0YWJsZUxvb3BTdGFydFRpbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gIF90aGlzLmVsZW1lbnRzLmVkaXRhYmxlTG9vcFN0YXJ0VGltZS50eXBlID0gXCJ0ZXh0XCI7XG4gIF90aGlzLmVsZW1lbnRzLmVkaXRhYmxlTG9vcFN0YXJ0VGltZS5zaXplID0gZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi10aW1lLXRvdGFsXCIpKS5pbm5lckhUTUwubGVuZ3RoICsgMTtcbiAgX3RoaXMuZWxlbWVudHMuZWRpdGFibGVMb29wU3RhcnRUaW1lLm1heExlbmd0aCA9IGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItdGltZS10b3RhbFwiKSkuaW5uZXJIVE1MLmxlbmd0aDtcbiAgX3RoaXMuZWxlbWVudHMuZWRpdGFibGVMb29wU3RhcnRUaW1lLnN0eWxlLmhlaWdodCA9IGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItdGltZS10b3RhbFwiKSkub2Zmc2V0SGVpZ2h0O1xuICBfdGhpcy5lbGVtZW50cy5lZGl0YWJsZUxvb3BTdGFydFRpbWUudmFsdWUgPSBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLWxvb3BiYXItc3RhcnQtdGltZVwiKSkuaW5uZXJIVE1MO1xuICBfdGhpcy5lbGVtZW50cy5lZGl0YWJsZUxvb3BTdGFydFRpbWUuc3R5bGUuZm9udFNpemUgPSBcIjhweFwiO1xuICBfdGhpcy5lbGVtZW50cy5lZGl0YWJsZUxvb3BFbmRUaW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICBfdGhpcy5lbGVtZW50cy5lZGl0YWJsZUxvb3BFbmRUaW1lLnR5cGUgPSBcInRleHRcIjtcbiAgX3RoaXMuZWxlbWVudHMuZWRpdGFibGVMb29wRW5kVGltZS5zaXplID0gZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi10aW1lLXRvdGFsXCIpKS5pbm5lckhUTUwubGVuZ3RoICsgMTtcbiAgX3RoaXMuZWxlbWVudHMuZWRpdGFibGVMb29wRW5kVGltZS5tYXhMZW5ndGggPSBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLXRpbWUtdG90YWxcIikpLmlubmVySFRNTC5sZW5ndGg7XG4gIF90aGlzLmVsZW1lbnRzLmVkaXRhYmxlTG9vcEVuZFRpbWUuc3R5bGUuaGVpZ2h0ID0gZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi10aW1lLXRvdGFsXCIpKS5vZmZzZXRIZWlnaHQ7XG4gIF90aGlzLmVsZW1lbnRzLmVkaXRhYmxlTG9vcEVuZFRpbWUudmFsdWUgPSBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLWxvb3BiYXItc3RhcnQtdGltZVwiKSkuaW5uZXJIVE1MO1xuICBfdGhpcy5lbGVtZW50cy5lZGl0YWJsZUxvb3BFbmRUaW1lLnBhdHRlcm4gPSBcImQqXCI7XG4gIF90aGlzLmVsZW1lbnRzLmVkaXRhYmxlTG9vcEVuZFRpbWUuc3R5bGUuZm9udFNpemUgPSBcIjhweFwiO1xuICBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLWxvb3AtdGltZVwiKSkuY2xhc3NMaXN0LmFkZChcIm0tZmFkZU91dFwiLCBcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1oaWRlXCIpKTtcbiAgZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1ob3Zlci1kaXNwbGF5XCIpKS5jbGFzc0xpc3QuYWRkKFwibS1mYWRlT3V0XCIgLy8gYCR7X3RoaXMubmFtZX0taGlkZWBcbiAgKTtcbiAgZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1zaG93LXZvbHVtZS1jaGVja2JveFwiKSkuY2hlY2tlZCA9IF90aGlzLm9wdGlvbnMuc2hvd1ZvbHVtZTtcbiAgZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1zaG93LWluZGljYXRvci1jaGVja2JveFwiKSkuY2hlY2tlZCA9IF90aGlzLm9wdGlvbnMuc2hvd0luZGljYXRvcjtcbiAgZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1zaG93LXByZXZpZXctY2hlY2tib3hcIikpLmNoZWNrZWQgPSBfdGhpcy5vcHRpb25zLnByZXZpZXc7XG4gIGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItcG9pbnRlci1ldmVudHMtY2hlY2tib3hcIikpLmNoZWNrZWQgPSBfdGhpcy5vcHRpb25zLnBvaW50ZXJFdmVudHM7XG5cbiAgaWYgKF90aGlzLm9wdGlvbnMucG9pbnRlckV2ZW50cykge1xuICAgIF90aGlzLmVsZW1lbnRzLm1jUGxheWVyLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIjtcbiAgICBfdGhpcy5lbGVtZW50cy5wb2ludGVyRXZlbnRQYW5lbC5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJhdXRvXCI7XG4gICAgZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1jb250cm9sc1wiKSkuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwiYXV0b1wiO1xuICAgIF90aGlzLmVsZW1lbnRzLnNldHRpbmdzUGFuZWwuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwiYXV0b1wiO1xuICB9IGVsc2Uge1xuICAgIF90aGlzLmVsZW1lbnRzLm1jUGxheWVyLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIjtcbiAgICBfdGhpcy5lbGVtZW50cy5wb2ludGVyRXZlbnRQYW5lbC5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XG4gICAgZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1jb250cm9sc1wiKSkuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwiYXV0b1wiO1xuICAgIF90aGlzLmVsZW1lbnRzLnNldHRpbmdzUGFuZWwuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwiYXV0b1wiO1xuICB9XG5cbiAgX3RoaXMuZWxlbWVudHMubGlzdGVuZXJIZWxwZXIuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiO1xuXG4gIGlmICghX3RoaXMub3B0aW9ucy5zaG93Vm9sdW1lKSB7XG4gICAgX3RoaXMuZWxlbWVudHMudGltZURpc3BsYXkuc3R5bGUubGVmdCA9IFwiNDVweFwiO1xuICAgIF90aGlzLmVsZW1lbnRzLnZvbHVtZUNvbnRyb2wuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG5cbiAgICBfdGhpcy5lbGVtZW50cy52b2x1bWVDb250cm9sLmNsYXNzTGlzdC50b2dnbGUoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItaGlkZVwiKSk7XG5cbiAgICBfdGhpcy5lbGVtZW50cy52b2x1bWVDb250cm9sLmNsYXNzTGlzdC50b2dnbGUoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItdm9sdW1lLXdpZHRoLXRyYW5zaXRpb25cIikpO1xuICB9IGVsc2Uge1xuICAgIF90aGlzLmVsZW1lbnRzLnRpbWVEaXNwbGF5LnN0eWxlLmxlZnQgPSBcIlwiO1xuICAgIF90aGlzLmVsZW1lbnRzLnZvbHVtZUNvbnRyb2wuc3R5bGUudmlzaWJpbGl0eSA9IFwidmlzaWJsZVwiO1xuICB9XG5cbiAgZm9yICh2YXIgX2kgaW4gX3RoaXMub3B0aW9ucy5zcGVlZFZhbHVlcykge1xuICAgIHZhciBiYXJEaXYgPSBlbGNyZWF0ZShcImRpdlwiKTtcbiAgICBiYXJEaXYuY2xhc3NOYW1lID0gXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItc3BlZWQtdmFsdWUtc3RlcFwiKTtcbiAgICB2YXIgdmFsdWVEaXYgPSBlbGNyZWF0ZShcImRpdlwiKTtcbiAgICB2YWx1ZURpdi5jbGFzc05hbWUgPSBcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1zcGVlZC12YWx1ZVwiKTtcbiAgICB2YWx1ZURpdi5kYXRhc2V0LnNwZWVkVmFsdWUgPSBfdGhpcy5vcHRpb25zLnNwZWVkVmFsdWVzW19pXTtcbiAgICB2YWx1ZURpdi5pbm5lckhUTUwgPSBfdGhpcy5vcHRpb25zLnNwZWVkVmFsdWVzW19pXTtcbiAgICB2YWx1ZURpdi5kYXRhc2V0LnpvbmUgPSBfaTtcbiAgICBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLXNwZWVkLXZhbHVlXCIpKS5wcmVwZW5kKHZhbHVlRGl2KTtcblxuICAgIF90aGlzLmVsZW1lbnRzLnNwZWVkQmFyLnByZXBlbmQoYmFyRGl2KTtcbiAgfSAvLyBzaG93IGhpZGUgYnV0dG9uc1xuXG5cbiAgaWYgKF90aGlzLm9wdGlvbnMuYnV0dG9ucy5mdWxsU2NyZWVuID09PSBmYWxzZSkge1xuICAgIF90aGlzLmVsZW1lbnRzLmZ1bGxTY3JlZW5CdXR0b24ucmVtb3ZlKCk7XG4gIH1cblxuICBpZiAoX3RoaXMub3B0aW9ucy5idXR0b25zLnNldHRpbmdzID09PSBmYWxzZSkge1xuICAgIF90aGlzLmVsZW1lbnRzLnNldHRpbmdzQnV0dG9uLnJlbW92ZSgpO1xuICB9XG5cbiAgaWYgKF90aGlzLm9wdGlvbnMuYnV0dG9ucy5kb25rZXljbGlwID09PSBmYWxzZSkge1xuICAgIF90aGlzLmVsZW1lbnRzLmRvbmtleWNsaXBCdXR0b24ucmVtb3ZlKCk7XG4gIH1cblxuICBpZiAoX3RoaXMub3B0aW9ucy5idXR0b25zLmxvb3AgPT09IGZhbHNlKSB7XG4gICAgX3RoaXMuZWxlbWVudHMubG9vcEJ1dHRvbi5yZW1vdmUoKTtcbiAgfVxufTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex-player/dist/html/setElements.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex-player/dist/html/style.js":
/*!***************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex-player/dist/html/style.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function (theme, name, options) {\n  return \"\\n.background {\\n  background-color: black;\\n  width:100%;\\n  height:\".concat(theme[\"background-height\"], \";;\\n  position:absolute;\\n  top:0px;\\n  left:0px;\\n  z-index:-2000;\\n}\\n\\n.full-screen #\").concat(name, \"-controls {\\n  position:fixed;\\n  left:0px;\\n  bottom:0px;\\n}\\n\\n.full-screen #\").concat(name, \"-settings-panel {\\n  position:fixed;\\n  bottom: 45px;\\n}\\n\\n.svg, .svg path {\\n  fill: \").concat(theme[\"svg-color\"], \";\\n}\\n\\n.svg.arrow {\\n  stroke: \").concat(theme[\"svg-color\"], \";\\n}\\n\\n.pointer-event-panel {\\n  height: \").concat(theme[\"pointer-event-panel-height\"], \";\\n  display:flex;\\n  align-items:center;\\n  justify-content:center;\\n}\\n#\").concat(name, \"-pointer-event-panel{\\n  width:100%;\\n  position:absolute;\\n  z-index:100;\\n}\\n#\").concat(name, \"-listener-helper{\\n  width:100%;\\n  height:calc( 100% - 45px );\\n  position:absolute;\\n  z-index:110;\\n}\\n.svg-selected svg{\\n  fill: \").concat(theme[\"svg-selected-color\"], \";\\n  stroke: \").concat(theme[\"svg-selected-color\"], \";\\n}\\n#\").concat(name, \"-hover-display{\\n    border: \").concat(theme[\"preview-border\"], \";\\n    display: flex;\\n    overflow:hidden;\\n    background-color: black;\\n    position: absolute;\\n    bottom: 14px;\\n    left: 0px;\\n    align-items: flex-end;\\n    justify-content: center;\\n}\\n\\n#\").concat(name, \"-hover-millisecond {\\n  background-color: \").concat(theme[\"hms-background-color\"], \";\\n  padding:3px;\\n  height:18px;\\n  margin:0px;\\n  line-height:12px;\\n  font-size:10px;\\n  text-align: center;\\n  min-width:20px;\\n  max-width:100px;\\n  z-index:2;\\n}\\n#\").concat(name, \",\\n#\").concat(name, \" ::before,\\n#\").concat(name, \" :::after,\\n#\").concat(name, \" div,\\n#\").concat(name, \" p,\\n#\").concat(name, \" span,\\n#\").concat(name, \" ul,\\n#\").concat(name, \" li {\\n  font-weight: 400;\\n  line-height: 1.9 !important;\\n  color: \").concat(theme[\"color\"], \";\\n  font-family: \\\"Century Gothic\\\", CenturyGothic, AppleGothic, sans-serif;\\n  box-sizing:border-box;\\n  -webkit-touch-callout: none;\\n  -webkit-user-select: none;\\n  -moz-user-select: none;\\n  -ms-user-select: none;\\n  user-select: none;\\n}\\n#\").concat(name, \" {\\n  line-height: 1.9;\\n  font-size: 12px;\\n  overflow:hidden;\\n  height: calc(100% + \").concat(theme[\"controls-position\"], \");\\n  width:100%;\\n  position: absolute;\\n  top: 0px;\\n  left: 0px;\\n  color: \").concat(theme[\"color\"], \";  \\n}\\n\\n#\").concat(name, \"-settings-speed-hide {\\n  text-align:right;\\n}\\n\\n.grad {\\n  background-image: linear-gradient(\\n    rgba(100,100,100,00.01),\\n    rgba(100,100,100,00.02),\\n    rgba(100,100,100,00.03),\\n    rgba(100,100,100,0.04),\\n    rgba(100,100,100,0.05),\\n    rgba(0,0,0,0.06),\\n    rgba(0,0,0,0.07),\\n    rgba(0,0,0,0.08),\\n    rgba(0,0,0,0.09),\\n    rgba(0,0,0,0.1),\\n    rgba(0,0,0,0.2),\\n    rgba(0,0,0,0.3),\\n    rgba(0,0,0,0.4),\\n    rgba(0,0,0,0.4),\\n    rgba(0,0,0,0.5),\\n    rgba(0,0,0,0.6),\\n    rgba(0,0,0,0.7),\\n    rgba(0,0,0,0.8),\\n    rgba(0,0,0,0.9),\\n    rgba(0,0,0,1)\\n  );\\n  position:absolute;\\n  width:100%;\\n  height:\").concat(theme[\"grad-height\"], \";\\n  left:0px;\\n  bottom:0px;\\n  z-index:100;\\n}\\n\\n#\").concat(name, \"-controls {\\n  touch-action: none;\\n  background-color: \").concat(theme[\"background-color\"], \";\\n  border: \").concat(theme[\"controls-border\"], \";\\n  position: absolute;\\n  bottom: \").concat(theme[\"controls-bottom\"], \";\\n  left: 0px;\\n  width: 100%;\\n  z-index:100;\\n  height: 44px;\\n  border-radius: 6px;\\n  display:flex;\\n  align-items:center;\\n}\\n\\n#\").concat(name, \"-totalbar {\\n  width: calc(100% - 20px);\\n  height: 5px;\\n  margin: 0px 10px 0px 10px;\\n  background-color: \").concat(theme[\"totalbar-color\"], \";\\n  position: absolute;\\n  top: 0px;\\n  left: 0px;\\n}\\n\\n#\").concat(name, \"-loopbar {\\n  position: absolute;\\n  height: 100%;\\n  width: 100%;\\n  top: 0px;\\n  left: 0px;\\n  background-color: \").concat(theme[\"loopbar-color\"], \";\\n}\\n\\n.\").concat(name, \"-loop-boundaries::before {\\n  \").concat(theme[\"loopbar-boundaries-style::before\"], \"\\n\\n}\\n.\").concat(name, \"-loop-boundaries {\\n  transform:translate(-50%,-37%);\\n  position:absolute;\\n  width:18px;\\n  background-color:\").concat(theme[\"loopbar-boundaries-color\"], \";\\n  height:18px;\\n  border-radius:10px;\\n  z-index:40;\\n  \").concat(theme[\"loopbar-boundaries-style\"], \"\\n}\\n\\n.\").concat(name, \"-loop-boundaries::after {\\n  \").concat(theme[\"loopbar-boundaries-style::after\"], \"\\n\\n}\\n\\n#\").concat(name, \"-helperbar {\\n  position: absolute;\\n  height: 20px;\\n  top: -10px;\\n  left: 0px;\\n  right: 0px;\\n  z-index:2;\\n}\\n\\n#\").concat(name, \"-runningbar {\\n  position: relative;\\n  width: 0px;\\n  max-width:100%;\\n  height: 100%;\\n  background-color: \").concat(theme[\"runningbar-color\"], \";\\n}\\n\\n#\").concat(name, \"-cursor {\\n  transform:translate(50%,-36%);\\n  right: 0px;\\n  top: 0px;\\n  width: 0px;\\n  height: 0px;\\n  position: absolute;\\n  background-color: \").concat(theme[\"cursor-color\"], \";\\n  border-radius: 10px;\\n  z-index: 5;\\n}\\n\\n#\").concat(name, \"-left-controls,#\").concat(name, \"-right-controls {\\n    display: flex;\\n    align-items:center;\\n    height: 100%;\\n    padding: 5px 5px 0px;\\n}\\n#\").concat(name, \"-right-controls {\\n  position:absolute;\\n  right:0px;\\n}\\n\\n\\n#\").concat(name, \"-left-controls > div,#\").concat(name, \"-right-controls > div {\\n    display: inline-flex;\\n    align-items:center;\\n   margin:0 10px 0 10px;\\n}\\n\\n\\n\\n/*#\").concat(name, \"-time-display {\\n  display: table;\\n  text-align: center;\\n  width: auto;\\n  height: 34px;\\n  position: absolute;\\n  left: 90px;\\n  -webkit-transition: left 0.1s ease;\\n  -moz-transition: left 0.1s ease;\\n  transition: left 0.1s ease;\\n}\\n*/\\n#\").concat(name, \"-time-display span {\\n  display: table-cell;\\n  vertical-align: middle;\\n}\\n\\n#\").concat(name, \"-status-btn {\\n  opacity: \").concat(theme[\"button-opacity\"], \";\\n}\\n#\").concat(name, \"-status-btn svg{\\n  width:20px;\\n  height:18px;\\n}\\n#\").concat(name, \"-volume {\\n  opacity: \").concat(theme[\"button-opacity\"], \";\\n  position: relative;\\n}\\n#\").concat(name, \"-volume-btn {\\n  width: 20px;\\n  height: 15px;\\n}\\n\\n#\").concat(name, \"-volumebar {\\n  width: 0px;\\n  height: 3px;\\n  background-color: \").concat(theme[\"loopbar-color\"], \";\\n  -webkit-transition: left 0.1s ease;\\n  -moz-transition: left 0.1s ease;\\n  transition: left 0.1s ease;\\n  position:relative;\\n  left:5px;\\n}\\n\\n#\").concat(name, \"-volumebar-helper {\\n  position: absolute;\\n    width: 0px;\\n    height: 15px;\\n    bottom: 0px;\\n    z-index: 10;\\n    left: 25px;\\n}\\n\\n#\").concat(name, \"-volumebar-active {\\n  position: relative;\\n  width: 0%;\\n  height: 100%;\\n  background-color: \").concat(theme[\"color\"], \";\\n  position:relative;\\n  bottom:0px;\\n}\\n\\n#\").concat(name, \"-volume-cursor {\\n  transform:translate(50%,-36%);\\n  right: 0px;\\n  top: 0px;\\n  width: 0px;\\n  height: 0px;\\n  position: absolute;\\n  background-color: \").concat(theme[\"color\"], \";\\n  border-radius: 10px;\\n  z-index: 5;\\n}\\n\\n.\").concat(name, \"-loopbar-time {\\n  width:auto;\\n  height:12px;\\n  background-color:\").concat(theme[\"background-color\"], \";\\n  line-height:10px;\\n  font-size:10px;\\n}\\n\\n#\").concat(name, \"-loop-time {\\n  margin: 7px;\\n}\\n\\n#\").concat(name, \"-dc-btn {\\n    background-repeat: no-repeat;\\n    background-size: 100% 100%;\\n    width: 20px;\\n    height: 15px;\\n    margin: 7px 10px 5px 0px;\\n    transform: scale(1.5,1.5);\\n}\\n\\n#\").concat(name, \"-loop-btn {\\n  opacity: \").concat(theme[\"button-opacity\"], \";\\n  display:flex;\\n  align-items:center;\\n}\\n\\n\\n#\").concat(name, \"-settings-btn {\\n  opacity: \").concat(theme[\"button-opacity\"], \";\\n}\\n\\n#\").concat(name, \"-full-screen-btn {\\n  opacity: \").concat(theme[\"button-opacity\"], \";\\n}\\n\\n.\").concat(name, \"-speed-btn {\\n  opacity: \").concat(theme[\"button-opacity\"], \";\\n  height: 14px;\\n}\\n\\n#\").concat(name, \"-settings-panel {\\n  touch-action: none;\\n  box-sizing: border-box;\\n  position: absolute;\\n  z-index:101;\\n  background-color: \").concat(theme[\"settings-background-color\"], \";\\n  bottom: \").concat(theme[\"settings-panel-bottom\"], \";\\n  border: \").concat(theme[\"border\"], \";\\n  right: 8px;\\n  width: 167px;\\n  padding: 5px;\\n  margin: 0px;\\n  -webkit-transition: all 0.3s ease;\\n  -moz-transition: all 0.3s ease;\\n  transition: all 0.3s ease;\\n}\\n\\n.\").concat(name, \"-hide {\\n  display:none !important;\\n}\\n\\n#\").concat(name, \"-speed-value-bar {\\n  position: relative;\\n  width: 5px;\\n  background-color: \").concat(theme[\"speedbar-color\"], \";\\n  display: inline-block;\\n  box-sizing: border-box;\\n  height: \").concat(options.speedValues.length * 16, \"px;\\n  float: left;\\n  margin-right:15px;\\n}\\n\\n#\").concat(name, \"-speed-value-helperbar {\\n  position: absolute;\\n  width: 25px;\\n  height: \").concat(options.speedValues.length * 16, \"px;\\n  float: left;\\n  left: 18px;\\n  z-index:10;\\n}\\n\\n\\n#\").concat(name, \"-speed-value-bar:hover,\\n#\").concat(name, \"-speed-value-helperbar {\\n  cursor: pointer;\\n}\\n\\n#\").concat(name, \"-volumebar:hover,\\n#\").concat(name, \"-volumebar-helper:hover,\\n#\").concat(name, \"-volume-btn:hover,\\n#\").concat(name, \"-volumebar:active,\\n#\").concat(name, \"-volumebar-helper:active,\\n#\").concat(name, \"-volume-btn:active {\\n  cursor:pointer;\\n}\\n\\n#\").concat(name, \"-speed-cursor {\\n  position: absolute;\\n  background-color: \").concat(theme[\"speedbar-cursor-color\"], \";\\n  top: 0px;\\n  left: 0px;\\n}\\n\\n#\").concat(name, \"-speed-cursor div {\\n  position: absolute;\\n  background-color: \").concat(theme[\"speedbar-cursor-color\"], \";\\n  left: -2.5px;\\n  top: -4px;\\n  width: 10px;\\n  height: 10px;\\n  border-radius: 5px;\\n}\\n\\n#\").concat(name, \"-time-separator{\\n  margin:0 3px;\\n}\\n#\").concat(name, \"-speed-cursor:hover {\\n  cursor: pointer;\\n}\\n\\n.\").concat(name, \"-speed-value-step {\\n  width: 16px;\\n  background-color: \").concat(theme[\"speedbar-color\"], \";\\n  display: inline-block;\\n  box-sizing: border-box;\\n  height: 2px;\\n  margin-top: 7px;\\n  margin-bottom: 7px;\\n  float: left;\\n}\\n\\n#\").concat(name, \"-speed-value {\\n  display: inline-block;\\n  box-sizing: border-box;\\n  height: \").concat(options.speedValues.length * 16, \"px;\\n  text-align: left;\\n}\\n\\n.\").concat(name, \"-speed-value {\\n  box-sizing: border-box;\\n  height: 16px;\\n  font-size: 12px;\\n}\\n\\n#\").concat(name, \"-indicator {\\n  font-size: 8px !important;\\n  position: absolute;\\n  bottom: -3px;\\n  color: \").concat(theme[\"color\"], \";\\n}\\n\\n/*#\").concat(name, \"-speed-settings {\\n  height: \").concat(options.speedValues.length * 16 + 32 + 10 - 2, \"px;\\n}*/\\n\\n#\").concat(name, \"-speed-settings li.no-hover { \\n  height: \").concat(options.speedValues.length * 16 + 10 - 2, \"px !important; \\n}\\n#\").concat(name, \"-settings-panel.\").concat(name, \"-settings-speed-panel {\\n  overflow: hidden;\\n  width: 92px;\\n  position:absolute;\\n  z-index:120;\\n  /*height: \").concat(options.speedValues.length * 16 + 32 + 20, \"px;*/\\n  -webkit-transition: all 0.3s ease;\\n  -moz-transition: all 0.3s ease;\\n  transition: all 0.3s ease;\\n}\\n\\n#\").concat(name, \"-settings-panel.\").concat(name, \"-settings-speed-panel .\").concat(name, \"-speed-btn {\\n  float: left;\\n}\\n\\n.\").concat(name, \"-settings-speed-panel ul:first-child {\\n  text-align: right;\\n}\\n\\n#\").concat(name, \"-speed-current {\\n  float: right;\\n  padding-right: 10px\\n}\\n\\n#\").concat(name, \"-settings-panel .\").concat(name, \"-speed-btn {\\n  float: right;\\n}\\n\\n#\").concat(name, \"-settings-panel ul {\\n  width: 100%;\\n  margin: 0px;\\n  padding: 0px;\\n  overflow: hidden;\\n}\\n\\n#\").concat(name, \"-settings-panel.\").concat(name, \"-settings-speed-panel ul li {\\n  min-width: 70px;\\n  display: flex;\\n  height: 32px;\\n  align-items: center;\\n  justify-content:center;\\n}\\n\\n#\").concat(name, \"-settings-panel ul li.no-hover:hover {\\n  background-color: transparent;\\n  cursor: default;\\n}\\n\\ndiv.\").concat(name, \"-speed-value:hover {\\n  background-color: \").concat(theme[\"hover-color\"], \";\\n  cursor: pointer;\\n}\\n\\n#\").concat(name, \"-settings-panel ul li {\\n  /*position: relative;\\n  width: 100%;\\n  min-width: 154px;*/\\n  list-style-type: none;\\n  margin: 0px;\\n  padding: 5px;\\n  display: flex;\\n  height:32px;\\n  align-items:center;\\n}\\n\\n#\").concat(name, \"-settings-panel ul li label {\\n  margin: 0px;\\n}\\n\\n.switch {\\n  position: relative;\\n  display: inline-block;\\n  width: 32px;\\n  height: 18px;\\n}\\n\\n.switch input {\\n  display: none;\\n}\\n\\n.settings-switch {\\n  position: absolute;\\n  right: 24px;\\n}\\n\\n.settings-switch::after {\\n  clear: both;\\n}\\n\\n.slider {\\n  position: absolute;\\n  cursor: pointer;\\n  top: 0;\\n  left: 0;\\n  right: 0;\\n  bottom: 0;\\n  background-color: \").concat(theme[\"slider-off-color\"], \";\\n  -webkit-transition: .4s;\\n  transition: .4s;\\n}\\n\\n.slider:before {\\n  position: absolute;\\n  content: \\\"\\\";\\n  height: 16px;\\n  width: 16px;\\n  left: 1px;\\n  bottom: 1px;\\n  background-color: white;\\n  -webkit-transition: .4s;\\n  transition: .4s;\\n}\\n\\ninput:checked+.slider {\\n  background-color: \").concat(theme[\"slider-on-color\"], \";\\n}\\n\\ninput:focus+.slider {\\n  box-shadow: 0 0 1px \").concat(theme[\"slider-on-color\"], \";\\n}\\n\\ninput:checked+.slider:before {\\n  -webkit-transform: translateX(16px);\\n  -ms-transform: translateX(16px);\\n  transform: translateX(16px);\\n}\\n\\n\\n/* Rounded sliders */\\n\\n.slider.round {\\n  border-radius: 34px;\\n}\\n\\n.slider.round:before {\\n  border-radius: 50%;\\n}\\n\\n\\n.m-fadeOut {\\n  visibility: hidden;\\n  opacity: 0;\\n  transition: visibility 0s linear 300ms, opacity 300ms;\\n}\\n\\n.m-fadeIn {\\n  visibility: visible;\\n  opacity: 1;\\n  transition: visibility 0s linear 0s, opacity 300ms;\\n}\\n\\n#\").concat(name, \"-settings-panel ul li:hover {\\n  background-color: \").concat(theme[\"hover-color\"], \";\\n  cursor: pointer;\\n}\\n\\n#\").concat(name, \"-settings-panel ul li label:hover {\\n  cursor: pointer;\\n}\\n\\n#\").concat(name, \"-loopbar:hover {\\n  cursor: pointer;\\n}\\n\\n#\").concat(name, \"-status-btn:hover {\\n  cursor: pointer;\\n}\\n\\n#\").concat(name, \"-controls:active #\").concat(name, \"-cursor,\\n#\").concat(name, \"-controls:hover #\").concat(name, \"-cursor  {\\n  width: 16px;\\n  height: 16px;\\n  -webkit-transition: all 0.3s ease;\\n  -moz-transition: all 0.3s ease;\\n  transition: all 0.3s ease;\\n}\\n\\n#\").concat(name, \"-volume .\").concat(name, \"-volume-cursor-transition {\\n  width: 12px;\\n  height: 12px;\\n  -webkit-transition: all 0.3s ease;\\n  -moz-transition: all 0.3s ease;\\n  transition: all 0.3s ease;\\n}\\n\\n#\").concat(name, \"-volume .\").concat(name, \"-volume-width-transition\\n {\\n  width: 50px;\\n  -webkit-transition: all 0.3s ease;\\n  -moz-transition: all 0.3s ease;\\n  transition: all 0.3s ease;\\n}\\n\\n#\").concat(name, \"-time-display.\").concat(name, \"-time-width-transition {\\n  position:relative;\\n  left: 10px;\\n  -webkit-transition: left 0.3s ease;\\n  -moz-transition: left 0.3s ease;\\n  transition: left 0.3s ease;\\n}\\n\\n#\").concat(name, \"-settings-speed:hover .\").concat(name, \"-speed-btn {\\n  opacity: 1;\\n  -webkit-transition: all 0.3s ease;\\n  -moz-transition: all 0.3s ease;\\n  transition: all 0.3s ease;\\n}\\n\\n#\").concat(name, \"-status-btn:hover {\\n  opacity: 1;\\n  -webkit-transition: all 0.3s ease;\\n  -moz-transition: all 0.3s ease;\\n  transition: all 0.3s ease;\\n}\\n\\n#\").concat(name, \"-loop-btn:hover,\\n#\").concat(name, \"-dc-btn:hover\\n {\\n  cursor: pointer;\\n  opacity: 1;\\n  -webkit-transition: all 0.3s ease;\\n  -moz-transition: all 0.3s ease;\\n  transition: all 0.3s ease;\\n}\\n#\").concat(name, \"-settings-btn:hover {\\n  cursor: pointer;\\n  opacity: 1;\\n  -webkit-transition: all 0.3s ease;\\n  -moz-transition: all 0.3s ease;\\n  transition: all 0.3s ease;\\n}\\n\\n#\").concat(name, \"-full-screen-btn:hover {\\n  cursor: pointer;\\n  opacity: 1;\\n  -webkit-transition: all 0.3s ease;\\n  -moz-transition: all 0.3s ease;\\n  transition: all 0.3s ease;\\n}\\n\").concat(theme[\"theme-style\"], \"\\n\");\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgtcGxheWVyL2Rpc3QvaHRtbC9zdHlsZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC1wbGF5ZXIvZGlzdC9odG1sL3N0eWxlLmpzPzM2M2QiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRoZW1lLCBuYW1lLCBvcHRpb25zKSB7XG4gIHJldHVybiBcIlxcbi5iYWNrZ3JvdW5kIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IGJsYWNrO1xcbiAgd2lkdGg6MTAwJTtcXG4gIGhlaWdodDpcIi5jb25jYXQodGhlbWVbXCJiYWNrZ3JvdW5kLWhlaWdodFwiXSwgXCI7O1xcbiAgcG9zaXRpb246YWJzb2x1dGU7XFxuICB0b3A6MHB4O1xcbiAgbGVmdDowcHg7XFxuICB6LWluZGV4Oi0yMDAwO1xcbn1cXG5cXG4uZnVsbC1zY3JlZW4gI1wiKS5jb25jYXQobmFtZSwgXCItY29udHJvbHMge1xcbiAgcG9zaXRpb246Zml4ZWQ7XFxuICBsZWZ0OjBweDtcXG4gIGJvdHRvbTowcHg7XFxufVxcblxcbi5mdWxsLXNjcmVlbiAjXCIpLmNvbmNhdChuYW1lLCBcIi1zZXR0aW5ncy1wYW5lbCB7XFxuICBwb3NpdGlvbjpmaXhlZDtcXG4gIGJvdHRvbTogNDVweDtcXG59XFxuXFxuLnN2ZywgLnN2ZyBwYXRoIHtcXG4gIGZpbGw6IFwiKS5jb25jYXQodGhlbWVbXCJzdmctY29sb3JcIl0sIFwiO1xcbn1cXG5cXG4uc3ZnLmFycm93IHtcXG4gIHN0cm9rZTogXCIpLmNvbmNhdCh0aGVtZVtcInN2Zy1jb2xvclwiXSwgXCI7XFxufVxcblxcbi5wb2ludGVyLWV2ZW50LXBhbmVsIHtcXG4gIGhlaWdodDogXCIpLmNvbmNhdCh0aGVtZVtcInBvaW50ZXItZXZlbnQtcGFuZWwtaGVpZ2h0XCJdLCBcIjtcXG4gIGRpc3BsYXk6ZmxleDtcXG4gIGFsaWduLWl0ZW1zOmNlbnRlcjtcXG4gIGp1c3RpZnktY29udGVudDpjZW50ZXI7XFxufVxcbiNcIikuY29uY2F0KG5hbWUsIFwiLXBvaW50ZXItZXZlbnQtcGFuZWx7XFxuICB3aWR0aDoxMDAlO1xcbiAgcG9zaXRpb246YWJzb2x1dGU7XFxuICB6LWluZGV4OjEwMDtcXG59XFxuI1wiKS5jb25jYXQobmFtZSwgXCItbGlzdGVuZXItaGVscGVye1xcbiAgd2lkdGg6MTAwJTtcXG4gIGhlaWdodDpjYWxjKCAxMDAlIC0gNDVweCApO1xcbiAgcG9zaXRpb246YWJzb2x1dGU7XFxuICB6LWluZGV4OjExMDtcXG59XFxuLnN2Zy1zZWxlY3RlZCBzdmd7XFxuICBmaWxsOiBcIikuY29uY2F0KHRoZW1lW1wic3ZnLXNlbGVjdGVkLWNvbG9yXCJdLCBcIjtcXG4gIHN0cm9rZTogXCIpLmNvbmNhdCh0aGVtZVtcInN2Zy1zZWxlY3RlZC1jb2xvclwiXSwgXCI7XFxufVxcbiNcIikuY29uY2F0KG5hbWUsIFwiLWhvdmVyLWRpc3BsYXl7XFxuICAgIGJvcmRlcjogXCIpLmNvbmNhdCh0aGVtZVtcInByZXZpZXctYm9yZGVyXCJdLCBcIjtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgb3ZlcmZsb3c6aGlkZGVuO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBibGFjaztcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBib3R0b206IDE0cHg7XFxuICAgIGxlZnQ6IDBweDtcXG4gICAgYWxpZ24taXRlbXM6IGZsZXgtZW5kO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG59XFxuXFxuI1wiKS5jb25jYXQobmFtZSwgXCItaG92ZXItbWlsbGlzZWNvbmQge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogXCIpLmNvbmNhdCh0aGVtZVtcImhtcy1iYWNrZ3JvdW5kLWNvbG9yXCJdLCBcIjtcXG4gIHBhZGRpbmc6M3B4O1xcbiAgaGVpZ2h0OjE4cHg7XFxuICBtYXJnaW46MHB4O1xcbiAgbGluZS1oZWlnaHQ6MTJweDtcXG4gIGZvbnQtc2l6ZToxMHB4O1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgbWluLXdpZHRoOjIwcHg7XFxuICBtYXgtd2lkdGg6MTAwcHg7XFxuICB6LWluZGV4OjI7XFxufVxcbiNcIikuY29uY2F0KG5hbWUsIFwiLFxcbiNcIikuY29uY2F0KG5hbWUsIFwiIDo6YmVmb3JlLFxcbiNcIikuY29uY2F0KG5hbWUsIFwiIDo6OmFmdGVyLFxcbiNcIikuY29uY2F0KG5hbWUsIFwiIGRpdixcXG4jXCIpLmNvbmNhdChuYW1lLCBcIiBwLFxcbiNcIikuY29uY2F0KG5hbWUsIFwiIHNwYW4sXFxuI1wiKS5jb25jYXQobmFtZSwgXCIgdWwsXFxuI1wiKS5jb25jYXQobmFtZSwgXCIgbGkge1xcbiAgZm9udC13ZWlnaHQ6IDQwMDtcXG4gIGxpbmUtaGVpZ2h0OiAxLjkgIWltcG9ydGFudDtcXG4gIGNvbG9yOiBcIikuY29uY2F0KHRoZW1lW1wiY29sb3JcIl0sIFwiO1xcbiAgZm9udC1mYW1pbHk6IFxcXCJDZW50dXJ5IEdvdGhpY1xcXCIsIENlbnR1cnlHb3RoaWMsIEFwcGxlR290aGljLCBzYW5zLXNlcmlmO1xcbiAgYm94LXNpemluZzpib3JkZXItYm94O1xcbiAgLXdlYmtpdC10b3VjaC1jYWxsb3V0OiBub25lO1xcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICB1c2VyLXNlbGVjdDogbm9uZTtcXG59XFxuI1wiKS5jb25jYXQobmFtZSwgXCIge1xcbiAgbGluZS1oZWlnaHQ6IDEuOTtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIG92ZXJmbG93OmhpZGRlbjtcXG4gIGhlaWdodDogY2FsYygxMDAlICsgXCIpLmNvbmNhdCh0aGVtZVtcImNvbnRyb2xzLXBvc2l0aW9uXCJdLCBcIik7XFxuICB3aWR0aDoxMDAlO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAwcHg7XFxuICBsZWZ0OiAwcHg7XFxuICBjb2xvcjogXCIpLmNvbmNhdCh0aGVtZVtcImNvbG9yXCJdLCBcIjsgIFxcbn1cXG5cXG4jXCIpLmNvbmNhdChuYW1lLCBcIi1zZXR0aW5ncy1zcGVlZC1oaWRlIHtcXG4gIHRleHQtYWxpZ246cmlnaHQ7XFxufVxcblxcbi5ncmFkIHtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IGxpbmVhci1ncmFkaWVudChcXG4gICAgcmdiYSgxMDAsMTAwLDEwMCwwMC4wMSksXFxuICAgIHJnYmEoMTAwLDEwMCwxMDAsMDAuMDIpLFxcbiAgICByZ2JhKDEwMCwxMDAsMTAwLDAwLjAzKSxcXG4gICAgcmdiYSgxMDAsMTAwLDEwMCwwLjA0KSxcXG4gICAgcmdiYSgxMDAsMTAwLDEwMCwwLjA1KSxcXG4gICAgcmdiYSgwLDAsMCwwLjA2KSxcXG4gICAgcmdiYSgwLDAsMCwwLjA3KSxcXG4gICAgcmdiYSgwLDAsMCwwLjA4KSxcXG4gICAgcmdiYSgwLDAsMCwwLjA5KSxcXG4gICAgcmdiYSgwLDAsMCwwLjEpLFxcbiAgICByZ2JhKDAsMCwwLDAuMiksXFxuICAgIHJnYmEoMCwwLDAsMC4zKSxcXG4gICAgcmdiYSgwLDAsMCwwLjQpLFxcbiAgICByZ2JhKDAsMCwwLDAuNCksXFxuICAgIHJnYmEoMCwwLDAsMC41KSxcXG4gICAgcmdiYSgwLDAsMCwwLjYpLFxcbiAgICByZ2JhKDAsMCwwLDAuNyksXFxuICAgIHJnYmEoMCwwLDAsMC44KSxcXG4gICAgcmdiYSgwLDAsMCwwLjkpLFxcbiAgICByZ2JhKDAsMCwwLDEpXFxuICApO1xcbiAgcG9zaXRpb246YWJzb2x1dGU7XFxuICB3aWR0aDoxMDAlO1xcbiAgaGVpZ2h0OlwiKS5jb25jYXQodGhlbWVbXCJncmFkLWhlaWdodFwiXSwgXCI7XFxuICBsZWZ0OjBweDtcXG4gIGJvdHRvbTowcHg7XFxuICB6LWluZGV4OjEwMDtcXG59XFxuXFxuI1wiKS5jb25jYXQobmFtZSwgXCItY29udHJvbHMge1xcbiAgdG91Y2gtYWN0aW9uOiBub25lO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogXCIpLmNvbmNhdCh0aGVtZVtcImJhY2tncm91bmQtY29sb3JcIl0sIFwiO1xcbiAgYm9yZGVyOiBcIikuY29uY2F0KHRoZW1lW1wiY29udHJvbHMtYm9yZGVyXCJdLCBcIjtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGJvdHRvbTogXCIpLmNvbmNhdCh0aGVtZVtcImNvbnRyb2xzLWJvdHRvbVwiXSwgXCI7XFxuICBsZWZ0OiAwcHg7XFxuICB3aWR0aDogMTAwJTtcXG4gIHotaW5kZXg6MTAwO1xcbiAgaGVpZ2h0OiA0NHB4O1xcbiAgYm9yZGVyLXJhZGl1czogNnB4O1xcbiAgZGlzcGxheTpmbGV4O1xcbiAgYWxpZ24taXRlbXM6Y2VudGVyO1xcbn1cXG5cXG4jXCIpLmNvbmNhdChuYW1lLCBcIi10b3RhbGJhciB7XFxuICB3aWR0aDogY2FsYygxMDAlIC0gMjBweCk7XFxuICBoZWlnaHQ6IDVweDtcXG4gIG1hcmdpbjogMHB4IDEwcHggMHB4IDEwcHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiBcIikuY29uY2F0KHRoZW1lW1widG90YWxiYXItY29sb3JcIl0sIFwiO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAwcHg7XFxuICBsZWZ0OiAwcHg7XFxufVxcblxcbiNcIikuY29uY2F0KG5hbWUsIFwiLWxvb3BiYXIge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgd2lkdGg6IDEwMCU7XFxuICB0b3A6IDBweDtcXG4gIGxlZnQ6IDBweDtcXG4gIGJhY2tncm91bmQtY29sb3I6IFwiKS5jb25jYXQodGhlbWVbXCJsb29wYmFyLWNvbG9yXCJdLCBcIjtcXG59XFxuXFxuLlwiKS5jb25jYXQobmFtZSwgXCItbG9vcC1ib3VuZGFyaWVzOjpiZWZvcmUge1xcbiAgXCIpLmNvbmNhdCh0aGVtZVtcImxvb3BiYXItYm91bmRhcmllcy1zdHlsZTo6YmVmb3JlXCJdLCBcIlxcblxcbn1cXG4uXCIpLmNvbmNhdChuYW1lLCBcIi1sb29wLWJvdW5kYXJpZXMge1xcbiAgdHJhbnNmb3JtOnRyYW5zbGF0ZSgtNTAlLC0zNyUpO1xcbiAgcG9zaXRpb246YWJzb2x1dGU7XFxuICB3aWR0aDoxOHB4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjpcIikuY29uY2F0KHRoZW1lW1wibG9vcGJhci1ib3VuZGFyaWVzLWNvbG9yXCJdLCBcIjtcXG4gIGhlaWdodDoxOHB4O1xcbiAgYm9yZGVyLXJhZGl1czoxMHB4O1xcbiAgei1pbmRleDo0MDtcXG4gIFwiKS5jb25jYXQodGhlbWVbXCJsb29wYmFyLWJvdW5kYXJpZXMtc3R5bGVcIl0sIFwiXFxufVxcblxcbi5cIikuY29uY2F0KG5hbWUsIFwiLWxvb3AtYm91bmRhcmllczo6YWZ0ZXIge1xcbiAgXCIpLmNvbmNhdCh0aGVtZVtcImxvb3BiYXItYm91bmRhcmllcy1zdHlsZTo6YWZ0ZXJcIl0sIFwiXFxuXFxufVxcblxcbiNcIikuY29uY2F0KG5hbWUsIFwiLWhlbHBlcmJhciB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBoZWlnaHQ6IDIwcHg7XFxuICB0b3A6IC0xMHB4O1xcbiAgbGVmdDogMHB4O1xcbiAgcmlnaHQ6IDBweDtcXG4gIHotaW5kZXg6MjtcXG59XFxuXFxuI1wiKS5jb25jYXQobmFtZSwgXCItcnVubmluZ2JhciB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB3aWR0aDogMHB4O1xcbiAgbWF4LXdpZHRoOjEwMCU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiBcIikuY29uY2F0KHRoZW1lW1wicnVubmluZ2Jhci1jb2xvclwiXSwgXCI7XFxufVxcblxcbiNcIikuY29uY2F0KG5hbWUsIFwiLWN1cnNvciB7XFxuICB0cmFuc2Zvcm06dHJhbnNsYXRlKDUwJSwtMzYlKTtcXG4gIHJpZ2h0OiAwcHg7XFxuICB0b3A6IDBweDtcXG4gIHdpZHRoOiAwcHg7XFxuICBoZWlnaHQ6IDBweDtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGJhY2tncm91bmQtY29sb3I6IFwiKS5jb25jYXQodGhlbWVbXCJjdXJzb3ItY29sb3JcIl0sIFwiO1xcbiAgYm9yZGVyLXJhZGl1czogMTBweDtcXG4gIHotaW5kZXg6IDU7XFxufVxcblxcbiNcIikuY29uY2F0KG5hbWUsIFwiLWxlZnQtY29udHJvbHMsI1wiKS5jb25jYXQobmFtZSwgXCItcmlnaHQtY29udHJvbHMge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBhbGlnbi1pdGVtczpjZW50ZXI7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgcGFkZGluZzogNXB4IDVweCAwcHg7XFxufVxcbiNcIikuY29uY2F0KG5hbWUsIFwiLXJpZ2h0LWNvbnRyb2xzIHtcXG4gIHBvc2l0aW9uOmFic29sdXRlO1xcbiAgcmlnaHQ6MHB4O1xcbn1cXG5cXG5cXG4jXCIpLmNvbmNhdChuYW1lLCBcIi1sZWZ0LWNvbnRyb2xzID4gZGl2LCNcIikuY29uY2F0KG5hbWUsIFwiLXJpZ2h0LWNvbnRyb2xzID4gZGl2IHtcXG4gICAgZGlzcGxheTogaW5saW5lLWZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOmNlbnRlcjtcXG4gICBtYXJnaW46MCAxMHB4IDAgMTBweDtcXG59XFxuXFxuXFxuXFxuLyojXCIpLmNvbmNhdChuYW1lLCBcIi10aW1lLWRpc3BsYXkge1xcbiAgZGlzcGxheTogdGFibGU7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICB3aWR0aDogYXV0bztcXG4gIGhlaWdodDogMzRweDtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGxlZnQ6IDkwcHg7XFxuICAtd2Via2l0LXRyYW5zaXRpb246IGxlZnQgMC4xcyBlYXNlO1xcbiAgLW1vei10cmFuc2l0aW9uOiBsZWZ0IDAuMXMgZWFzZTtcXG4gIHRyYW5zaXRpb246IGxlZnQgMC4xcyBlYXNlO1xcbn1cXG4qL1xcbiNcIikuY29uY2F0KG5hbWUsIFwiLXRpbWUtZGlzcGxheSBzcGFuIHtcXG4gIGRpc3BsYXk6IHRhYmxlLWNlbGw7XFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbn1cXG5cXG4jXCIpLmNvbmNhdChuYW1lLCBcIi1zdGF0dXMtYnRuIHtcXG4gIG9wYWNpdHk6IFwiKS5jb25jYXQodGhlbWVbXCJidXR0b24tb3BhY2l0eVwiXSwgXCI7XFxufVxcbiNcIikuY29uY2F0KG5hbWUsIFwiLXN0YXR1cy1idG4gc3Zne1xcbiAgd2lkdGg6MjBweDtcXG4gIGhlaWdodDoxOHB4O1xcbn1cXG4jXCIpLmNvbmNhdChuYW1lLCBcIi12b2x1bWUge1xcbiAgb3BhY2l0eTogXCIpLmNvbmNhdCh0aGVtZVtcImJ1dHRvbi1vcGFjaXR5XCJdLCBcIjtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG59XFxuI1wiKS5jb25jYXQobmFtZSwgXCItdm9sdW1lLWJ0biB7XFxuICB3aWR0aDogMjBweDtcXG4gIGhlaWdodDogMTVweDtcXG59XFxuXFxuI1wiKS5jb25jYXQobmFtZSwgXCItdm9sdW1lYmFyIHtcXG4gIHdpZHRoOiAwcHg7XFxuICBoZWlnaHQ6IDNweDtcXG4gIGJhY2tncm91bmQtY29sb3I6IFwiKS5jb25jYXQodGhlbWVbXCJsb29wYmFyLWNvbG9yXCJdLCBcIjtcXG4gIC13ZWJraXQtdHJhbnNpdGlvbjogbGVmdCAwLjFzIGVhc2U7XFxuICAtbW96LXRyYW5zaXRpb246IGxlZnQgMC4xcyBlYXNlO1xcbiAgdHJhbnNpdGlvbjogbGVmdCAwLjFzIGVhc2U7XFxuICBwb3NpdGlvbjpyZWxhdGl2ZTtcXG4gIGxlZnQ6NXB4O1xcbn1cXG5cXG4jXCIpLmNvbmNhdChuYW1lLCBcIi12b2x1bWViYXItaGVscGVyIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgd2lkdGg6IDBweDtcXG4gICAgaGVpZ2h0OiAxNXB4O1xcbiAgICBib3R0b206IDBweDtcXG4gICAgei1pbmRleDogMTA7XFxuICAgIGxlZnQ6IDI1cHg7XFxufVxcblxcbiNcIikuY29uY2F0KG5hbWUsIFwiLXZvbHVtZWJhci1hY3RpdmUge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgd2lkdGg6IDAlO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogXCIpLmNvbmNhdCh0aGVtZVtcImNvbG9yXCJdLCBcIjtcXG4gIHBvc2l0aW9uOnJlbGF0aXZlO1xcbiAgYm90dG9tOjBweDtcXG59XFxuXFxuI1wiKS5jb25jYXQobmFtZSwgXCItdm9sdW1lLWN1cnNvciB7XFxuICB0cmFuc2Zvcm06dHJhbnNsYXRlKDUwJSwtMzYlKTtcXG4gIHJpZ2h0OiAwcHg7XFxuICB0b3A6IDBweDtcXG4gIHdpZHRoOiAwcHg7XFxuICBoZWlnaHQ6IDBweDtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGJhY2tncm91bmQtY29sb3I6IFwiKS5jb25jYXQodGhlbWVbXCJjb2xvclwiXSwgXCI7XFxuICBib3JkZXItcmFkaXVzOiAxMHB4O1xcbiAgei1pbmRleDogNTtcXG59XFxuXFxuLlwiKS5jb25jYXQobmFtZSwgXCItbG9vcGJhci10aW1lIHtcXG4gIHdpZHRoOmF1dG87XFxuICBoZWlnaHQ6MTJweDtcXG4gIGJhY2tncm91bmQtY29sb3I6XCIpLmNvbmNhdCh0aGVtZVtcImJhY2tncm91bmQtY29sb3JcIl0sIFwiO1xcbiAgbGluZS1oZWlnaHQ6MTBweDtcXG4gIGZvbnQtc2l6ZToxMHB4O1xcbn1cXG5cXG4jXCIpLmNvbmNhdChuYW1lLCBcIi1sb29wLXRpbWUge1xcbiAgbWFyZ2luOiA3cHg7XFxufVxcblxcbiNcIikuY29uY2F0KG5hbWUsIFwiLWRjLWJ0biB7XFxuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxuICAgIGJhY2tncm91bmQtc2l6ZTogMTAwJSAxMDAlO1xcbiAgICB3aWR0aDogMjBweDtcXG4gICAgaGVpZ2h0OiAxNXB4O1xcbiAgICBtYXJnaW46IDdweCAxMHB4IDVweCAwcHg7XFxuICAgIHRyYW5zZm9ybTogc2NhbGUoMS41LDEuNSk7XFxufVxcblxcbiNcIikuY29uY2F0KG5hbWUsIFwiLWxvb3AtYnRuIHtcXG4gIG9wYWNpdHk6IFwiKS5jb25jYXQodGhlbWVbXCJidXR0b24tb3BhY2l0eVwiXSwgXCI7XFxuICBkaXNwbGF5OmZsZXg7XFxuICBhbGlnbi1pdGVtczpjZW50ZXI7XFxufVxcblxcblxcbiNcIikuY29uY2F0KG5hbWUsIFwiLXNldHRpbmdzLWJ0biB7XFxuICBvcGFjaXR5OiBcIikuY29uY2F0KHRoZW1lW1wiYnV0dG9uLW9wYWNpdHlcIl0sIFwiO1xcbn1cXG5cXG4jXCIpLmNvbmNhdChuYW1lLCBcIi1mdWxsLXNjcmVlbi1idG4ge1xcbiAgb3BhY2l0eTogXCIpLmNvbmNhdCh0aGVtZVtcImJ1dHRvbi1vcGFjaXR5XCJdLCBcIjtcXG59XFxuXFxuLlwiKS5jb25jYXQobmFtZSwgXCItc3BlZWQtYnRuIHtcXG4gIG9wYWNpdHk6IFwiKS5jb25jYXQodGhlbWVbXCJidXR0b24tb3BhY2l0eVwiXSwgXCI7XFxuICBoZWlnaHQ6IDE0cHg7XFxufVxcblxcbiNcIikuY29uY2F0KG5hbWUsIFwiLXNldHRpbmdzLXBhbmVsIHtcXG4gIHRvdWNoLWFjdGlvbjogbm9uZTtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB6LWluZGV4OjEwMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IFwiKS5jb25jYXQodGhlbWVbXCJzZXR0aW5ncy1iYWNrZ3JvdW5kLWNvbG9yXCJdLCBcIjtcXG4gIGJvdHRvbTogXCIpLmNvbmNhdCh0aGVtZVtcInNldHRpbmdzLXBhbmVsLWJvdHRvbVwiXSwgXCI7XFxuICBib3JkZXI6IFwiKS5jb25jYXQodGhlbWVbXCJib3JkZXJcIl0sIFwiO1xcbiAgcmlnaHQ6IDhweDtcXG4gIHdpZHRoOiAxNjdweDtcXG4gIHBhZGRpbmc6IDVweDtcXG4gIG1hcmdpbjogMHB4O1xcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlO1xcbiAgLW1vei10cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlO1xcbiAgdHJhbnNpdGlvbjogYWxsIDAuM3MgZWFzZTtcXG59XFxuXFxuLlwiKS5jb25jYXQobmFtZSwgXCItaGlkZSB7XFxuICBkaXNwbGF5Om5vbmUgIWltcG9ydGFudDtcXG59XFxuXFxuI1wiKS5jb25jYXQobmFtZSwgXCItc3BlZWQtdmFsdWUtYmFyIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHdpZHRoOiA1cHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiBcIikuY29uY2F0KHRoZW1lW1wic3BlZWRiYXItY29sb3JcIl0sIFwiO1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIGhlaWdodDogXCIpLmNvbmNhdChvcHRpb25zLnNwZWVkVmFsdWVzLmxlbmd0aCAqIDE2LCBcInB4O1xcbiAgZmxvYXQ6IGxlZnQ7XFxuICBtYXJnaW4tcmlnaHQ6MTVweDtcXG59XFxuXFxuI1wiKS5jb25jYXQobmFtZSwgXCItc3BlZWQtdmFsdWUtaGVscGVyYmFyIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHdpZHRoOiAyNXB4O1xcbiAgaGVpZ2h0OiBcIikuY29uY2F0KG9wdGlvbnMuc3BlZWRWYWx1ZXMubGVuZ3RoICogMTYsIFwicHg7XFxuICBmbG9hdDogbGVmdDtcXG4gIGxlZnQ6IDE4cHg7XFxuICB6LWluZGV4OjEwO1xcbn1cXG5cXG5cXG4jXCIpLmNvbmNhdChuYW1lLCBcIi1zcGVlZC12YWx1ZS1iYXI6aG92ZXIsXFxuI1wiKS5jb25jYXQobmFtZSwgXCItc3BlZWQtdmFsdWUtaGVscGVyYmFyIHtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXFxuI1wiKS5jb25jYXQobmFtZSwgXCItdm9sdW1lYmFyOmhvdmVyLFxcbiNcIikuY29uY2F0KG5hbWUsIFwiLXZvbHVtZWJhci1oZWxwZXI6aG92ZXIsXFxuI1wiKS5jb25jYXQobmFtZSwgXCItdm9sdW1lLWJ0bjpob3ZlcixcXG4jXCIpLmNvbmNhdChuYW1lLCBcIi12b2x1bWViYXI6YWN0aXZlLFxcbiNcIikuY29uY2F0KG5hbWUsIFwiLXZvbHVtZWJhci1oZWxwZXI6YWN0aXZlLFxcbiNcIikuY29uY2F0KG5hbWUsIFwiLXZvbHVtZS1idG46YWN0aXZlIHtcXG4gIGN1cnNvcjpwb2ludGVyO1xcbn1cXG5cXG4jXCIpLmNvbmNhdChuYW1lLCBcIi1zcGVlZC1jdXJzb3Ige1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogXCIpLmNvbmNhdCh0aGVtZVtcInNwZWVkYmFyLWN1cnNvci1jb2xvclwiXSwgXCI7XFxuICB0b3A6IDBweDtcXG4gIGxlZnQ6IDBweDtcXG59XFxuXFxuI1wiKS5jb25jYXQobmFtZSwgXCItc3BlZWQtY3Vyc29yIGRpdiB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiBcIikuY29uY2F0KHRoZW1lW1wic3BlZWRiYXItY3Vyc29yLWNvbG9yXCJdLCBcIjtcXG4gIGxlZnQ6IC0yLjVweDtcXG4gIHRvcDogLTRweDtcXG4gIHdpZHRoOiAxMHB4O1xcbiAgaGVpZ2h0OiAxMHB4O1xcbiAgYm9yZGVyLXJhZGl1czogNXB4O1xcbn1cXG5cXG4jXCIpLmNvbmNhdChuYW1lLCBcIi10aW1lLXNlcGFyYXRvcntcXG4gIG1hcmdpbjowIDNweDtcXG59XFxuI1wiKS5jb25jYXQobmFtZSwgXCItc3BlZWQtY3Vyc29yOmhvdmVyIHtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXFxuLlwiKS5jb25jYXQobmFtZSwgXCItc3BlZWQtdmFsdWUtc3RlcCB7XFxuICB3aWR0aDogMTZweDtcXG4gIGJhY2tncm91bmQtY29sb3I6IFwiKS5jb25jYXQodGhlbWVbXCJzcGVlZGJhci1jb2xvclwiXSwgXCI7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgaGVpZ2h0OiAycHg7XFxuICBtYXJnaW4tdG9wOiA3cHg7XFxuICBtYXJnaW4tYm90dG9tOiA3cHg7XFxuICBmbG9hdDogbGVmdDtcXG59XFxuXFxuI1wiKS5jb25jYXQobmFtZSwgXCItc3BlZWQtdmFsdWUge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIGhlaWdodDogXCIpLmNvbmNhdChvcHRpb25zLnNwZWVkVmFsdWVzLmxlbmd0aCAqIDE2LCBcInB4O1xcbiAgdGV4dC1hbGlnbjogbGVmdDtcXG59XFxuXFxuLlwiKS5jb25jYXQobmFtZSwgXCItc3BlZWQtdmFsdWUge1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIGhlaWdodDogMTZweDtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG59XFxuXFxuI1wiKS5jb25jYXQobmFtZSwgXCItaW5kaWNhdG9yIHtcXG4gIGZvbnQtc2l6ZTogOHB4ICFpbXBvcnRhbnQ7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBib3R0b206IC0zcHg7XFxuICBjb2xvcjogXCIpLmNvbmNhdCh0aGVtZVtcImNvbG9yXCJdLCBcIjtcXG59XFxuXFxuLyojXCIpLmNvbmNhdChuYW1lLCBcIi1zcGVlZC1zZXR0aW5ncyB7XFxuICBoZWlnaHQ6IFwiKS5jb25jYXQob3B0aW9ucy5zcGVlZFZhbHVlcy5sZW5ndGggKiAxNiArIDMyICsgMTAgLSAyLCBcInB4O1xcbn0qL1xcblxcbiNcIikuY29uY2F0KG5hbWUsIFwiLXNwZWVkLXNldHRpbmdzIGxpLm5vLWhvdmVyIHsgXFxuICBoZWlnaHQ6IFwiKS5jb25jYXQob3B0aW9ucy5zcGVlZFZhbHVlcy5sZW5ndGggKiAxNiArIDEwIC0gMiwgXCJweCAhaW1wb3J0YW50OyBcXG59XFxuI1wiKS5jb25jYXQobmFtZSwgXCItc2V0dGluZ3MtcGFuZWwuXCIpLmNvbmNhdChuYW1lLCBcIi1zZXR0aW5ncy1zcGVlZC1wYW5lbCB7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgd2lkdGg6IDkycHg7XFxuICBwb3NpdGlvbjphYnNvbHV0ZTtcXG4gIHotaW5kZXg6MTIwO1xcbiAgLypoZWlnaHQ6IFwiKS5jb25jYXQob3B0aW9ucy5zcGVlZFZhbHVlcy5sZW5ndGggKiAxNiArIDMyICsgMjAsIFwicHg7Ki9cXG4gIC13ZWJraXQtdHJhbnNpdGlvbjogYWxsIDAuM3MgZWFzZTtcXG4gIC1tb3otdHJhbnNpdGlvbjogYWxsIDAuM3MgZWFzZTtcXG4gIHRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2U7XFxufVxcblxcbiNcIikuY29uY2F0KG5hbWUsIFwiLXNldHRpbmdzLXBhbmVsLlwiKS5jb25jYXQobmFtZSwgXCItc2V0dGluZ3Mtc3BlZWQtcGFuZWwgLlwiKS5jb25jYXQobmFtZSwgXCItc3BlZWQtYnRuIHtcXG4gIGZsb2F0OiBsZWZ0O1xcbn1cXG5cXG4uXCIpLmNvbmNhdChuYW1lLCBcIi1zZXR0aW5ncy1zcGVlZC1wYW5lbCB1bDpmaXJzdC1jaGlsZCB7XFxuICB0ZXh0LWFsaWduOiByaWdodDtcXG59XFxuXFxuI1wiKS5jb25jYXQobmFtZSwgXCItc3BlZWQtY3VycmVudCB7XFxuICBmbG9hdDogcmlnaHQ7XFxuICBwYWRkaW5nLXJpZ2h0OiAxMHB4XFxufVxcblxcbiNcIikuY29uY2F0KG5hbWUsIFwiLXNldHRpbmdzLXBhbmVsIC5cIikuY29uY2F0KG5hbWUsIFwiLXNwZWVkLWJ0biB7XFxuICBmbG9hdDogcmlnaHQ7XFxufVxcblxcbiNcIikuY29uY2F0KG5hbWUsIFwiLXNldHRpbmdzLXBhbmVsIHVsIHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgbWFyZ2luOiAwcHg7XFxuICBwYWRkaW5nOiAwcHg7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbn1cXG5cXG4jXCIpLmNvbmNhdChuYW1lLCBcIi1zZXR0aW5ncy1wYW5lbC5cIikuY29uY2F0KG5hbWUsIFwiLXNldHRpbmdzLXNwZWVkLXBhbmVsIHVsIGxpIHtcXG4gIG1pbi13aWR0aDogNzBweDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBoZWlnaHQ6IDMycHg7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAganVzdGlmeS1jb250ZW50OmNlbnRlcjtcXG59XFxuXFxuI1wiKS5jb25jYXQobmFtZSwgXCItc2V0dGluZ3MtcGFuZWwgdWwgbGkubm8taG92ZXI6aG92ZXIge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICBjdXJzb3I6IGRlZmF1bHQ7XFxufVxcblxcbmRpdi5cIikuY29uY2F0KG5hbWUsIFwiLXNwZWVkLXZhbHVlOmhvdmVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IFwiKS5jb25jYXQodGhlbWVbXCJob3Zlci1jb2xvclwiXSwgXCI7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcbiNcIikuY29uY2F0KG5hbWUsIFwiLXNldHRpbmdzLXBhbmVsIHVsIGxpIHtcXG4gIC8qcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBtaW4td2lkdGg6IDE1NHB4OyovXFxuICBsaXN0LXN0eWxlLXR5cGU6IG5vbmU7XFxuICBtYXJnaW46IDBweDtcXG4gIHBhZGRpbmc6IDVweDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBoZWlnaHQ6MzJweDtcXG4gIGFsaWduLWl0ZW1zOmNlbnRlcjtcXG59XFxuXFxuI1wiKS5jb25jYXQobmFtZSwgXCItc2V0dGluZ3MtcGFuZWwgdWwgbGkgbGFiZWwge1xcbiAgbWFyZ2luOiAwcHg7XFxufVxcblxcbi5zd2l0Y2gge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgd2lkdGg6IDMycHg7XFxuICBoZWlnaHQ6IDE4cHg7XFxufVxcblxcbi5zd2l0Y2ggaW5wdXQge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuXFxuLnNldHRpbmdzLXN3aXRjaCB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICByaWdodDogMjRweDtcXG59XFxuXFxuLnNldHRpbmdzLXN3aXRjaDo6YWZ0ZXIge1xcbiAgY2xlYXI6IGJvdGg7XFxufVxcblxcbi5zbGlkZXIge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgdG9wOiAwO1xcbiAgbGVmdDogMDtcXG4gIHJpZ2h0OiAwO1xcbiAgYm90dG9tOiAwO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogXCIpLmNvbmNhdCh0aGVtZVtcInNsaWRlci1vZmYtY29sb3JcIl0sIFwiO1xcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiAuNHM7XFxuICB0cmFuc2l0aW9uOiAuNHM7XFxufVxcblxcbi5zbGlkZXI6YmVmb3JlIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGNvbnRlbnQ6IFxcXCJcXFwiO1xcbiAgaGVpZ2h0OiAxNnB4O1xcbiAgd2lkdGg6IDE2cHg7XFxuICBsZWZ0OiAxcHg7XFxuICBib3R0b206IDFweDtcXG4gIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiAuNHM7XFxuICB0cmFuc2l0aW9uOiAuNHM7XFxufVxcblxcbmlucHV0OmNoZWNrZWQrLnNsaWRlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiBcIikuY29uY2F0KHRoZW1lW1wic2xpZGVyLW9uLWNvbG9yXCJdLCBcIjtcXG59XFxuXFxuaW5wdXQ6Zm9jdXMrLnNsaWRlciB7XFxuICBib3gtc2hhZG93OiAwIDAgMXB4IFwiKS5jb25jYXQodGhlbWVbXCJzbGlkZXItb24tY29sb3JcIl0sIFwiO1xcbn1cXG5cXG5pbnB1dDpjaGVja2VkKy5zbGlkZXI6YmVmb3JlIHtcXG4gIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDE2cHgpO1xcbiAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlWCgxNnB4KTtcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgxNnB4KTtcXG59XFxuXFxuXFxuLyogUm91bmRlZCBzbGlkZXJzICovXFxuXFxuLnNsaWRlci5yb3VuZCB7XFxuICBib3JkZXItcmFkaXVzOiAzNHB4O1xcbn1cXG5cXG4uc2xpZGVyLnJvdW5kOmJlZm9yZSB7XFxuICBib3JkZXItcmFkaXVzOiA1MCU7XFxufVxcblxcblxcbi5tLWZhZGVPdXQge1xcbiAgdmlzaWJpbGl0eTogaGlkZGVuO1xcbiAgb3BhY2l0eTogMDtcXG4gIHRyYW5zaXRpb246IHZpc2liaWxpdHkgMHMgbGluZWFyIDMwMG1zLCBvcGFjaXR5IDMwMG1zO1xcbn1cXG5cXG4ubS1mYWRlSW4ge1xcbiAgdmlzaWJpbGl0eTogdmlzaWJsZTtcXG4gIG9wYWNpdHk6IDE7XFxuICB0cmFuc2l0aW9uOiB2aXNpYmlsaXR5IDBzIGxpbmVhciAwcywgb3BhY2l0eSAzMDBtcztcXG59XFxuXFxuI1wiKS5jb25jYXQobmFtZSwgXCItc2V0dGluZ3MtcGFuZWwgdWwgbGk6aG92ZXIge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogXCIpLmNvbmNhdCh0aGVtZVtcImhvdmVyLWNvbG9yXCJdLCBcIjtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXFxuI1wiKS5jb25jYXQobmFtZSwgXCItc2V0dGluZ3MtcGFuZWwgdWwgbGkgbGFiZWw6aG92ZXIge1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG5cXG4jXCIpLmNvbmNhdChuYW1lLCBcIi1sb29wYmFyOmhvdmVyIHtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXFxuI1wiKS5jb25jYXQobmFtZSwgXCItc3RhdHVzLWJ0bjpob3ZlciB7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcbiNcIikuY29uY2F0KG5hbWUsIFwiLWNvbnRyb2xzOmFjdGl2ZSAjXCIpLmNvbmNhdChuYW1lLCBcIi1jdXJzb3IsXFxuI1wiKS5jb25jYXQobmFtZSwgXCItY29udHJvbHM6aG92ZXIgI1wiKS5jb25jYXQobmFtZSwgXCItY3Vyc29yICB7XFxuICB3aWR0aDogMTZweDtcXG4gIGhlaWdodDogMTZweDtcXG4gIC13ZWJraXQtdHJhbnNpdGlvbjogYWxsIDAuM3MgZWFzZTtcXG4gIC1tb3otdHJhbnNpdGlvbjogYWxsIDAuM3MgZWFzZTtcXG4gIHRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2U7XFxufVxcblxcbiNcIikuY29uY2F0KG5hbWUsIFwiLXZvbHVtZSAuXCIpLmNvbmNhdChuYW1lLCBcIi12b2x1bWUtY3Vyc29yLXRyYW5zaXRpb24ge1xcbiAgd2lkdGg6IDEycHg7XFxuICBoZWlnaHQ6IDEycHg7XFxuICAtd2Via2l0LXRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2U7XFxuICAtbW96LXRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2U7XFxuICB0cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlO1xcbn1cXG5cXG4jXCIpLmNvbmNhdChuYW1lLCBcIi12b2x1bWUgLlwiKS5jb25jYXQobmFtZSwgXCItdm9sdW1lLXdpZHRoLXRyYW5zaXRpb25cXG4ge1xcbiAgd2lkdGg6IDUwcHg7XFxuICAtd2Via2l0LXRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2U7XFxuICAtbW96LXRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2U7XFxuICB0cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlO1xcbn1cXG5cXG4jXCIpLmNvbmNhdChuYW1lLCBcIi10aW1lLWRpc3BsYXkuXCIpLmNvbmNhdChuYW1lLCBcIi10aW1lLXdpZHRoLXRyYW5zaXRpb24ge1xcbiAgcG9zaXRpb246cmVsYXRpdmU7XFxuICBsZWZ0OiAxMHB4O1xcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiBsZWZ0IDAuM3MgZWFzZTtcXG4gIC1tb3otdHJhbnNpdGlvbjogbGVmdCAwLjNzIGVhc2U7XFxuICB0cmFuc2l0aW9uOiBsZWZ0IDAuM3MgZWFzZTtcXG59XFxuXFxuI1wiKS5jb25jYXQobmFtZSwgXCItc2V0dGluZ3Mtc3BlZWQ6aG92ZXIgLlwiKS5jb25jYXQobmFtZSwgXCItc3BlZWQtYnRuIHtcXG4gIG9wYWNpdHk6IDE7XFxuICAtd2Via2l0LXRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2U7XFxuICAtbW96LXRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2U7XFxuICB0cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlO1xcbn1cXG5cXG4jXCIpLmNvbmNhdChuYW1lLCBcIi1zdGF0dXMtYnRuOmhvdmVyIHtcXG4gIG9wYWNpdHk6IDE7XFxuICAtd2Via2l0LXRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2U7XFxuICAtbW96LXRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2U7XFxuICB0cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlO1xcbn1cXG5cXG4jXCIpLmNvbmNhdChuYW1lLCBcIi1sb29wLWJ0bjpob3ZlcixcXG4jXCIpLmNvbmNhdChuYW1lLCBcIi1kYy1idG46aG92ZXJcXG4ge1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgb3BhY2l0eTogMTtcXG4gIC13ZWJraXQtdHJhbnNpdGlvbjogYWxsIDAuM3MgZWFzZTtcXG4gIC1tb3otdHJhbnNpdGlvbjogYWxsIDAuM3MgZWFzZTtcXG4gIHRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2U7XFxufVxcbiNcIikuY29uY2F0KG5hbWUsIFwiLXNldHRpbmdzLWJ0bjpob3ZlciB7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICBvcGFjaXR5OiAxO1xcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlO1xcbiAgLW1vei10cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlO1xcbiAgdHJhbnNpdGlvbjogYWxsIDAuM3MgZWFzZTtcXG59XFxuXFxuI1wiKS5jb25jYXQobmFtZSwgXCItZnVsbC1zY3JlZW4tYnRuOmhvdmVyIHtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIG9wYWNpdHk6IDE7XFxuICAtd2Via2l0LXRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2U7XFxuICAtbW96LXRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2U7XFxuICB0cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlO1xcbn1cXG5cIikuY29uY2F0KHRoZW1lW1widGhlbWUtc3R5bGVcIl0sIFwiXFxuXCIpO1xufTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex-player/dist/html/style.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex-player/dist/html/svg.js":
/*!*************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex-player/dist/html/svg.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar svg = module.exports = {};\nsvg.playSVG = \"\\n  <svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"18\\\" height=\\\"20\\\" viewBox=\\\"0 0 18 20\\\">\\n    <path fill=\\\"#999\\\" fill-rule=\\\"nonzero\\\" d=\\\"M16.224 8.515L2.582.245A1.7 1.7 0 0 0 0 1.702V18.24a1.7 1.7 0 0 0 2.582 1.455l13.642-8.27a1.7 1.7 0 0 0 0-2.91z\\\"/>\\n</svg>\\n\\n\";\nsvg.dcSVG = \"\\n  <svg class=\\\"svg\\\" style=\\\"transform:scale(0.55)\\\" version=\\\"1.0\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"\\n width=\\\"1705.000000pt\\\" height=\\\"1903.000000pt\\\" viewBox=\\\"0 0 1705.000000 1903.000000\\\"\\n preserveAspectRatio=\\\"xMidYMid meet\\\">\\n<metadata>\\nCreated by potrace 1.15, written by Peter Selinger 2001-2017\\n</metadata>\\n<g transform=\\\"translate(0.000000,1903.000000) scale(0.100000,-0.100000)\\\"\\nfill=\\\"#000000\\\" stroke=\\\"none\\\">\\n<path d=\\\"M0 9515 l0 -9515 1583 0 1582 0 4430 4655 c2437 2561 4457 4687 4490\\n4726 33 38 1164 1227 2513 2642 l2452 2572 0 2192 c0 1206 -2 2193 -4 2193 -3\\n0 -1597 -1652 -3542 -3671 l-3538 -3671 -31 35 c-16 20 -1497 1683 -3290 3696\\nl-3260 3661 -1692 0 -1693 0 0 -9515z m5504 2412 c1253 -1413 2279 -2574 2282\\n-2580 3 -9 -3274 -3438 -4597 -4811 -5 -6 -9 1968 -9 4999 l0 5010 24 -25 c13\\n-14 1048 -1181 2300 -2593z\\\"/>\\n<path d=\\\"M13924 7584 c-34 -17 -2029 -2158 -2029 -2178 0 -15 5121 -5400 5141\\n-5404 12 -3 14 295 14 2241 l0 2245 -1478 1543 c-813 849 -1490 1550 -1505\\n1557 -38 16 -105 15 -143 -4z\\\"/>\\n</g>\\n</svg>\\n\";\nsvg.pauseSVG = \"\\n  <svg class=\\\"svg\\\" style=\\\"transform:scale(1.5)\\\" width=\\\"100%\\\" height=\\\"100%\\\" viewBox=\\\"0 0 36 36\\\" >\\n    <path id=\\\"pause-icon\\\" data-state=\\\"playing\\\" d=\\\"M11,10 L17,10 17,26 11,26 M20,10 L26,10 26,26 20,26\\\" />\\n  </svg>\\n\";\nsvg.replaySVG = \"\\n  <svg class=\\\"svg\\\" width=\\\"100%\\\" height=\\\"100%\\\" version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" x=\\\"0px\\\" y=\\\"0px\\\" viewBox=\\\"0 0 1000 1000\\\" enable-background=\\\"new 0 0 1000 1000\\\" xml:space=\\\"preserve\\\">\\n    <metadata> Svg Vector Icons : http://www.onlinewebfonts.com/icon </metadata>\\n    <g><g transform=\\\"translate(0.000000,511.000000) scale(0.100000,-0.100000)\\\">\\n      <path d=\\\"M5356.3,4203.8c-1247.8-153.1-2324.2-811.3-3000.7-1839.7c-379.4-578.2-596.5-1209-660.5-1933.4l-27.4-294.8H883.9c-431.9,0-783.9-6.9-783.9-18.3c0-9.2,477.6-493.7,1062.7-1078.7l1062.7-1062.7L3288.1-961.1C3873.1-376,4350.8,108.5,4350.8,117.6c0,11.4-356.5,18.3-790.7,18.3h-793l18.3,189.7C2831,876.3,2991,1338,3288.1,1779.1C4122.3,3026.9,5706,3472.5,7065.8,2841.8C7639.4,2578.9,8197,2035,8487.3,1461.4C8581,1274,8709,896.9,8754.7,666.1c48-246.8,54.8-811.3,9.1-1055.8C8567.3-1491.3,7788-2394,6720.7-2750.5c-315.4-107.4-541.6-139.4-941.6-139.4c-287.9,0-415.9,11.4-598.8,50.3c-523.3,112-973.6,335.9-1371.2,681c-75.4,68.6-148.5,123.4-160,123.4c-9.1,0-187.4-169.1-393.1-374.8c-434.2-434.2-420.5-363.4-105.1-628.5c852.4-710.7,1972.3-1055.8,3046.4-937c1627.2,176,2977.8,1257,3489.8,2790.4c457.1,1368.9,169.1,2843-777,3969.7C8322.7,3484,7417.8,4000.4,6503.6,4160.4C6197.4,4213,5619.2,4235.8,5356.3,4203.8z\\\"/>\\n      <path d=\\\"M4990.7,124.5c0-1503.8,4.6-1794,32-1778c16,9.1,505.1,413.6,1085.6,895.8C7113.8,78.8,7161.8,122.2,7122.9,161c-80,75.4-2109.4,1757.5-2120.8,1757.5C4995.3,1918.5,4990.7,1111.8,4990.7,124.5z\\\"/>\\n    </g></g>\\n  </svg>\\n\";\nsvg.volumeSVG = \"\\n  <svg class=\\\"svg\\\" width=\\\"100%\\\" height=\\\"100%\\\" version=\\\"1.1\\\" id=\\\"Capa_1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" x=\\\"0px\\\" y=\\\"0px\\\"\\n   viewBox=\\\"0 0 286.374 286.374\\\" style=\\\"enable-background:new 0 0 286.374 286.374;\\\" xml:space=\\\"preserve\\\">\\n    <g id=\\\"Volume_2\\\">\\n      <path style=\\\"fill-rule:evenodd;clip-rule:evenodd;\\\" d=\\\"M233.636,26.767l-33.372,28.5c25.659,21.07,42.006,52.616,42.006,87.92\\n        c0,35.305-16.347,66.851-42.006,87.921l33.372,28.499c32.324-28.869,52.738-70.268,52.738-116.421\\n        C286.374,97.034,265.96,55.635,233.636,26.767z M177.737,74.513l-34.69,29.64c15.14,6.818,27.19,21.681,27.19,39.034\\n        s-12.05,32.216-27.19,39.034l34.69,29.64c21.294-15.717,36.051-40.586,36.051-68.674C213.788,115.099,199.03,90.23,177.737,74.513z\\n         M108.672,48.317L44.746,98.441H17.898C4.671,98.441,0,103.268,0,116.34v53.695c0,13.072,4.951,17.898,17.898,17.898h26.848\\n        l63.926,50.068c7.668,4.948,16.558,6.505,16.558-7.365V55.683C125.23,41.813,116.34,43.37,108.672,48.317z\\\"/>\\n    </g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g>\\n  </svg>\\n\";\nsvg.volumeMuteSVG = \"\\n  <svg class=\\\"svg\\\" width=\\\"100%\\\" height=\\\"100%\\\" version=\\\"1.1\\\" id=\\\"Capa_1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" x=\\\"0px\\\" y=\\\"0px\\\"\\n   viewBox=\\\"0 0 286.277 286.277\\\" style=\\\"enable-background:new 0 0 286.277 286.277;\\\" xml:space=\\\"preserve\\\">\\n    <g id=\\\"Volume_none\\\">\\n      <path style=\\\"fill-rule:evenodd;clip-rule:evenodd;\\\" d=\\\"M245.102,143.151l36.98-37.071c5.593-5.605,5.593-14.681,0-20.284\\n        l-10.124-10.142c-5.593-5.604-14.655-5.604-20.247,0l-36.98,37.071l-36.977-37.043c-5.594-5.603-14.654-5.603-20.247,0\\n        l-10.124,10.143c-5.594,5.603-5.594,14.679,0,20.282l36.987,37.053l-36.961,37.051c-5.591,5.604-5.591,14.681,0,20.284\\n        l10.126,10.141c5.593,5.604,14.654,5.604,20.247,0l36.96-37.05l36.97,37.035c5.592,5.605,14.654,5.605,20.247,0l10.124-10.141\\n        c5.593-5.603,5.593-14.68,0-20.282L245.102,143.151z M108.674,48.296L44.747,98.42H17.9c-13.228,0-17.899,4.826-17.899,17.898\\n        L0,142.719l0.001,27.295c0,13.072,4.951,17.898,17.899,17.898h26.847l63.927,50.068c7.667,4.948,16.557,6.505,16.557-7.365V55.662\\n        C125.23,41.792,116.341,43.349,108.674,48.296z\\\"/>\\n    </g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g>\\n  </svg>\\n\";\nsvg.settingsSVG = \"\\n  <svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"19\\\" height=\\\"19\\\" viewBox=\\\"0 0 19 19\\\">\\n    <path fill=\\\"#999\\\" fill-rule=\\\"nonzero\\\" d=\\\"M17.812 7.52h-1.474a7.09 7.09 0 0 0-.604-1.456l1.043-1.042a1.187 1.187 0 0 0 0-1.68l-1.12-1.118a1.188 1.188 0 0 0-1.68 0l-1.043 1.042a7.05 7.05 0 0 0-1.455-.604V1.188C11.48.531 10.948 0 10.292 0H8.708c-.656 0-1.187.532-1.187 1.188v1.474a7.1 7.1 0 0 0-1.456.604L5.022 2.224a1.187 1.187 0 0 0-1.68 0l-1.12 1.12a1.188 1.188 0 0 0 0 1.68l1.044 1.042c-.256.46-.458.949-.604 1.455H1.188C.531 7.52 0 8.052 0 8.708v1.584c0 .656.532 1.187 1.188 1.187h1.474c.146.507.348.995.604 1.456L2.22 13.979a1.188 1.188 0 0 0 0 1.68l1.12 1.119a1.223 1.223 0 0 0 1.68 0l1.043-1.043c.462.255.95.458 1.457.605v1.472c0 .656.531 1.188 1.187 1.188h1.584c.656 0 1.187-.532 1.187-1.188V16.34c.506-.147.995-.35 1.456-.604l1.043 1.043a1.188 1.188 0 0 0 1.68 0l1.119-1.12a1.187 1.187 0 0 0 0-1.679l-1.043-1.043c.256-.461.458-.95.604-1.456h1.474A1.188 1.188 0 0 0 19 10.29V8.709c0-.656-.532-1.187-1.188-1.187zM9.5 13.459a3.958 3.958 0 1 1 0-7.916 3.958 3.958 0 0 1 0 7.916z\\\"/>\\n</svg>\\n\\n\";\nsvg.arrowRightSVG = \"\\n  <svg class=\\\"svg arrow\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" width=\\\"100%\\\" height=\\\"100%\\\" viewBox=\\\"0 0 50 80\\\" xml:space=\\\"preserve\\\">\\n    <polyline fill=\\\"none\\\" stroke-width=\\\"10\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\" points=\\\"0.375,0.375 45.63,38.087 0.375,75.8 \\\"/>\\n  </svg>\\n\";\nsvg.arrowLeftSVG = \"\\n  <svg class=\\\"svg arrow\\\" class=\\\"svg\\\" width=\\\"100%\\\" height=\\\"100%\\\" viewBox=\\\"0 0 50 80\\\" xml:space=\\\"preserve\\\">\\n    <polyline fill=\\\"none\\\" stroke-width=\\\"10\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\" points=\\\"45.63,75.8 0.375,38.087 45.63,0.375 \\\"/>\\n  </svg> \\n\";\nsvg.fullScreenSVG = \"\\n <svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"19\\\" height=\\\"19\\\" viewBox=\\\"0 0 19 19\\\">\\n    <g fill=\\\"#999\\\" fill-rule=\\\"nonzero\\\">\\n        <path d=\\\"M18.802 1.942A1.746 1.746 0 0 0 17.06.2h-4.537a.99.99 0 1 0 0 1.98h4.102c.11 0 .198.088.198.197v2.588a.99.99 0 1 0 1.98 0V1.942zM.198 4.965a.99.99 0 0 0 1.98 0v-2.59a.198.198 0 0 1 .197-.199h4.102a.99.99 0 0 0 0-1.979H1.944C.983.2.204.978.202 1.94L.198 4.965zM18.802 17.056v-3.023a.99.99 0 1 0-1.98 0v2.592c0 .11-.088.198-.197.198h-4.102a.99.99 0 1 0 0 1.98h4.533c.964-.001 1.746-.783 1.746-1.747zM.198 17.056a1.746 1.746 0 0 0 1.746 1.742h4.533a.99.99 0 1 0 0-1.979H2.375a.198.198 0 0 1-.198-.194v-2.592a.99.99 0 1 0-1.98 0v3.023z\\\"/>\\n        <rect width=\\\"10.651\\\" height=\\\"6.117\\\" x=\\\"4.174\\\" y=\\\"6.441\\\" rx=\\\"1.954\\\"/>\\n    </g>\\n</svg>\\n\\n\";\nsvg.loopSVG = \"\\n<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"24\\\" height=\\\"22\\\" viewBox=\\\"0 0 24 22\\\">\\n    <g fill=\\\"#999\\\" fill-rule=\\\"nonzero\\\">\\n        <path d=\\\"M16.773 15.476H16.3a1.25 1.25 0 0 0 0 2.5h.478a6.944 6.944 0 0 0 .98-13.823.251.251 0 0 1-.208-.246V1.93A1.25 1.25 0 0 0 15.584.906l-4.778 3.341a1.25 1.25 0 0 0 .717 2.274h4.764c2.829 0 4.963 1.925 4.963 4.478a4.482 4.482 0 0 1-4.477 4.477zM6.247 17.845c.12.02.208.124.208.246v1.976a1.249 1.249 0 0 0 1.966 1.024l4.773-3.34a1.251 1.251 0 0 0-.717-2.275H7.713c-2.829 0-4.963-1.925-4.963-4.476a4.482 4.482 0 0 1 4.477-4.479h.478a1.25 1.25 0 1 0 0-2.5h-.478a6.945 6.945 0 0 0-.98 13.824z\\\"/>\\n    </g>\\n</svg>\\n\";\nsvg.loadingSVG = \"<svg class=\\\"lds-spinner\\\" width=\\\"200px\\\"  height=\\\"200px\\\"  xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" viewBox=\\\"0 0 100 100\\\" preserveAspectRatio=\\\"xMidYMid\\\" style=\\\"background: none;\\\"><g transform=\\\"rotate(0 50 50)\\\">\\n  <rect x=\\\"47\\\" y=\\\"24\\\" rx=\\\"9.4\\\" ry=\\\"4.8\\\" width=\\\"6\\\" height=\\\"12\\\" fill=\\\"#999\\\">\\n    <animate attributeName=\\\"opacity\\\" values=\\\"1;0\\\" keyTimes=\\\"0;1\\\" dur=\\\"1s\\\" begin=\\\"-0.9166666666666666s\\\" repeatCount=\\\"indefinite\\\"></animate>\\n  </rect>\\n</g><g transform=\\\"rotate(30 50 50)\\\">\\n  <rect x=\\\"47\\\" y=\\\"24\\\" rx=\\\"9.4\\\" ry=\\\"4.8\\\" width=\\\"6\\\" height=\\\"12\\\" fill=\\\"#999\\\">\\n    <animate attributeName=\\\"opacity\\\" values=\\\"1;0\\\" keyTimes=\\\"0;1\\\" dur=\\\"1s\\\" begin=\\\"-0.8333333333333334s\\\" repeatCount=\\\"indefinite\\\"></animate>\\n  </rect>\\n</g><g transform=\\\"rotate(60 50 50)\\\">\\n  <rect x=\\\"47\\\" y=\\\"24\\\" rx=\\\"9.4\\\" ry=\\\"4.8\\\" width=\\\"6\\\" height=\\\"12\\\" fill=\\\"#999\\\">\\n    <animate attributeName=\\\"opacity\\\" values=\\\"1;0\\\" keyTimes=\\\"0;1\\\" dur=\\\"1s\\\" begin=\\\"-0.75s\\\" repeatCount=\\\"indefinite\\\"></animate>\\n  </rect>\\n</g><g transform=\\\"rotate(90 50 50)\\\">\\n  <rect x=\\\"47\\\" y=\\\"24\\\" rx=\\\"9.4\\\" ry=\\\"4.8\\\" width=\\\"6\\\" height=\\\"12\\\" fill=\\\"#999\\\">\\n    <animate attributeName=\\\"opacity\\\" values=\\\"1;0\\\" keyTimes=\\\"0;1\\\" dur=\\\"1s\\\" begin=\\\"-0.6666666666666666s\\\" repeatCount=\\\"indefinite\\\"></animate>\\n  </rect>\\n</g><g transform=\\\"rotate(120 50 50)\\\">\\n  <rect x=\\\"47\\\" y=\\\"24\\\" rx=\\\"9.4\\\" ry=\\\"4.8\\\" width=\\\"6\\\" height=\\\"12\\\" fill=\\\"#999\\\">\\n    <animate attributeName=\\\"opacity\\\" values=\\\"1;0\\\" keyTimes=\\\"0;1\\\" dur=\\\"1s\\\" begin=\\\"-0.5833333333333334s\\\" repeatCount=\\\"indefinite\\\"></animate>\\n  </rect>\\n</g><g transform=\\\"rotate(150 50 50)\\\">\\n  <rect x=\\\"47\\\" y=\\\"24\\\" rx=\\\"9.4\\\" ry=\\\"4.8\\\" width=\\\"6\\\" height=\\\"12\\\" fill=\\\"#999\\\">\\n    <animate attributeName=\\\"opacity\\\" values=\\\"1;0\\\" keyTimes=\\\"0;1\\\" dur=\\\"1s\\\" begin=\\\"-0.5s\\\" repeatCount=\\\"indefinite\\\"></animate>\\n  </rect>\\n</g><g transform=\\\"rotate(180 50 50)\\\">\\n  <rect x=\\\"47\\\" y=\\\"24\\\" rx=\\\"9.4\\\" ry=\\\"4.8\\\" width=\\\"6\\\" height=\\\"12\\\" fill=\\\"#999\\\">\\n    <animate attributeName=\\\"opacity\\\" values=\\\"1;0\\\" keyTimes=\\\"0;1\\\" dur=\\\"1s\\\" begin=\\\"-0.4166666666666667s\\\" repeatCount=\\\"indefinite\\\"></animate>\\n  </rect>\\n</g><g transform=\\\"rotate(210 50 50)\\\">\\n  <rect x=\\\"47\\\" y=\\\"24\\\" rx=\\\"9.4\\\" ry=\\\"4.8\\\" width=\\\"6\\\" height=\\\"12\\\" fill=\\\"#999\\\">\\n    <animate attributeName=\\\"opacity\\\" values=\\\"1;0\\\" keyTimes=\\\"0;1\\\" dur=\\\"1s\\\" begin=\\\"-0.3333333333333333s\\\" repeatCount=\\\"indefinite\\\"></animate>\\n  </rect>\\n</g><g transform=\\\"rotate(240 50 50)\\\">\\n  <rect x=\\\"47\\\" y=\\\"24\\\" rx=\\\"9.4\\\" ry=\\\"4.8\\\" width=\\\"6\\\" height=\\\"12\\\" fill=\\\"#999\\\">\\n    <animate attributeName=\\\"opacity\\\" values=\\\"1;0\\\" keyTimes=\\\"0;1\\\" dur=\\\"1s\\\" begin=\\\"-0.25s\\\" repeatCount=\\\"indefinite\\\"></animate>\\n  </rect>\\n</g><g transform=\\\"rotate(270 50 50)\\\">\\n  <rect x=\\\"47\\\" y=\\\"24\\\" rx=\\\"9.4\\\" ry=\\\"4.8\\\" width=\\\"6\\\" height=\\\"12\\\" fill=\\\"#999\\\">\\n    <animate attributeName=\\\"opacity\\\" values=\\\"1;0\\\" keyTimes=\\\"0;1\\\" dur=\\\"1s\\\" begin=\\\"-0.16666666666666666s\\\" repeatCount=\\\"indefinite\\\"></animate>\\n  </rect>\\n</g><g transform=\\\"rotate(300 50 50)\\\">\\n  <rect x=\\\"47\\\" y=\\\"24\\\" rx=\\\"9.4\\\" ry=\\\"4.8\\\" width=\\\"6\\\" height=\\\"12\\\" fill=\\\"#999\\\">\\n    <animate attributeName=\\\"opacity\\\" values=\\\"1;0\\\" keyTimes=\\\"0;1\\\" dur=\\\"1s\\\" begin=\\\"-0.08333333333333333s\\\" repeatCount=\\\"indefinite\\\"></animate>\\n  </rect>\\n</g><g transform=\\\"rotate(330 50 50)\\\">\\n  <rect x=\\\"47\\\" y=\\\"24\\\" rx=\\\"9.4\\\" ry=\\\"4.8\\\" width=\\\"6\\\" height=\\\"12\\\" fill=\\\"#999\\\">\\n    <animate attributeName=\\\"opacity\\\" values=\\\"1;0\\\" keyTimes=\\\"0;1\\\" dur=\\\"1s\\\" begin=\\\"0s\\\" repeatCount=\\\"indefinite\\\"></animate>\\n  </rect>\\n</g></svg>\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgtcGxheWVyL2Rpc3QvaHRtbC9zdmcuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgtcGxheWVyL2Rpc3QvaHRtbC9zdmcuanM/MDcwZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIHN2ZyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5zdmcucGxheVNWRyA9IFwiXFxuICA8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgd2lkdGg9XFxcIjE4XFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMTggMjBcXFwiPlxcbiAgICA8cGF0aCBmaWxsPVxcXCIjOTk5XFxcIiBmaWxsLXJ1bGU9XFxcIm5vbnplcm9cXFwiIGQ9XFxcIk0xNi4yMjQgOC41MTVMMi41ODIuMjQ1QTEuNyAxLjcgMCAwIDAgMCAxLjcwMlYxOC4yNGExLjcgMS43IDAgMCAwIDIuNTgyIDEuNDU1bDEzLjY0Mi04LjI3YTEuNyAxLjcgMCAwIDAgMC0yLjkxelxcXCIvPlxcbjwvc3ZnPlxcblxcblwiO1xuc3ZnLmRjU1ZHID0gXCJcXG4gIDxzdmcgY2xhc3M9XFxcInN2Z1xcXCIgc3R5bGU9XFxcInRyYW5zZm9ybTpzY2FsZSgwLjU1KVxcXCIgdmVyc2lvbj1cXFwiMS4wXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiXFxuIHdpZHRoPVxcXCIxNzA1LjAwMDAwMHB0XFxcIiBoZWlnaHQ9XFxcIjE5MDMuMDAwMDAwcHRcXFwiIHZpZXdCb3g9XFxcIjAgMCAxNzA1LjAwMDAwMCAxOTAzLjAwMDAwMFxcXCJcXG4gcHJlc2VydmVBc3BlY3RSYXRpbz1cXFwieE1pZFlNaWQgbWVldFxcXCI+XFxuPG1ldGFkYXRhPlxcbkNyZWF0ZWQgYnkgcG90cmFjZSAxLjE1LCB3cml0dGVuIGJ5IFBldGVyIFNlbGluZ2VyIDIwMDEtMjAxN1xcbjwvbWV0YWRhdGE+XFxuPGcgdHJhbnNmb3JtPVxcXCJ0cmFuc2xhdGUoMC4wMDAwMDAsMTkwMy4wMDAwMDApIHNjYWxlKDAuMTAwMDAwLC0wLjEwMDAwMClcXFwiXFxuZmlsbD1cXFwiIzAwMDAwMFxcXCIgc3Ryb2tlPVxcXCJub25lXFxcIj5cXG48cGF0aCBkPVxcXCJNMCA5NTE1IGwwIC05NTE1IDE1ODMgMCAxNTgyIDAgNDQzMCA0NjU1IGMyNDM3IDI1NjEgNDQ1NyA0Njg3IDQ0OTBcXG40NzI2IDMzIDM4IDExNjQgMTIyNyAyNTEzIDI2NDIgbDI0NTIgMjU3MiAwIDIxOTIgYzAgMTIwNiAtMiAyMTkzIC00IDIxOTMgLTNcXG4wIC0xNTk3IC0xNjUyIC0zNTQyIC0zNjcxIGwtMzUzOCAtMzY3MSAtMzEgMzUgYy0xNiAyMCAtMTQ5NyAxNjgzIC0zMjkwIDM2OTZcXG5sLTMyNjAgMzY2MSAtMTY5MiAwIC0xNjkzIDAgMCAtOTUxNXogbTU1MDQgMjQxMiBjMTI1MyAtMTQxMyAyMjc5IC0yNTc0IDIyODJcXG4tMjU4MCAzIC05IC0zMjc0IC0zNDM4IC00NTk3IC00ODExIC01IC02IC05IDE5NjggLTkgNDk5OSBsMCA1MDEwIDI0IC0yNSBjMTNcXG4tMTQgMTA0OCAtMTE4MSAyMzAwIC0yNTkzelxcXCIvPlxcbjxwYXRoIGQ9XFxcIk0xMzkyNCA3NTg0IGMtMzQgLTE3IC0yMDI5IC0yMTU4IC0yMDI5IC0yMTc4IDAgLTE1IDUxMjEgLTU0MDAgNTE0MVxcbi01NDA0IDEyIC0zIDE0IDI5NSAxNCAyMjQxIGwwIDIyNDUgLTE0NzggMTU0MyBjLTgxMyA4NDkgLTE0OTAgMTU1MCAtMTUwNVxcbjE1NTcgLTM4IDE2IC0xMDUgMTUgLTE0MyAtNHpcXFwiLz5cXG48L2c+XFxuPC9zdmc+XFxuXCI7XG5zdmcucGF1c2VTVkcgPSBcIlxcbiAgPHN2ZyBjbGFzcz1cXFwic3ZnXFxcIiBzdHlsZT1cXFwidHJhbnNmb3JtOnNjYWxlKDEuNSlcXFwiIHdpZHRoPVxcXCIxMDAlXFxcIiBoZWlnaHQ9XFxcIjEwMCVcXFwiIHZpZXdCb3g9XFxcIjAgMCAzNiAzNlxcXCIgPlxcbiAgICA8cGF0aCBpZD1cXFwicGF1c2UtaWNvblxcXCIgZGF0YS1zdGF0ZT1cXFwicGxheWluZ1xcXCIgZD1cXFwiTTExLDEwIEwxNywxMCAxNywyNiAxMSwyNiBNMjAsMTAgTDI2LDEwIDI2LDI2IDIwLDI2XFxcIiAvPlxcbiAgPC9zdmc+XFxuXCI7XG5zdmcucmVwbGF5U1ZHID0gXCJcXG4gIDxzdmcgY2xhc3M9XFxcInN2Z1xcXCIgd2lkdGg9XFxcIjEwMCVcXFwiIGhlaWdodD1cXFwiMTAwJVxcXCIgdmVyc2lvbj1cXFwiMS4xXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHhtbG5zOnhsaW5rPVxcXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXFxcIiB4PVxcXCIwcHhcXFwiIHk9XFxcIjBweFxcXCIgdmlld0JveD1cXFwiMCAwIDEwMDAgMTAwMFxcXCIgZW5hYmxlLWJhY2tncm91bmQ9XFxcIm5ldyAwIDAgMTAwMCAxMDAwXFxcIiB4bWw6c3BhY2U9XFxcInByZXNlcnZlXFxcIj5cXG4gICAgPG1ldGFkYXRhPiBTdmcgVmVjdG9yIEljb25zIDogaHR0cDovL3d3dy5vbmxpbmV3ZWJmb250cy5jb20vaWNvbiA8L21ldGFkYXRhPlxcbiAgICA8Zz48ZyB0cmFuc2Zvcm09XFxcInRyYW5zbGF0ZSgwLjAwMDAwMCw1MTEuMDAwMDAwKSBzY2FsZSgwLjEwMDAwMCwtMC4xMDAwMDApXFxcIj5cXG4gICAgICA8cGF0aCBkPVxcXCJNNTM1Ni4zLDQyMDMuOGMtMTI0Ny44LTE1My4xLTIzMjQuMi04MTEuMy0zMDAwLjctMTgzOS43Yy0zNzkuNC01NzguMi01OTYuNS0xMjA5LTY2MC41LTE5MzMuNGwtMjcuNC0yOTQuOEg4ODMuOWMtNDMxLjksMC03ODMuOS02LjktNzgzLjktMTguM2MwLTkuMiw0NzcuNi00OTMuNywxMDYyLjctMTA3OC43bDEwNjIuNy0xMDYyLjdMMzI4OC4xLTk2MS4xQzM4NzMuMS0zNzYsNDM1MC44LDEwOC41LDQzNTAuOCwxMTcuNmMwLDExLjQtMzU2LjUsMTguMy03OTAuNywxOC4zaC03OTNsMTguMywxODkuN0MyODMxLDg3Ni4zLDI5OTEsMTMzOCwzMjg4LjEsMTc3OS4xQzQxMjIuMywzMDI2LjksNTcwNiwzNDcyLjUsNzA2NS44LDI4NDEuOEM3NjM5LjQsMjU3OC45LDgxOTcsMjAzNSw4NDg3LjMsMTQ2MS40Qzg1ODEsMTI3NCw4NzA5LDg5Ni45LDg3NTQuNyw2NjYuMWM0OC0yNDYuOCw1NC44LTgxMS4zLDkuMS0xMDU1LjhDODU2Ny4zLTE0OTEuMyw3Nzg4LTIzOTQsNjcyMC43LTI3NTAuNWMtMzE1LjQtMTA3LjQtNTQxLjYtMTM5LjQtOTQxLjYtMTM5LjRjLTI4Ny45LDAtNDE1LjksMTEuNC01OTguOCw1MC4zYy01MjMuMywxMTItOTczLjYsMzM1LjktMTM3MS4yLDY4MWMtNzUuNCw2OC42LTE0OC41LDEyMy40LTE2MCwxMjMuNGMtOS4xLDAtMTg3LjQtMTY5LjEtMzkzLjEtMzc0LjhjLTQzNC4yLTQzNC4yLTQyMC41LTM2My40LTEwNS4xLTYyOC41Yzg1Mi40LTcxMC43LDE5NzIuMy0xMDU1LjgsMzA0Ni40LTkzN2MxNjI3LjIsMTc2LDI5NzcuOCwxMjU3LDM0ODkuOCwyNzkwLjRjNDU3LjEsMTM2OC45LDE2OS4xLDI4NDMtNzc3LDM5NjkuN0M4MzIyLjcsMzQ4NCw3NDE3LjgsNDAwMC40LDY1MDMuNiw0MTYwLjRDNjE5Ny40LDQyMTMsNTYxOS4yLDQyMzUuOCw1MzU2LjMsNDIwMy44elxcXCIvPlxcbiAgICAgIDxwYXRoIGQ9XFxcIk00OTkwLjcsMTI0LjVjMC0xNTAzLjgsNC42LTE3OTQsMzItMTc3OGMxNiw5LjEsNTA1LjEsNDEzLjYsMTA4NS42LDg5NS44QzcxMTMuOCw3OC44LDcxNjEuOCwxMjIuMiw3MTIyLjksMTYxYy04MCw3NS40LTIxMDkuNCwxNzU3LjUtMjEyMC44LDE3NTcuNUM0OTk1LjMsMTkxOC41LDQ5OTAuNywxMTExLjgsNDk5MC43LDEyNC41elxcXCIvPlxcbiAgICA8L2c+PC9nPlxcbiAgPC9zdmc+XFxuXCI7XG5zdmcudm9sdW1lU1ZHID0gXCJcXG4gIDxzdmcgY2xhc3M9XFxcInN2Z1xcXCIgd2lkdGg9XFxcIjEwMCVcXFwiIGhlaWdodD1cXFwiMTAwJVxcXCIgdmVyc2lvbj1cXFwiMS4xXFxcIiBpZD1cXFwiQ2FwYV8xXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHhtbG5zOnhsaW5rPVxcXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXFxcIiB4PVxcXCIwcHhcXFwiIHk9XFxcIjBweFxcXCJcXG4gICB2aWV3Qm94PVxcXCIwIDAgMjg2LjM3NCAyODYuMzc0XFxcIiBzdHlsZT1cXFwiZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCAyODYuMzc0IDI4Ni4zNzQ7XFxcIiB4bWw6c3BhY2U9XFxcInByZXNlcnZlXFxcIj5cXG4gICAgPGcgaWQ9XFxcIlZvbHVtZV8yXFxcIj5cXG4gICAgICA8cGF0aCBzdHlsZT1cXFwiZmlsbC1ydWxlOmV2ZW5vZGQ7Y2xpcC1ydWxlOmV2ZW5vZGQ7XFxcIiBkPVxcXCJNMjMzLjYzNiwyNi43NjdsLTMzLjM3MiwyOC41YzI1LjY1OSwyMS4wNyw0Mi4wMDYsNTIuNjE2LDQyLjAwNiw4Ny45MlxcbiAgICAgICAgYzAsMzUuMzA1LTE2LjM0Nyw2Ni44NTEtNDIuMDA2LDg3LjkyMWwzMy4zNzIsMjguNDk5YzMyLjMyNC0yOC44NjksNTIuNzM4LTcwLjI2OCw1Mi43MzgtMTE2LjQyMVxcbiAgICAgICAgQzI4Ni4zNzQsOTcuMDM0LDI2NS45Niw1NS42MzUsMjMzLjYzNiwyNi43Njd6IE0xNzcuNzM3LDc0LjUxM2wtMzQuNjksMjkuNjRjMTUuMTQsNi44MTgsMjcuMTksMjEuNjgxLDI3LjE5LDM5LjAzNFxcbiAgICAgICAgcy0xMi4wNSwzMi4yMTYtMjcuMTksMzkuMDM0bDM0LjY5LDI5LjY0YzIxLjI5NC0xNS43MTcsMzYuMDUxLTQwLjU4NiwzNi4wNTEtNjguNjc0QzIxMy43ODgsMTE1LjA5OSwxOTkuMDMsOTAuMjMsMTc3LjczNyw3NC41MTN6XFxuICAgICAgICAgTTEwOC42NzIsNDguMzE3TDQ0Ljc0Niw5OC40NDFIMTcuODk4QzQuNjcxLDk4LjQ0MSwwLDEwMy4yNjgsMCwxMTYuMzR2NTMuNjk1YzAsMTMuMDcyLDQuOTUxLDE3Ljg5OCwxNy44OTgsMTcuODk4aDI2Ljg0OFxcbiAgICAgICAgbDYzLjkyNiw1MC4wNjhjNy42NjgsNC45NDgsMTYuNTU4LDYuNTA1LDE2LjU1OC03LjM2NVY1NS42ODNDMTI1LjIzLDQxLjgxMywxMTYuMzQsNDMuMzcsMTA4LjY3Miw0OC4zMTd6XFxcIi8+XFxuICAgIDwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz5cXG4gIDwvc3ZnPlxcblwiO1xuc3ZnLnZvbHVtZU11dGVTVkcgPSBcIlxcbiAgPHN2ZyBjbGFzcz1cXFwic3ZnXFxcIiB3aWR0aD1cXFwiMTAwJVxcXCIgaGVpZ2h0PVxcXCIxMDAlXFxcIiB2ZXJzaW9uPVxcXCIxLjFcXFwiIGlkPVxcXCJDYXBhXzFcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgeG1sbnM6eGxpbms9XFxcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcXFwiIHg9XFxcIjBweFxcXCIgeT1cXFwiMHB4XFxcIlxcbiAgIHZpZXdCb3g9XFxcIjAgMCAyODYuMjc3IDI4Ni4yNzdcXFwiIHN0eWxlPVxcXCJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDI4Ni4yNzcgMjg2LjI3NztcXFwiIHhtbDpzcGFjZT1cXFwicHJlc2VydmVcXFwiPlxcbiAgICA8ZyBpZD1cXFwiVm9sdW1lX25vbmVcXFwiPlxcbiAgICAgIDxwYXRoIHN0eWxlPVxcXCJmaWxsLXJ1bGU6ZXZlbm9kZDtjbGlwLXJ1bGU6ZXZlbm9kZDtcXFwiIGQ9XFxcIk0yNDUuMTAyLDE0My4xNTFsMzYuOTgtMzcuMDcxYzUuNTkzLTUuNjA1LDUuNTkzLTE0LjY4MSwwLTIwLjI4NFxcbiAgICAgICAgbC0xMC4xMjQtMTAuMTQyYy01LjU5My01LjYwNC0xNC42NTUtNS42MDQtMjAuMjQ3LDBsLTM2Ljk4LDM3LjA3MWwtMzYuOTc3LTM3LjA0M2MtNS41OTQtNS42MDMtMTQuNjU0LTUuNjAzLTIwLjI0NywwXFxuICAgICAgICBsLTEwLjEyNCwxMC4xNDNjLTUuNTk0LDUuNjAzLTUuNTk0LDE0LjY3OSwwLDIwLjI4MmwzNi45ODcsMzcuMDUzbC0zNi45NjEsMzcuMDUxYy01LjU5MSw1LjYwNC01LjU5MSwxNC42ODEsMCwyMC4yODRcXG4gICAgICAgIGwxMC4xMjYsMTAuMTQxYzUuNTkzLDUuNjA0LDE0LjY1NCw1LjYwNCwyMC4yNDcsMGwzNi45Ni0zNy4wNWwzNi45NywzNy4wMzVjNS41OTIsNS42MDUsMTQuNjU0LDUuNjA1LDIwLjI0NywwbDEwLjEyNC0xMC4xNDFcXG4gICAgICAgIGM1LjU5My01LjYwMyw1LjU5My0xNC42OCwwLTIwLjI4MkwyNDUuMTAyLDE0My4xNTF6IE0xMDguNjc0LDQ4LjI5Nkw0NC43NDcsOTguNDJIMTcuOWMtMTMuMjI4LDAtMTcuODk5LDQuODI2LTE3Ljg5OSwxNy44OThcXG4gICAgICAgIEwwLDE0Mi43MTlsMC4wMDEsMjcuMjk1YzAsMTMuMDcyLDQuOTUxLDE3Ljg5OCwxNy44OTksMTcuODk4aDI2Ljg0N2w2My45MjcsNTAuMDY4YzcuNjY3LDQuOTQ4LDE2LjU1Nyw2LjUwNSwxNi41NTctNy4zNjVWNTUuNjYyXFxuICAgICAgICBDMTI1LjIzLDQxLjc5MiwxMTYuMzQxLDQzLjM0OSwxMDguNjc0LDQ4LjI5NnpcXFwiLz5cXG4gICAgPC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPlxcbiAgPC9zdmc+XFxuXCI7XG5zdmcuc2V0dGluZ3NTVkcgPSBcIlxcbiAgPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHdpZHRoPVxcXCIxOVxcXCIgaGVpZ2h0PVxcXCIxOVxcXCIgdmlld0JveD1cXFwiMCAwIDE5IDE5XFxcIj5cXG4gICAgPHBhdGggZmlsbD1cXFwiIzk5OVxcXCIgZmlsbC1ydWxlPVxcXCJub256ZXJvXFxcIiBkPVxcXCJNMTcuODEyIDcuNTJoLTEuNDc0YTcuMDkgNy4wOSAwIDAgMC0uNjA0LTEuNDU2bDEuMDQzLTEuMDQyYTEuMTg3IDEuMTg3IDAgMCAwIDAtMS42OGwtMS4xMi0xLjExOGExLjE4OCAxLjE4OCAwIDAgMC0xLjY4IDBsLTEuMDQzIDEuMDQyYTcuMDUgNy4wNSAwIDAgMC0xLjQ1NS0uNjA0VjEuMTg4QzExLjQ4LjUzMSAxMC45NDggMCAxMC4yOTIgMEg4LjcwOGMtLjY1NiAwLTEuMTg3LjUzMi0xLjE4NyAxLjE4OHYxLjQ3NGE3LjEgNy4xIDAgMCAwLTEuNDU2LjYwNEw1LjAyMiAyLjIyNGExLjE4NyAxLjE4NyAwIDAgMC0xLjY4IDBsLTEuMTIgMS4xMmExLjE4OCAxLjE4OCAwIDAgMCAwIDEuNjhsMS4wNDQgMS4wNDJjLS4yNTYuNDYtLjQ1OC45NDktLjYwNCAxLjQ1NUgxLjE4OEMuNTMxIDcuNTIgMCA4LjA1MiAwIDguNzA4djEuNTg0YzAgLjY1Ni41MzIgMS4xODcgMS4xODggMS4xODdoMS40NzRjLjE0Ni41MDcuMzQ4Ljk5NS42MDQgMS40NTZMMi4yMiAxMy45NzlhMS4xODggMS4xODggMCAwIDAgMCAxLjY4bDEuMTIgMS4xMTlhMS4yMjMgMS4yMjMgMCAwIDAgMS42OCAwbDEuMDQzLTEuMDQzYy40NjIuMjU1Ljk1LjQ1OCAxLjQ1Ny42MDV2MS40NzJjMCAuNjU2LjUzMSAxLjE4OCAxLjE4NyAxLjE4OGgxLjU4NGMuNjU2IDAgMS4xODctLjUzMiAxLjE4Ny0xLjE4OFYxNi4zNGMuNTA2LS4xNDcuOTk1LS4zNSAxLjQ1Ni0uNjA0bDEuMDQzIDEuMDQzYTEuMTg4IDEuMTg4IDAgMCAwIDEuNjggMGwxLjExOS0xLjEyYTEuMTg3IDEuMTg3IDAgMCAwIDAtMS42NzlsLTEuMDQzLTEuMDQzYy4yNTYtLjQ2MS40NTgtLjk1LjYwNC0xLjQ1NmgxLjQ3NEExLjE4OCAxLjE4OCAwIDAgMCAxOSAxMC4yOVY4LjcwOWMwLS42NTYtLjUzMi0xLjE4Ny0xLjE4OC0xLjE4N3pNOS41IDEzLjQ1OWEzLjk1OCAzLjk1OCAwIDEgMSAwLTcuOTE2IDMuOTU4IDMuOTU4IDAgMCAxIDAgNy45MTZ6XFxcIi8+XFxuPC9zdmc+XFxuXFxuXCI7XG5zdmcuYXJyb3dSaWdodFNWRyA9IFwiXFxuICA8c3ZnIGNsYXNzPVxcXCJzdmcgYXJyb3dcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgeG1sbnM6eGxpbms9XFxcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcXFwiIHdpZHRoPVxcXCIxMDAlXFxcIiBoZWlnaHQ9XFxcIjEwMCVcXFwiIHZpZXdCb3g9XFxcIjAgMCA1MCA4MFxcXCIgeG1sOnNwYWNlPVxcXCJwcmVzZXJ2ZVxcXCI+XFxuICAgIDxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEwXFxcIiBzdHJva2UtbGluZWNhcD1cXFwicm91bmRcXFwiIHN0cm9rZS1saW5lam9pbj1cXFwicm91bmRcXFwiIHBvaW50cz1cXFwiMC4zNzUsMC4zNzUgNDUuNjMsMzguMDg3IDAuMzc1LDc1LjggXFxcIi8+XFxuICA8L3N2Zz5cXG5cIjtcbnN2Zy5hcnJvd0xlZnRTVkcgPSBcIlxcbiAgPHN2ZyBjbGFzcz1cXFwic3ZnIGFycm93XFxcIiBjbGFzcz1cXFwic3ZnXFxcIiB3aWR0aD1cXFwiMTAwJVxcXCIgaGVpZ2h0PVxcXCIxMDAlXFxcIiB2aWV3Qm94PVxcXCIwIDAgNTAgODBcXFwiIHhtbDpzcGFjZT1cXFwicHJlc2VydmVcXFwiPlxcbiAgICA8cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxMFxcXCIgc3Ryb2tlLWxpbmVjYXA9XFxcInJvdW5kXFxcIiBzdHJva2UtbGluZWpvaW49XFxcInJvdW5kXFxcIiBwb2ludHM9XFxcIjQ1LjYzLDc1LjggMC4zNzUsMzguMDg3IDQ1LjYzLDAuMzc1IFxcXCIvPlxcbiAgPC9zdmc+IFxcblwiO1xuc3ZnLmZ1bGxTY3JlZW5TVkcgPSBcIlxcbiA8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgd2lkdGg9XFxcIjE5XFxcIiBoZWlnaHQ9XFxcIjE5XFxcIiB2aWV3Qm94PVxcXCIwIDAgMTkgMTlcXFwiPlxcbiAgICA8ZyBmaWxsPVxcXCIjOTk5XFxcIiBmaWxsLXJ1bGU9XFxcIm5vbnplcm9cXFwiPlxcbiAgICAgICAgPHBhdGggZD1cXFwiTTE4LjgwMiAxLjk0MkExLjc0NiAxLjc0NiAwIDAgMCAxNy4wNi4yaC00LjUzN2EuOTkuOTkgMCAxIDAgMCAxLjk4aDQuMTAyYy4xMSAwIC4xOTguMDg4LjE5OC4xOTd2Mi41ODhhLjk5Ljk5IDAgMSAwIDEuOTggMFYxLjk0MnpNLjE5OCA0Ljk2NWEuOTkuOTkgMCAwIDAgMS45OCAwdi0yLjU5YS4xOTguMTk4IDAgMCAxIC4xOTctLjE5OWg0LjEwMmEuOTkuOTkgMCAwIDAgMC0xLjk3OUgxLjk0NEMuOTgzLjIuMjA0Ljk3OC4yMDIgMS45NEwuMTk4IDQuOTY1ek0xOC44MDIgMTcuMDU2di0zLjAyM2EuOTkuOTkgMCAxIDAtMS45OCAwdjIuNTkyYzAgLjExLS4wODguMTk4LS4xOTcuMTk4aC00LjEwMmEuOTkuOTkgMCAxIDAgMCAxLjk4aDQuNTMzYy45NjQtLjAwMSAxLjc0Ni0uNzgzIDEuNzQ2LTEuNzQ3ek0uMTk4IDE3LjA1NmExLjc0NiAxLjc0NiAwIDAgMCAxLjc0NiAxLjc0Mmg0LjUzM2EuOTkuOTkgMCAxIDAgMC0xLjk3OUgyLjM3NWEuMTk4LjE5OCAwIDAgMS0uMTk4LS4xOTR2LTIuNTkyYS45OS45OSAwIDEgMC0xLjk4IDB2My4wMjN6XFxcIi8+XFxuICAgICAgICA8cmVjdCB3aWR0aD1cXFwiMTAuNjUxXFxcIiBoZWlnaHQ9XFxcIjYuMTE3XFxcIiB4PVxcXCI0LjE3NFxcXCIgeT1cXFwiNi40NDFcXFwiIHJ4PVxcXCIxLjk1NFxcXCIvPlxcbiAgICA8L2c+XFxuPC9zdmc+XFxuXFxuXCI7XG5zdmcubG9vcFNWRyA9IFwiXFxuPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHdpZHRoPVxcXCIyNFxcXCIgaGVpZ2h0PVxcXCIyMlxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDIyXFxcIj5cXG4gICAgPGcgZmlsbD1cXFwiIzk5OVxcXCIgZmlsbC1ydWxlPVxcXCJub256ZXJvXFxcIj5cXG4gICAgICAgIDxwYXRoIGQ9XFxcIk0xNi43NzMgMTUuNDc2SDE2LjNhMS4yNSAxLjI1IDAgMCAwIDAgMi41aC40NzhhNi45NDQgNi45NDQgMCAwIDAgLjk4LTEzLjgyMy4yNTEuMjUxIDAgMCAxLS4yMDgtLjI0NlYxLjkzQTEuMjUgMS4yNSAwIDAgMCAxNS41ODQuOTA2bC00Ljc3OCAzLjM0MWExLjI1IDEuMjUgMCAwIDAgLjcxNyAyLjI3NGg0Ljc2NGMyLjgyOSAwIDQuOTYzIDEuOTI1IDQuOTYzIDQuNDc4YTQuNDgyIDQuNDgyIDAgMCAxLTQuNDc3IDQuNDc3ek02LjI0NyAxNy44NDVjLjEyLjAyLjIwOC4xMjQuMjA4LjI0NnYxLjk3NmExLjI0OSAxLjI0OSAwIDAgMCAxLjk2NiAxLjAyNGw0Ljc3My0zLjM0YTEuMjUxIDEuMjUxIDAgMCAwLS43MTctMi4yNzVINy43MTNjLTIuODI5IDAtNC45NjMtMS45MjUtNC45NjMtNC40NzZhNC40ODIgNC40ODIgMCAwIDEgNC40NzctNC40NzloLjQ3OGExLjI1IDEuMjUgMCAxIDAgMC0yLjVoLS40NzhhNi45NDUgNi45NDUgMCAwIDAtLjk4IDEzLjgyNHpcXFwiLz5cXG4gICAgPC9nPlxcbjwvc3ZnPlxcblwiO1xuc3ZnLmxvYWRpbmdTVkcgPSBcIjxzdmcgY2xhc3M9XFxcImxkcy1zcGlubmVyXFxcIiB3aWR0aD1cXFwiMjAwcHhcXFwiICBoZWlnaHQ9XFxcIjIwMHB4XFxcIiAgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB4bWxuczp4bGluaz1cXFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1xcXCIgdmlld0JveD1cXFwiMCAwIDEwMCAxMDBcXFwiIHByZXNlcnZlQXNwZWN0UmF0aW89XFxcInhNaWRZTWlkXFxcIiBzdHlsZT1cXFwiYmFja2dyb3VuZDogbm9uZTtcXFwiPjxnIHRyYW5zZm9ybT1cXFwicm90YXRlKDAgNTAgNTApXFxcIj5cXG4gIDxyZWN0IHg9XFxcIjQ3XFxcIiB5PVxcXCIyNFxcXCIgcng9XFxcIjkuNFxcXCIgcnk9XFxcIjQuOFxcXCIgd2lkdGg9XFxcIjZcXFwiIGhlaWdodD1cXFwiMTJcXFwiIGZpbGw9XFxcIiM5OTlcXFwiPlxcbiAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPVxcXCJvcGFjaXR5XFxcIiB2YWx1ZXM9XFxcIjE7MFxcXCIga2V5VGltZXM9XFxcIjA7MVxcXCIgZHVyPVxcXCIxc1xcXCIgYmVnaW49XFxcIi0wLjkxNjY2NjY2NjY2NjY2NjZzXFxcIiByZXBlYXRDb3VudD1cXFwiaW5kZWZpbml0ZVxcXCI+PC9hbmltYXRlPlxcbiAgPC9yZWN0PlxcbjwvZz48ZyB0cmFuc2Zvcm09XFxcInJvdGF0ZSgzMCA1MCA1MClcXFwiPlxcbiAgPHJlY3QgeD1cXFwiNDdcXFwiIHk9XFxcIjI0XFxcIiByeD1cXFwiOS40XFxcIiByeT1cXFwiNC44XFxcIiB3aWR0aD1cXFwiNlxcXCIgaGVpZ2h0PVxcXCIxMlxcXCIgZmlsbD1cXFwiIzk5OVxcXCI+XFxuICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9XFxcIm9wYWNpdHlcXFwiIHZhbHVlcz1cXFwiMTswXFxcIiBrZXlUaW1lcz1cXFwiMDsxXFxcIiBkdXI9XFxcIjFzXFxcIiBiZWdpbj1cXFwiLTAuODMzMzMzMzMzMzMzMzMzNHNcXFwiIHJlcGVhdENvdW50PVxcXCJpbmRlZmluaXRlXFxcIj48L2FuaW1hdGU+XFxuICA8L3JlY3Q+XFxuPC9nPjxnIHRyYW5zZm9ybT1cXFwicm90YXRlKDYwIDUwIDUwKVxcXCI+XFxuICA8cmVjdCB4PVxcXCI0N1xcXCIgeT1cXFwiMjRcXFwiIHJ4PVxcXCI5LjRcXFwiIHJ5PVxcXCI0LjhcXFwiIHdpZHRoPVxcXCI2XFxcIiBoZWlnaHQ9XFxcIjEyXFxcIiBmaWxsPVxcXCIjOTk5XFxcIj5cXG4gICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT1cXFwib3BhY2l0eVxcXCIgdmFsdWVzPVxcXCIxOzBcXFwiIGtleVRpbWVzPVxcXCIwOzFcXFwiIGR1cj1cXFwiMXNcXFwiIGJlZ2luPVxcXCItMC43NXNcXFwiIHJlcGVhdENvdW50PVxcXCJpbmRlZmluaXRlXFxcIj48L2FuaW1hdGU+XFxuICA8L3JlY3Q+XFxuPC9nPjxnIHRyYW5zZm9ybT1cXFwicm90YXRlKDkwIDUwIDUwKVxcXCI+XFxuICA8cmVjdCB4PVxcXCI0N1xcXCIgeT1cXFwiMjRcXFwiIHJ4PVxcXCI5LjRcXFwiIHJ5PVxcXCI0LjhcXFwiIHdpZHRoPVxcXCI2XFxcIiBoZWlnaHQ9XFxcIjEyXFxcIiBmaWxsPVxcXCIjOTk5XFxcIj5cXG4gICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT1cXFwib3BhY2l0eVxcXCIgdmFsdWVzPVxcXCIxOzBcXFwiIGtleVRpbWVzPVxcXCIwOzFcXFwiIGR1cj1cXFwiMXNcXFwiIGJlZ2luPVxcXCItMC42NjY2NjY2NjY2NjY2NjY2c1xcXCIgcmVwZWF0Q291bnQ9XFxcImluZGVmaW5pdGVcXFwiPjwvYW5pbWF0ZT5cXG4gIDwvcmVjdD5cXG48L2c+PGcgdHJhbnNmb3JtPVxcXCJyb3RhdGUoMTIwIDUwIDUwKVxcXCI+XFxuICA8cmVjdCB4PVxcXCI0N1xcXCIgeT1cXFwiMjRcXFwiIHJ4PVxcXCI5LjRcXFwiIHJ5PVxcXCI0LjhcXFwiIHdpZHRoPVxcXCI2XFxcIiBoZWlnaHQ9XFxcIjEyXFxcIiBmaWxsPVxcXCIjOTk5XFxcIj5cXG4gICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT1cXFwib3BhY2l0eVxcXCIgdmFsdWVzPVxcXCIxOzBcXFwiIGtleVRpbWVzPVxcXCIwOzFcXFwiIGR1cj1cXFwiMXNcXFwiIGJlZ2luPVxcXCItMC41ODMzMzMzMzMzMzMzMzM0c1xcXCIgcmVwZWF0Q291bnQ9XFxcImluZGVmaW5pdGVcXFwiPjwvYW5pbWF0ZT5cXG4gIDwvcmVjdD5cXG48L2c+PGcgdHJhbnNmb3JtPVxcXCJyb3RhdGUoMTUwIDUwIDUwKVxcXCI+XFxuICA8cmVjdCB4PVxcXCI0N1xcXCIgeT1cXFwiMjRcXFwiIHJ4PVxcXCI5LjRcXFwiIHJ5PVxcXCI0LjhcXFwiIHdpZHRoPVxcXCI2XFxcIiBoZWlnaHQ9XFxcIjEyXFxcIiBmaWxsPVxcXCIjOTk5XFxcIj5cXG4gICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT1cXFwib3BhY2l0eVxcXCIgdmFsdWVzPVxcXCIxOzBcXFwiIGtleVRpbWVzPVxcXCIwOzFcXFwiIGR1cj1cXFwiMXNcXFwiIGJlZ2luPVxcXCItMC41c1xcXCIgcmVwZWF0Q291bnQ9XFxcImluZGVmaW5pdGVcXFwiPjwvYW5pbWF0ZT5cXG4gIDwvcmVjdD5cXG48L2c+PGcgdHJhbnNmb3JtPVxcXCJyb3RhdGUoMTgwIDUwIDUwKVxcXCI+XFxuICA8cmVjdCB4PVxcXCI0N1xcXCIgeT1cXFwiMjRcXFwiIHJ4PVxcXCI5LjRcXFwiIHJ5PVxcXCI0LjhcXFwiIHdpZHRoPVxcXCI2XFxcIiBoZWlnaHQ9XFxcIjEyXFxcIiBmaWxsPVxcXCIjOTk5XFxcIj5cXG4gICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT1cXFwib3BhY2l0eVxcXCIgdmFsdWVzPVxcXCIxOzBcXFwiIGtleVRpbWVzPVxcXCIwOzFcXFwiIGR1cj1cXFwiMXNcXFwiIGJlZ2luPVxcXCItMC40MTY2NjY2NjY2NjY2NjY3c1xcXCIgcmVwZWF0Q291bnQ9XFxcImluZGVmaW5pdGVcXFwiPjwvYW5pbWF0ZT5cXG4gIDwvcmVjdD5cXG48L2c+PGcgdHJhbnNmb3JtPVxcXCJyb3RhdGUoMjEwIDUwIDUwKVxcXCI+XFxuICA8cmVjdCB4PVxcXCI0N1xcXCIgeT1cXFwiMjRcXFwiIHJ4PVxcXCI5LjRcXFwiIHJ5PVxcXCI0LjhcXFwiIHdpZHRoPVxcXCI2XFxcIiBoZWlnaHQ9XFxcIjEyXFxcIiBmaWxsPVxcXCIjOTk5XFxcIj5cXG4gICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT1cXFwib3BhY2l0eVxcXCIgdmFsdWVzPVxcXCIxOzBcXFwiIGtleVRpbWVzPVxcXCIwOzFcXFwiIGR1cj1cXFwiMXNcXFwiIGJlZ2luPVxcXCItMC4zMzMzMzMzMzMzMzMzMzMzc1xcXCIgcmVwZWF0Q291bnQ9XFxcImluZGVmaW5pdGVcXFwiPjwvYW5pbWF0ZT5cXG4gIDwvcmVjdD5cXG48L2c+PGcgdHJhbnNmb3JtPVxcXCJyb3RhdGUoMjQwIDUwIDUwKVxcXCI+XFxuICA8cmVjdCB4PVxcXCI0N1xcXCIgeT1cXFwiMjRcXFwiIHJ4PVxcXCI5LjRcXFwiIHJ5PVxcXCI0LjhcXFwiIHdpZHRoPVxcXCI2XFxcIiBoZWlnaHQ9XFxcIjEyXFxcIiBmaWxsPVxcXCIjOTk5XFxcIj5cXG4gICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT1cXFwib3BhY2l0eVxcXCIgdmFsdWVzPVxcXCIxOzBcXFwiIGtleVRpbWVzPVxcXCIwOzFcXFwiIGR1cj1cXFwiMXNcXFwiIGJlZ2luPVxcXCItMC4yNXNcXFwiIHJlcGVhdENvdW50PVxcXCJpbmRlZmluaXRlXFxcIj48L2FuaW1hdGU+XFxuICA8L3JlY3Q+XFxuPC9nPjxnIHRyYW5zZm9ybT1cXFwicm90YXRlKDI3MCA1MCA1MClcXFwiPlxcbiAgPHJlY3QgeD1cXFwiNDdcXFwiIHk9XFxcIjI0XFxcIiByeD1cXFwiOS40XFxcIiByeT1cXFwiNC44XFxcIiB3aWR0aD1cXFwiNlxcXCIgaGVpZ2h0PVxcXCIxMlxcXCIgZmlsbD1cXFwiIzk5OVxcXCI+XFxuICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9XFxcIm9wYWNpdHlcXFwiIHZhbHVlcz1cXFwiMTswXFxcIiBrZXlUaW1lcz1cXFwiMDsxXFxcIiBkdXI9XFxcIjFzXFxcIiBiZWdpbj1cXFwiLTAuMTY2NjY2NjY2NjY2NjY2NjZzXFxcIiByZXBlYXRDb3VudD1cXFwiaW5kZWZpbml0ZVxcXCI+PC9hbmltYXRlPlxcbiAgPC9yZWN0PlxcbjwvZz48ZyB0cmFuc2Zvcm09XFxcInJvdGF0ZSgzMDAgNTAgNTApXFxcIj5cXG4gIDxyZWN0IHg9XFxcIjQ3XFxcIiB5PVxcXCIyNFxcXCIgcng9XFxcIjkuNFxcXCIgcnk9XFxcIjQuOFxcXCIgd2lkdGg9XFxcIjZcXFwiIGhlaWdodD1cXFwiMTJcXFwiIGZpbGw9XFxcIiM5OTlcXFwiPlxcbiAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPVxcXCJvcGFjaXR5XFxcIiB2YWx1ZXM9XFxcIjE7MFxcXCIga2V5VGltZXM9XFxcIjA7MVxcXCIgZHVyPVxcXCIxc1xcXCIgYmVnaW49XFxcIi0wLjA4MzMzMzMzMzMzMzMzMzMzc1xcXCIgcmVwZWF0Q291bnQ9XFxcImluZGVmaW5pdGVcXFwiPjwvYW5pbWF0ZT5cXG4gIDwvcmVjdD5cXG48L2c+PGcgdHJhbnNmb3JtPVxcXCJyb3RhdGUoMzMwIDUwIDUwKVxcXCI+XFxuICA8cmVjdCB4PVxcXCI0N1xcXCIgeT1cXFwiMjRcXFwiIHJ4PVxcXCI5LjRcXFwiIHJ5PVxcXCI0LjhcXFwiIHdpZHRoPVxcXCI2XFxcIiBoZWlnaHQ9XFxcIjEyXFxcIiBmaWxsPVxcXCIjOTk5XFxcIj5cXG4gICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT1cXFwib3BhY2l0eVxcXCIgdmFsdWVzPVxcXCIxOzBcXFwiIGtleVRpbWVzPVxcXCIwOzFcXFwiIGR1cj1cXFwiMXNcXFwiIGJlZ2luPVxcXCIwc1xcXCIgcmVwZWF0Q291bnQ9XFxcImluZGVmaW5pdGVcXFwiPjwvYW5pbWF0ZT5cXG4gIDwvcmVjdD5cXG48L2c+PC9zdmc+XCI7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex-player/dist/html/svg.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex-player/dist/html/themes.js":
/*!****************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex-player/dist/html/themes.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function (theme, name) {\n  var themes = {\n    default: {\n      \"settings-background-color\": \"whitesmoke\",\n      \"hms-background-color\": \"whitesmoke\",\n      \"background-color\": \"whitesmoke\",\n      \"grad-height\": \"0px\",\n      color: \"black\",\n      \"svg-color\": \"black\",\n      \"loopbar-color\": \"#808086\",\n      \"speedbar-color\": \"#999\",\n      \"runningbar-color\": \"red\",\n      \"cursor-color\": \"red\",\n      \"speedbar-cursor-color\": \"red\",\n      \"button-opacity\": \"1\",\n      \"hover-color\": \"rgba(200, 200, 200, 0.5)\",\n      \"slider-off-color\": \"#ccc\",\n      \"slider-on-color\": \"red\",\n      \"preview-border\": \"1px solid rgba(0,0,0,1)\",\n      border: \"1px solid rgba(255,255,255,0.2)\",\n      \"controls-border\": \"none\",\n      \"svg-selected-color\": \"red\",\n      \"loopbar-boundaries-style::before\": \"\",\n      \"loopbar-boundaries-style::after\": \"\",\n      \"theme-style\": \"\",\n      \"loopbar-boundaries-color\": \"#808086\"\n    },\n    dark: {\n      \"settings-background-color\": \"black\",\n      \"hms-background-color\": \"black\",\n      \"background-color\": \"black\",\n      \"grad-height\": \"0px\",\n      color: \"white\",\n      \"svg-color\": \"white\",\n      \"loopbar-color\": \"#808086\",\n      \"speedbar-color\": \"#999\",\n      \"runningbar-color\": \"red\",\n      \"cursor-color\": \"red\",\n      \"speedbar-cursor-color\": \"red\",\n      \"button-opacity\": \"1\",\n      \"hover-color\": \"rgba(90, 90, 90, 0.5)\",\n      \"slider-off-color\": \"#ccc\",\n      \"slider-on-color\": \"red\",\n      \"preview-border\": \"1px solid rgba(0,0,0,1)\",\n      border: \"1px solid rgba(255,255,255,0.2)\",\n      \"controls-border\": \"none\",\n      \"svg-selected-color\": \"red\",\n      \"loopbar-boundaries-style::before\": \"\",\n      \"loopbar-boundaries-style::after\": \"\",\n      \"theme-style\": \"\",\n      \"loopbar-boundaries-color\": \"#808086\"\n    },\n    whiteGold: {\n      \"settings-background-color\": \"white\",\n      \"hms-background-color\": \"white\",\n      \"background-color\": \"white\",\n      \"grad-height\": \"0px\",\n      color: \"#a17f1a\",\n      \"svg-color\": \"#a17f1a\",\n      \"loopbar-color\": \"#808086\",\n      \"speedbar-color\": \"#999\",\n      \"runningbar-color\": \"#a17f1a\",\n      \"cursor-color\": \"#a17f1a\",\n      \"speedbar-cursor-color\": \"#a17f1a\",\n      \"button-opacity\": \"1\",\n      \"hover-color\": \"rgba(200, 200, 200, 0.5)\",\n      \"slider-off-color\": \"#ccc\",\n      \"slider-on-color\": \"#a17f1a\",\n      \"preview-border\": \"1px solid rgba(0,0,0,1)\",\n      border: \"1px solid rgba(255,255,255,0.2)\",\n      \"controls-border\": \"none\",\n      \"svg-selected-color\": \"red\",\n      \"loopbar-boundaries-style::before\": \"\",\n      \"loopbar-boundaries-style::after\": \"\",\n      \"theme-style\": \"\",\n      \"loopbar-boundaries-color\": \"#808086\"\n    },\n    darkGold: {\n      \"settings-background-color\": \"black\",\n      \"hms-background-color\": \"black\",\n      \"background-color\": \"black\",\n      \"grad-height\": \"0px\",\n      color: \"#a17f1a\",\n      \"svg-color\": \"#a17f1a\",\n      \"loopbar-color\": \"#808086\",\n      \"speedbar-color\": \"#999\",\n      \"runningbar-color\": \"#a17f1a\",\n      \"cursor-color\": \"#a17f1a\",\n      \"speedbar-cursor-color\": \"#a17f1a\",\n      \"button-opacity\": \"1\",\n      \"hover-color\": \"rgba(90, 90, 90, 0.5)\",\n      \"slider-off-color\": \"#ccc\",\n      \"slider-on-color\": \"#a17f1a\",\n      \"preview-border\": \"1px solid rgba(0,0,0,1)\",\n      border: \"1px solid rgba(255,255,255,0.2)\",\n      \"controls-border\": \"none\",\n      \"svg-selected-color\": \"red\",\n      \"loopbar-boundaries-style::before\": \"\",\n      \"loopbar-boundaries-style::after\": \"\",\n      \"theme-style\": \"\",\n      \"loopbar-boundaries-color\": \"#808086\"\n    },\n    transparent: {\n      \"background-color\": \"transparent\",\n      \"settings-background-color\": \"rgba(0,0,0,0.5)\",\n      \"hms-background-color\": \"rgba(0,0,0,0.5)\",\n      \"preview-border\": \"1px solid rgba(0,0,0,1)\",\n      color: \"white\",\n      \"grad-height\": \"60px\",\n      \"svg-color\": \"white\",\n      \"loopbar-color\": \"#808086\",\n      \"speedbar-color\": \"#999\",\n      \"runningbar-color\": \"red\",\n      \"cursor-color\": \"red\",\n      \"speedbar-cursor-color\": \"red\",\n      \"button-opacity\": \"1\",\n      \"hover-color\": \"rgba(200, 200, 200, 0.5)\",\n      \"slider-off-color\": \"#ccc\",\n      \"slider-on-color\": \"red\",\n      border: \"1px solid rgba(255,255,255,0.1)\",\n      \"controls-border\": \"1px solid rgba(255,255,255,0.1)\",\n      \"svg-selected-color\": \"red\",\n      \"loopbar-boundaries-style::before\": \"\",\n      \"loopbar-boundaries-style::after\": \"\",\n      \"theme-style\": \"\",\n      \"loopbar-boundaries-color\": \"#808086\"\n    },\n    \"mc-green\": {\n      \"background-color\": \"#141416\",\n      \"settings-background-color\": \"rgba(0,0,0,0.5)\",\n      \"hms-background-color\": \"rgba(0,0,0,0.5)\",\n      \"preview-border\": \"1px solid rgba(0,0,0,1)\",\n      color: \"#999\",\n      \"grad-height\": \"60px\",\n      \"svg-color\": \"#999\",\n      \"loopbar-color\": \"rgba(0,184,139,0.2)\",\n      \"loopbar-boundaries-color\": \"#00b88b\",\n      \"totalbar-color\": \"rgba(255, 255, 255, 0.11)\",\n      \"speedbar-color\": \"#999\",\n      \"runningbar-color\": \"#00b88b\",\n      \"cursor-color\": \"#00b88b\",\n      \"speedbar-cursor-color\": \"#00b88b\",\n      \"button-opacity\": \"1\",\n      \"hover-color\": \"rgba(0,184,139,0.2)\",\n      \"slider-off-color\": \"#ccc\",\n      \"slider-on-color\": \"#00b88b\",\n      border: \"1px solid rgba(255,255,255,0.1)\",\n      \"controls-border\": \"1px solid #151515\",\n      \"svg-selected-color\": \"#00b88b\",\n      \"loopbar-boundaries-style\": \"\\n        transform: translate(-50%,-37%);\\n        position: absolute;\\n        width: 18px;\\n        background-color: #00b88b;\\n        height: 18px;\\n        border-radius: 10px;\\n        z-index: 40;\\n        position: absolute;\\n        width: 18px;\\n        background-color: #00b88b;\\n        height: 18px;\\n        border-radius: 10px;\\n        z-index: 40;\\n        width: 18px;\\n        height: 9px;\\n        border-radius: 100%;\\n        top: 1.5px;\\n    \",\n      \"loopbar-boundaries-style::before\": \"\\n            width: 16px;\\n        height: 5px;\\n        background: #00b88b;\\n        border-radius: 100%;\\n        display: block;\\n        content: \\\"\\\";\\n        position: relative;\\n        left: -2px;\\n        top: 2px;\\n    \",\n      \"loopbar-boundaries-style::after\": \"\\n        width: 14px;\\n        height: 11px;\\n        border-radius: 100%;\\n        background: #00b88b;\\n        content: \\\"\\\";\\n        display: block;\\n        position: relative;\\n        top: -6px;\\n        left: 5px;\\n    \",\n      \"theme-style\": \"\\n        #\".concat(name, \"-loopbar-start {\\n            left: -9px !important;\\n            transform: rotate(180deg);\\n            top: -2px;\\n        }\\n    \")\n    },\n    \"mc-blue\": {\n      \"background-color\": \"#141416\",\n      \"settings-background-color\": \"rgba(0,0,0,0.5)\",\n      \"hms-background-color\": \"rgba(0,0,0,0.5)\",\n      \"preview-border\": \"1px solid rgba(0,0,0,1)\",\n      color: \"#999\",\n      \"grad-height\": \"60px\",\n      \"svg-color\": \"#999\",\n      \"loopbar-color\": \"rgba(0,153,225,0.2)\",\n      \"loopbar-boundaries-color\": \"#0099e1\",\n      \"totalbar-color\": \"rgba(255, 255, 255, 0.11)\",\n      \"speedbar-color\": \"#999\",\n      \"runningbar-color\": \"#0099e1\",\n      \"cursor-color\": \"#0099e1\",\n      \"speedbar-cursor-color\": \"#0099e1\",\n      \"button-opacity\": \"1\",\n      \"hover-color\": \"rgba(0,153,225,0.2)\",\n      \"slider-off-color\": \"#ccc\",\n      \"slider-on-color\": \"#0099e1\",\n      border: \"1px solid rgba(255,255,255,0.1)\",\n      \"controls-border\": \"1px solid #151515\",\n      \"svg-selected-color\": \"#0099e1\",\n      \"loopbar-boundaries-style\": \"\\n        transform: translate(-50%,-37%);\\n        position: absolute;\\n        width: 18px;\\n        background-color: #0099e1;\\n        height: 18px;\\n        border-radius: 10px;\\n        z-index: 40;\\n        position: absolute;\\n        width: 18px;\\n        background-color: #0099e1;\\n        height: 18px;\\n        border-radius: 10px;\\n        z-index: 40;\\n        width: 18px;\\n        height: 9px;\\n        border-radius: 100%;\\n        top: 1.5px;\\n    \",\n      \"loopbar-boundaries-style::before\": \"\\n            width: 16px;\\n        height: 5px;\\n        background: #0099e1;\\n        border-radius: 100%;\\n        display: block;\\n        content: \\\"\\\";\\n        position: relative;\\n        left: -2px;\\n        top: 2px;\\n    \",\n      \"loopbar-boundaries-style::after\": \"\\n        width: 14px;\\n        height: 11px;\\n        border-radius: 100%;\\n        background: #0099e1;\\n        content: \\\"\\\";\\n        display: block;\\n        position: relative;\\n        top: -6px;\\n        left: 5px;\\n    \",\n      \"theme-style\": \"\\n        #\".concat(name, \"-loopbar-start {\\n            left: -9px !important;\\n            transform: rotate(180deg);\\n            top: -2px;\\n        }\\n    \")\n    },\n    \"on-top\": {\n      \"background-height\": \"100%\",\n      \"pointer-event-panel-height\": \"calc(100% - 44px)\",\n      \"controls-bottom\": \"0px\",\n      \"settings-panel-bottom\": \"48px\",\n      \"controls-position\": \"0px\"\n    },\n    \"position-default\": {\n      \"background-height\": \"calc(100% - 44px)\",\n      \"pointer-event-panel-height\": \"calc(100% - 44px)\",\n      \"controls-bottom\": \"-0px\",\n      \"settings-panel-bottom\": \"48px\",\n      \"controls-position\": \"40px\"\n    }\n  };\n  return themes[theme];\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgtcGxheWVyL2Rpc3QvaHRtbC90aGVtZXMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgtcGxheWVyL2Rpc3QvaHRtbC90aGVtZXMuanM/MjhhOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGhlbWUsIG5hbWUpIHtcbiAgdmFyIHRoZW1lcyA9IHtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBcInNldHRpbmdzLWJhY2tncm91bmQtY29sb3JcIjogXCJ3aGl0ZXNtb2tlXCIsXG4gICAgICBcImhtcy1iYWNrZ3JvdW5kLWNvbG9yXCI6IFwid2hpdGVzbW9rZVwiLFxuICAgICAgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IFwid2hpdGVzbW9rZVwiLFxuICAgICAgXCJncmFkLWhlaWdodFwiOiBcIjBweFwiLFxuICAgICAgY29sb3I6IFwiYmxhY2tcIixcbiAgICAgIFwic3ZnLWNvbG9yXCI6IFwiYmxhY2tcIixcbiAgICAgIFwibG9vcGJhci1jb2xvclwiOiBcIiM4MDgwODZcIixcbiAgICAgIFwic3BlZWRiYXItY29sb3JcIjogXCIjOTk5XCIsXG4gICAgICBcInJ1bm5pbmdiYXItY29sb3JcIjogXCJyZWRcIixcbiAgICAgIFwiY3Vyc29yLWNvbG9yXCI6IFwicmVkXCIsXG4gICAgICBcInNwZWVkYmFyLWN1cnNvci1jb2xvclwiOiBcInJlZFwiLFxuICAgICAgXCJidXR0b24tb3BhY2l0eVwiOiBcIjFcIixcbiAgICAgIFwiaG92ZXItY29sb3JcIjogXCJyZ2JhKDIwMCwgMjAwLCAyMDAsIDAuNSlcIixcbiAgICAgIFwic2xpZGVyLW9mZi1jb2xvclwiOiBcIiNjY2NcIixcbiAgICAgIFwic2xpZGVyLW9uLWNvbG9yXCI6IFwicmVkXCIsXG4gICAgICBcInByZXZpZXctYm9yZGVyXCI6IFwiMXB4IHNvbGlkIHJnYmEoMCwwLDAsMSlcIixcbiAgICAgIGJvcmRlcjogXCIxcHggc29saWQgcmdiYSgyNTUsMjU1LDI1NSwwLjIpXCIsXG4gICAgICBcImNvbnRyb2xzLWJvcmRlclwiOiBcIm5vbmVcIixcbiAgICAgIFwic3ZnLXNlbGVjdGVkLWNvbG9yXCI6IFwicmVkXCIsXG4gICAgICBcImxvb3BiYXItYm91bmRhcmllcy1zdHlsZTo6YmVmb3JlXCI6IFwiXCIsXG4gICAgICBcImxvb3BiYXItYm91bmRhcmllcy1zdHlsZTo6YWZ0ZXJcIjogXCJcIixcbiAgICAgIFwidGhlbWUtc3R5bGVcIjogXCJcIixcbiAgICAgIFwibG9vcGJhci1ib3VuZGFyaWVzLWNvbG9yXCI6IFwiIzgwODA4NlwiXG4gICAgfSxcbiAgICBkYXJrOiB7XG4gICAgICBcInNldHRpbmdzLWJhY2tncm91bmQtY29sb3JcIjogXCJibGFja1wiLFxuICAgICAgXCJobXMtYmFja2dyb3VuZC1jb2xvclwiOiBcImJsYWNrXCIsXG4gICAgICBcImJhY2tncm91bmQtY29sb3JcIjogXCJibGFja1wiLFxuICAgICAgXCJncmFkLWhlaWdodFwiOiBcIjBweFwiLFxuICAgICAgY29sb3I6IFwid2hpdGVcIixcbiAgICAgIFwic3ZnLWNvbG9yXCI6IFwid2hpdGVcIixcbiAgICAgIFwibG9vcGJhci1jb2xvclwiOiBcIiM4MDgwODZcIixcbiAgICAgIFwic3BlZWRiYXItY29sb3JcIjogXCIjOTk5XCIsXG4gICAgICBcInJ1bm5pbmdiYXItY29sb3JcIjogXCJyZWRcIixcbiAgICAgIFwiY3Vyc29yLWNvbG9yXCI6IFwicmVkXCIsXG4gICAgICBcInNwZWVkYmFyLWN1cnNvci1jb2xvclwiOiBcInJlZFwiLFxuICAgICAgXCJidXR0b24tb3BhY2l0eVwiOiBcIjFcIixcbiAgICAgIFwiaG92ZXItY29sb3JcIjogXCJyZ2JhKDkwLCA5MCwgOTAsIDAuNSlcIixcbiAgICAgIFwic2xpZGVyLW9mZi1jb2xvclwiOiBcIiNjY2NcIixcbiAgICAgIFwic2xpZGVyLW9uLWNvbG9yXCI6IFwicmVkXCIsXG4gICAgICBcInByZXZpZXctYm9yZGVyXCI6IFwiMXB4IHNvbGlkIHJnYmEoMCwwLDAsMSlcIixcbiAgICAgIGJvcmRlcjogXCIxcHggc29saWQgcmdiYSgyNTUsMjU1LDI1NSwwLjIpXCIsXG4gICAgICBcImNvbnRyb2xzLWJvcmRlclwiOiBcIm5vbmVcIixcbiAgICAgIFwic3ZnLXNlbGVjdGVkLWNvbG9yXCI6IFwicmVkXCIsXG4gICAgICBcImxvb3BiYXItYm91bmRhcmllcy1zdHlsZTo6YmVmb3JlXCI6IFwiXCIsXG4gICAgICBcImxvb3BiYXItYm91bmRhcmllcy1zdHlsZTo6YWZ0ZXJcIjogXCJcIixcbiAgICAgIFwidGhlbWUtc3R5bGVcIjogXCJcIixcbiAgICAgIFwibG9vcGJhci1ib3VuZGFyaWVzLWNvbG9yXCI6IFwiIzgwODA4NlwiXG4gICAgfSxcbiAgICB3aGl0ZUdvbGQ6IHtcbiAgICAgIFwic2V0dGluZ3MtYmFja2dyb3VuZC1jb2xvclwiOiBcIndoaXRlXCIsXG4gICAgICBcImhtcy1iYWNrZ3JvdW5kLWNvbG9yXCI6IFwid2hpdGVcIixcbiAgICAgIFwiYmFja2dyb3VuZC1jb2xvclwiOiBcIndoaXRlXCIsXG4gICAgICBcImdyYWQtaGVpZ2h0XCI6IFwiMHB4XCIsXG4gICAgICBjb2xvcjogXCIjYTE3ZjFhXCIsXG4gICAgICBcInN2Zy1jb2xvclwiOiBcIiNhMTdmMWFcIixcbiAgICAgIFwibG9vcGJhci1jb2xvclwiOiBcIiM4MDgwODZcIixcbiAgICAgIFwic3BlZWRiYXItY29sb3JcIjogXCIjOTk5XCIsXG4gICAgICBcInJ1bm5pbmdiYXItY29sb3JcIjogXCIjYTE3ZjFhXCIsXG4gICAgICBcImN1cnNvci1jb2xvclwiOiBcIiNhMTdmMWFcIixcbiAgICAgIFwic3BlZWRiYXItY3Vyc29yLWNvbG9yXCI6IFwiI2ExN2YxYVwiLFxuICAgICAgXCJidXR0b24tb3BhY2l0eVwiOiBcIjFcIixcbiAgICAgIFwiaG92ZXItY29sb3JcIjogXCJyZ2JhKDIwMCwgMjAwLCAyMDAsIDAuNSlcIixcbiAgICAgIFwic2xpZGVyLW9mZi1jb2xvclwiOiBcIiNjY2NcIixcbiAgICAgIFwic2xpZGVyLW9uLWNvbG9yXCI6IFwiI2ExN2YxYVwiLFxuICAgICAgXCJwcmV2aWV3LWJvcmRlclwiOiBcIjFweCBzb2xpZCByZ2JhKDAsMCwwLDEpXCIsXG4gICAgICBib3JkZXI6IFwiMXB4IHNvbGlkIHJnYmEoMjU1LDI1NSwyNTUsMC4yKVwiLFxuICAgICAgXCJjb250cm9scy1ib3JkZXJcIjogXCJub25lXCIsXG4gICAgICBcInN2Zy1zZWxlY3RlZC1jb2xvclwiOiBcInJlZFwiLFxuICAgICAgXCJsb29wYmFyLWJvdW5kYXJpZXMtc3R5bGU6OmJlZm9yZVwiOiBcIlwiLFxuICAgICAgXCJsb29wYmFyLWJvdW5kYXJpZXMtc3R5bGU6OmFmdGVyXCI6IFwiXCIsXG4gICAgICBcInRoZW1lLXN0eWxlXCI6IFwiXCIsXG4gICAgICBcImxvb3BiYXItYm91bmRhcmllcy1jb2xvclwiOiBcIiM4MDgwODZcIlxuICAgIH0sXG4gICAgZGFya0dvbGQ6IHtcbiAgICAgIFwic2V0dGluZ3MtYmFja2dyb3VuZC1jb2xvclwiOiBcImJsYWNrXCIsXG4gICAgICBcImhtcy1iYWNrZ3JvdW5kLWNvbG9yXCI6IFwiYmxhY2tcIixcbiAgICAgIFwiYmFja2dyb3VuZC1jb2xvclwiOiBcImJsYWNrXCIsXG4gICAgICBcImdyYWQtaGVpZ2h0XCI6IFwiMHB4XCIsXG4gICAgICBjb2xvcjogXCIjYTE3ZjFhXCIsXG4gICAgICBcInN2Zy1jb2xvclwiOiBcIiNhMTdmMWFcIixcbiAgICAgIFwibG9vcGJhci1jb2xvclwiOiBcIiM4MDgwODZcIixcbiAgICAgIFwic3BlZWRiYXItY29sb3JcIjogXCIjOTk5XCIsXG4gICAgICBcInJ1bm5pbmdiYXItY29sb3JcIjogXCIjYTE3ZjFhXCIsXG4gICAgICBcImN1cnNvci1jb2xvclwiOiBcIiNhMTdmMWFcIixcbiAgICAgIFwic3BlZWRiYXItY3Vyc29yLWNvbG9yXCI6IFwiI2ExN2YxYVwiLFxuICAgICAgXCJidXR0b24tb3BhY2l0eVwiOiBcIjFcIixcbiAgICAgIFwiaG92ZXItY29sb3JcIjogXCJyZ2JhKDkwLCA5MCwgOTAsIDAuNSlcIixcbiAgICAgIFwic2xpZGVyLW9mZi1jb2xvclwiOiBcIiNjY2NcIixcbiAgICAgIFwic2xpZGVyLW9uLWNvbG9yXCI6IFwiI2ExN2YxYVwiLFxuICAgICAgXCJwcmV2aWV3LWJvcmRlclwiOiBcIjFweCBzb2xpZCByZ2JhKDAsMCwwLDEpXCIsXG4gICAgICBib3JkZXI6IFwiMXB4IHNvbGlkIHJnYmEoMjU1LDI1NSwyNTUsMC4yKVwiLFxuICAgICAgXCJjb250cm9scy1ib3JkZXJcIjogXCJub25lXCIsXG4gICAgICBcInN2Zy1zZWxlY3RlZC1jb2xvclwiOiBcInJlZFwiLFxuICAgICAgXCJsb29wYmFyLWJvdW5kYXJpZXMtc3R5bGU6OmJlZm9yZVwiOiBcIlwiLFxuICAgICAgXCJsb29wYmFyLWJvdW5kYXJpZXMtc3R5bGU6OmFmdGVyXCI6IFwiXCIsXG4gICAgICBcInRoZW1lLXN0eWxlXCI6IFwiXCIsXG4gICAgICBcImxvb3BiYXItYm91bmRhcmllcy1jb2xvclwiOiBcIiM4MDgwODZcIlxuICAgIH0sXG4gICAgdHJhbnNwYXJlbnQ6IHtcbiAgICAgIFwiYmFja2dyb3VuZC1jb2xvclwiOiBcInRyYW5zcGFyZW50XCIsXG4gICAgICBcInNldHRpbmdzLWJhY2tncm91bmQtY29sb3JcIjogXCJyZ2JhKDAsMCwwLDAuNSlcIixcbiAgICAgIFwiaG1zLWJhY2tncm91bmQtY29sb3JcIjogXCJyZ2JhKDAsMCwwLDAuNSlcIixcbiAgICAgIFwicHJldmlldy1ib3JkZXJcIjogXCIxcHggc29saWQgcmdiYSgwLDAsMCwxKVwiLFxuICAgICAgY29sb3I6IFwid2hpdGVcIixcbiAgICAgIFwiZ3JhZC1oZWlnaHRcIjogXCI2MHB4XCIsXG4gICAgICBcInN2Zy1jb2xvclwiOiBcIndoaXRlXCIsXG4gICAgICBcImxvb3BiYXItY29sb3JcIjogXCIjODA4MDg2XCIsXG4gICAgICBcInNwZWVkYmFyLWNvbG9yXCI6IFwiIzk5OVwiLFxuICAgICAgXCJydW5uaW5nYmFyLWNvbG9yXCI6IFwicmVkXCIsXG4gICAgICBcImN1cnNvci1jb2xvclwiOiBcInJlZFwiLFxuICAgICAgXCJzcGVlZGJhci1jdXJzb3ItY29sb3JcIjogXCJyZWRcIixcbiAgICAgIFwiYnV0dG9uLW9wYWNpdHlcIjogXCIxXCIsXG4gICAgICBcImhvdmVyLWNvbG9yXCI6IFwicmdiYSgyMDAsIDIwMCwgMjAwLCAwLjUpXCIsXG4gICAgICBcInNsaWRlci1vZmYtY29sb3JcIjogXCIjY2NjXCIsXG4gICAgICBcInNsaWRlci1vbi1jb2xvclwiOiBcInJlZFwiLFxuICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCByZ2JhKDI1NSwyNTUsMjU1LDAuMSlcIixcbiAgICAgIFwiY29udHJvbHMtYm9yZGVyXCI6IFwiMXB4IHNvbGlkIHJnYmEoMjU1LDI1NSwyNTUsMC4xKVwiLFxuICAgICAgXCJzdmctc2VsZWN0ZWQtY29sb3JcIjogXCJyZWRcIixcbiAgICAgIFwibG9vcGJhci1ib3VuZGFyaWVzLXN0eWxlOjpiZWZvcmVcIjogXCJcIixcbiAgICAgIFwibG9vcGJhci1ib3VuZGFyaWVzLXN0eWxlOjphZnRlclwiOiBcIlwiLFxuICAgICAgXCJ0aGVtZS1zdHlsZVwiOiBcIlwiLFxuICAgICAgXCJsb29wYmFyLWJvdW5kYXJpZXMtY29sb3JcIjogXCIjODA4MDg2XCJcbiAgICB9LFxuICAgIFwibWMtZ3JlZW5cIjoge1xuICAgICAgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IFwiIzE0MTQxNlwiLFxuICAgICAgXCJzZXR0aW5ncy1iYWNrZ3JvdW5kLWNvbG9yXCI6IFwicmdiYSgwLDAsMCwwLjUpXCIsXG4gICAgICBcImhtcy1iYWNrZ3JvdW5kLWNvbG9yXCI6IFwicmdiYSgwLDAsMCwwLjUpXCIsXG4gICAgICBcInByZXZpZXctYm9yZGVyXCI6IFwiMXB4IHNvbGlkIHJnYmEoMCwwLDAsMSlcIixcbiAgICAgIGNvbG9yOiBcIiM5OTlcIixcbiAgICAgIFwiZ3JhZC1oZWlnaHRcIjogXCI2MHB4XCIsXG4gICAgICBcInN2Zy1jb2xvclwiOiBcIiM5OTlcIixcbiAgICAgIFwibG9vcGJhci1jb2xvclwiOiBcInJnYmEoMCwxODQsMTM5LDAuMilcIixcbiAgICAgIFwibG9vcGJhci1ib3VuZGFyaWVzLWNvbG9yXCI6IFwiIzAwYjg4YlwiLFxuICAgICAgXCJ0b3RhbGJhci1jb2xvclwiOiBcInJnYmEoMjU1LCAyNTUsIDI1NSwgMC4xMSlcIixcbiAgICAgIFwic3BlZWRiYXItY29sb3JcIjogXCIjOTk5XCIsXG4gICAgICBcInJ1bm5pbmdiYXItY29sb3JcIjogXCIjMDBiODhiXCIsXG4gICAgICBcImN1cnNvci1jb2xvclwiOiBcIiMwMGI4OGJcIixcbiAgICAgIFwic3BlZWRiYXItY3Vyc29yLWNvbG9yXCI6IFwiIzAwYjg4YlwiLFxuICAgICAgXCJidXR0b24tb3BhY2l0eVwiOiBcIjFcIixcbiAgICAgIFwiaG92ZXItY29sb3JcIjogXCJyZ2JhKDAsMTg0LDEzOSwwLjIpXCIsXG4gICAgICBcInNsaWRlci1vZmYtY29sb3JcIjogXCIjY2NjXCIsXG4gICAgICBcInNsaWRlci1vbi1jb2xvclwiOiBcIiMwMGI4OGJcIixcbiAgICAgIGJvcmRlcjogXCIxcHggc29saWQgcmdiYSgyNTUsMjU1LDI1NSwwLjEpXCIsXG4gICAgICBcImNvbnRyb2xzLWJvcmRlclwiOiBcIjFweCBzb2xpZCAjMTUxNTE1XCIsXG4gICAgICBcInN2Zy1zZWxlY3RlZC1jb2xvclwiOiBcIiMwMGI4OGJcIixcbiAgICAgIFwibG9vcGJhci1ib3VuZGFyaWVzLXN0eWxlXCI6IFwiXFxuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLC0zNyUpO1xcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgICAgd2lkdGg6IDE4cHg7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMDBiODhiO1xcbiAgICAgICAgaGVpZ2h0OiAxOHB4O1xcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMTBweDtcXG4gICAgICAgIHotaW5kZXg6IDQwO1xcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgICAgd2lkdGg6IDE4cHg7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMDBiODhiO1xcbiAgICAgICAgaGVpZ2h0OiAxOHB4O1xcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMTBweDtcXG4gICAgICAgIHotaW5kZXg6IDQwO1xcbiAgICAgICAgd2lkdGg6IDE4cHg7XFxuICAgICAgICBoZWlnaHQ6IDlweDtcXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDEwMCU7XFxuICAgICAgICB0b3A6IDEuNXB4O1xcbiAgICBcIixcbiAgICAgIFwibG9vcGJhci1ib3VuZGFyaWVzLXN0eWxlOjpiZWZvcmVcIjogXCJcXG4gICAgICAgICAgICB3aWR0aDogMTZweDtcXG4gICAgICAgIGhlaWdodDogNXB4O1xcbiAgICAgICAgYmFja2dyb3VuZDogIzAwYjg4YjtcXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDEwMCU7XFxuICAgICAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgICAgIGNvbnRlbnQ6IFxcXCJcXFwiO1xcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICAgICAgbGVmdDogLTJweDtcXG4gICAgICAgIHRvcDogMnB4O1xcbiAgICBcIixcbiAgICAgIFwibG9vcGJhci1ib3VuZGFyaWVzLXN0eWxlOjphZnRlclwiOiBcIlxcbiAgICAgICAgd2lkdGg6IDE0cHg7XFxuICAgICAgICBoZWlnaHQ6IDExcHg7XFxuICAgICAgICBib3JkZXItcmFkaXVzOiAxMDAlO1xcbiAgICAgICAgYmFja2dyb3VuZDogIzAwYjg4YjtcXG4gICAgICAgIGNvbnRlbnQ6IFxcXCJcXFwiO1xcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XFxuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgICAgICB0b3A6IC02cHg7XFxuICAgICAgICBsZWZ0OiA1cHg7XFxuICAgIFwiLFxuICAgICAgXCJ0aGVtZS1zdHlsZVwiOiBcIlxcbiAgICAgICAgI1wiLmNvbmNhdChuYW1lLCBcIi1sb29wYmFyLXN0YXJ0IHtcXG4gICAgICAgICAgICBsZWZ0OiAtOXB4ICFpbXBvcnRhbnQ7XFxuICAgICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMTgwZGVnKTtcXG4gICAgICAgICAgICB0b3A6IC0ycHg7XFxuICAgICAgICB9XFxuICAgIFwiKVxuICAgIH0sXG4gICAgXCJtYy1ibHVlXCI6IHtcbiAgICAgIFwiYmFja2dyb3VuZC1jb2xvclwiOiBcIiMxNDE0MTZcIixcbiAgICAgIFwic2V0dGluZ3MtYmFja2dyb3VuZC1jb2xvclwiOiBcInJnYmEoMCwwLDAsMC41KVwiLFxuICAgICAgXCJobXMtYmFja2dyb3VuZC1jb2xvclwiOiBcInJnYmEoMCwwLDAsMC41KVwiLFxuICAgICAgXCJwcmV2aWV3LWJvcmRlclwiOiBcIjFweCBzb2xpZCByZ2JhKDAsMCwwLDEpXCIsXG4gICAgICBjb2xvcjogXCIjOTk5XCIsXG4gICAgICBcImdyYWQtaGVpZ2h0XCI6IFwiNjBweFwiLFxuICAgICAgXCJzdmctY29sb3JcIjogXCIjOTk5XCIsXG4gICAgICBcImxvb3BiYXItY29sb3JcIjogXCJyZ2JhKDAsMTUzLDIyNSwwLjIpXCIsXG4gICAgICBcImxvb3BiYXItYm91bmRhcmllcy1jb2xvclwiOiBcIiMwMDk5ZTFcIixcbiAgICAgIFwidG90YWxiYXItY29sb3JcIjogXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMTEpXCIsXG4gICAgICBcInNwZWVkYmFyLWNvbG9yXCI6IFwiIzk5OVwiLFxuICAgICAgXCJydW5uaW5nYmFyLWNvbG9yXCI6IFwiIzAwOTllMVwiLFxuICAgICAgXCJjdXJzb3ItY29sb3JcIjogXCIjMDA5OWUxXCIsXG4gICAgICBcInNwZWVkYmFyLWN1cnNvci1jb2xvclwiOiBcIiMwMDk5ZTFcIixcbiAgICAgIFwiYnV0dG9uLW9wYWNpdHlcIjogXCIxXCIsXG4gICAgICBcImhvdmVyLWNvbG9yXCI6IFwicmdiYSgwLDE1MywyMjUsMC4yKVwiLFxuICAgICAgXCJzbGlkZXItb2ZmLWNvbG9yXCI6IFwiI2NjY1wiLFxuICAgICAgXCJzbGlkZXItb24tY29sb3JcIjogXCIjMDA5OWUxXCIsXG4gICAgICBib3JkZXI6IFwiMXB4IHNvbGlkIHJnYmEoMjU1LDI1NSwyNTUsMC4xKVwiLFxuICAgICAgXCJjb250cm9scy1ib3JkZXJcIjogXCIxcHggc29saWQgIzE1MTUxNVwiLFxuICAgICAgXCJzdmctc2VsZWN0ZWQtY29sb3JcIjogXCIjMDA5OWUxXCIsXG4gICAgICBcImxvb3BiYXItYm91bmRhcmllcy1zdHlsZVwiOiBcIlxcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwtMzclKTtcXG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICAgIHdpZHRoOiAxOHB4O1xcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzAwOTllMTtcXG4gICAgICAgIGhlaWdodDogMThweDtcXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDEwcHg7XFxuICAgICAgICB6LWluZGV4OiA0MDtcXG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICAgIHdpZHRoOiAxOHB4O1xcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzAwOTllMTtcXG4gICAgICAgIGhlaWdodDogMThweDtcXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDEwcHg7XFxuICAgICAgICB6LWluZGV4OiA0MDtcXG4gICAgICAgIHdpZHRoOiAxOHB4O1xcbiAgICAgICAgaGVpZ2h0OiA5cHg7XFxuICAgICAgICBib3JkZXItcmFkaXVzOiAxMDAlO1xcbiAgICAgICAgdG9wOiAxLjVweDtcXG4gICAgXCIsXG4gICAgICBcImxvb3BiYXItYm91bmRhcmllcy1zdHlsZTo6YmVmb3JlXCI6IFwiXFxuICAgICAgICAgICAgd2lkdGg6IDE2cHg7XFxuICAgICAgICBoZWlnaHQ6IDVweDtcXG4gICAgICAgIGJhY2tncm91bmQ6ICMwMDk5ZTE7XFxuICAgICAgICBib3JkZXItcmFkaXVzOiAxMDAlO1xcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XFxuICAgICAgICBjb250ZW50OiBcXFwiXFxcIjtcXG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgICAgIGxlZnQ6IC0ycHg7XFxuICAgICAgICB0b3A6IDJweDtcXG4gICAgXCIsXG4gICAgICBcImxvb3BiYXItYm91bmRhcmllcy1zdHlsZTo6YWZ0ZXJcIjogXCJcXG4gICAgICAgIHdpZHRoOiAxNHB4O1xcbiAgICAgICAgaGVpZ2h0OiAxMXB4O1xcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMTAwJTtcXG4gICAgICAgIGJhY2tncm91bmQ6ICMwMDk5ZTE7XFxuICAgICAgICBjb250ZW50OiBcXFwiXFxcIjtcXG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICAgICAgdG9wOiAtNnB4O1xcbiAgICAgICAgbGVmdDogNXB4O1xcbiAgICBcIixcbiAgICAgIFwidGhlbWUtc3R5bGVcIjogXCJcXG4gICAgICAgICNcIi5jb25jYXQobmFtZSwgXCItbG9vcGJhci1zdGFydCB7XFxuICAgICAgICAgICAgbGVmdDogLTlweCAhaW1wb3J0YW50O1xcbiAgICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDE4MGRlZyk7XFxuICAgICAgICAgICAgdG9wOiAtMnB4O1xcbiAgICAgICAgfVxcbiAgICBcIilcbiAgICB9LFxuICAgIFwib24tdG9wXCI6IHtcbiAgICAgIFwiYmFja2dyb3VuZC1oZWlnaHRcIjogXCIxMDAlXCIsXG4gICAgICBcInBvaW50ZXItZXZlbnQtcGFuZWwtaGVpZ2h0XCI6IFwiY2FsYygxMDAlIC0gNDRweClcIixcbiAgICAgIFwiY29udHJvbHMtYm90dG9tXCI6IFwiMHB4XCIsXG4gICAgICBcInNldHRpbmdzLXBhbmVsLWJvdHRvbVwiOiBcIjQ4cHhcIixcbiAgICAgIFwiY29udHJvbHMtcG9zaXRpb25cIjogXCIwcHhcIlxuICAgIH0sXG4gICAgXCJwb3NpdGlvbi1kZWZhdWx0XCI6IHtcbiAgICAgIFwiYmFja2dyb3VuZC1oZWlnaHRcIjogXCJjYWxjKDEwMCUgLSA0NHB4KVwiLFxuICAgICAgXCJwb2ludGVyLWV2ZW50LXBhbmVsLWhlaWdodFwiOiBcImNhbGMoMTAwJSAtIDQ0cHgpXCIsXG4gICAgICBcImNvbnRyb2xzLWJvdHRvbVwiOiBcIi0wcHhcIixcbiAgICAgIFwic2V0dGluZ3MtcGFuZWwtYm90dG9tXCI6IFwiNDhweFwiLFxuICAgICAgXCJjb250cm9scy1wb3NpdGlvblwiOiBcIjQwcHhcIlxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHRoZW1lc1t0aGVtZV07XG59OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex-player/dist/html/themes.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex-player/dist/listeners/body.js":
/*!*******************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex-player/dist/listeners/body.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _require = __webpack_require__(/*! ../helpers */ \"../node_modules/@kissmybutton/motorcortex-player/dist/helpers.js\"),\n    el = _require.el,\n    elid = _require.elid;\n\nmodule.exports = function (_this) {\n  el(\"body\")[0].addEventListener(\"click\", function (e) {\n    if (e.target.className === \"\".concat(_this.name, \"-speed-value\")) {\n      var speedDisplay = e.target.dataset.speedValue - 0;\n      _this.clip.executionSpeed = e.target.dataset.speedValue;\n      _this.clip.speed == 1 ? speedDisplay = \"Normal\" : speedDisplay = _this.clip.speed;\n      _this.elements.speedCurrent.innerHTML = speedDisplay;\n      var step = 1 / (_this.options.speedValues.length - 1);\n      var positionY = (e.target.dataset.zone * step - 1) * -1 * ((_this.options.speedValues.length - 1) * 16);\n      elid(\"\".concat(_this.name, \"-speed-cursor\")).style.top = positionY + \"px\";\n    }\n  });\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgtcGxheWVyL2Rpc3QvbGlzdGVuZXJzL2JvZHkuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgtcGxheWVyL2Rpc3QvbGlzdGVuZXJzL2JvZHkuanM/MmFjOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4uL2hlbHBlcnNcIiksXG4gICAgZWwgPSBfcmVxdWlyZS5lbCxcbiAgICBlbGlkID0gX3JlcXVpcmUuZWxpZDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoX3RoaXMpIHtcbiAgZWwoXCJib2R5XCIpWzBdLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnRhcmdldC5jbGFzc05hbWUgPT09IFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLXNwZWVkLXZhbHVlXCIpKSB7XG4gICAgICB2YXIgc3BlZWREaXNwbGF5ID0gZS50YXJnZXQuZGF0YXNldC5zcGVlZFZhbHVlIC0gMDtcbiAgICAgIF90aGlzLmNsaXAuZXhlY3V0aW9uU3BlZWQgPSBlLnRhcmdldC5kYXRhc2V0LnNwZWVkVmFsdWU7XG4gICAgICBfdGhpcy5jbGlwLnNwZWVkID09IDEgPyBzcGVlZERpc3BsYXkgPSBcIk5vcm1hbFwiIDogc3BlZWREaXNwbGF5ID0gX3RoaXMuY2xpcC5zcGVlZDtcbiAgICAgIF90aGlzLmVsZW1lbnRzLnNwZWVkQ3VycmVudC5pbm5lckhUTUwgPSBzcGVlZERpc3BsYXk7XG4gICAgICB2YXIgc3RlcCA9IDEgLyAoX3RoaXMub3B0aW9ucy5zcGVlZFZhbHVlcy5sZW5ndGggLSAxKTtcbiAgICAgIHZhciBwb3NpdGlvblkgPSAoZS50YXJnZXQuZGF0YXNldC56b25lICogc3RlcCAtIDEpICogLTEgKiAoKF90aGlzLm9wdGlvbnMuc3BlZWRWYWx1ZXMubGVuZ3RoIC0gMSkgKiAxNik7XG4gICAgICBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLXNwZWVkLWN1cnNvclwiKSkuc3R5bGUudG9wID0gcG9zaXRpb25ZICsgXCJweFwiO1xuICAgIH1cbiAgfSk7XG59OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex-player/dist/listeners/body.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex-player/dist/listeners/controls.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex-player/dist/listeners/controls.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _require = __webpack_require__(/*! ../helpers */ \"../node_modules/@kissmybutton/motorcortex-player/dist/helpers.js\"),\n    elid = _require.elid;\n\nmodule.exports = function (_this) {\n  elid(\"\".concat(_this.name, \"-controls\")).onmouseover = function () {\n    if (!_this.settings.loopActivated) {\n      return;\n    }\n\n    _this.elements.loopBarStart.classList.remove(\"m-fadeOut\");\n\n    _this.elements.loopBarEnd.classList.remove(\"m-fadeOut\");\n\n    _this.elements.loopBarStart.classList.add(\"m-fadeIn\");\n\n    _this.elements.loopBarEnd.classList.add(\"m-fadeIn\");\n  };\n\n  elid(\"\".concat(_this.name, \"-controls\")).onmouseout = function (event) {\n    var e = event.toElement || event.relatedTarget || event.target;\n\n    if (isDescendant(this, e) || e === this) {\n      return;\n    }\n\n    if (!_this.settings.loopActivated) {\n      return;\n    }\n\n    _this.elements.loopBarStart.classList.add(\"m-fadeOut\");\n\n    _this.elements.loopBarEnd.classList.add(\"m-fadeOut\");\n\n    _this.elements.loopBarStart.classList.remove(\"m-fadeIn\");\n\n    _this.elements.loopBarEnd.classList.remove(\"m-fadeIn\");\n  };\n\n  var twt = false;\n\n  elid(\"\".concat(_this.name, \"-controls\")).ontouchstart = function (event) {\n    var e = event.toElement || event.relatedTarget || event.target;\n\n    if (isDescendant(_this.elements.statusButton, e) || e === _this.elements.statusButton || isDescendant(_this.elements.settingsButton, e) || e === _this.elements.settingsButton || isDescendant(_this.elements.fullScreenButton, e) || e === _this.elements.fullScreenButton || isDescendant(_this.elements.loopButton, e) || e === _this.elements.loopButton || isDescendant(_this.elements.totalBar, e) || e === _this.elements.totalBar) {\n      return;\n    }\n\n    _this.elements.volumeControl.className = \"\".concat(_this.name, \"-volume-width-transition\");\n    _this.elements.volumeBar.className = \"\".concat(_this.name, \"-volume-width-transition\");\n    _this.elements.volumeBarHelper.className = \"\".concat(_this.name, \"-volume-width-transition\");\n    _this.elements.timeDisplay.className = \"\".concat(_this.name, \"-time-width-transition\");\n    _this.elements.volumeCursor.className = \"\".concat(_this.name, \"-volume-cursor-transition\");\n    twt = true;\n  };\n\n  window.addEventListener(\"touchstart\", function (event) {\n    var e = event.toElement || event.relatedTarget || event.target;\n\n    if (isDescendant(elid(\"\".concat(_this.name, \"-controls\")), e) || e === elid(\"\".concat(_this.name, \"-controls\"))) {\n      return;\n    }\n\n    if (twt) {\n      _this.elements.volumeControl.className = \"\";\n      _this.elements.volumeBar.className = \"\";\n      _this.elements.volumeBarHelper.className = \"\";\n      _this.elements.timeDisplay.className = \"\";\n      _this.elements.volumeCursor.className = \"\";\n    }\n  }); // elid(`${_this.name}-left-controls`).ontouchstart = function (event) {\n  //   const e = event.toElement || event.relatedTarget || event.target;\n  //     if (isDescendant(_this.elements.statusBtn, e) || e === _this.elements.statusBtn) {\n  //       return false;\n  //     }\n  //     return \"\";\n  // };\n};\n\nfunction isDescendant(parent, child) {\n  var node = child.parentNode;\n\n  while (node != null) {\n    if (node == parent) {\n      return true;\n    }\n\n    node = node.parentNode;\n  }\n\n  return false;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgtcGxheWVyL2Rpc3QvbGlzdGVuZXJzL2NvbnRyb2xzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4LXBsYXllci9kaXN0L2xpc3RlbmVycy9jb250cm9scy5qcz9hNWMyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiLi4vaGVscGVyc1wiKSxcbiAgICBlbGlkID0gX3JlcXVpcmUuZWxpZDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoX3RoaXMpIHtcbiAgZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1jb250cm9sc1wiKSkub25tb3VzZW92ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFfdGhpcy5zZXR0aW5ncy5sb29wQWN0aXZhdGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgX3RoaXMuZWxlbWVudHMubG9vcEJhclN0YXJ0LmNsYXNzTGlzdC5yZW1vdmUoXCJtLWZhZGVPdXRcIik7XG5cbiAgICBfdGhpcy5lbGVtZW50cy5sb29wQmFyRW5kLmNsYXNzTGlzdC5yZW1vdmUoXCJtLWZhZGVPdXRcIik7XG5cbiAgICBfdGhpcy5lbGVtZW50cy5sb29wQmFyU3RhcnQuY2xhc3NMaXN0LmFkZChcIm0tZmFkZUluXCIpO1xuXG4gICAgX3RoaXMuZWxlbWVudHMubG9vcEJhckVuZC5jbGFzc0xpc3QuYWRkKFwibS1mYWRlSW5cIik7XG4gIH07XG5cbiAgZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1jb250cm9sc1wiKSkub25tb3VzZW91dCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBlID0gZXZlbnQudG9FbGVtZW50IHx8IGV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgZXZlbnQudGFyZ2V0O1xuXG4gICAgaWYgKGlzRGVzY2VuZGFudCh0aGlzLCBlKSB8fCBlID09PSB0aGlzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFfdGhpcy5zZXR0aW5ncy5sb29wQWN0aXZhdGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgX3RoaXMuZWxlbWVudHMubG9vcEJhclN0YXJ0LmNsYXNzTGlzdC5hZGQoXCJtLWZhZGVPdXRcIik7XG5cbiAgICBfdGhpcy5lbGVtZW50cy5sb29wQmFyRW5kLmNsYXNzTGlzdC5hZGQoXCJtLWZhZGVPdXRcIik7XG5cbiAgICBfdGhpcy5lbGVtZW50cy5sb29wQmFyU3RhcnQuY2xhc3NMaXN0LnJlbW92ZShcIm0tZmFkZUluXCIpO1xuXG4gICAgX3RoaXMuZWxlbWVudHMubG9vcEJhckVuZC5jbGFzc0xpc3QucmVtb3ZlKFwibS1mYWRlSW5cIik7XG4gIH07XG5cbiAgdmFyIHR3dCA9IGZhbHNlO1xuXG4gIGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItY29udHJvbHNcIikpLm9udG91Y2hzdGFydCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBlID0gZXZlbnQudG9FbGVtZW50IHx8IGV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgZXZlbnQudGFyZ2V0O1xuXG4gICAgaWYgKGlzRGVzY2VuZGFudChfdGhpcy5lbGVtZW50cy5zdGF0dXNCdXR0b24sIGUpIHx8IGUgPT09IF90aGlzLmVsZW1lbnRzLnN0YXR1c0J1dHRvbiB8fCBpc0Rlc2NlbmRhbnQoX3RoaXMuZWxlbWVudHMuc2V0dGluZ3NCdXR0b24sIGUpIHx8IGUgPT09IF90aGlzLmVsZW1lbnRzLnNldHRpbmdzQnV0dG9uIHx8IGlzRGVzY2VuZGFudChfdGhpcy5lbGVtZW50cy5mdWxsU2NyZWVuQnV0dG9uLCBlKSB8fCBlID09PSBfdGhpcy5lbGVtZW50cy5mdWxsU2NyZWVuQnV0dG9uIHx8IGlzRGVzY2VuZGFudChfdGhpcy5lbGVtZW50cy5sb29wQnV0dG9uLCBlKSB8fCBlID09PSBfdGhpcy5lbGVtZW50cy5sb29wQnV0dG9uIHx8IGlzRGVzY2VuZGFudChfdGhpcy5lbGVtZW50cy50b3RhbEJhciwgZSkgfHwgZSA9PT0gX3RoaXMuZWxlbWVudHMudG90YWxCYXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBfdGhpcy5lbGVtZW50cy52b2x1bWVDb250cm9sLmNsYXNzTmFtZSA9IFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLXZvbHVtZS13aWR0aC10cmFuc2l0aW9uXCIpO1xuICAgIF90aGlzLmVsZW1lbnRzLnZvbHVtZUJhci5jbGFzc05hbWUgPSBcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi12b2x1bWUtd2lkdGgtdHJhbnNpdGlvblwiKTtcbiAgICBfdGhpcy5lbGVtZW50cy52b2x1bWVCYXJIZWxwZXIuY2xhc3NOYW1lID0gXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItdm9sdW1lLXdpZHRoLXRyYW5zaXRpb25cIik7XG4gICAgX3RoaXMuZWxlbWVudHMudGltZURpc3BsYXkuY2xhc3NOYW1lID0gXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItdGltZS13aWR0aC10cmFuc2l0aW9uXCIpO1xuICAgIF90aGlzLmVsZW1lbnRzLnZvbHVtZUN1cnNvci5jbGFzc05hbWUgPSBcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi12b2x1bWUtY3Vyc29yLXRyYW5zaXRpb25cIik7XG4gICAgdHd0ID0gdHJ1ZTtcbiAgfTtcblxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGUgPSBldmVudC50b0VsZW1lbnQgfHwgZXZlbnQucmVsYXRlZFRhcmdldCB8fCBldmVudC50YXJnZXQ7XG5cbiAgICBpZiAoaXNEZXNjZW5kYW50KGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItY29udHJvbHNcIikpLCBlKSB8fCBlID09PSBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLWNvbnRyb2xzXCIpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0d3QpIHtcbiAgICAgIF90aGlzLmVsZW1lbnRzLnZvbHVtZUNvbnRyb2wuY2xhc3NOYW1lID0gXCJcIjtcbiAgICAgIF90aGlzLmVsZW1lbnRzLnZvbHVtZUJhci5jbGFzc05hbWUgPSBcIlwiO1xuICAgICAgX3RoaXMuZWxlbWVudHMudm9sdW1lQmFySGVscGVyLmNsYXNzTmFtZSA9IFwiXCI7XG4gICAgICBfdGhpcy5lbGVtZW50cy50aW1lRGlzcGxheS5jbGFzc05hbWUgPSBcIlwiO1xuICAgICAgX3RoaXMuZWxlbWVudHMudm9sdW1lQ3Vyc29yLmNsYXNzTmFtZSA9IFwiXCI7XG4gICAgfVxuICB9KTsgLy8gZWxpZChgJHtfdGhpcy5uYW1lfS1sZWZ0LWNvbnRyb2xzYCkub250b3VjaHN0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIC8vICAgY29uc3QgZSA9IGV2ZW50LnRvRWxlbWVudCB8fCBldmVudC5yZWxhdGVkVGFyZ2V0IHx8IGV2ZW50LnRhcmdldDtcbiAgLy8gICAgIGlmIChpc0Rlc2NlbmRhbnQoX3RoaXMuZWxlbWVudHMuc3RhdHVzQnRuLCBlKSB8fCBlID09PSBfdGhpcy5lbGVtZW50cy5zdGF0dXNCdG4pIHtcbiAgLy8gICAgICAgcmV0dXJuIGZhbHNlO1xuICAvLyAgICAgfVxuICAvLyAgICAgcmV0dXJuIFwiXCI7XG4gIC8vIH07XG59O1xuXG5mdW5jdGlvbiBpc0Rlc2NlbmRhbnQocGFyZW50LCBjaGlsZCkge1xuICB2YXIgbm9kZSA9IGNoaWxkLnBhcmVudE5vZGU7XG5cbiAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xuICAgIGlmIChub2RlID09IHBhcmVudCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex-player/dist/listeners/controls.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex-player/dist/listeners/donkeyclip.js":
/*!*************************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex-player/dist/listeners/donkeyclip.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function (_this) {\n  _this.elements.donkeyclipButton.addEventListener(\"click\", function () {\n    var u = create_UUID();\n    var popupDC = window.open(\"http://localhost:8081?u=\".concat(u));\n\n    \n    var definition = _this.clip.exportDefinition();\n\n    var clipClass = _this.clipClass;\n    window.addEventListener(\"message\", receiveMessage, false);\n\n    function receiveMessage(event) {\n      if (event.data === u) {\n        popupDC.postMessage(JSON.stringify({\n          definition: definition,\n          clipClass: clipClass,\n          u: u\n        }), \"*\");\n      }\n    }\n  });\n};\n\nfunction create_UUID() {\n  var dt = new Date().getTime();\n  var uuid = \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (c) {\n    var r = (dt + Math.random() * 16) % 16 | 0;\n    dt = Math.floor(dt / 16);\n    return (c == \"x\" ? r : r & 0x3 | 0x8).toString(16);\n  });\n  return uuid;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgtcGxheWVyL2Rpc3QvbGlzdGVuZXJzL2RvbmtleWNsaXAuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgtcGxheWVyL2Rpc3QvbGlzdGVuZXJzL2RvbmtleWNsaXAuanM/NWQyZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoX3RoaXMpIHtcbiAgX3RoaXMuZWxlbWVudHMuZG9ua2V5Y2xpcEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1ID0gY3JlYXRlX1VVSUQoKTtcbiAgICB2YXIgcG9wdXBEQyA9IHdpbmRvdy5vcGVuKFwiaHR0cDovL2xvY2FsaG9zdDo4MDgxP3U9XCIuY29uY2F0KHUpKTtcblxuICAgIFxuICAgIHZhciBkZWZpbml0aW9uID0gX3RoaXMuY2xpcC5leHBvcnREZWZpbml0aW9uKCk7XG5cbiAgICB2YXIgY2xpcENsYXNzID0gX3RoaXMuY2xpcENsYXNzO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCByZWNlaXZlTWVzc2FnZSwgZmFsc2UpO1xuXG4gICAgZnVuY3Rpb24gcmVjZWl2ZU1lc3NhZ2UoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5kYXRhID09PSB1KSB7XG4gICAgICAgIHBvcHVwREMucG9zdE1lc3NhZ2UoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGRlZmluaXRpb246IGRlZmluaXRpb24sXG4gICAgICAgICAgY2xpcENsYXNzOiBjbGlwQ2xhc3MsXG4gICAgICAgICAgdTogdVxuICAgICAgICB9KSwgXCIqXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVfVVVJRCgpIHtcbiAgdmFyIGR0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIHZhciB1dWlkID0gXCJ4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHhcIi5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgdmFyIHIgPSAoZHQgKyBNYXRoLnJhbmRvbSgpICogMTYpICUgMTYgfCAwO1xuICAgIGR0ID0gTWF0aC5mbG9vcihkdCAvIDE2KTtcbiAgICByZXR1cm4gKGMgPT0gXCJ4XCIgPyByIDogciAmIDB4MyB8IDB4OCkudG9TdHJpbmcoMTYpO1xuICB9KTtcbiAgcmV0dXJuIHV1aWQ7XG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex-player/dist/listeners/donkeyclip.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex-player/dist/listeners/fullscreen.js":
/*!*************************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex-player/dist/listeners/fullscreen.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function (_this) {\n  _this.elements.fullScreenButton.addEventListener(\"click\", function () {\n    var elFullScreen = _this.clip.props.host.className.includes(\"full-screen\");\n\n    _this.clip.props.host !== _this.options.host && !elFullScreen ? _this.clip.props.host.appendChild(_this.elements.mcPlayer) : null;\n    _this.clip.props.host !== _this.options.host && elFullScreen ? _this.options.host.appendChild(_this.elements.mcPlayer) : null;\n    elFullScreen ? _this.exitFullscreen() : _this.launchIntoFullscreen(_this.clip.props.host);\n\n    _this.clip.props.host.classList.toggle(\"full-screen\");\n  });\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgtcGxheWVyL2Rpc3QvbGlzdGVuZXJzL2Z1bGxzY3JlZW4uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgtcGxheWVyL2Rpc3QvbGlzdGVuZXJzL2Z1bGxzY3JlZW4uanM/OTM2OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoX3RoaXMpIHtcbiAgX3RoaXMuZWxlbWVudHMuZnVsbFNjcmVlbkJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbEZ1bGxTY3JlZW4gPSBfdGhpcy5jbGlwLnByb3BzLmhvc3QuY2xhc3NOYW1lLmluY2x1ZGVzKFwiZnVsbC1zY3JlZW5cIik7XG5cbiAgICBfdGhpcy5jbGlwLnByb3BzLmhvc3QgIT09IF90aGlzLm9wdGlvbnMuaG9zdCAmJiAhZWxGdWxsU2NyZWVuID8gX3RoaXMuY2xpcC5wcm9wcy5ob3N0LmFwcGVuZENoaWxkKF90aGlzLmVsZW1lbnRzLm1jUGxheWVyKSA6IG51bGw7XG4gICAgX3RoaXMuY2xpcC5wcm9wcy5ob3N0ICE9PSBfdGhpcy5vcHRpb25zLmhvc3QgJiYgZWxGdWxsU2NyZWVuID8gX3RoaXMub3B0aW9ucy5ob3N0LmFwcGVuZENoaWxkKF90aGlzLmVsZW1lbnRzLm1jUGxheWVyKSA6IG51bGw7XG4gICAgZWxGdWxsU2NyZWVuID8gX3RoaXMuZXhpdEZ1bGxzY3JlZW4oKSA6IF90aGlzLmxhdW5jaEludG9GdWxsc2NyZWVuKF90aGlzLmNsaXAucHJvcHMuaG9zdCk7XG5cbiAgICBfdGhpcy5jbGlwLnByb3BzLmhvc3QuY2xhc3NMaXN0LnRvZ2dsZShcImZ1bGwtc2NyZWVuXCIpO1xuICB9KTtcbn07Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex-player/dist/listeners/fullscreen.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex-player/dist/listeners/loopBarEnd.js":
/*!*************************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex-player/dist/listeners/loopBarEnd.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _require = __webpack_require__(/*! ../helpers */ \"../node_modules/@kissmybutton/motorcortex-player/dist/helpers.js\"),\n    addListener = _require.addListener,\n    removeListener = _require.removeListener;\n\nmodule.exports = function (_this) {\n  // let pe = false;\n  _this.listeners.onCursorMoveLoopEnd = function (e) {\n    e.preventDefault();\n    var clientX = e.clientX || ((e.touches || [])[0] || {}).clientX;\n\n    var viewportOffset = _this.elements.totalBar.getBoundingClientRect();\n\n    var positionX = clientX - viewportOffset.left;\n\n    if (positionX < 0) {\n      positionX = 0;\n    } else if (positionX > _this.elements.totalBar.offsetWidth) {\n      positionX = _this.elements.totalBar.offsetWidth;\n    }\n\n    if (_this.elements.runningBar.offsetWidth >= _this.elements.loopBar.offsetWidth) {\n      _this.elements.runningBar.style.width = _this.elements.loopBar.offsetWidth + \"px\";\n    }\n\n    if (_this.settings.loopLastPositionXPxls - positionX < 0) {\n      _this.elements.loopBar.style.width = Math.abs(_this.settings.loopLastPositionXPxls - positionX) + \"px\";\n    } else {\n      _this.elements.loopBar.style.left = positionX + \"px\";\n      _this.settings.loopLastPositionXPxls = positionX;\n    }\n\n    _this.settings.loopEndMillisecond = Math.round(_this.clip.duration * ((parseFloat(_this.elements.loopBar.style.left) || 0) + parseFloat(_this.elements.loopBar.style.width)) / _this.elements.totalBar.offsetWidth);\n\n    if (_this.settings.loopEndMillisecond < _this.clip.runTimeInfo.currentMillisecond) {\n      _this.settings.loopJourney = true;\n    }\n\n    if (_this.settings.loopStartMillisecond > _this.settings.loopEndMillisecond) {\n      _this.settings.loopStartMillisecond = _this.settings.loopEndMillisecond;\n      _this.settings.loopJourney = true;\n    }\n\n    _this.elements.loopEndTime.innerHTML = _this.settings.loopEndMillisecond;\n    _this.elements.loopStartTime.innerHTML = _this.settings.loopStartMillisecond;\n  };\n\n  _this.listeners.onMouseUpLoopEnd = function (e) {\n    _this.elements.listenerHelper.style.pointerEvents = \"none\"; // if (pe) {\n    //   _this.elements.settingsPointerEvents.click();\n    // }\n\n    _this.settings.resizeLoop = false;\n    e.preventDefault();\n    _this.elements.runningBar.style.width = _this.elements.runningBar.offsetWidth / _this.elements.loopBar.offsetWidth * 100 + \"%\";\n    _this.elements.loopBar.style.left = _this.elements.loopBar.offsetLeft / _this.elements.totalBar.offsetWidth * 100 + \"%\";\n    _this.elements.loopBar.style.width = _this.elements.loopBar.offsetWidth / _this.elements.totalBar.offsetWidth * 100 + \"%\";\n\n    if (_this.settings.loopJourney) {\n      _this.createProgressDrag(_this.elements.runningBar.offsetWidth);\n\n      _this.settings.loopJourney = false;\n    }\n\n    removeListener(\"mouseup\", _this.listeners.onMouseUpLoopEnd, false);\n    removeListener(\"touchend\", _this.listeners.onMouseUpLoopEnd, false);\n    removeListener(\"mousemove\", _this.listeners.onCursorMoveLoopEnd, false);\n    removeListener(\"touchmove\", _this.listeners.onCursorMoveLoopEnd, false);\n\n    _this.elements.loopBar.addEventListener(\"mousedown\", _this.listeners.onMouseDown, false);\n\n    _this.elements.loopBar.addEventListener(\"touchstart\", _this.listeners.onMouseDown, {\n      passive: true\n    }, false);\n\n    if (_this.settings.playAfterResize) {\n      if (_this.clip.runTimeInfo.state === \"idle\") {\n        var loopms;\n\n        if (_this.clip.speed >= 0) {\n          loopms = _this.settings.loopStartMillisecond + 1;\n        } else {\n          loopms = _this.settings.loopEndMillisecond - 1;\n        }\n\n        _this.settings.needsUpdate = true;\n\n        _this.createJourney(_this.clip, loopms, {\n          before: \"pause\",\n          after: \"play\"\n        });\n      } else if (_this.clip.runTimeInfo.state === \"completed\") {\n        var _loopms;\n\n        if (_this.clip.speed >= 0) {\n          _loopms = _this.settings.loopStartMillisecond + 1;\n        } else {\n          _loopms = _this.settings.loopEndMillisecond - 1;\n        }\n\n        _this.settings.needsUpdate = true;\n\n        _this.createJourney(_this.clip, _loopms, {\n          before: \"pause\",\n          after: \"play\"\n        });\n      } else {\n        _this.clip.play();\n      }\n\n      _this.settings.playAfterResize = false;\n    }\n  };\n\n  _this.listeners.onMouseDownLoopEnd = function (e) {\n    _this.elements.listenerHelper.style.pointerEvents = \"auto\"; // if (!_this.options.pointerEvents) {\n    //   pe = true;\n    //   _this.elements.settingsPointerEvents.click();\n    // }\n\n    _this.settings.resizeLoop = true;\n    _this.settings.needsUpdate = true;\n\n    if (_this.clip.runTimeInfo.state === \"playing\") {\n      _this.clip.pause();\n\n      _this.settings.playAfterResize = true;\n    }\n\n    e.preventDefault();\n    _this.elements.runningBar.style.width = _this.elements.runningBar.offsetWidth + \"px\";\n    _this.elements.loopBar.style.left = _this.elements.loopBar.offsetLeft + \"px\";\n    _this.elements.loopBar.style.width = _this.elements.loopBar.offsetWidth + \"px\";\n\n    _this.elements.loopBar.removeEventListener(\"mousedown\", _this.listeners.onMouseDown, false);\n\n    _this.elements.loopBar.removeEventListener(\"touchstart\", _this.listeners.onMouseDown, false);\n\n    _this.listeners.onCursorMoveLoopEnd(e);\n\n    addListener(\"mouseup\", _this.listeners.onMouseUpLoopEnd, false);\n    addListener(\"touchend\", _this.listeners.onMouseUpLoopEnd, false);\n    addListener(\"mousemove\", _this.listeners.onCursorMoveLoopEnd, false);\n    addListener(\"touchmove\", _this.listeners.onCursorMoveLoopEnd, false);\n  };\n\n  _this.elements.loopBarEnd.addEventListener(\"mousedown\", _this.listeners.onMouseDownLoopEnd, false);\n\n  _this.elements.loopBarEnd.addEventListener(\"touchstart\", _this.listeners.onMouseDownLoopEnd, {\n    passive: false\n  }, false);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgtcGxheWVyL2Rpc3QvbGlzdGVuZXJzL2xvb3BCYXJFbmQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgtcGxheWVyL2Rpc3QvbGlzdGVuZXJzL2xvb3BCYXJFbmQuanM/MjQ4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4uL2hlbHBlcnNcIiksXG4gICAgYWRkTGlzdGVuZXIgPSBfcmVxdWlyZS5hZGRMaXN0ZW5lcixcbiAgICByZW1vdmVMaXN0ZW5lciA9IF9yZXF1aXJlLnJlbW92ZUxpc3RlbmVyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfdGhpcykge1xuICAvLyBsZXQgcGUgPSBmYWxzZTtcbiAgX3RoaXMubGlzdGVuZXJzLm9uQ3Vyc29yTW92ZUxvb3BFbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB2YXIgY2xpZW50WCA9IGUuY2xpZW50WCB8fCAoKGUudG91Y2hlcyB8fCBbXSlbMF0gfHwge30pLmNsaWVudFg7XG5cbiAgICB2YXIgdmlld3BvcnRPZmZzZXQgPSBfdGhpcy5lbGVtZW50cy50b3RhbEJhci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgIHZhciBwb3NpdGlvblggPSBjbGllbnRYIC0gdmlld3BvcnRPZmZzZXQubGVmdDtcblxuICAgIGlmIChwb3NpdGlvblggPCAwKSB7XG4gICAgICBwb3NpdGlvblggPSAwO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb25YID4gX3RoaXMuZWxlbWVudHMudG90YWxCYXIub2Zmc2V0V2lkdGgpIHtcbiAgICAgIHBvc2l0aW9uWCA9IF90aGlzLmVsZW1lbnRzLnRvdGFsQmFyLm9mZnNldFdpZHRoO1xuICAgIH1cblxuICAgIGlmIChfdGhpcy5lbGVtZW50cy5ydW5uaW5nQmFyLm9mZnNldFdpZHRoID49IF90aGlzLmVsZW1lbnRzLmxvb3BCYXIub2Zmc2V0V2lkdGgpIHtcbiAgICAgIF90aGlzLmVsZW1lbnRzLnJ1bm5pbmdCYXIuc3R5bGUud2lkdGggPSBfdGhpcy5lbGVtZW50cy5sb29wQmFyLm9mZnNldFdpZHRoICsgXCJweFwiO1xuICAgIH1cblxuICAgIGlmIChfdGhpcy5zZXR0aW5ncy5sb29wTGFzdFBvc2l0aW9uWFB4bHMgLSBwb3NpdGlvblggPCAwKSB7XG4gICAgICBfdGhpcy5lbGVtZW50cy5sb29wQmFyLnN0eWxlLndpZHRoID0gTWF0aC5hYnMoX3RoaXMuc2V0dGluZ3MubG9vcExhc3RQb3NpdGlvblhQeGxzIC0gcG9zaXRpb25YKSArIFwicHhcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgX3RoaXMuZWxlbWVudHMubG9vcEJhci5zdHlsZS5sZWZ0ID0gcG9zaXRpb25YICsgXCJweFwiO1xuICAgICAgX3RoaXMuc2V0dGluZ3MubG9vcExhc3RQb3NpdGlvblhQeGxzID0gcG9zaXRpb25YO1xuICAgIH1cblxuICAgIF90aGlzLnNldHRpbmdzLmxvb3BFbmRNaWxsaXNlY29uZCA9IE1hdGgucm91bmQoX3RoaXMuY2xpcC5kdXJhdGlvbiAqICgocGFyc2VGbG9hdChfdGhpcy5lbGVtZW50cy5sb29wQmFyLnN0eWxlLmxlZnQpIHx8IDApICsgcGFyc2VGbG9hdChfdGhpcy5lbGVtZW50cy5sb29wQmFyLnN0eWxlLndpZHRoKSkgLyBfdGhpcy5lbGVtZW50cy50b3RhbEJhci5vZmZzZXRXaWR0aCk7XG5cbiAgICBpZiAoX3RoaXMuc2V0dGluZ3MubG9vcEVuZE1pbGxpc2Vjb25kIDwgX3RoaXMuY2xpcC5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQpIHtcbiAgICAgIF90aGlzLnNldHRpbmdzLmxvb3BKb3VybmV5ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoX3RoaXMuc2V0dGluZ3MubG9vcFN0YXJ0TWlsbGlzZWNvbmQgPiBfdGhpcy5zZXR0aW5ncy5sb29wRW5kTWlsbGlzZWNvbmQpIHtcbiAgICAgIF90aGlzLnNldHRpbmdzLmxvb3BTdGFydE1pbGxpc2Vjb25kID0gX3RoaXMuc2V0dGluZ3MubG9vcEVuZE1pbGxpc2Vjb25kO1xuICAgICAgX3RoaXMuc2V0dGluZ3MubG9vcEpvdXJuZXkgPSB0cnVlO1xuICAgIH1cblxuICAgIF90aGlzLmVsZW1lbnRzLmxvb3BFbmRUaW1lLmlubmVySFRNTCA9IF90aGlzLnNldHRpbmdzLmxvb3BFbmRNaWxsaXNlY29uZDtcbiAgICBfdGhpcy5lbGVtZW50cy5sb29wU3RhcnRUaW1lLmlubmVySFRNTCA9IF90aGlzLnNldHRpbmdzLmxvb3BTdGFydE1pbGxpc2Vjb25kO1xuICB9O1xuXG4gIF90aGlzLmxpc3RlbmVycy5vbk1vdXNlVXBMb29wRW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICBfdGhpcy5lbGVtZW50cy5saXN0ZW5lckhlbHBlci5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7IC8vIGlmIChwZSkge1xuICAgIC8vICAgX3RoaXMuZWxlbWVudHMuc2V0dGluZ3NQb2ludGVyRXZlbnRzLmNsaWNrKCk7XG4gICAgLy8gfVxuXG4gICAgX3RoaXMuc2V0dGluZ3MucmVzaXplTG9vcCA9IGZhbHNlO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBfdGhpcy5lbGVtZW50cy5ydW5uaW5nQmFyLnN0eWxlLndpZHRoID0gX3RoaXMuZWxlbWVudHMucnVubmluZ0Jhci5vZmZzZXRXaWR0aCAvIF90aGlzLmVsZW1lbnRzLmxvb3BCYXIub2Zmc2V0V2lkdGggKiAxMDAgKyBcIiVcIjtcbiAgICBfdGhpcy5lbGVtZW50cy5sb29wQmFyLnN0eWxlLmxlZnQgPSBfdGhpcy5lbGVtZW50cy5sb29wQmFyLm9mZnNldExlZnQgLyBfdGhpcy5lbGVtZW50cy50b3RhbEJhci5vZmZzZXRXaWR0aCAqIDEwMCArIFwiJVwiO1xuICAgIF90aGlzLmVsZW1lbnRzLmxvb3BCYXIuc3R5bGUud2lkdGggPSBfdGhpcy5lbGVtZW50cy5sb29wQmFyLm9mZnNldFdpZHRoIC8gX3RoaXMuZWxlbWVudHMudG90YWxCYXIub2Zmc2V0V2lkdGggKiAxMDAgKyBcIiVcIjtcblxuICAgIGlmIChfdGhpcy5zZXR0aW5ncy5sb29wSm91cm5leSkge1xuICAgICAgX3RoaXMuY3JlYXRlUHJvZ3Jlc3NEcmFnKF90aGlzLmVsZW1lbnRzLnJ1bm5pbmdCYXIub2Zmc2V0V2lkdGgpO1xuXG4gICAgICBfdGhpcy5zZXR0aW5ncy5sb29wSm91cm5leSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJlbW92ZUxpc3RlbmVyKFwibW91c2V1cFwiLCBfdGhpcy5saXN0ZW5lcnMub25Nb3VzZVVwTG9vcEVuZCwgZmFsc2UpO1xuICAgIHJlbW92ZUxpc3RlbmVyKFwidG91Y2hlbmRcIiwgX3RoaXMubGlzdGVuZXJzLm9uTW91c2VVcExvb3BFbmQsIGZhbHNlKTtcbiAgICByZW1vdmVMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBfdGhpcy5saXN0ZW5lcnMub25DdXJzb3JNb3ZlTG9vcEVuZCwgZmFsc2UpO1xuICAgIHJlbW92ZUxpc3RlbmVyKFwidG91Y2htb3ZlXCIsIF90aGlzLmxpc3RlbmVycy5vbkN1cnNvck1vdmVMb29wRW5kLCBmYWxzZSk7XG5cbiAgICBfdGhpcy5lbGVtZW50cy5sb29wQmFyLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgX3RoaXMubGlzdGVuZXJzLm9uTW91c2VEb3duLCBmYWxzZSk7XG5cbiAgICBfdGhpcy5lbGVtZW50cy5sb29wQmFyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIF90aGlzLmxpc3RlbmVycy5vbk1vdXNlRG93biwge1xuICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgIH0sIGZhbHNlKTtcblxuICAgIGlmIChfdGhpcy5zZXR0aW5ncy5wbGF5QWZ0ZXJSZXNpemUpIHtcbiAgICAgIGlmIChfdGhpcy5jbGlwLnJ1blRpbWVJbmZvLnN0YXRlID09PSBcImlkbGVcIikge1xuICAgICAgICB2YXIgbG9vcG1zO1xuXG4gICAgICAgIGlmIChfdGhpcy5jbGlwLnNwZWVkID49IDApIHtcbiAgICAgICAgICBsb29wbXMgPSBfdGhpcy5zZXR0aW5ncy5sb29wU3RhcnRNaWxsaXNlY29uZCArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9vcG1zID0gX3RoaXMuc2V0dGluZ3MubG9vcEVuZE1pbGxpc2Vjb25kIC0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLnNldHRpbmdzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgICBfdGhpcy5jcmVhdGVKb3VybmV5KF90aGlzLmNsaXAsIGxvb3Btcywge1xuICAgICAgICAgIGJlZm9yZTogXCJwYXVzZVwiLFxuICAgICAgICAgIGFmdGVyOiBcInBsYXlcIlxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoX3RoaXMuY2xpcC5ydW5UaW1lSW5mby5zdGF0ZSA9PT0gXCJjb21wbGV0ZWRcIikge1xuICAgICAgICB2YXIgX2xvb3BtcztcblxuICAgICAgICBpZiAoX3RoaXMuY2xpcC5zcGVlZCA+PSAwKSB7XG4gICAgICAgICAgX2xvb3BtcyA9IF90aGlzLnNldHRpbmdzLmxvb3BTdGFydE1pbGxpc2Vjb25kICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfbG9vcG1zID0gX3RoaXMuc2V0dGluZ3MubG9vcEVuZE1pbGxpc2Vjb25kIC0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLnNldHRpbmdzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgICBfdGhpcy5jcmVhdGVKb3VybmV5KF90aGlzLmNsaXAsIF9sb29wbXMsIHtcbiAgICAgICAgICBiZWZvcmU6IFwicGF1c2VcIixcbiAgICAgICAgICBhZnRlcjogXCJwbGF5XCJcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy5jbGlwLnBsYXkoKTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuc2V0dGluZ3MucGxheUFmdGVyUmVzaXplID0gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIF90aGlzLmxpc3RlbmVycy5vbk1vdXNlRG93bkxvb3BFbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgIF90aGlzLmVsZW1lbnRzLmxpc3RlbmVySGVscGVyLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcImF1dG9cIjsgLy8gaWYgKCFfdGhpcy5vcHRpb25zLnBvaW50ZXJFdmVudHMpIHtcbiAgICAvLyAgIHBlID0gdHJ1ZTtcbiAgICAvLyAgIF90aGlzLmVsZW1lbnRzLnNldHRpbmdzUG9pbnRlckV2ZW50cy5jbGljaygpO1xuICAgIC8vIH1cblxuICAgIF90aGlzLnNldHRpbmdzLnJlc2l6ZUxvb3AgPSB0cnVlO1xuICAgIF90aGlzLnNldHRpbmdzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIGlmIChfdGhpcy5jbGlwLnJ1blRpbWVJbmZvLnN0YXRlID09PSBcInBsYXlpbmdcIikge1xuICAgICAgX3RoaXMuY2xpcC5wYXVzZSgpO1xuXG4gICAgICBfdGhpcy5zZXR0aW5ncy5wbGF5QWZ0ZXJSZXNpemUgPSB0cnVlO1xuICAgIH1cblxuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBfdGhpcy5lbGVtZW50cy5ydW5uaW5nQmFyLnN0eWxlLndpZHRoID0gX3RoaXMuZWxlbWVudHMucnVubmluZ0Jhci5vZmZzZXRXaWR0aCArIFwicHhcIjtcbiAgICBfdGhpcy5lbGVtZW50cy5sb29wQmFyLnN0eWxlLmxlZnQgPSBfdGhpcy5lbGVtZW50cy5sb29wQmFyLm9mZnNldExlZnQgKyBcInB4XCI7XG4gICAgX3RoaXMuZWxlbWVudHMubG9vcEJhci5zdHlsZS53aWR0aCA9IF90aGlzLmVsZW1lbnRzLmxvb3BCYXIub2Zmc2V0V2lkdGggKyBcInB4XCI7XG5cbiAgICBfdGhpcy5lbGVtZW50cy5sb29wQmFyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgX3RoaXMubGlzdGVuZXJzLm9uTW91c2VEb3duLCBmYWxzZSk7XG5cbiAgICBfdGhpcy5lbGVtZW50cy5sb29wQmFyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIF90aGlzLmxpc3RlbmVycy5vbk1vdXNlRG93biwgZmFsc2UpO1xuXG4gICAgX3RoaXMubGlzdGVuZXJzLm9uQ3Vyc29yTW92ZUxvb3BFbmQoZSk7XG5cbiAgICBhZGRMaXN0ZW5lcihcIm1vdXNldXBcIiwgX3RoaXMubGlzdGVuZXJzLm9uTW91c2VVcExvb3BFbmQsIGZhbHNlKTtcbiAgICBhZGRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIF90aGlzLmxpc3RlbmVycy5vbk1vdXNlVXBMb29wRW5kLCBmYWxzZSk7XG4gICAgYWRkTGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgX3RoaXMubGlzdGVuZXJzLm9uQ3Vyc29yTW92ZUxvb3BFbmQsIGZhbHNlKTtcbiAgICBhZGRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBfdGhpcy5saXN0ZW5lcnMub25DdXJzb3JNb3ZlTG9vcEVuZCwgZmFsc2UpO1xuICB9O1xuXG4gIF90aGlzLmVsZW1lbnRzLmxvb3BCYXJFbmQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBfdGhpcy5saXN0ZW5lcnMub25Nb3VzZURvd25Mb29wRW5kLCBmYWxzZSk7XG5cbiAgX3RoaXMuZWxlbWVudHMubG9vcEJhckVuZC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCBfdGhpcy5saXN0ZW5lcnMub25Nb3VzZURvd25Mb29wRW5kLCB7XG4gICAgcGFzc2l2ZTogZmFsc2VcbiAgfSwgZmFsc2UpO1xufTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex-player/dist/listeners/loopBarEnd.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex-player/dist/listeners/loopBarStart.js":
/*!***************************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex-player/dist/listeners/loopBarStart.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _require = __webpack_require__(/*! ../helpers */ \"../node_modules/@kissmybutton/motorcortex-player/dist/helpers.js\"),\n    addListener = _require.addListener,\n    removeListener = _require.removeListener;\n\nmodule.exports = function (_this) {\n  // let pe = false;\n  _this.listeners.onCursorMoveLoopStart = function (e) {\n    e.preventDefault();\n    var clientX = e.clientX || ((e.touches || [])[0] || {}).clientX;\n\n    var viewportOffset = _this.elements.totalBar.getBoundingClientRect();\n\n    var positionX = Math.round(clientX - viewportOffset.left);\n    var endPositionsInPxls = Math.round(_this.settings.loopEndMillisecond / _this.clip.duration * _this.elements.totalBar.offsetWidth);\n\n    if (positionX < 0) {\n      positionX = 0;\n    } else if (positionX > _this.elements.totalBar.offsetWidth) {\n      positionX = _this.elements.totalBar.offsetWidth;\n    }\n\n    var runningBarWidthInPxls = _this.clip.runTimeInfo.currentMillisecond / _this.clip.duration * _this.elements.totalBar.offsetWidth - positionX;\n    _this.elements.loopBar.style.left = positionX + \"px\";\n    _this.elements.loopBar.style.width = endPositionsInPxls - positionX + \"px\";\n    _this.elements.runningBar.style.width = runningBarWidthInPxls + \"px\";\n    _this.settings.loopLastPositionXPxls = positionX;\n    _this.settings.loopStartMillisecond = Math.round(_this.clip.duration * _this.elements.loopBar.offsetLeft / _this.elements.totalBar.offsetWidth);\n\n    if (_this.settings.loopEndMillisecond < _this.settings.loopStartMillisecond) {\n      _this.settings.loopEndMillisecond = _this.settings.loopStartMillisecond;\n      _this.elements.loopBar.style.width = \"0px\";\n      _this.elements.runningBar.style.width = \"0px\";\n    }\n\n    _this.elements.loopEndTime.innerHTML = _this.settings.loopEndMillisecond;\n    _this.elements.loopStartTime.innerHTML = _this.settings.loopStartMillisecond;\n\n    if (_this.settings.loopStartMillisecond > _this.clip.runTimeInfo.currentMillisecond) {\n      _this.settings.loopJourney = true;\n    }\n  };\n\n  _this.listeners.onMouseUpLoopStart = function (e) {\n    _this.elements.listenerHelper.style.pointerEvents = \"none\"; // if (pe) {\n    //   _this.elements.settingsPointerEvents.click();\n    // }\n\n    _this.settings.resizeLoop = false;\n    e.preventDefault();\n\n    if (_this.settings.loopJourney) {\n      _this.createProgressDrag(_this.elements.runningBar.offsetWidth);\n\n      _this.settings.loopJourney = false;\n    }\n\n    _this.elements.loopBar.style.left = _this.elements.loopBar.offsetLeft / _this.elements.totalBar.offsetWidth * 100 + \"%\";\n    _this.elements.loopBar.style.width = _this.elements.loopBar.offsetWidth / _this.elements.totalBar.offsetWidth * 100 + \"%\";\n    _this.settings.loopStartMillisecond = Math.round(_this.clip.duration * _this.elements.loopBar.offsetLeft / _this.elements.totalBar.offsetWidth);\n    _this.elements.runningBar.style.width = _this.elements.runningBar.offsetWidth / _this.elements.loopBar.offsetWidth * 100 + \"%\";\n    removeListener(\"mouseup\", _this.listeners.onMouseUpLoopStart, false);\n    removeListener(\"touchend\", _this.listeners.onMouseUpLoopStart, false);\n    removeListener(\"mousemove\", _this.listeners.onCursorMoveLoopStart, false);\n    removeListener(\"touchmove\", _this.listeners.onCursorMoveLoopStart, false);\n\n    _this.elements.loopBar.addEventListener(\"mousedown\", _this.listeners.onMouseDown, false);\n\n    _this.elements.loopBar.addEventListener(\"touchstart\", _this.listeners.onMouseDown, {\n      passive: true\n    }, false);\n\n    if (_this.settings.playAfterResize) {\n      if (_this.clip.runTimeInfo.state === \"idle\") {\n        var loopms;\n\n        if (_this.clip.speed >= 0) {\n          loopms = _this.settings.loopStartMillisecond + 1;\n        } else {\n          loopms = _this.settings.loopEndMillisecond - 1;\n        }\n\n        _this.settings.needsUpdate = true;\n\n        _this.createJourney(_this.clip, loopms, {\n          before: \"pause\",\n          after: \"play\"\n        });\n      } else {\n        _this.clip.play();\n      }\n\n      _this.settings.playAfterResize = false;\n    }\n  };\n\n  _this.listeners.onMouseDownLoopStart = function (e) {\n    _this.elements.listenerHelper.style.pointerEvents = \"auto\"; // if (!_this.options.pointerEvents) {\n    //   pe = true;\n    //   _this.elements.settingsPointerEvents.click();\n    // }\n\n    _this.settings.resizeLoop = true;\n    e.preventDefault();\n    _this.settings.needsUpdate = true;\n\n    if (_this.clip.runTimeInfo.state === \"playing\") {\n      _this.clip.pause();\n\n      _this.settings.playAfterResize = true;\n    }\n\n    _this.elements.loopBar.removeEventListener(\"mousedown\", _this.listeners.onMouseDown, false);\n\n    _this.elements.loopBar.removeEventListener(\"touchstart\", _this.listeners.onMouseDown, false);\n\n    _this.listeners.onCursorMoveLoopStart(e);\n\n    addListener(\"mouseup\", _this.listeners.onMouseUpLoopStart, false);\n    addListener(\"touchend\", _this.listeners.onMouseUpLoopStart, false);\n    addListener(\"mousemove\", _this.listeners.onCursorMoveLoopStart, false);\n    addListener(\"touchmove\", _this.listeners.onCursorMoveLoopStart, false);\n  };\n\n  _this.elements.loopBarStart.addEventListener(\"mousedown\", _this.listeners.onMouseDownLoopStart, false);\n\n  _this.elements.loopBarStart.addEventListener(\"touchstart\", _this.listeners.onMouseDownLoopStart, {\n    passive: false\n  }, false);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgtcGxheWVyL2Rpc3QvbGlzdGVuZXJzL2xvb3BCYXJTdGFydC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC1wbGF5ZXIvZGlzdC9saXN0ZW5lcnMvbG9vcEJhclN0YXJ0LmpzPzc5ZDUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzXCIpLFxuICAgIGFkZExpc3RlbmVyID0gX3JlcXVpcmUuYWRkTGlzdGVuZXIsXG4gICAgcmVtb3ZlTGlzdGVuZXIgPSBfcmVxdWlyZS5yZW1vdmVMaXN0ZW5lcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoX3RoaXMpIHtcbiAgLy8gbGV0IHBlID0gZmFsc2U7XG4gIF90aGlzLmxpc3RlbmVycy5vbkN1cnNvck1vdmVMb29wU3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB2YXIgY2xpZW50WCA9IGUuY2xpZW50WCB8fCAoKGUudG91Y2hlcyB8fCBbXSlbMF0gfHwge30pLmNsaWVudFg7XG5cbiAgICB2YXIgdmlld3BvcnRPZmZzZXQgPSBfdGhpcy5lbGVtZW50cy50b3RhbEJhci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgIHZhciBwb3NpdGlvblggPSBNYXRoLnJvdW5kKGNsaWVudFggLSB2aWV3cG9ydE9mZnNldC5sZWZ0KTtcbiAgICB2YXIgZW5kUG9zaXRpb25zSW5QeGxzID0gTWF0aC5yb3VuZChfdGhpcy5zZXR0aW5ncy5sb29wRW5kTWlsbGlzZWNvbmQgLyBfdGhpcy5jbGlwLmR1cmF0aW9uICogX3RoaXMuZWxlbWVudHMudG90YWxCYXIub2Zmc2V0V2lkdGgpO1xuXG4gICAgaWYgKHBvc2l0aW9uWCA8IDApIHtcbiAgICAgIHBvc2l0aW9uWCA9IDA7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvblggPiBfdGhpcy5lbGVtZW50cy50b3RhbEJhci5vZmZzZXRXaWR0aCkge1xuICAgICAgcG9zaXRpb25YID0gX3RoaXMuZWxlbWVudHMudG90YWxCYXIub2Zmc2V0V2lkdGg7XG4gICAgfVxuXG4gICAgdmFyIHJ1bm5pbmdCYXJXaWR0aEluUHhscyA9IF90aGlzLmNsaXAucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kIC8gX3RoaXMuY2xpcC5kdXJhdGlvbiAqIF90aGlzLmVsZW1lbnRzLnRvdGFsQmFyLm9mZnNldFdpZHRoIC0gcG9zaXRpb25YO1xuICAgIF90aGlzLmVsZW1lbnRzLmxvb3BCYXIuc3R5bGUubGVmdCA9IHBvc2l0aW9uWCArIFwicHhcIjtcbiAgICBfdGhpcy5lbGVtZW50cy5sb29wQmFyLnN0eWxlLndpZHRoID0gZW5kUG9zaXRpb25zSW5QeGxzIC0gcG9zaXRpb25YICsgXCJweFwiO1xuICAgIF90aGlzLmVsZW1lbnRzLnJ1bm5pbmdCYXIuc3R5bGUud2lkdGggPSBydW5uaW5nQmFyV2lkdGhJblB4bHMgKyBcInB4XCI7XG4gICAgX3RoaXMuc2V0dGluZ3MubG9vcExhc3RQb3NpdGlvblhQeGxzID0gcG9zaXRpb25YO1xuICAgIF90aGlzLnNldHRpbmdzLmxvb3BTdGFydE1pbGxpc2Vjb25kID0gTWF0aC5yb3VuZChfdGhpcy5jbGlwLmR1cmF0aW9uICogX3RoaXMuZWxlbWVudHMubG9vcEJhci5vZmZzZXRMZWZ0IC8gX3RoaXMuZWxlbWVudHMudG90YWxCYXIub2Zmc2V0V2lkdGgpO1xuXG4gICAgaWYgKF90aGlzLnNldHRpbmdzLmxvb3BFbmRNaWxsaXNlY29uZCA8IF90aGlzLnNldHRpbmdzLmxvb3BTdGFydE1pbGxpc2Vjb25kKSB7XG4gICAgICBfdGhpcy5zZXR0aW5ncy5sb29wRW5kTWlsbGlzZWNvbmQgPSBfdGhpcy5zZXR0aW5ncy5sb29wU3RhcnRNaWxsaXNlY29uZDtcbiAgICAgIF90aGlzLmVsZW1lbnRzLmxvb3BCYXIuc3R5bGUud2lkdGggPSBcIjBweFwiO1xuICAgICAgX3RoaXMuZWxlbWVudHMucnVubmluZ0Jhci5zdHlsZS53aWR0aCA9IFwiMHB4XCI7XG4gICAgfVxuXG4gICAgX3RoaXMuZWxlbWVudHMubG9vcEVuZFRpbWUuaW5uZXJIVE1MID0gX3RoaXMuc2V0dGluZ3MubG9vcEVuZE1pbGxpc2Vjb25kO1xuICAgIF90aGlzLmVsZW1lbnRzLmxvb3BTdGFydFRpbWUuaW5uZXJIVE1MID0gX3RoaXMuc2V0dGluZ3MubG9vcFN0YXJ0TWlsbGlzZWNvbmQ7XG5cbiAgICBpZiAoX3RoaXMuc2V0dGluZ3MubG9vcFN0YXJ0TWlsbGlzZWNvbmQgPiBfdGhpcy5jbGlwLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCkge1xuICAgICAgX3RoaXMuc2V0dGluZ3MubG9vcEpvdXJuZXkgPSB0cnVlO1xuICAgIH1cbiAgfTtcblxuICBfdGhpcy5saXN0ZW5lcnMub25Nb3VzZVVwTG9vcFN0YXJ0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICBfdGhpcy5lbGVtZW50cy5saXN0ZW5lckhlbHBlci5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7IC8vIGlmIChwZSkge1xuICAgIC8vICAgX3RoaXMuZWxlbWVudHMuc2V0dGluZ3NQb2ludGVyRXZlbnRzLmNsaWNrKCk7XG4gICAgLy8gfVxuXG4gICAgX3RoaXMuc2V0dGluZ3MucmVzaXplTG9vcCA9IGZhbHNlO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIGlmIChfdGhpcy5zZXR0aW5ncy5sb29wSm91cm5leSkge1xuICAgICAgX3RoaXMuY3JlYXRlUHJvZ3Jlc3NEcmFnKF90aGlzLmVsZW1lbnRzLnJ1bm5pbmdCYXIub2Zmc2V0V2lkdGgpO1xuXG4gICAgICBfdGhpcy5zZXR0aW5ncy5sb29wSm91cm5leSA9IGZhbHNlO1xuICAgIH1cblxuICAgIF90aGlzLmVsZW1lbnRzLmxvb3BCYXIuc3R5bGUubGVmdCA9IF90aGlzLmVsZW1lbnRzLmxvb3BCYXIub2Zmc2V0TGVmdCAvIF90aGlzLmVsZW1lbnRzLnRvdGFsQmFyLm9mZnNldFdpZHRoICogMTAwICsgXCIlXCI7XG4gICAgX3RoaXMuZWxlbWVudHMubG9vcEJhci5zdHlsZS53aWR0aCA9IF90aGlzLmVsZW1lbnRzLmxvb3BCYXIub2Zmc2V0V2lkdGggLyBfdGhpcy5lbGVtZW50cy50b3RhbEJhci5vZmZzZXRXaWR0aCAqIDEwMCArIFwiJVwiO1xuICAgIF90aGlzLnNldHRpbmdzLmxvb3BTdGFydE1pbGxpc2Vjb25kID0gTWF0aC5yb3VuZChfdGhpcy5jbGlwLmR1cmF0aW9uICogX3RoaXMuZWxlbWVudHMubG9vcEJhci5vZmZzZXRMZWZ0IC8gX3RoaXMuZWxlbWVudHMudG90YWxCYXIub2Zmc2V0V2lkdGgpO1xuICAgIF90aGlzLmVsZW1lbnRzLnJ1bm5pbmdCYXIuc3R5bGUud2lkdGggPSBfdGhpcy5lbGVtZW50cy5ydW5uaW5nQmFyLm9mZnNldFdpZHRoIC8gX3RoaXMuZWxlbWVudHMubG9vcEJhci5vZmZzZXRXaWR0aCAqIDEwMCArIFwiJVwiO1xuICAgIHJlbW92ZUxpc3RlbmVyKFwibW91c2V1cFwiLCBfdGhpcy5saXN0ZW5lcnMub25Nb3VzZVVwTG9vcFN0YXJ0LCBmYWxzZSk7XG4gICAgcmVtb3ZlTGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBfdGhpcy5saXN0ZW5lcnMub25Nb3VzZVVwTG9vcFN0YXJ0LCBmYWxzZSk7XG4gICAgcmVtb3ZlTGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgX3RoaXMubGlzdGVuZXJzLm9uQ3Vyc29yTW92ZUxvb3BTdGFydCwgZmFsc2UpO1xuICAgIHJlbW92ZUxpc3RlbmVyKFwidG91Y2htb3ZlXCIsIF90aGlzLmxpc3RlbmVycy5vbkN1cnNvck1vdmVMb29wU3RhcnQsIGZhbHNlKTtcblxuICAgIF90aGlzLmVsZW1lbnRzLmxvb3BCYXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBfdGhpcy5saXN0ZW5lcnMub25Nb3VzZURvd24sIGZhbHNlKTtcblxuICAgIF90aGlzLmVsZW1lbnRzLmxvb3BCYXIuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgX3RoaXMubGlzdGVuZXJzLm9uTW91c2VEb3duLCB7XG4gICAgICBwYXNzaXZlOiB0cnVlXG4gICAgfSwgZmFsc2UpO1xuXG4gICAgaWYgKF90aGlzLnNldHRpbmdzLnBsYXlBZnRlclJlc2l6ZSkge1xuICAgICAgaWYgKF90aGlzLmNsaXAucnVuVGltZUluZm8uc3RhdGUgPT09IFwiaWRsZVwiKSB7XG4gICAgICAgIHZhciBsb29wbXM7XG5cbiAgICAgICAgaWYgKF90aGlzLmNsaXAuc3BlZWQgPj0gMCkge1xuICAgICAgICAgIGxvb3BtcyA9IF90aGlzLnNldHRpbmdzLmxvb3BTdGFydE1pbGxpc2Vjb25kICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb29wbXMgPSBfdGhpcy5zZXR0aW5ncy5sb29wRW5kTWlsbGlzZWNvbmQgLSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuc2V0dGluZ3MubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgIF90aGlzLmNyZWF0ZUpvdXJuZXkoX3RoaXMuY2xpcCwgbG9vcG1zLCB7XG4gICAgICAgICAgYmVmb3JlOiBcInBhdXNlXCIsXG4gICAgICAgICAgYWZ0ZXI6IFwicGxheVwiXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMuY2xpcC5wbGF5KCk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnNldHRpbmdzLnBsYXlBZnRlclJlc2l6ZSA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBfdGhpcy5saXN0ZW5lcnMub25Nb3VzZURvd25Mb29wU3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgIF90aGlzLmVsZW1lbnRzLmxpc3RlbmVySGVscGVyLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcImF1dG9cIjsgLy8gaWYgKCFfdGhpcy5vcHRpb25zLnBvaW50ZXJFdmVudHMpIHtcbiAgICAvLyAgIHBlID0gdHJ1ZTtcbiAgICAvLyAgIF90aGlzLmVsZW1lbnRzLnNldHRpbmdzUG9pbnRlckV2ZW50cy5jbGljaygpO1xuICAgIC8vIH1cblxuICAgIF90aGlzLnNldHRpbmdzLnJlc2l6ZUxvb3AgPSB0cnVlO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBfdGhpcy5zZXR0aW5ncy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICBpZiAoX3RoaXMuY2xpcC5ydW5UaW1lSW5mby5zdGF0ZSA9PT0gXCJwbGF5aW5nXCIpIHtcbiAgICAgIF90aGlzLmNsaXAucGF1c2UoKTtcblxuICAgICAgX3RoaXMuc2V0dGluZ3MucGxheUFmdGVyUmVzaXplID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBfdGhpcy5lbGVtZW50cy5sb29wQmFyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgX3RoaXMubGlzdGVuZXJzLm9uTW91c2VEb3duLCBmYWxzZSk7XG5cbiAgICBfdGhpcy5lbGVtZW50cy5sb29wQmFyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIF90aGlzLmxpc3RlbmVycy5vbk1vdXNlRG93biwgZmFsc2UpO1xuXG4gICAgX3RoaXMubGlzdGVuZXJzLm9uQ3Vyc29yTW92ZUxvb3BTdGFydChlKTtcblxuICAgIGFkZExpc3RlbmVyKFwibW91c2V1cFwiLCBfdGhpcy5saXN0ZW5lcnMub25Nb3VzZVVwTG9vcFN0YXJ0LCBmYWxzZSk7XG4gICAgYWRkTGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBfdGhpcy5saXN0ZW5lcnMub25Nb3VzZVVwTG9vcFN0YXJ0LCBmYWxzZSk7XG4gICAgYWRkTGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgX3RoaXMubGlzdGVuZXJzLm9uQ3Vyc29yTW92ZUxvb3BTdGFydCwgZmFsc2UpO1xuICAgIGFkZExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIF90aGlzLmxpc3RlbmVycy5vbkN1cnNvck1vdmVMb29wU3RhcnQsIGZhbHNlKTtcbiAgfTtcblxuICBfdGhpcy5lbGVtZW50cy5sb29wQmFyU3RhcnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBfdGhpcy5saXN0ZW5lcnMub25Nb3VzZURvd25Mb29wU3RhcnQsIGZhbHNlKTtcblxuICBfdGhpcy5lbGVtZW50cy5sb29wQmFyU3RhcnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgX3RoaXMubGlzdGVuZXJzLm9uTW91c2VEb3duTG9vcFN0YXJ0LCB7XG4gICAgcGFzc2l2ZTogZmFsc2VcbiAgfSwgZmFsc2UpO1xufTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex-player/dist/listeners/loopBarStart.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex-player/dist/listeners/loopBtn.js":
/*!**********************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex-player/dist/listeners/loopBtn.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _require = __webpack_require__(/*! ../helpers */ \"../node_modules/@kissmybutton/motorcortex-player/dist/helpers.js\"),\n    elid = _require.elid;\n\nmodule.exports = function (_this) {\n  _this.elements.loopButton.onclick = function () {\n    _this.settings.loopActivated = !_this.settings.loopActivated;\n\n    _this.elements.loopButton.classList.toggle(\"svg-selected\");\n\n    _this.elements.loopBarStart.classList.toggle(\"m-fadeOut\");\n\n    _this.elements.loopBarEnd.classList.toggle(\"m-fadeOut\");\n\n    _this.elements.loopBarStart.classList.toggle(\"m-fadeIn\");\n\n    _this.elements.loopBarStart.classList.toggle(\"\".concat(_this.name, \"-hide\"));\n\n    _this.elements.loopBarEnd.classList.toggle(\"m-fadeIn\");\n\n    _this.elements.loopBarEnd.classList.toggle(\"\".concat(_this.name, \"-hide\"));\n\n    elid(\"\".concat(_this.name, \"-loop-time\")).classList.toggle(\"m-fadeOut\");\n    elid(\"\".concat(_this.name, \"-loop-time\")).classList.toggle(\"m-fadeIn\");\n    elid(\"\".concat(_this.name, \"-loop-time\")).classList.toggle(\"\".concat(_this.name, \"-hide\"));\n    _this.elements.loopEndTime.innerHTML = _this.settings.loopEndMillisecond;\n    _this.elements.loopStartTime.innerHTML = _this.settings.loopStartMillisecond;\n    _this.settings.needsUpdate = true;\n\n    if (!_this.settings.loopActivated) {\n      _this.elements.loopBar.style.left = \"0%\";\n      _this.elements.loopBar.style.width = \"100%\";\n      _this.settings.loopStartMillisecond = 0;\n      _this.settings.loopEndMillisecond = _this.clip.duration;\n      _this.settings.loopLastPositionXPxls = 0;\n      _this.settings.loopLastPositionXPercentage = 0;\n      _this.elements.runningBar.style.width = _this.clip.runTimeInfo.currentMillisecond / _this.clip.duration * 100 + \"%\";\n    }\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgtcGxheWVyL2Rpc3QvbGlzdGVuZXJzL2xvb3BCdG4uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgtcGxheWVyL2Rpc3QvbGlzdGVuZXJzL2xvb3BCdG4uanM/N2ExZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4uL2hlbHBlcnNcIiksXG4gICAgZWxpZCA9IF9yZXF1aXJlLmVsaWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF90aGlzKSB7XG4gIF90aGlzLmVsZW1lbnRzLmxvb3BCdXR0b24ub25jbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICBfdGhpcy5zZXR0aW5ncy5sb29wQWN0aXZhdGVkID0gIV90aGlzLnNldHRpbmdzLmxvb3BBY3RpdmF0ZWQ7XG5cbiAgICBfdGhpcy5lbGVtZW50cy5sb29wQnV0dG9uLmNsYXNzTGlzdC50b2dnbGUoXCJzdmctc2VsZWN0ZWRcIik7XG5cbiAgICBfdGhpcy5lbGVtZW50cy5sb29wQmFyU3RhcnQuY2xhc3NMaXN0LnRvZ2dsZShcIm0tZmFkZU91dFwiKTtcblxuICAgIF90aGlzLmVsZW1lbnRzLmxvb3BCYXJFbmQuY2xhc3NMaXN0LnRvZ2dsZShcIm0tZmFkZU91dFwiKTtcblxuICAgIF90aGlzLmVsZW1lbnRzLmxvb3BCYXJTdGFydC5jbGFzc0xpc3QudG9nZ2xlKFwibS1mYWRlSW5cIik7XG5cbiAgICBfdGhpcy5lbGVtZW50cy5sb29wQmFyU3RhcnQuY2xhc3NMaXN0LnRvZ2dsZShcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1oaWRlXCIpKTtcblxuICAgIF90aGlzLmVsZW1lbnRzLmxvb3BCYXJFbmQuY2xhc3NMaXN0LnRvZ2dsZShcIm0tZmFkZUluXCIpO1xuXG4gICAgX3RoaXMuZWxlbWVudHMubG9vcEJhckVuZC5jbGFzc0xpc3QudG9nZ2xlKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLWhpZGVcIikpO1xuXG4gICAgZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1sb29wLXRpbWVcIikpLmNsYXNzTGlzdC50b2dnbGUoXCJtLWZhZGVPdXRcIik7XG4gICAgZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1sb29wLXRpbWVcIikpLmNsYXNzTGlzdC50b2dnbGUoXCJtLWZhZGVJblwiKTtcbiAgICBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLWxvb3AtdGltZVwiKSkuY2xhc3NMaXN0LnRvZ2dsZShcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1oaWRlXCIpKTtcbiAgICBfdGhpcy5lbGVtZW50cy5sb29wRW5kVGltZS5pbm5lckhUTUwgPSBfdGhpcy5zZXR0aW5ncy5sb29wRW5kTWlsbGlzZWNvbmQ7XG4gICAgX3RoaXMuZWxlbWVudHMubG9vcFN0YXJ0VGltZS5pbm5lckhUTUwgPSBfdGhpcy5zZXR0aW5ncy5sb29wU3RhcnRNaWxsaXNlY29uZDtcbiAgICBfdGhpcy5zZXR0aW5ncy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICBpZiAoIV90aGlzLnNldHRpbmdzLmxvb3BBY3RpdmF0ZWQpIHtcbiAgICAgIF90aGlzLmVsZW1lbnRzLmxvb3BCYXIuc3R5bGUubGVmdCA9IFwiMCVcIjtcbiAgICAgIF90aGlzLmVsZW1lbnRzLmxvb3BCYXIuc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcbiAgICAgIF90aGlzLnNldHRpbmdzLmxvb3BTdGFydE1pbGxpc2Vjb25kID0gMDtcbiAgICAgIF90aGlzLnNldHRpbmdzLmxvb3BFbmRNaWxsaXNlY29uZCA9IF90aGlzLmNsaXAuZHVyYXRpb247XG4gICAgICBfdGhpcy5zZXR0aW5ncy5sb29wTGFzdFBvc2l0aW9uWFB4bHMgPSAwO1xuICAgICAgX3RoaXMuc2V0dGluZ3MubG9vcExhc3RQb3NpdGlvblhQZXJjZW50YWdlID0gMDtcbiAgICAgIF90aGlzLmVsZW1lbnRzLnJ1bm5pbmdCYXIuc3R5bGUud2lkdGggPSBfdGhpcy5jbGlwLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCAvIF90aGlzLmNsaXAuZHVyYXRpb24gKiAxMDAgKyBcIiVcIjtcbiAgICB9XG4gIH07XG59OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex-player/dist/listeners/loopBtn.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex-player/dist/listeners/loopStartEnd.js":
/*!***************************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex-player/dist/listeners/loopStartEnd.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function (_this) {\n  _this.listeners.editableLoopStartTime = function () {\n    _this.elements.editableLoopStartTime.value = _this.elements.loopStartTime.innerHTML;\n\n    _this.elements.loopStartTime.replaceWith(_this.elements.editableLoopStartTime);\n\n    _this.elements.editableLoopStartTime.focus();\n  };\n\n  _this.listeners.editableLoopEndTime = function () {\n    _this.elements.editableLoopEndTime.value = _this.elements.loopEndTime.innerHTML;\n\n    _this.elements.loopEndTime.replaceWith(_this.elements.editableLoopEndTime);\n\n    _this.elements.editableLoopEndTime.focus();\n  };\n\n  _this.elements.editableLoopEndTime.onkeydown = _this.elements.editableLoopStartTime.onkeydown = function (e) {\n    e.preventDefault();\n\n    if (e.keyCode === 13) {\n      _this.elements.editableLoopStartTime.onfocusout();\n\n      _this.elements.editableLoopEndTime.onfocusout();\n    }\n\n    if (e.keyCode === 8) {\n      e.target.value = e.target.value.toString().substring(0, e.target.value.toString().length - 1);\n    }\n\n    if (e.keyCode === 13) {\n      e.target.blur();\n    }\n\n    var newValue = parseFloat((e.target.value || 0).toString() + e.key);\n\n    if (newValue > _this.clip.duration) {\n      return;\n    }\n\n    e.target.value = newValue;\n\n    if (e.target === _this.elements.editableLoopStartTime) {\n      var viewportOffset = _this.elements.totalBar.getBoundingClientRect();\n\n      var event = {\n        preventDefault: function preventDefault() {},\n        clientX: _this.elements.totalBar.offsetWidth / _this.clip.duration * e.target.value + viewportOffset.left\n      };\n\n      _this.listeners.onMouseDownLoopStart(event);\n\n      _this.listeners.onCursorMoveLoopStart(event);\n\n      _this.listeners.onMouseUpLoopStart(event);\n    } else if (e.target === _this.elements.editableLoopEndTime) {\n      var _viewportOffset = _this.elements.totalBar.getBoundingClientRect();\n\n      var _event = {\n        preventDefault: function preventDefault() {},\n        clientX: _this.elements.totalBar.offsetWidth / _this.clip.duration * e.target.value + _viewportOffset.left\n      };\n\n      _this.listeners.onMouseDownLoopEnd(_event);\n\n      _this.listeners.onCursorMoveLoopEnd(_event);\n\n      _this.listeners.onMouseUpLoopEnd(_event);\n    }\n  };\n\n  _this.elements.loopStartTime.onclick = _this.listeners.editableLoopStartTime;\n  _this.elements.loopEndTime.onclick = _this.listeners.editableLoopEndTime;\n\n  _this.elements.editableLoopStartTime.onfocusout = function () {\n    _this.elements.editableLoopStartTime.replaceWith(_this.elements.loopStartTime);\n  };\n\n  _this.elements.editableLoopEndTime.onfocusout = function () {\n    _this.elements.editableLoopEndTime.replaceWith(_this.elements.loopEndTime);\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgtcGxheWVyL2Rpc3QvbGlzdGVuZXJzL2xvb3BTdGFydEVuZC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC1wbGF5ZXIvZGlzdC9saXN0ZW5lcnMvbG9vcFN0YXJ0RW5kLmpzP2M3MTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF90aGlzKSB7XG4gIF90aGlzLmxpc3RlbmVycy5lZGl0YWJsZUxvb3BTdGFydFRpbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgX3RoaXMuZWxlbWVudHMuZWRpdGFibGVMb29wU3RhcnRUaW1lLnZhbHVlID0gX3RoaXMuZWxlbWVudHMubG9vcFN0YXJ0VGltZS5pbm5lckhUTUw7XG5cbiAgICBfdGhpcy5lbGVtZW50cy5sb29wU3RhcnRUaW1lLnJlcGxhY2VXaXRoKF90aGlzLmVsZW1lbnRzLmVkaXRhYmxlTG9vcFN0YXJ0VGltZSk7XG5cbiAgICBfdGhpcy5lbGVtZW50cy5lZGl0YWJsZUxvb3BTdGFydFRpbWUuZm9jdXMoKTtcbiAgfTtcblxuICBfdGhpcy5saXN0ZW5lcnMuZWRpdGFibGVMb29wRW5kVGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBfdGhpcy5lbGVtZW50cy5lZGl0YWJsZUxvb3BFbmRUaW1lLnZhbHVlID0gX3RoaXMuZWxlbWVudHMubG9vcEVuZFRpbWUuaW5uZXJIVE1MO1xuXG4gICAgX3RoaXMuZWxlbWVudHMubG9vcEVuZFRpbWUucmVwbGFjZVdpdGgoX3RoaXMuZWxlbWVudHMuZWRpdGFibGVMb29wRW5kVGltZSk7XG5cbiAgICBfdGhpcy5lbGVtZW50cy5lZGl0YWJsZUxvb3BFbmRUaW1lLmZvY3VzKCk7XG4gIH07XG5cbiAgX3RoaXMuZWxlbWVudHMuZWRpdGFibGVMb29wRW5kVGltZS5vbmtleWRvd24gPSBfdGhpcy5lbGVtZW50cy5lZGl0YWJsZUxvb3BTdGFydFRpbWUub25rZXlkb3duID0gZnVuY3Rpb24gKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICBpZiAoZS5rZXlDb2RlID09PSAxMykge1xuICAgICAgX3RoaXMuZWxlbWVudHMuZWRpdGFibGVMb29wU3RhcnRUaW1lLm9uZm9jdXNvdXQoKTtcblxuICAgICAgX3RoaXMuZWxlbWVudHMuZWRpdGFibGVMb29wRW5kVGltZS5vbmZvY3Vzb3V0KCk7XG4gICAgfVxuXG4gICAgaWYgKGUua2V5Q29kZSA9PT0gOCkge1xuICAgICAgZS50YXJnZXQudmFsdWUgPSBlLnRhcmdldC52YWx1ZS50b1N0cmluZygpLnN1YnN0cmluZygwLCBlLnRhcmdldC52YWx1ZS50b1N0cmluZygpLmxlbmd0aCAtIDEpO1xuICAgIH1cblxuICAgIGlmIChlLmtleUNvZGUgPT09IDEzKSB7XG4gICAgICBlLnRhcmdldC5ibHVyKCk7XG4gICAgfVxuXG4gICAgdmFyIG5ld1ZhbHVlID0gcGFyc2VGbG9hdCgoZS50YXJnZXQudmFsdWUgfHwgMCkudG9TdHJpbmcoKSArIGUua2V5KTtcblxuICAgIGlmIChuZXdWYWx1ZSA+IF90aGlzLmNsaXAuZHVyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlLnRhcmdldC52YWx1ZSA9IG5ld1ZhbHVlO1xuXG4gICAgaWYgKGUudGFyZ2V0ID09PSBfdGhpcy5lbGVtZW50cy5lZGl0YWJsZUxvb3BTdGFydFRpbWUpIHtcbiAgICAgIHZhciB2aWV3cG9ydE9mZnNldCA9IF90aGlzLmVsZW1lbnRzLnRvdGFsQmFyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICB2YXIgZXZlbnQgPSB7XG4gICAgICAgIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdCgpIHt9LFxuICAgICAgICBjbGllbnRYOiBfdGhpcy5lbGVtZW50cy50b3RhbEJhci5vZmZzZXRXaWR0aCAvIF90aGlzLmNsaXAuZHVyYXRpb24gKiBlLnRhcmdldC52YWx1ZSArIHZpZXdwb3J0T2Zmc2V0LmxlZnRcbiAgICAgIH07XG5cbiAgICAgIF90aGlzLmxpc3RlbmVycy5vbk1vdXNlRG93bkxvb3BTdGFydChldmVudCk7XG5cbiAgICAgIF90aGlzLmxpc3RlbmVycy5vbkN1cnNvck1vdmVMb29wU3RhcnQoZXZlbnQpO1xuXG4gICAgICBfdGhpcy5saXN0ZW5lcnMub25Nb3VzZVVwTG9vcFN0YXJ0KGV2ZW50KTtcbiAgICB9IGVsc2UgaWYgKGUudGFyZ2V0ID09PSBfdGhpcy5lbGVtZW50cy5lZGl0YWJsZUxvb3BFbmRUaW1lKSB7XG4gICAgICB2YXIgX3ZpZXdwb3J0T2Zmc2V0ID0gX3RoaXMuZWxlbWVudHMudG90YWxCYXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgIHZhciBfZXZlbnQgPSB7XG4gICAgICAgIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdCgpIHt9LFxuICAgICAgICBjbGllbnRYOiBfdGhpcy5lbGVtZW50cy50b3RhbEJhci5vZmZzZXRXaWR0aCAvIF90aGlzLmNsaXAuZHVyYXRpb24gKiBlLnRhcmdldC52YWx1ZSArIF92aWV3cG9ydE9mZnNldC5sZWZ0XG4gICAgICB9O1xuXG4gICAgICBfdGhpcy5saXN0ZW5lcnMub25Nb3VzZURvd25Mb29wRW5kKF9ldmVudCk7XG5cbiAgICAgIF90aGlzLmxpc3RlbmVycy5vbkN1cnNvck1vdmVMb29wRW5kKF9ldmVudCk7XG5cbiAgICAgIF90aGlzLmxpc3RlbmVycy5vbk1vdXNlVXBMb29wRW5kKF9ldmVudCk7XG4gICAgfVxuICB9O1xuXG4gIF90aGlzLmVsZW1lbnRzLmxvb3BTdGFydFRpbWUub25jbGljayA9IF90aGlzLmxpc3RlbmVycy5lZGl0YWJsZUxvb3BTdGFydFRpbWU7XG4gIF90aGlzLmVsZW1lbnRzLmxvb3BFbmRUaW1lLm9uY2xpY2sgPSBfdGhpcy5saXN0ZW5lcnMuZWRpdGFibGVMb29wRW5kVGltZTtcblxuICBfdGhpcy5lbGVtZW50cy5lZGl0YWJsZUxvb3BTdGFydFRpbWUub25mb2N1c291dCA9IGZ1bmN0aW9uICgpIHtcbiAgICBfdGhpcy5lbGVtZW50cy5lZGl0YWJsZUxvb3BTdGFydFRpbWUucmVwbGFjZVdpdGgoX3RoaXMuZWxlbWVudHMubG9vcFN0YXJ0VGltZSk7XG4gIH07XG5cbiAgX3RoaXMuZWxlbWVudHMuZWRpdGFibGVMb29wRW5kVGltZS5vbmZvY3Vzb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgIF90aGlzLmVsZW1lbnRzLmVkaXRhYmxlTG9vcEVuZFRpbWUucmVwbGFjZVdpdGgoX3RoaXMuZWxlbWVudHMubG9vcEVuZFRpbWUpO1xuICB9O1xufTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex-player/dist/listeners/loopStartEnd.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex-player/dist/listeners/preview.js":
/*!**********************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex-player/dist/listeners/preview.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _require = __webpack_require__(/*! ../helpers */ \"../node_modules/@kissmybutton/motorcortex-player/dist/helpers.js\"),\n    elid = _require.elid,\n    addListener = _require.addListener,\n    removeListener = _require.removeListener;\n\nmodule.exports = function (_this) {\n  // only on desctop devices\n  if (!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {\n    var loopBarMouseInOut = function loopBarMouseInOut() {\n      if (!_this.options.preview) {\n        return;\n      }\n\n      elid(\"\".concat(_this.name, \"-hover-display\")).classList.toggle(\"m-fadeOut\");\n      elid(\"\".concat(_this.name, \"-hover-display\")).classList.toggle(\"m-fadeIn\"); // elid(`${_this.name}-hover-display`).classList.toggle(\n      //   `${_this.name}-hide`\n      // );\n      // if (elid(`${_this.name}-hover-display`).className.includes(`m-fadeIn`)) {\n      //   _this.previewJourney = hoverTimeCapsule.startJourney(_this.previewClip);\n      // } else {\n      //   _this.previewJourney.destination();\n      // }\n\n      _this.elements.loopBar.onmousemove = loopBarMouseMove;\n    };\n\n    var loopBarAddListeners = function loopBarAddListeners() {\n      if (!_this.options.preview) {\n        return;\n      }\n\n      loopBarMouseInOut();\n      _this.elements.loopBar.onmouseover = _this.elements.loopBar.onmouseout = loopBarMouseInOut;\n      _this.elements.loopBar.onmousemove = loopBarMouseMove;\n      removeListener(\"mouseup\", loopBarAddListeners, false);\n      removeListener(\"touchend\", loopBarAddListeners, false);\n      removeListener(\"mousemove\", loopBarMouseMove, false);\n      removeListener(\"touchmove\", loopBarMouseMove, false);\n    };\n\n    _this.elements.loopBar.onmouseover = _this.elements.loopBar.onmouseout = loopBarMouseInOut;\n\n    _this.elements.loopBar.onmousedown = function () {\n      if (!_this.options.preview) {\n        return;\n      }\n\n      _this.elements.loopBar.onmouseover = _this.elements.loopBar.onmouseout = null;\n      _this.elements.loopBar.onmousemove = null;\n      addListener(\"mouseup\", loopBarAddListeners, false);\n      addListener(\"touchend\", loopBarAddListeners, false);\n      addListener(\"mousemove\", loopBarMouseMove, false);\n      addListener(\"touchmove\", loopBarMouseMove, false);\n    };\n\n    _this.elements.loopBar.onmouseup = function () {\n      if (!_this.options.preview) {\n        return;\n      }\n\n      removeListener(\"mouseup\", loopBarAddListeners, false);\n      removeListener(\"touchend\", loopBarAddListeners, false);\n      removeListener(\"mousemove\", loopBarMouseMove, false);\n      removeListener(\"touchmove\", loopBarMouseMove, false);\n      _this.elements.loopBar.onmouseover = _this.elements.loopBar.onmouseout = loopBarMouseInOut;\n      _this.elements.loopBar.onmousemove = loopBarMouseMove;\n    };\n\n    var loopBarMouseMove = function loopBarMouseMove(e) {\n      var clientX = e.clientX;\n\n      var viewportOffset = _this.elements.loopBar.getBoundingClientRect();\n\n      if (clientX - viewportOffset.left + _this.settings.loopLastPositionXPxls > _this.settings.loopLastPositionXPxls + _this.elements.loopBar.offsetWidth && !_this.settings.resizeLoop) {\n        elid(\"\".concat(_this.name, \"-hover-millisecond\")).innerHTML = _this.settings.loopEndMillisecond;\n        return;\n      } else if (clientX - viewportOffset.left < 0 && !_this.settings.resizeLoop) {\n        elid(\"\".concat(_this.name, \"-hover-millisecond\")).innerHTML = _this.settings.loopStartMillisecond;\n        return;\n      }\n\n      var positionX = clientX - viewportOffset.left + _this.settings.loopLastPositionXPxls;\n\n      if (positionX < 0) {\n        positionX = 0;\n      }\n\n      var previewWidth = elid(\"\".concat(_this.name, \"-hover-display\")).offsetWidth * _this.previewScale;\n\n      var halfPreviewWidth = previewWidth / 2;\n      var clipWidth = elid(\"\".concat(_this.name, \"-hover-display\")).offsetWidth;\n      var halfClipWidth = clipWidth / 2; // console.log(\n      //   elid(`${_this.name}-hover-display`).offsetWidth,\n      //   _this.previewScale,\n      //   positionX,\n      //   clipWidth,\n      //   halfClipWidth,\n      //   previewWidth,\n      //   halfPreviewWidth\n      // );\n\n      var left = positionX - halfClipWidth; // console.log(left, halfClipWidth);\n\n      if (positionX - halfPreviewWidth < 0) {\n        left = 0 - (previewWidth + halfPreviewWidth);\n      } else if (positionX + halfPreviewWidth > _this.elements.totalBar.offsetWidth) {\n        left = _this.elements.totalBar.offsetWidth - halfClipWidth - halfPreviewWidth;\n      }\n\n      var ms = Math.round(positionX / _this.elements.totalBar.offsetWidth * _this.clip.duration);\n\n      if (_this.options.preview) {\n        var fraction = ms / _this.clip.duration;\n\n        _this.previewClip.onProgress(fraction, ms);\n      }\n\n      elid(\"\".concat(_this.name, \"-hover-millisecond\")).innerHTML = ms;\n      elid(\"\".concat(_this.name, \"-hover-display\")).style.left = left + \"px\";\n    };\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgtcGxheWVyL2Rpc3QvbGlzdGVuZXJzL3ByZXZpZXcuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgtcGxheWVyL2Rpc3QvbGlzdGVuZXJzL3ByZXZpZXcuanM/ZGQ5YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4uL2hlbHBlcnNcIiksXG4gICAgZWxpZCA9IF9yZXF1aXJlLmVsaWQsXG4gICAgYWRkTGlzdGVuZXIgPSBfcmVxdWlyZS5hZGRMaXN0ZW5lcixcbiAgICByZW1vdmVMaXN0ZW5lciA9IF9yZXF1aXJlLnJlbW92ZUxpc3RlbmVyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfdGhpcykge1xuICAvLyBvbmx5IG9uIGRlc2N0b3AgZGV2aWNlc1xuICBpZiAoIS9BbmRyb2lkfHdlYk9TfGlQaG9uZXxpUGFkfGlQb2R8QmxhY2tCZXJyeXxJRU1vYmlsZXxPcGVyYSBNaW5pL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgIHZhciBsb29wQmFyTW91c2VJbk91dCA9IGZ1bmN0aW9uIGxvb3BCYXJNb3VzZUluT3V0KCkge1xuICAgICAgaWYgKCFfdGhpcy5vcHRpb25zLnByZXZpZXcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLWhvdmVyLWRpc3BsYXlcIikpLmNsYXNzTGlzdC50b2dnbGUoXCJtLWZhZGVPdXRcIik7XG4gICAgICBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLWhvdmVyLWRpc3BsYXlcIikpLmNsYXNzTGlzdC50b2dnbGUoXCJtLWZhZGVJblwiKTsgLy8gZWxpZChgJHtfdGhpcy5uYW1lfS1ob3Zlci1kaXNwbGF5YCkuY2xhc3NMaXN0LnRvZ2dsZShcbiAgICAgIC8vICAgYCR7X3RoaXMubmFtZX0taGlkZWBcbiAgICAgIC8vICk7XG4gICAgICAvLyBpZiAoZWxpZChgJHtfdGhpcy5uYW1lfS1ob3Zlci1kaXNwbGF5YCkuY2xhc3NOYW1lLmluY2x1ZGVzKGBtLWZhZGVJbmApKSB7XG4gICAgICAvLyAgIF90aGlzLnByZXZpZXdKb3VybmV5ID0gaG92ZXJUaW1lQ2Fwc3VsZS5zdGFydEpvdXJuZXkoX3RoaXMucHJldmlld0NsaXApO1xuICAgICAgLy8gfSBlbHNlIHtcbiAgICAgIC8vICAgX3RoaXMucHJldmlld0pvdXJuZXkuZGVzdGluYXRpb24oKTtcbiAgICAgIC8vIH1cblxuICAgICAgX3RoaXMuZWxlbWVudHMubG9vcEJhci5vbm1vdXNlbW92ZSA9IGxvb3BCYXJNb3VzZU1vdmU7XG4gICAgfTtcblxuICAgIHZhciBsb29wQmFyQWRkTGlzdGVuZXJzID0gZnVuY3Rpb24gbG9vcEJhckFkZExpc3RlbmVycygpIHtcbiAgICAgIGlmICghX3RoaXMub3B0aW9ucy5wcmV2aWV3KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbG9vcEJhck1vdXNlSW5PdXQoKTtcbiAgICAgIF90aGlzLmVsZW1lbnRzLmxvb3BCYXIub25tb3VzZW92ZXIgPSBfdGhpcy5lbGVtZW50cy5sb29wQmFyLm9ubW91c2VvdXQgPSBsb29wQmFyTW91c2VJbk91dDtcbiAgICAgIF90aGlzLmVsZW1lbnRzLmxvb3BCYXIub25tb3VzZW1vdmUgPSBsb29wQmFyTW91c2VNb3ZlO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoXCJtb3VzZXVwXCIsIGxvb3BCYXJBZGRMaXN0ZW5lcnMsIGZhbHNlKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKFwidG91Y2hlbmRcIiwgbG9vcEJhckFkZExpc3RlbmVycywgZmFsc2UpO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgbG9vcEJhck1vdXNlTW92ZSwgZmFsc2UpO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgbG9vcEJhck1vdXNlTW92ZSwgZmFsc2UpO1xuICAgIH07XG5cbiAgICBfdGhpcy5lbGVtZW50cy5sb29wQmFyLm9ubW91c2VvdmVyID0gX3RoaXMuZWxlbWVudHMubG9vcEJhci5vbm1vdXNlb3V0ID0gbG9vcEJhck1vdXNlSW5PdXQ7XG5cbiAgICBfdGhpcy5lbGVtZW50cy5sb29wQmFyLm9ubW91c2Vkb3duID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFfdGhpcy5vcHRpb25zLnByZXZpZXcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5lbGVtZW50cy5sb29wQmFyLm9ubW91c2VvdmVyID0gX3RoaXMuZWxlbWVudHMubG9vcEJhci5vbm1vdXNlb3V0ID0gbnVsbDtcbiAgICAgIF90aGlzLmVsZW1lbnRzLmxvb3BCYXIub25tb3VzZW1vdmUgPSBudWxsO1xuICAgICAgYWRkTGlzdGVuZXIoXCJtb3VzZXVwXCIsIGxvb3BCYXJBZGRMaXN0ZW5lcnMsIGZhbHNlKTtcbiAgICAgIGFkZExpc3RlbmVyKFwidG91Y2hlbmRcIiwgbG9vcEJhckFkZExpc3RlbmVycywgZmFsc2UpO1xuICAgICAgYWRkTGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgbG9vcEJhck1vdXNlTW92ZSwgZmFsc2UpO1xuICAgICAgYWRkTGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgbG9vcEJhck1vdXNlTW92ZSwgZmFsc2UpO1xuICAgIH07XG5cbiAgICBfdGhpcy5lbGVtZW50cy5sb29wQmFyLm9ubW91c2V1cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghX3RoaXMub3B0aW9ucy5wcmV2aWV3KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVtb3ZlTGlzdGVuZXIoXCJtb3VzZXVwXCIsIGxvb3BCYXJBZGRMaXN0ZW5lcnMsIGZhbHNlKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKFwidG91Y2hlbmRcIiwgbG9vcEJhckFkZExpc3RlbmVycywgZmFsc2UpO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgbG9vcEJhck1vdXNlTW92ZSwgZmFsc2UpO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgbG9vcEJhck1vdXNlTW92ZSwgZmFsc2UpO1xuICAgICAgX3RoaXMuZWxlbWVudHMubG9vcEJhci5vbm1vdXNlb3ZlciA9IF90aGlzLmVsZW1lbnRzLmxvb3BCYXIub25tb3VzZW91dCA9IGxvb3BCYXJNb3VzZUluT3V0O1xuICAgICAgX3RoaXMuZWxlbWVudHMubG9vcEJhci5vbm1vdXNlbW92ZSA9IGxvb3BCYXJNb3VzZU1vdmU7XG4gICAgfTtcblxuICAgIHZhciBsb29wQmFyTW91c2VNb3ZlID0gZnVuY3Rpb24gbG9vcEJhck1vdXNlTW92ZShlKSB7XG4gICAgICB2YXIgY2xpZW50WCA9IGUuY2xpZW50WDtcblxuICAgICAgdmFyIHZpZXdwb3J0T2Zmc2V0ID0gX3RoaXMuZWxlbWVudHMubG9vcEJhci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgaWYgKGNsaWVudFggLSB2aWV3cG9ydE9mZnNldC5sZWZ0ICsgX3RoaXMuc2V0dGluZ3MubG9vcExhc3RQb3NpdGlvblhQeGxzID4gX3RoaXMuc2V0dGluZ3MubG9vcExhc3RQb3NpdGlvblhQeGxzICsgX3RoaXMuZWxlbWVudHMubG9vcEJhci5vZmZzZXRXaWR0aCAmJiAhX3RoaXMuc2V0dGluZ3MucmVzaXplTG9vcCkge1xuICAgICAgICBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLWhvdmVyLW1pbGxpc2Vjb25kXCIpKS5pbm5lckhUTUwgPSBfdGhpcy5zZXR0aW5ncy5sb29wRW5kTWlsbGlzZWNvbmQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAoY2xpZW50WCAtIHZpZXdwb3J0T2Zmc2V0LmxlZnQgPCAwICYmICFfdGhpcy5zZXR0aW5ncy5yZXNpemVMb29wKSB7XG4gICAgICAgIGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItaG92ZXItbWlsbGlzZWNvbmRcIikpLmlubmVySFRNTCA9IF90aGlzLnNldHRpbmdzLmxvb3BTdGFydE1pbGxpc2Vjb25kO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBwb3NpdGlvblggPSBjbGllbnRYIC0gdmlld3BvcnRPZmZzZXQubGVmdCArIF90aGlzLnNldHRpbmdzLmxvb3BMYXN0UG9zaXRpb25YUHhscztcblxuICAgICAgaWYgKHBvc2l0aW9uWCA8IDApIHtcbiAgICAgICAgcG9zaXRpb25YID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIHByZXZpZXdXaWR0aCA9IGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItaG92ZXItZGlzcGxheVwiKSkub2Zmc2V0V2lkdGggKiBfdGhpcy5wcmV2aWV3U2NhbGU7XG5cbiAgICAgIHZhciBoYWxmUHJldmlld1dpZHRoID0gcHJldmlld1dpZHRoIC8gMjtcbiAgICAgIHZhciBjbGlwV2lkdGggPSBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLWhvdmVyLWRpc3BsYXlcIikpLm9mZnNldFdpZHRoO1xuICAgICAgdmFyIGhhbGZDbGlwV2lkdGggPSBjbGlwV2lkdGggLyAyOyAvLyBjb25zb2xlLmxvZyhcbiAgICAgIC8vICAgZWxpZChgJHtfdGhpcy5uYW1lfS1ob3Zlci1kaXNwbGF5YCkub2Zmc2V0V2lkdGgsXG4gICAgICAvLyAgIF90aGlzLnByZXZpZXdTY2FsZSxcbiAgICAgIC8vICAgcG9zaXRpb25YLFxuICAgICAgLy8gICBjbGlwV2lkdGgsXG4gICAgICAvLyAgIGhhbGZDbGlwV2lkdGgsXG4gICAgICAvLyAgIHByZXZpZXdXaWR0aCxcbiAgICAgIC8vICAgaGFsZlByZXZpZXdXaWR0aFxuICAgICAgLy8gKTtcblxuICAgICAgdmFyIGxlZnQgPSBwb3NpdGlvblggLSBoYWxmQ2xpcFdpZHRoOyAvLyBjb25zb2xlLmxvZyhsZWZ0LCBoYWxmQ2xpcFdpZHRoKTtcblxuICAgICAgaWYgKHBvc2l0aW9uWCAtIGhhbGZQcmV2aWV3V2lkdGggPCAwKSB7XG4gICAgICAgIGxlZnQgPSAwIC0gKHByZXZpZXdXaWR0aCArIGhhbGZQcmV2aWV3V2lkdGgpO1xuICAgICAgfSBlbHNlIGlmIChwb3NpdGlvblggKyBoYWxmUHJldmlld1dpZHRoID4gX3RoaXMuZWxlbWVudHMudG90YWxCYXIub2Zmc2V0V2lkdGgpIHtcbiAgICAgICAgbGVmdCA9IF90aGlzLmVsZW1lbnRzLnRvdGFsQmFyLm9mZnNldFdpZHRoIC0gaGFsZkNsaXBXaWR0aCAtIGhhbGZQcmV2aWV3V2lkdGg7XG4gICAgICB9XG5cbiAgICAgIHZhciBtcyA9IE1hdGgucm91bmQocG9zaXRpb25YIC8gX3RoaXMuZWxlbWVudHMudG90YWxCYXIub2Zmc2V0V2lkdGggKiBfdGhpcy5jbGlwLmR1cmF0aW9uKTtcblxuICAgICAgaWYgKF90aGlzLm9wdGlvbnMucHJldmlldykge1xuICAgICAgICB2YXIgZnJhY3Rpb24gPSBtcyAvIF90aGlzLmNsaXAuZHVyYXRpb247XG5cbiAgICAgICAgX3RoaXMucHJldmlld0NsaXAub25Qcm9ncmVzcyhmcmFjdGlvbiwgbXMpO1xuICAgICAgfVxuXG4gICAgICBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLWhvdmVyLW1pbGxpc2Vjb25kXCIpKS5pbm5lckhUTUwgPSBtcztcbiAgICAgIGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItaG92ZXItZGlzcGxheVwiKSkuc3R5bGUubGVmdCA9IGxlZnQgKyBcInB4XCI7XG4gICAgfTtcbiAgfVxufTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex-player/dist/listeners/preview.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex-player/dist/listeners/progressBar.js":
/*!**************************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex-player/dist/listeners/progressBar.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _require = __webpack_require__(/*! ../helpers */ \"../node_modules/@kissmybutton/motorcortex-player/dist/helpers.js\"),\n    addListener = _require.addListener,\n    removeListener = _require.removeListener;\n\nmodule.exports = function (_this) {\n  // let pe = false;\n  _this.listeners.onCursorMove = function (e) {\n    e.preventDefault();\n    var clientX = e.clientX || ((e.touches || [])[0] || {}).clientX;\n\n    var viewportOffset = _this.elements.loopBar.getBoundingClientRect();\n\n    var positionX = clientX - viewportOffset.left;\n\n    if (positionX < 0) {\n      positionX = 0;\n    } else if (positionX > _this.elements.loopBar.offsetWidth) {\n      positionX = _this.elements.loopBar.offsetWidth;\n    }\n\n    _this.handleDrag(positionX);\n  };\n\n  _this.listeners.onMouseUp = function () {\n    _this.elements.listenerHelper.style.pointerEvents = \"none\";\n    removeListener(\"mouseup\", _this.listeners.onMouseUp, false);\n    removeListener(\"touchend\", _this.listeners.onMouseUp, false);\n    removeListener(\"mousemove\", _this.listeners.onCursorMove, false);\n    removeListener(\"touchmove\", _this.listeners.onCursorMove, false);\n\n    _this.handleDragEnd(_this.settings);\n  };\n\n  _this.listeners.onMouseDown = function (e) {\n    _this.elements.listenerHelper.style.pointerEvents = \"auto\";\n\n    if (_this.clip.runTimeInfo.state === \"playing\") {\n      _this.settings.playAfterResize = true;\n    }\n\n    _this.handleDragStart(_this.clip);\n\n    _this.listeners.onCursorMove(e);\n\n    addListener(\"mouseup\", _this.listeners.onMouseUp, false);\n    addListener(\"touchend\", _this.listeners.onMouseUp, false);\n    addListener(\"mousemove\", _this.listeners.onCursorMove, false);\n    addListener(\"touchmove\", _this.listeners.onCursorMove, false);\n  };\n\n  _this.elements.loopBar.addEventListener(\"mousedown\", _this.listeners.onMouseDown, false);\n\n  _this.elements.loopBar.addEventListener(\"touchstart\", _this.listeners.onMouseDown, {\n    passive: false\n  }, false);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgtcGxheWVyL2Rpc3QvbGlzdGVuZXJzL3Byb2dyZXNzQmFyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4LXBsYXllci9kaXN0L2xpc3RlbmVycy9wcm9ncmVzc0Jhci5qcz80NzU3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiLi4vaGVscGVyc1wiKSxcbiAgICBhZGRMaXN0ZW5lciA9IF9yZXF1aXJlLmFkZExpc3RlbmVyLFxuICAgIHJlbW92ZUxpc3RlbmVyID0gX3JlcXVpcmUucmVtb3ZlTGlzdGVuZXI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF90aGlzKSB7XG4gIC8vIGxldCBwZSA9IGZhbHNlO1xuICBfdGhpcy5saXN0ZW5lcnMub25DdXJzb3JNb3ZlID0gZnVuY3Rpb24gKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdmFyIGNsaWVudFggPSBlLmNsaWVudFggfHwgKChlLnRvdWNoZXMgfHwgW10pWzBdIHx8IHt9KS5jbGllbnRYO1xuXG4gICAgdmFyIHZpZXdwb3J0T2Zmc2V0ID0gX3RoaXMuZWxlbWVudHMubG9vcEJhci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgIHZhciBwb3NpdGlvblggPSBjbGllbnRYIC0gdmlld3BvcnRPZmZzZXQubGVmdDtcblxuICAgIGlmIChwb3NpdGlvblggPCAwKSB7XG4gICAgICBwb3NpdGlvblggPSAwO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb25YID4gX3RoaXMuZWxlbWVudHMubG9vcEJhci5vZmZzZXRXaWR0aCkge1xuICAgICAgcG9zaXRpb25YID0gX3RoaXMuZWxlbWVudHMubG9vcEJhci5vZmZzZXRXaWR0aDtcbiAgICB9XG5cbiAgICBfdGhpcy5oYW5kbGVEcmFnKHBvc2l0aW9uWCk7XG4gIH07XG5cbiAgX3RoaXMubGlzdGVuZXJzLm9uTW91c2VVcCA9IGZ1bmN0aW9uICgpIHtcbiAgICBfdGhpcy5lbGVtZW50cy5saXN0ZW5lckhlbHBlci5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XG4gICAgcmVtb3ZlTGlzdGVuZXIoXCJtb3VzZXVwXCIsIF90aGlzLmxpc3RlbmVycy5vbk1vdXNlVXAsIGZhbHNlKTtcbiAgICByZW1vdmVMaXN0ZW5lcihcInRvdWNoZW5kXCIsIF90aGlzLmxpc3RlbmVycy5vbk1vdXNlVXAsIGZhbHNlKTtcbiAgICByZW1vdmVMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBfdGhpcy5saXN0ZW5lcnMub25DdXJzb3JNb3ZlLCBmYWxzZSk7XG4gICAgcmVtb3ZlTGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgX3RoaXMubGlzdGVuZXJzLm9uQ3Vyc29yTW92ZSwgZmFsc2UpO1xuXG4gICAgX3RoaXMuaGFuZGxlRHJhZ0VuZChfdGhpcy5zZXR0aW5ncyk7XG4gIH07XG5cbiAgX3RoaXMubGlzdGVuZXJzLm9uTW91c2VEb3duID0gZnVuY3Rpb24gKGUpIHtcbiAgICBfdGhpcy5lbGVtZW50cy5saXN0ZW5lckhlbHBlci5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJhdXRvXCI7XG5cbiAgICBpZiAoX3RoaXMuY2xpcC5ydW5UaW1lSW5mby5zdGF0ZSA9PT0gXCJwbGF5aW5nXCIpIHtcbiAgICAgIF90aGlzLnNldHRpbmdzLnBsYXlBZnRlclJlc2l6ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgX3RoaXMuaGFuZGxlRHJhZ1N0YXJ0KF90aGlzLmNsaXApO1xuXG4gICAgX3RoaXMubGlzdGVuZXJzLm9uQ3Vyc29yTW92ZShlKTtcblxuICAgIGFkZExpc3RlbmVyKFwibW91c2V1cFwiLCBfdGhpcy5saXN0ZW5lcnMub25Nb3VzZVVwLCBmYWxzZSk7XG4gICAgYWRkTGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBfdGhpcy5saXN0ZW5lcnMub25Nb3VzZVVwLCBmYWxzZSk7XG4gICAgYWRkTGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgX3RoaXMubGlzdGVuZXJzLm9uQ3Vyc29yTW92ZSwgZmFsc2UpO1xuICAgIGFkZExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIF90aGlzLmxpc3RlbmVycy5vbkN1cnNvck1vdmUsIGZhbHNlKTtcbiAgfTtcblxuICBfdGhpcy5lbGVtZW50cy5sb29wQmFyLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgX3RoaXMubGlzdGVuZXJzLm9uTW91c2VEb3duLCBmYWxzZSk7XG5cbiAgX3RoaXMuZWxlbWVudHMubG9vcEJhci5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCBfdGhpcy5saXN0ZW5lcnMub25Nb3VzZURvd24sIHtcbiAgICBwYXNzaXZlOiBmYWxzZVxuICB9LCBmYWxzZSk7XG59OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex-player/dist/listeners/progressBar.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex-player/dist/listeners/settings.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex-player/dist/listeners/settings.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _require = __webpack_require__(/*! ../helpers */ \"../node_modules/@kissmybutton/motorcortex-player/dist/helpers.js\"),\n    elid = _require.elid,\n    addListener = _require.addListener,\n    removeListener = _require.removeListener;\n\nmodule.exports = function (_this) {\n  _this.elements.settingsShowIndicator.onclick = function (e) {\n    e.preventDefault();\n    var checkbox = elid(\"\".concat(_this.name, \"-show-indicator-checkbox\"));\n\n    if (checkbox.checked) {\n      checkbox.checked = false;\n      _this.elements.indicator.style.visibility = \"hidden\";\n    } else {\n      checkbox.checked = true;\n      _this.elements.indicator.style.visibility = \"visible\";\n    }\n  };\n\n  _this.elements.settingsPointerEvents.onclick = function (e) {\n    e.preventDefault();\n    var checkbox = elid(\"\".concat(_this.name, \"-pointer-events-checkbox\"));\n\n    if (checkbox.checked) {\n      checkbox.checked = false;\n      _this.options.pointerEvents = false;\n      _this.elements.mcPlayer.style.pointerEvents = \"none\";\n      _this.elements.pointerEventPanel.style.pointerEvents = \"none\";\n      elid(\"\".concat(_this.name, \"-controls\")).style.pointerEvents = \"auto\";\n      _this.elements.settingsPanel.style.pointerEvents = \"auto\";\n    } else {\n      checkbox.checked = true;\n      _this.elements.mcPlayer.style.pointerEvents = \"none\";\n      _this.elements.pointerEventPanel.style.pointerEvents = \"auto\";\n      elid(\"\".concat(_this.name, \"-controls\")).style.pointerEvents = \"auto\";\n      _this.elements.settingsPanel.style.pointerEvents = \"auto\";\n    }\n  };\n\n  _this.elements.settingsShowVolume.onclick = function (e) {\n    e.preventDefault();\n\n    _this.elements.volumeControl.classList.toggle(\"\".concat(_this.name, \"-volume-width-transition\"));\n\n    _this.elements.volumeControl.classList.toggle(\"\".concat(_this.name, \"-hide\"));\n\n    var checkbox = elid(\"\".concat(_this.name, \"-show-volume-checkbox\"));\n\n    if (checkbox.checked) {\n      checkbox.checked = false;\n      _this.elements.volumeControl.style.visibility = \"hidden\";\n      _this.elements.timeDisplay.style.left = \"45px\";\n    } else {\n      checkbox.checked = true;\n      _this.elements.volumeControl.style.visibility = \"visible\";\n      _this.elements.timeDisplay.style.left = \"\";\n    }\n  };\n\n  _this.elements.settingsShowPreview.onclick = function (e) {\n    e.preventDefault();\n    var checkbox = elid(\"\".concat(_this.name, \"-show-preview-checkbox\"));\n\n    if (checkbox.checked) {\n      checkbox.checked = false;\n      elid(\"\".concat(_this.name, \"-hover-display\")).style.visibility = \"hidden\";\n      elid(\"\".concat(_this.name, \"-hover-display\")).style.display = \"none\";\n      _this.options.preview = false;\n    } else {\n      if (!_this.previewClip) {\n        _this.createPreviewDisplay();\n      }\n\n      checkbox.checked = true;\n      elid(\"\".concat(_this.name, \"-hover-display\")).style.visibility = \"visible\";\n      elid(\"\".concat(_this.name, \"-hover-display\")).style.display = \"flex\";\n      _this.options.preview = true;\n    }\n  };\n\n  _this.elements.settingsButton.onclick = function (e) {\n    e.preventDefault();\n\n    var showHideSettings = function showHideSettings(e) {\n      if (_this.elements.settingsPanel.contains(e.target)) {\n        return true;\n      }\n\n      _this.elements.settingsPanel.classList.toggle(\"\".concat(_this.name, \"-hide\"));\n\n      _this.elements.settingsPanel.classList.toggle(\"m-fadeOut\");\n\n      _this.elements.settingsPanel.classList.toggle(\"m-fadeIn\");\n\n      if (_this.elements.settingsPanel.className.includes(\"m-fadeOut\")) {\n        removeListener(\"click\", showHideSettings, false);\n      }\n    };\n\n    if (_this.elements.settingsPanel.className.includes(\"m-fadeOut\")) {\n      addListener(\"click\", showHideSettings, false);\n    } else {\n      removeListener(\"click\", showHideSettings, false);\n    }\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgtcGxheWVyL2Rpc3QvbGlzdGVuZXJzL3NldHRpbmdzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4LXBsYXllci9kaXN0L2xpc3RlbmVycy9zZXR0aW5ncy5qcz9kMjUxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiLi4vaGVscGVyc1wiKSxcbiAgICBlbGlkID0gX3JlcXVpcmUuZWxpZCxcbiAgICBhZGRMaXN0ZW5lciA9IF9yZXF1aXJlLmFkZExpc3RlbmVyLFxuICAgIHJlbW92ZUxpc3RlbmVyID0gX3JlcXVpcmUucmVtb3ZlTGlzdGVuZXI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF90aGlzKSB7XG4gIF90aGlzLmVsZW1lbnRzLnNldHRpbmdzU2hvd0luZGljYXRvci5vbmNsaWNrID0gZnVuY3Rpb24gKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdmFyIGNoZWNrYm94ID0gZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1zaG93LWluZGljYXRvci1jaGVja2JveFwiKSk7XG5cbiAgICBpZiAoY2hlY2tib3guY2hlY2tlZCkge1xuICAgICAgY2hlY2tib3guY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgX3RoaXMuZWxlbWVudHMuaW5kaWNhdG9yLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGVja2JveC5jaGVja2VkID0gdHJ1ZTtcbiAgICAgIF90aGlzLmVsZW1lbnRzLmluZGljYXRvci5zdHlsZS52aXNpYmlsaXR5ID0gXCJ2aXNpYmxlXCI7XG4gICAgfVxuICB9O1xuXG4gIF90aGlzLmVsZW1lbnRzLnNldHRpbmdzUG9pbnRlckV2ZW50cy5vbmNsaWNrID0gZnVuY3Rpb24gKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdmFyIGNoZWNrYm94ID0gZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1wb2ludGVyLWV2ZW50cy1jaGVja2JveFwiKSk7XG5cbiAgICBpZiAoY2hlY2tib3guY2hlY2tlZCkge1xuICAgICAgY2hlY2tib3guY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgX3RoaXMub3B0aW9ucy5wb2ludGVyRXZlbnRzID0gZmFsc2U7XG4gICAgICBfdGhpcy5lbGVtZW50cy5tY1BsYXllci5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XG4gICAgICBfdGhpcy5lbGVtZW50cy5wb2ludGVyRXZlbnRQYW5lbC5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XG4gICAgICBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLWNvbnRyb2xzXCIpKS5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJhdXRvXCI7XG4gICAgICBfdGhpcy5lbGVtZW50cy5zZXR0aW5nc1BhbmVsLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcImF1dG9cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hlY2tib3guY2hlY2tlZCA9IHRydWU7XG4gICAgICBfdGhpcy5lbGVtZW50cy5tY1BsYXllci5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XG4gICAgICBfdGhpcy5lbGVtZW50cy5wb2ludGVyRXZlbnRQYW5lbC5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJhdXRvXCI7XG4gICAgICBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLWNvbnRyb2xzXCIpKS5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJhdXRvXCI7XG4gICAgICBfdGhpcy5lbGVtZW50cy5zZXR0aW5nc1BhbmVsLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcImF1dG9cIjtcbiAgICB9XG4gIH07XG5cbiAgX3RoaXMuZWxlbWVudHMuc2V0dGluZ3NTaG93Vm9sdW1lLm9uY2xpY2sgPSBmdW5jdGlvbiAoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIF90aGlzLmVsZW1lbnRzLnZvbHVtZUNvbnRyb2wuY2xhc3NMaXN0LnRvZ2dsZShcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi12b2x1bWUtd2lkdGgtdHJhbnNpdGlvblwiKSk7XG5cbiAgICBfdGhpcy5lbGVtZW50cy52b2x1bWVDb250cm9sLmNsYXNzTGlzdC50b2dnbGUoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItaGlkZVwiKSk7XG5cbiAgICB2YXIgY2hlY2tib3ggPSBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLXNob3ctdm9sdW1lLWNoZWNrYm94XCIpKTtcblxuICAgIGlmIChjaGVja2JveC5jaGVja2VkKSB7XG4gICAgICBjaGVja2JveC5jaGVja2VkID0gZmFsc2U7XG4gICAgICBfdGhpcy5lbGVtZW50cy52b2x1bWVDb250cm9sLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgICAgX3RoaXMuZWxlbWVudHMudGltZURpc3BsYXkuc3R5bGUubGVmdCA9IFwiNDVweFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGVja2JveC5jaGVja2VkID0gdHJ1ZTtcbiAgICAgIF90aGlzLmVsZW1lbnRzLnZvbHVtZUNvbnRyb2wuc3R5bGUudmlzaWJpbGl0eSA9IFwidmlzaWJsZVwiO1xuICAgICAgX3RoaXMuZWxlbWVudHMudGltZURpc3BsYXkuc3R5bGUubGVmdCA9IFwiXCI7XG4gICAgfVxuICB9O1xuXG4gIF90aGlzLmVsZW1lbnRzLnNldHRpbmdzU2hvd1ByZXZpZXcub25jbGljayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHZhciBjaGVja2JveCA9IGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItc2hvdy1wcmV2aWV3LWNoZWNrYm94XCIpKTtcblxuICAgIGlmIChjaGVja2JveC5jaGVja2VkKSB7XG4gICAgICBjaGVja2JveC5jaGVja2VkID0gZmFsc2U7XG4gICAgICBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLWhvdmVyLWRpc3BsYXlcIikpLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgICAgZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1ob3Zlci1kaXNwbGF5XCIpKS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICBfdGhpcy5vcHRpb25zLnByZXZpZXcgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFfdGhpcy5wcmV2aWV3Q2xpcCkge1xuICAgICAgICBfdGhpcy5jcmVhdGVQcmV2aWV3RGlzcGxheSgpO1xuICAgICAgfVxuXG4gICAgICBjaGVja2JveC5jaGVja2VkID0gdHJ1ZTtcbiAgICAgIGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItaG92ZXItZGlzcGxheVwiKSkuc3R5bGUudmlzaWJpbGl0eSA9IFwidmlzaWJsZVwiO1xuICAgICAgZWxpZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1ob3Zlci1kaXNwbGF5XCIpKS5zdHlsZS5kaXNwbGF5ID0gXCJmbGV4XCI7XG4gICAgICBfdGhpcy5vcHRpb25zLnByZXZpZXcgPSB0cnVlO1xuICAgIH1cbiAgfTtcblxuICBfdGhpcy5lbGVtZW50cy5zZXR0aW5nc0J1dHRvbi5vbmNsaWNrID0gZnVuY3Rpb24gKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICB2YXIgc2hvd0hpZGVTZXR0aW5ncyA9IGZ1bmN0aW9uIHNob3dIaWRlU2V0dGluZ3MoZSkge1xuICAgICAgaWYgKF90aGlzLmVsZW1lbnRzLnNldHRpbmdzUGFuZWwuY29udGFpbnMoZS50YXJnZXQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5lbGVtZW50cy5zZXR0aW5nc1BhbmVsLmNsYXNzTGlzdC50b2dnbGUoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItaGlkZVwiKSk7XG5cbiAgICAgIF90aGlzLmVsZW1lbnRzLnNldHRpbmdzUGFuZWwuY2xhc3NMaXN0LnRvZ2dsZShcIm0tZmFkZU91dFwiKTtcblxuICAgICAgX3RoaXMuZWxlbWVudHMuc2V0dGluZ3NQYW5lbC5jbGFzc0xpc3QudG9nZ2xlKFwibS1mYWRlSW5cIik7XG5cbiAgICAgIGlmIChfdGhpcy5lbGVtZW50cy5zZXR0aW5nc1BhbmVsLmNsYXNzTmFtZS5pbmNsdWRlcyhcIm0tZmFkZU91dFwiKSkge1xuICAgICAgICByZW1vdmVMaXN0ZW5lcihcImNsaWNrXCIsIHNob3dIaWRlU2V0dGluZ3MsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKF90aGlzLmVsZW1lbnRzLnNldHRpbmdzUGFuZWwuY2xhc3NOYW1lLmluY2x1ZGVzKFwibS1mYWRlT3V0XCIpKSB7XG4gICAgICBhZGRMaXN0ZW5lcihcImNsaWNrXCIsIHNob3dIaWRlU2V0dGluZ3MsIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoXCJjbGlja1wiLCBzaG93SGlkZVNldHRpbmdzLCBmYWxzZSk7XG4gICAgfVxuICB9O1xufTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex-player/dist/listeners/settings.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex-player/dist/listeners/speed.js":
/*!********************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex-player/dist/listeners/speed.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _require = __webpack_require__(/*! ../helpers */ \"../node_modules/@kissmybutton/motorcortex-player/dist/helpers.js\"),\n    elid = _require.elid,\n    addListener = _require.addListener,\n    removeListener = _require.removeListener;\n\nmodule.exports = function (_this) {\n  // const pe = false;\n  _this.elements.settingsSpeedButtonShow.onclick = _this.elements.settingsSpeedButtonHide.onclick = function (e) {\n    e.preventDefault();\n\n    _this.elements.settingsPanel.classList.toggle(\"\".concat(_this.name, \"-settings-speed-panel\"));\n\n    var includesClass = _this.elements.settingsPanel.className.includes(\"\".concat(_this.name, \"-settings-speed-panel\"));\n\n    if (includesClass) {\n      _this.elements.settingsMainPanel.style.display = \"none\";\n      _this.elements.settingsSpeedPanel.style.display = \"block\";\n    } else {\n      _this.elements.settingsSpeedPanel.style.display = \"none\";\n      _this.elements.settingsMainPanel.style.display = \"block\";\n    }\n  };\n\n  var onCursorMoveSpeedBar = function onCursorMoveSpeedBar(e) {\n    e.preventDefault();\n\n    var viewportOffset = _this.elements.speedBar.getBoundingClientRect();\n\n    var clientY = e.clientY || ((e.touches || [])[0] || {}).clientY;\n    var positionY = clientY - viewportOffset.top;\n    positionY -= 8;\n\n    if (positionY < 0) {\n      positionY = 0;\n    } else if (positionY > _this.elements.speedBar.offsetHeight - 16) {\n      positionY = _this.elements.speedBar.offsetHeight - 16;\n    }\n\n    positionY = Math.floor(positionY); // show speed\n\n    var percentage = (positionY / ((_this.options.speedValues.length - 1) * 16) - 1) * -1;\n    var step = 1 / (_this.options.speedValues.length - 1);\n\n    var speed = _this.calculateSpeed(step, _this.options.speedValues, percentage);\n\n    elid(\"\".concat(_this.name, \"-speed-runtime\")).innerHTML = speed + \"0\";\n    elid(\"\".concat(_this.name, \"-speed-cursor\")).style.top = positionY + \"px\";\n    _this.clip.executionSpeed = speed;\n  };\n\n  var onMouseUpSpeedBar = function onMouseUpSpeedBar(e) {\n    // if (pe) {\n    //   _this.elements.settingsPointerEvents.click();\n    // }\n    _this.elements.listenerHelper.style.pointerEvents = \"none\";\n    e.preventDefault();\n    removeListener(\"mouseup\", onMouseUpSpeedBar, false);\n    removeListener(\"touchend\", onMouseUpSpeedBar, false);\n    removeListener(\"mousemove\", onCursorMoveSpeedBar, false);\n    removeListener(\"touchmove\", onCursorMoveSpeedBar, false);\n    elid(\"\".concat(_this.name, \"-speed-runtime\")).innerHTML = \"Speed\";\n    var speedDisplay;\n    _this.clip.speed == 1 ? speedDisplay = \"Normal\" : speedDisplay = _this.clip.speed;\n    _this.elements.speedCurrent.innerHTML = speedDisplay;\n  };\n\n  var onMouseDownSpeedBar = function onMouseDownSpeedBar(e) {\n    // if (!_this.options.pointerEvents) {\n    //   pe = true;\n    //   _this.elements.settingsPointerEvents.click();\n    // }\n    _this.elements.listenerHelper.style.pointerEvents = \"auto\";\n    e.preventDefault();\n    onCursorMoveSpeedBar(e);\n    addListener(\"mouseup\", onMouseUpSpeedBar, false);\n    addListener(\"touchend\", onMouseUpSpeedBar, false);\n    addListener(\"mousemove\", onCursorMoveSpeedBar, false);\n    addListener(\"touchmove\", onCursorMoveSpeedBar, false);\n  };\n\n  _this.elements.speedBarHelper.addEventListener(\"mousedown\", onMouseDownSpeedBar, false);\n\n  _this.elements.speedBarHelper.addEventListener(\"touchstart\", onMouseDownSpeedBar, {\n    passive: false\n  }, false);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgtcGxheWVyL2Rpc3QvbGlzdGVuZXJzL3NwZWVkLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4LXBsYXllci9kaXN0L2xpc3RlbmVycy9zcGVlZC5qcz9hNDc5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiLi4vaGVscGVyc1wiKSxcbiAgICBlbGlkID0gX3JlcXVpcmUuZWxpZCxcbiAgICBhZGRMaXN0ZW5lciA9IF9yZXF1aXJlLmFkZExpc3RlbmVyLFxuICAgIHJlbW92ZUxpc3RlbmVyID0gX3JlcXVpcmUucmVtb3ZlTGlzdGVuZXI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF90aGlzKSB7XG4gIC8vIGNvbnN0IHBlID0gZmFsc2U7XG4gIF90aGlzLmVsZW1lbnRzLnNldHRpbmdzU3BlZWRCdXR0b25TaG93Lm9uY2xpY2sgPSBfdGhpcy5lbGVtZW50cy5zZXR0aW5nc1NwZWVkQnV0dG9uSGlkZS5vbmNsaWNrID0gZnVuY3Rpb24gKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICBfdGhpcy5lbGVtZW50cy5zZXR0aW5nc1BhbmVsLmNsYXNzTGlzdC50b2dnbGUoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItc2V0dGluZ3Mtc3BlZWQtcGFuZWxcIikpO1xuXG4gICAgdmFyIGluY2x1ZGVzQ2xhc3MgPSBfdGhpcy5lbGVtZW50cy5zZXR0aW5nc1BhbmVsLmNsYXNzTmFtZS5pbmNsdWRlcyhcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi1zZXR0aW5ncy1zcGVlZC1wYW5lbFwiKSk7XG5cbiAgICBpZiAoaW5jbHVkZXNDbGFzcykge1xuICAgICAgX3RoaXMuZWxlbWVudHMuc2V0dGluZ3NNYWluUGFuZWwuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgX3RoaXMuZWxlbWVudHMuc2V0dGluZ3NTcGVlZFBhbmVsLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIF90aGlzLmVsZW1lbnRzLnNldHRpbmdzU3BlZWRQYW5lbC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICBfdGhpcy5lbGVtZW50cy5zZXR0aW5nc01haW5QYW5lbC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgIH1cbiAgfTtcblxuICB2YXIgb25DdXJzb3JNb3ZlU3BlZWRCYXIgPSBmdW5jdGlvbiBvbkN1cnNvck1vdmVTcGVlZEJhcihlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgdmFyIHZpZXdwb3J0T2Zmc2V0ID0gX3RoaXMuZWxlbWVudHMuc3BlZWRCYXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICB2YXIgY2xpZW50WSA9IGUuY2xpZW50WSB8fCAoKGUudG91Y2hlcyB8fCBbXSlbMF0gfHwge30pLmNsaWVudFk7XG4gICAgdmFyIHBvc2l0aW9uWSA9IGNsaWVudFkgLSB2aWV3cG9ydE9mZnNldC50b3A7XG4gICAgcG9zaXRpb25ZIC09IDg7XG5cbiAgICBpZiAocG9zaXRpb25ZIDwgMCkge1xuICAgICAgcG9zaXRpb25ZID0gMDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uWSA+IF90aGlzLmVsZW1lbnRzLnNwZWVkQmFyLm9mZnNldEhlaWdodCAtIDE2KSB7XG4gICAgICBwb3NpdGlvblkgPSBfdGhpcy5lbGVtZW50cy5zcGVlZEJhci5vZmZzZXRIZWlnaHQgLSAxNjtcbiAgICB9XG5cbiAgICBwb3NpdGlvblkgPSBNYXRoLmZsb29yKHBvc2l0aW9uWSk7IC8vIHNob3cgc3BlZWRcblxuICAgIHZhciBwZXJjZW50YWdlID0gKHBvc2l0aW9uWSAvICgoX3RoaXMub3B0aW9ucy5zcGVlZFZhbHVlcy5sZW5ndGggLSAxKSAqIDE2KSAtIDEpICogLTE7XG4gICAgdmFyIHN0ZXAgPSAxIC8gKF90aGlzLm9wdGlvbnMuc3BlZWRWYWx1ZXMubGVuZ3RoIC0gMSk7XG5cbiAgICB2YXIgc3BlZWQgPSBfdGhpcy5jYWxjdWxhdGVTcGVlZChzdGVwLCBfdGhpcy5vcHRpb25zLnNwZWVkVmFsdWVzLCBwZXJjZW50YWdlKTtcblxuICAgIGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItc3BlZWQtcnVudGltZVwiKSkuaW5uZXJIVE1MID0gc3BlZWQgKyBcIjBcIjtcbiAgICBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLXNwZWVkLWN1cnNvclwiKSkuc3R5bGUudG9wID0gcG9zaXRpb25ZICsgXCJweFwiO1xuICAgIF90aGlzLmNsaXAuZXhlY3V0aW9uU3BlZWQgPSBzcGVlZDtcbiAgfTtcblxuICB2YXIgb25Nb3VzZVVwU3BlZWRCYXIgPSBmdW5jdGlvbiBvbk1vdXNlVXBTcGVlZEJhcihlKSB7XG4gICAgLy8gaWYgKHBlKSB7XG4gICAgLy8gICBfdGhpcy5lbGVtZW50cy5zZXR0aW5nc1BvaW50ZXJFdmVudHMuY2xpY2soKTtcbiAgICAvLyB9XG4gICAgX3RoaXMuZWxlbWVudHMubGlzdGVuZXJIZWxwZXIuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICByZW1vdmVMaXN0ZW5lcihcIm1vdXNldXBcIiwgb25Nb3VzZVVwU3BlZWRCYXIsIGZhbHNlKTtcbiAgICByZW1vdmVMaXN0ZW5lcihcInRvdWNoZW5kXCIsIG9uTW91c2VVcFNwZWVkQmFyLCBmYWxzZSk7XG4gICAgcmVtb3ZlTGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgb25DdXJzb3JNb3ZlU3BlZWRCYXIsIGZhbHNlKTtcbiAgICByZW1vdmVMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBvbkN1cnNvck1vdmVTcGVlZEJhciwgZmFsc2UpO1xuICAgIGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItc3BlZWQtcnVudGltZVwiKSkuaW5uZXJIVE1MID0gXCJTcGVlZFwiO1xuICAgIHZhciBzcGVlZERpc3BsYXk7XG4gICAgX3RoaXMuY2xpcC5zcGVlZCA9PSAxID8gc3BlZWREaXNwbGF5ID0gXCJOb3JtYWxcIiA6IHNwZWVkRGlzcGxheSA9IF90aGlzLmNsaXAuc3BlZWQ7XG4gICAgX3RoaXMuZWxlbWVudHMuc3BlZWRDdXJyZW50LmlubmVySFRNTCA9IHNwZWVkRGlzcGxheTtcbiAgfTtcblxuICB2YXIgb25Nb3VzZURvd25TcGVlZEJhciA9IGZ1bmN0aW9uIG9uTW91c2VEb3duU3BlZWRCYXIoZSkge1xuICAgIC8vIGlmICghX3RoaXMub3B0aW9ucy5wb2ludGVyRXZlbnRzKSB7XG4gICAgLy8gICBwZSA9IHRydWU7XG4gICAgLy8gICBfdGhpcy5lbGVtZW50cy5zZXR0aW5nc1BvaW50ZXJFdmVudHMuY2xpY2soKTtcbiAgICAvLyB9XG4gICAgX3RoaXMuZWxlbWVudHMubGlzdGVuZXJIZWxwZXIuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwiYXV0b1wiO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBvbkN1cnNvck1vdmVTcGVlZEJhcihlKTtcbiAgICBhZGRMaXN0ZW5lcihcIm1vdXNldXBcIiwgb25Nb3VzZVVwU3BlZWRCYXIsIGZhbHNlKTtcbiAgICBhZGRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIG9uTW91c2VVcFNwZWVkQmFyLCBmYWxzZSk7XG4gICAgYWRkTGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgb25DdXJzb3JNb3ZlU3BlZWRCYXIsIGZhbHNlKTtcbiAgICBhZGRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBvbkN1cnNvck1vdmVTcGVlZEJhciwgZmFsc2UpO1xuICB9O1xuXG4gIF90aGlzLmVsZW1lbnRzLnNwZWVkQmFySGVscGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgb25Nb3VzZURvd25TcGVlZEJhciwgZmFsc2UpO1xuXG4gIF90aGlzLmVsZW1lbnRzLnNwZWVkQmFySGVscGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIG9uTW91c2VEb3duU3BlZWRCYXIsIHtcbiAgICBwYXNzaXZlOiBmYWxzZVxuICB9LCBmYWxzZSk7XG59OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex-player/dist/listeners/speed.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex-player/dist/listeners/statusBtn.js":
/*!************************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex-player/dist/listeners/statusBtn.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function (_this) {\n  _this.elements.statusButton.onclick = function (e) {\n    e.preventDefault(); // console.log(_this.clip);\n\n    if (_this.clip.runTimeInfo.state === \"playing\") {\n      _this.clip.pause();\n    } else if (_this.clip.runTimeInfo.state === \"paused\" || _this.clip.runTimeInfo.state === \"idle\" || _this.clip.runTimeInfo.state === \"transitional\" || _this.clip.runTimeInfo.state === \"armed\") {\n      _this.clip.play();\n    } //not working below this\n    else if (_this.clip.runTimeInfo.state === \"idle\") {\n        if (_this.clip.speed >= 0) {\n          _this.clip.play();\n\n          _this.settings.needsUpdate = true;\n        } else {\n          _this.createJourney(_this.clip, _this.settings.loopEndMillisecond - 1, {\n            before: \"pause\",\n            after: \"play\"\n          });\n\n          _this.settings.needsUpdate = true;\n        }\n      } else if (_this.clip.runTimeInfo.state === \"completed\") {\n        if (_this.clip.speed >= 0) {\n          _this.createJourney(_this.clip, 0, {\n            before: \"pause\",\n            after: \"play\"\n          });\n\n          _this.settings.needsUpdate = true;\n        } else {\n          _this.createJourney(_this.clip, _this.settings.loopEndMillisecond - 1, {\n            before: \"pause\",\n            after: \"play\"\n          });\n\n          _this.settings.needsUpdate = true;\n        }\n      }\n\n    return false;\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgtcGxheWVyL2Rpc3QvbGlzdGVuZXJzL3N0YXR1c0J0bi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC1wbGF5ZXIvZGlzdC9saXN0ZW5lcnMvc3RhdHVzQnRuLmpzPzczYzMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF90aGlzKSB7XG4gIF90aGlzLmVsZW1lbnRzLnN0YXR1c0J1dHRvbi5vbmNsaWNrID0gZnVuY3Rpb24gKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7IC8vIGNvbnNvbGUubG9nKF90aGlzLmNsaXApO1xuXG4gICAgaWYgKF90aGlzLmNsaXAucnVuVGltZUluZm8uc3RhdGUgPT09IFwicGxheWluZ1wiKSB7XG4gICAgICBfdGhpcy5jbGlwLnBhdXNlKCk7XG4gICAgfSBlbHNlIGlmIChfdGhpcy5jbGlwLnJ1blRpbWVJbmZvLnN0YXRlID09PSBcInBhdXNlZFwiIHx8IF90aGlzLmNsaXAucnVuVGltZUluZm8uc3RhdGUgPT09IFwiaWRsZVwiIHx8IF90aGlzLmNsaXAucnVuVGltZUluZm8uc3RhdGUgPT09IFwidHJhbnNpdGlvbmFsXCIgfHwgX3RoaXMuY2xpcC5ydW5UaW1lSW5mby5zdGF0ZSA9PT0gXCJhcm1lZFwiKSB7XG4gICAgICBfdGhpcy5jbGlwLnBsYXkoKTtcbiAgICB9IC8vbm90IHdvcmtpbmcgYmVsb3cgdGhpc1xuICAgIGVsc2UgaWYgKF90aGlzLmNsaXAucnVuVGltZUluZm8uc3RhdGUgPT09IFwiaWRsZVwiKSB7XG4gICAgICAgIGlmIChfdGhpcy5jbGlwLnNwZWVkID49IDApIHtcbiAgICAgICAgICBfdGhpcy5jbGlwLnBsYXkoKTtcblxuICAgICAgICAgIF90aGlzLnNldHRpbmdzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpcy5jcmVhdGVKb3VybmV5KF90aGlzLmNsaXAsIF90aGlzLnNldHRpbmdzLmxvb3BFbmRNaWxsaXNlY29uZCAtIDEsIHtcbiAgICAgICAgICAgIGJlZm9yZTogXCJwYXVzZVwiLFxuICAgICAgICAgICAgYWZ0ZXI6IFwicGxheVwiXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBfdGhpcy5zZXR0aW5ncy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoX3RoaXMuY2xpcC5ydW5UaW1lSW5mby5zdGF0ZSA9PT0gXCJjb21wbGV0ZWRcIikge1xuICAgICAgICBpZiAoX3RoaXMuY2xpcC5zcGVlZCA+PSAwKSB7XG4gICAgICAgICAgX3RoaXMuY3JlYXRlSm91cm5leShfdGhpcy5jbGlwLCAwLCB7XG4gICAgICAgICAgICBiZWZvcmU6IFwicGF1c2VcIixcbiAgICAgICAgICAgIGFmdGVyOiBcInBsYXlcIlxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgX3RoaXMuc2V0dGluZ3MubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzLmNyZWF0ZUpvdXJuZXkoX3RoaXMuY2xpcCwgX3RoaXMuc2V0dGluZ3MubG9vcEVuZE1pbGxpc2Vjb25kIC0gMSwge1xuICAgICAgICAgICAgYmVmb3JlOiBcInBhdXNlXCIsXG4gICAgICAgICAgICBhZnRlcjogXCJwbGF5XCJcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIF90aGlzLnNldHRpbmdzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xufTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex-player/dist/listeners/statusBtn.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex-player/dist/listeners/volume.js":
/*!*********************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex-player/dist/listeners/volume.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _require = __webpack_require__(/*! ../helpers */ \"../node_modules/@kissmybutton/motorcortex-player/dist/helpers.js\"),\n    addListener = _require.addListener,\n    removeListener = _require.removeListener,\n    elid = _require.elid;\n\nvar svg = __webpack_require__(/*! ../html/svg */ \"../node_modules/@kissmybutton/motorcortex-player/dist/html/svg.js\");\n\nmodule.exports = function (_this) {\n  // let pe = false;\n  var volumeDrag = false;\n\n  _this.elements.volumeBtn.onclick = function () {\n    if (_this.settings.volumeMute) {\n      _this.elements.volumeBarActive.style.width = _this.settings.previousVolume * 100 + \"%\";\n\n      _this.clip.setVolume(_this.settings.previousVolume);\n\n      _this.settings.volumeMute = false;\n      var SVG = document.createElement(\"span\");\n      SVG.innerHTML = svg.volumeSVG;\n\n      _this.elements.volumeBtn.getElementsByTagName(\"svg\")[0].replaceWith(SVG);\n    } else {\n      _this.settings.volumeMute = true;\n      _this.elements.volumeBarActive.style.width = \"0%\";\n\n      _this.clip.setVolume(0);\n\n      var _SVG = document.createElement(\"span\");\n\n      _SVG.innerHTML = svg.volumeMuteSVG;\n\n      _this.elements.volumeBtn.getElementsByTagName(\"svg\")[0].replaceWith(_SVG);\n    }\n  };\n\n  var volumeOpen = false;\n\n  _this.elements.volumeBtn.onmouseover = function () {\n    volumeOpen = true;\n\n    _this.elements.volumeCursor.classList.add(\"\".concat(_this.name, \"-volume-cursor-transition\"));\n\n    _this.elements.volumeBar.classList.add(\"\".concat(_this.name, \"-volume-width-transition\"));\n\n    _this.elements.volumeBarHelper.classList.add(\"\".concat(_this.name, \"-volume-width-transition\"));\n\n    _this.elements.timeDisplay.classList.add(\"\".concat(_this.name, \"-time-width-transition\"));\n  };\n\n  elid(\"\".concat(_this.name, \"-left-controls\")).onmouseout = function () {\n    if (!volumeOpen || volumeDrag) {\n      return;\n    }\n\n    var e = event.toElement || event.relatedTarget || event.target;\n\n    if (isDescendant(elid(\"\".concat(_this.name, \"-left-controls\")), e) || e === elid(\"\".concat(_this.name, \"-left-controls\"))) {\n      return;\n    }\n\n    volumeOpen = false;\n\n    _this.elements.volumeCursor.classList.remove(\"\".concat(_this.name, \"-volume-cursor-transition\"));\n\n    _this.elements.volumeBar.classList.remove(\"\".concat(_this.name, \"-volume-width-transition\"));\n\n    _this.elements.volumeBarHelper.classList.remove(\"\".concat(_this.name, \"-volume-width-transition\"));\n\n    _this.elements.timeDisplay.classList.remove(\"\".concat(_this.name, \"-time-width-transition\"));\n  };\n\n  _this.listeners.onCursorMoveVolumeBar = function (e) {\n    e.preventDefault();\n    var clientX = e.clientX || ((e.touches || [])[0] || {}).clientX;\n\n    var viewportOffset = _this.elements.volumeBarHelper.getBoundingClientRect();\n\n    var positionX = clientX - viewportOffset.left;\n\n    if (positionX < 0) {\n      positionX = 0;\n    } else if (positionX > _this.elements.volumeBarHelper.offsetWidth) {\n      positionX = _this.elements.volumeBarHelper.offsetWidth;\n    }\n\n    _this.settings.volume = Number((positionX / _this.elements.volumeBarHelper.offsetWidth).toFixed(2));\n    _this.elements.volumeBarActive.style.width = _this.settings.volume * 100 + \"%\";\n\n    _this.clip.setVolume(_this.settings.volume);\n\n    if (_this.settings.volume > 0) {\n      _this.settings.volumeMute = false;\n      var SVG = document.createElement(\"span\");\n      SVG.innerHTML = svg.volumeSVG;\n\n      _this.elements.volumeBtn.getElementsByTagName(\"svg\")[0].replaceWith(SVG);\n    } else if (_this.settings.volume === 0) {\n      _this.settings.volumeMute = true;\n\n      var _SVG2 = document.createElement(\"span\");\n\n      _SVG2.innerHTML = svg.volumeMuteSVG;\n\n      _this.elements.volumeBtn.getElementsByTagName(\"svg\")[0].replaceWith(_SVG2);\n    }\n  };\n\n  _this.listeners.onMouseUpVolumeBar = function (e) {\n    volumeDrag = false; // if (pe) {\n    //   _this.elements.settingsPointerEvents.click();\n    // }\n\n    _this.elements.listenerHelper.style.pointerEvents = \"none\";\n    e.preventDefault();\n\n    if (_this.settings.volume > 0) {\n      _this.settings.previousVolume = _this.settings.volume;\n    }\n\n    removeListener(\"mouseup\", _this.listeners.onMouseUpVolumeBar, false);\n    removeListener(\"touchend\", _this.listeners.onMouseUpVolumeBar, false);\n    removeListener(\"mousemove\", _this.listeners.onCursorMoveVolumeBar, false);\n    removeListener(\"touchmove\", _this.listeners.onCursorMoveVolumeBar, false);\n  };\n\n  _this.listeners.onMouseDownVolumeBar = function (e) {\n    volumeDrag = true; // if (!_this.options.pointerEvents) {\n    //   pe = true;\n    //   _this.elements.settingsPointerEvents.click();\n    // }\n\n    _this.elements.listenerHelper.style.pointerEvents = \"auto\";\n    e.preventDefault();\n\n    _this.listeners.onCursorMoveVolumeBar(e);\n\n    addListener(\"mouseup\", _this.listeners.onMouseUpVolumeBar, false);\n    addListener(\"touchend\", _this.listeners.onMouseUpVolumeBar, false);\n    addListener(\"mousemove\", _this.listeners.onCursorMoveVolumeBar, false);\n    addListener(\"touchmove\", _this.listeners.onCursorMoveVolumeBar, false);\n  };\n\n  _this.elements.volumeBarHelper.addEventListener(\"mousedown\", _this.listeners.onMouseDownVolumeBar, false);\n\n  _this.elements.volumeCursor.addEventListener(\"mousedown\", _this.listeners.onMouseDownVolumeBar, false);\n\n  _this.elements.volumeBarHelper.addEventListener(\"touchstart\", _this.listeners.onMouseDownVolumeBar, {\n    passive: false\n  }, false);\n\n  _this.elements.volumeCursor.addEventListener(\"touchstart\", _this.listeners.onMouseDownVolumeBar, {\n    passive: false\n  }, false);\n};\n\nfunction isDescendant(parent, child) {\n  var node = child.parentNode;\n\n  while (node != null) {\n    if (node == parent) {\n      return true;\n    }\n\n    node = node.parentNode;\n  }\n\n  return false;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgtcGxheWVyL2Rpc3QvbGlzdGVuZXJzL3ZvbHVtZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC1wbGF5ZXIvZGlzdC9saXN0ZW5lcnMvdm9sdW1lLmpzPzA3MWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzXCIpLFxuICAgIGFkZExpc3RlbmVyID0gX3JlcXVpcmUuYWRkTGlzdGVuZXIsXG4gICAgcmVtb3ZlTGlzdGVuZXIgPSBfcmVxdWlyZS5yZW1vdmVMaXN0ZW5lcixcbiAgICBlbGlkID0gX3JlcXVpcmUuZWxpZDtcblxudmFyIHN2ZyA9IHJlcXVpcmUoXCIuLi9odG1sL3N2Z1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoX3RoaXMpIHtcbiAgLy8gbGV0IHBlID0gZmFsc2U7XG4gIHZhciB2b2x1bWVEcmFnID0gZmFsc2U7XG5cbiAgX3RoaXMuZWxlbWVudHMudm9sdW1lQnRuLm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKF90aGlzLnNldHRpbmdzLnZvbHVtZU11dGUpIHtcbiAgICAgIF90aGlzLmVsZW1lbnRzLnZvbHVtZUJhckFjdGl2ZS5zdHlsZS53aWR0aCA9IF90aGlzLnNldHRpbmdzLnByZXZpb3VzVm9sdW1lICogMTAwICsgXCIlXCI7XG5cbiAgICAgIF90aGlzLmNsaXAuc2V0Vm9sdW1lKF90aGlzLnNldHRpbmdzLnByZXZpb3VzVm9sdW1lKTtcblxuICAgICAgX3RoaXMuc2V0dGluZ3Mudm9sdW1lTXV0ZSA9IGZhbHNlO1xuICAgICAgdmFyIFNWRyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgU1ZHLmlubmVySFRNTCA9IHN2Zy52b2x1bWVTVkc7XG5cbiAgICAgIF90aGlzLmVsZW1lbnRzLnZvbHVtZUJ0bi5nZXRFbGVtZW50c0J5VGFnTmFtZShcInN2Z1wiKVswXS5yZXBsYWNlV2l0aChTVkcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdGhpcy5zZXR0aW5ncy52b2x1bWVNdXRlID0gdHJ1ZTtcbiAgICAgIF90aGlzLmVsZW1lbnRzLnZvbHVtZUJhckFjdGl2ZS5zdHlsZS53aWR0aCA9IFwiMCVcIjtcblxuICAgICAgX3RoaXMuY2xpcC5zZXRWb2x1bWUoMCk7XG5cbiAgICAgIHZhciBfU1ZHID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG5cbiAgICAgIF9TVkcuaW5uZXJIVE1MID0gc3ZnLnZvbHVtZU11dGVTVkc7XG5cbiAgICAgIF90aGlzLmVsZW1lbnRzLnZvbHVtZUJ0bi5nZXRFbGVtZW50c0J5VGFnTmFtZShcInN2Z1wiKVswXS5yZXBsYWNlV2l0aChfU1ZHKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHZvbHVtZU9wZW4gPSBmYWxzZTtcblxuICBfdGhpcy5lbGVtZW50cy52b2x1bWVCdG4ub25tb3VzZW92ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdm9sdW1lT3BlbiA9IHRydWU7XG5cbiAgICBfdGhpcy5lbGVtZW50cy52b2x1bWVDdXJzb3IuY2xhc3NMaXN0LmFkZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi12b2x1bWUtY3Vyc29yLXRyYW5zaXRpb25cIikpO1xuXG4gICAgX3RoaXMuZWxlbWVudHMudm9sdW1lQmFyLmNsYXNzTGlzdC5hZGQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItdm9sdW1lLXdpZHRoLXRyYW5zaXRpb25cIikpO1xuXG4gICAgX3RoaXMuZWxlbWVudHMudm9sdW1lQmFySGVscGVyLmNsYXNzTGlzdC5hZGQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItdm9sdW1lLXdpZHRoLXRyYW5zaXRpb25cIikpO1xuXG4gICAgX3RoaXMuZWxlbWVudHMudGltZURpc3BsYXkuY2xhc3NMaXN0LmFkZChcIlwiLmNvbmNhdChfdGhpcy5uYW1lLCBcIi10aW1lLXdpZHRoLXRyYW5zaXRpb25cIikpO1xuICB9O1xuXG4gIGVsaWQoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItbGVmdC1jb250cm9sc1wiKSkub25tb3VzZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXZvbHVtZU9wZW4gfHwgdm9sdW1lRHJhZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBlID0gZXZlbnQudG9FbGVtZW50IHx8IGV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgZXZlbnQudGFyZ2V0O1xuXG4gICAgaWYgKGlzRGVzY2VuZGFudChlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLWxlZnQtY29udHJvbHNcIikpLCBlKSB8fCBlID09PSBlbGlkKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLWxlZnQtY29udHJvbHNcIikpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdm9sdW1lT3BlbiA9IGZhbHNlO1xuXG4gICAgX3RoaXMuZWxlbWVudHMudm9sdW1lQ3Vyc29yLmNsYXNzTGlzdC5yZW1vdmUoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItdm9sdW1lLWN1cnNvci10cmFuc2l0aW9uXCIpKTtcblxuICAgIF90aGlzLmVsZW1lbnRzLnZvbHVtZUJhci5jbGFzc0xpc3QucmVtb3ZlKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLXZvbHVtZS13aWR0aC10cmFuc2l0aW9uXCIpKTtcblxuICAgIF90aGlzLmVsZW1lbnRzLnZvbHVtZUJhckhlbHBlci5jbGFzc0xpc3QucmVtb3ZlKFwiXCIuY29uY2F0KF90aGlzLm5hbWUsIFwiLXZvbHVtZS13aWR0aC10cmFuc2l0aW9uXCIpKTtcblxuICAgIF90aGlzLmVsZW1lbnRzLnRpbWVEaXNwbGF5LmNsYXNzTGlzdC5yZW1vdmUoXCJcIi5jb25jYXQoX3RoaXMubmFtZSwgXCItdGltZS13aWR0aC10cmFuc2l0aW9uXCIpKTtcbiAgfTtcblxuICBfdGhpcy5saXN0ZW5lcnMub25DdXJzb3JNb3ZlVm9sdW1lQmFyID0gZnVuY3Rpb24gKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdmFyIGNsaWVudFggPSBlLmNsaWVudFggfHwgKChlLnRvdWNoZXMgfHwgW10pWzBdIHx8IHt9KS5jbGllbnRYO1xuXG4gICAgdmFyIHZpZXdwb3J0T2Zmc2V0ID0gX3RoaXMuZWxlbWVudHMudm9sdW1lQmFySGVscGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgdmFyIHBvc2l0aW9uWCA9IGNsaWVudFggLSB2aWV3cG9ydE9mZnNldC5sZWZ0O1xuXG4gICAgaWYgKHBvc2l0aW9uWCA8IDApIHtcbiAgICAgIHBvc2l0aW9uWCA9IDA7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvblggPiBfdGhpcy5lbGVtZW50cy52b2x1bWVCYXJIZWxwZXIub2Zmc2V0V2lkdGgpIHtcbiAgICAgIHBvc2l0aW9uWCA9IF90aGlzLmVsZW1lbnRzLnZvbHVtZUJhckhlbHBlci5vZmZzZXRXaWR0aDtcbiAgICB9XG5cbiAgICBfdGhpcy5zZXR0aW5ncy52b2x1bWUgPSBOdW1iZXIoKHBvc2l0aW9uWCAvIF90aGlzLmVsZW1lbnRzLnZvbHVtZUJhckhlbHBlci5vZmZzZXRXaWR0aCkudG9GaXhlZCgyKSk7XG4gICAgX3RoaXMuZWxlbWVudHMudm9sdW1lQmFyQWN0aXZlLnN0eWxlLndpZHRoID0gX3RoaXMuc2V0dGluZ3Mudm9sdW1lICogMTAwICsgXCIlXCI7XG5cbiAgICBfdGhpcy5jbGlwLnNldFZvbHVtZShfdGhpcy5zZXR0aW5ncy52b2x1bWUpO1xuXG4gICAgaWYgKF90aGlzLnNldHRpbmdzLnZvbHVtZSA+IDApIHtcbiAgICAgIF90aGlzLnNldHRpbmdzLnZvbHVtZU11dGUgPSBmYWxzZTtcbiAgICAgIHZhciBTVkcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgIFNWRy5pbm5lckhUTUwgPSBzdmcudm9sdW1lU1ZHO1xuXG4gICAgICBfdGhpcy5lbGVtZW50cy52b2x1bWVCdG4uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzdmdcIilbMF0ucmVwbGFjZVdpdGgoU1ZHKTtcbiAgICB9IGVsc2UgaWYgKF90aGlzLnNldHRpbmdzLnZvbHVtZSA9PT0gMCkge1xuICAgICAgX3RoaXMuc2V0dGluZ3Mudm9sdW1lTXV0ZSA9IHRydWU7XG5cbiAgICAgIHZhciBfU1ZHMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuXG4gICAgICBfU1ZHMi5pbm5lckhUTUwgPSBzdmcudm9sdW1lTXV0ZVNWRztcblxuICAgICAgX3RoaXMuZWxlbWVudHMudm9sdW1lQnRuLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic3ZnXCIpWzBdLnJlcGxhY2VXaXRoKF9TVkcyKTtcbiAgICB9XG4gIH07XG5cbiAgX3RoaXMubGlzdGVuZXJzLm9uTW91c2VVcFZvbHVtZUJhciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdm9sdW1lRHJhZyA9IGZhbHNlOyAvLyBpZiAocGUpIHtcbiAgICAvLyAgIF90aGlzLmVsZW1lbnRzLnNldHRpbmdzUG9pbnRlckV2ZW50cy5jbGljaygpO1xuICAgIC8vIH1cblxuICAgIF90aGlzLmVsZW1lbnRzLmxpc3RlbmVySGVscGVyLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIjtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICBpZiAoX3RoaXMuc2V0dGluZ3Mudm9sdW1lID4gMCkge1xuICAgICAgX3RoaXMuc2V0dGluZ3MucHJldmlvdXNWb2x1bWUgPSBfdGhpcy5zZXR0aW5ncy52b2x1bWU7XG4gICAgfVxuXG4gICAgcmVtb3ZlTGlzdGVuZXIoXCJtb3VzZXVwXCIsIF90aGlzLmxpc3RlbmVycy5vbk1vdXNlVXBWb2x1bWVCYXIsIGZhbHNlKTtcbiAgICByZW1vdmVMaXN0ZW5lcihcInRvdWNoZW5kXCIsIF90aGlzLmxpc3RlbmVycy5vbk1vdXNlVXBWb2x1bWVCYXIsIGZhbHNlKTtcbiAgICByZW1vdmVMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBfdGhpcy5saXN0ZW5lcnMub25DdXJzb3JNb3ZlVm9sdW1lQmFyLCBmYWxzZSk7XG4gICAgcmVtb3ZlTGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgX3RoaXMubGlzdGVuZXJzLm9uQ3Vyc29yTW92ZVZvbHVtZUJhciwgZmFsc2UpO1xuICB9O1xuXG4gIF90aGlzLmxpc3RlbmVycy5vbk1vdXNlRG93blZvbHVtZUJhciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdm9sdW1lRHJhZyA9IHRydWU7IC8vIGlmICghX3RoaXMub3B0aW9ucy5wb2ludGVyRXZlbnRzKSB7XG4gICAgLy8gICBwZSA9IHRydWU7XG4gICAgLy8gICBfdGhpcy5lbGVtZW50cy5zZXR0aW5nc1BvaW50ZXJFdmVudHMuY2xpY2soKTtcbiAgICAvLyB9XG5cbiAgICBfdGhpcy5lbGVtZW50cy5saXN0ZW5lckhlbHBlci5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJhdXRvXCI7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgX3RoaXMubGlzdGVuZXJzLm9uQ3Vyc29yTW92ZVZvbHVtZUJhcihlKTtcblxuICAgIGFkZExpc3RlbmVyKFwibW91c2V1cFwiLCBfdGhpcy5saXN0ZW5lcnMub25Nb3VzZVVwVm9sdW1lQmFyLCBmYWxzZSk7XG4gICAgYWRkTGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBfdGhpcy5saXN0ZW5lcnMub25Nb3VzZVVwVm9sdW1lQmFyLCBmYWxzZSk7XG4gICAgYWRkTGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgX3RoaXMubGlzdGVuZXJzLm9uQ3Vyc29yTW92ZVZvbHVtZUJhciwgZmFsc2UpO1xuICAgIGFkZExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIF90aGlzLmxpc3RlbmVycy5vbkN1cnNvck1vdmVWb2x1bWVCYXIsIGZhbHNlKTtcbiAgfTtcblxuICBfdGhpcy5lbGVtZW50cy52b2x1bWVCYXJIZWxwZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBfdGhpcy5saXN0ZW5lcnMub25Nb3VzZURvd25Wb2x1bWVCYXIsIGZhbHNlKTtcblxuICBfdGhpcy5lbGVtZW50cy52b2x1bWVDdXJzb3IuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBfdGhpcy5saXN0ZW5lcnMub25Nb3VzZURvd25Wb2x1bWVCYXIsIGZhbHNlKTtcblxuICBfdGhpcy5lbGVtZW50cy52b2x1bWVCYXJIZWxwZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgX3RoaXMubGlzdGVuZXJzLm9uTW91c2VEb3duVm9sdW1lQmFyLCB7XG4gICAgcGFzc2l2ZTogZmFsc2VcbiAgfSwgZmFsc2UpO1xuXG4gIF90aGlzLmVsZW1lbnRzLnZvbHVtZUN1cnNvci5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCBfdGhpcy5saXN0ZW5lcnMub25Nb3VzZURvd25Wb2x1bWVCYXIsIHtcbiAgICBwYXNzaXZlOiBmYWxzZVxuICB9LCBmYWxzZSk7XG59O1xuXG5mdW5jdGlvbiBpc0Rlc2NlbmRhbnQocGFyZW50LCBjaGlsZCkge1xuICB2YXIgbm9kZSA9IGNoaWxkLnBhcmVudE5vZGU7XG5cbiAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xuICAgIGlmIChub2RlID09IHBhcmVudCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex-player/dist/listeners/volume.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex/dist/motorcortex.umd.js":
/*!*************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex/dist/motorcortex.umd.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {(function (global, factory) {\n   true ? factory(exports) :\n  undefined;\n}(this, (function (exports) { 'use strict';\n\n  function _typeof(obj) {\n    \"@babel/helpers - typeof\";\n\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof = function (obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof = function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(object);\n      if (enumerableOnly) symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n      keys.push.apply(keys, symbols);\n    }\n\n    return keys;\n  }\n\n  function _objectSpread2(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n\n      if (i % 2) {\n        ownKeys(Object(source), true).forEach(function (key) {\n          _defineProperty(target, key, source[key]);\n        });\n      } else if (Object.getOwnPropertyDescriptors) {\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n      } else {\n        ownKeys(Object(source)).forEach(function (key) {\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n      }\n    }\n\n    return target;\n  }\n\n  function _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n  }\n\n  function _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n      return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n  }\n\n  function _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n      o.__proto__ = p;\n      return o;\n    };\n\n    return _setPrototypeOf(o, p);\n  }\n\n  function _assertThisInitialized(self) {\n    if (self === void 0) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return self;\n  }\n\n  function _possibleConstructorReturn(self, call) {\n    if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n      return call;\n    }\n\n    return _assertThisInitialized(self);\n  }\n\n  function _superPropBase(object, property) {\n    while (!Object.prototype.hasOwnProperty.call(object, property)) {\n      object = _getPrototypeOf(object);\n      if (object === null) break;\n    }\n\n    return object;\n  }\n\n  function _get(target, property, receiver) {\n    if (typeof Reflect !== \"undefined\" && Reflect.get) {\n      _get = Reflect.get;\n    } else {\n      _get = function _get(target, property, receiver) {\n        var base = _superPropBase(target, property);\n\n        if (!base) return;\n        var desc = Object.getOwnPropertyDescriptor(base, property);\n\n        if (desc.get) {\n          return desc.get.call(receiver);\n        }\n\n        return desc.value;\n      };\n    }\n\n    return _get(target, property, receiver || target);\n  }\n\n  function set(target, property, value, receiver) {\n    if (typeof Reflect !== \"undefined\" && Reflect.set) {\n      set = Reflect.set;\n    } else {\n      set = function set(target, property, value, receiver) {\n        var base = _superPropBase(target, property);\n\n        var desc;\n\n        if (base) {\n          desc = Object.getOwnPropertyDescriptor(base, property);\n\n          if (desc.set) {\n            desc.set.call(receiver, value);\n            return true;\n          } else if (!desc.writable) {\n            return false;\n          }\n        }\n\n        desc = Object.getOwnPropertyDescriptor(receiver, property);\n\n        if (desc) {\n          if (!desc.writable) {\n            return false;\n          }\n\n          desc.value = value;\n          Object.defineProperty(receiver, property, desc);\n        } else {\n          _defineProperty(receiver, property, value);\n        }\n\n        return true;\n      };\n    }\n\n    return set(target, property, value, receiver);\n  }\n\n  function _set(target, property, value, receiver, isStrict) {\n    var s = set(target, property, value, receiver || target);\n\n    if (!s && isStrict) {\n      throw new Error('failed to set property');\n    }\n\n    return value;\n  }\n\n  function _toArray(arr) {\n    return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest();\n  }\n\n  function _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n  }\n\n  function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n      return arr2;\n    }\n  }\n\n  function _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n  }\n\n  function _iterableToArray(iter) {\n    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n  }\n\n  function _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n  }\n\n  function _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n  }\n\n  function _toPrimitive(input, hint) {\n    if (typeof input !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n\n    if (prim !== undefined) {\n      var res = prim.call(input, hint || \"default\");\n      if (typeof res !== \"object\") return res;\n      throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n\n    return (hint === \"string\" ? String : Number)(input);\n  }\n\n  function _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, \"string\");\n\n    return typeof key === \"symbol\" ? key : String(key);\n  }\n\n  function _decorate(decorators, factory, superClass, mixins) {\n    var api = _getDecoratorsApi();\n\n    if (mixins) {\n      for (var i = 0; i < mixins.length; i++) {\n        api = mixins[i](api);\n      }\n    }\n\n    var r = factory(function initialize(O) {\n      api.initializeInstanceElements(O, decorated.elements);\n    }, superClass);\n    var decorated = api.decorateClass(_coalesceClassElements(r.d.map(_createElementDescriptor)), decorators);\n    api.initializeClassElements(r.F, decorated.elements);\n    return api.runClassFinishers(r.F, decorated.finishers);\n  }\n\n  function _getDecoratorsApi() {\n    _getDecoratorsApi = function () {\n      return api;\n    };\n\n    var api = {\n      elementsDefinitionOrder: [[\"method\"], [\"field\"]],\n      initializeInstanceElements: function (O, elements) {\n        [\"method\", \"field\"].forEach(function (kind) {\n          elements.forEach(function (element) {\n            if (element.kind === kind && element.placement === \"own\") {\n              this.defineClassElement(O, element);\n            }\n          }, this);\n        }, this);\n      },\n      initializeClassElements: function (F, elements) {\n        var proto = F.prototype;\n        [\"method\", \"field\"].forEach(function (kind) {\n          elements.forEach(function (element) {\n            var placement = element.placement;\n\n            if (element.kind === kind && (placement === \"static\" || placement === \"prototype\")) {\n              var receiver = placement === \"static\" ? F : proto;\n              this.defineClassElement(receiver, element);\n            }\n          }, this);\n        }, this);\n      },\n      defineClassElement: function (receiver, element) {\n        var descriptor = element.descriptor;\n\n        if (element.kind === \"field\") {\n          var initializer = element.initializer;\n          descriptor = {\n            enumerable: descriptor.enumerable,\n            writable: descriptor.writable,\n            configurable: descriptor.configurable,\n            value: initializer === void 0 ? void 0 : initializer.call(receiver)\n          };\n        }\n\n        Object.defineProperty(receiver, element.key, descriptor);\n      },\n      decorateClass: function (elements, decorators) {\n        var newElements = [];\n        var finishers = [];\n        var placements = {\n          static: [],\n          prototype: [],\n          own: []\n        };\n        elements.forEach(function (element) {\n          this.addElementPlacement(element, placements);\n        }, this);\n        elements.forEach(function (element) {\n          if (!_hasDecorators(element)) return newElements.push(element);\n          var elementFinishersExtras = this.decorateElement(element, placements);\n          newElements.push(elementFinishersExtras.element);\n          newElements.push.apply(newElements, elementFinishersExtras.extras);\n          finishers.push.apply(finishers, elementFinishersExtras.finishers);\n        }, this);\n\n        if (!decorators) {\n          return {\n            elements: newElements,\n            finishers: finishers\n          };\n        }\n\n        var result = this.decorateConstructor(newElements, decorators);\n        finishers.push.apply(finishers, result.finishers);\n        result.finishers = finishers;\n        return result;\n      },\n      addElementPlacement: function (element, placements, silent) {\n        var keys = placements[element.placement];\n\n        if (!silent && keys.indexOf(element.key) !== -1) {\n          throw new TypeError(\"Duplicated element (\" + element.key + \")\");\n        }\n\n        keys.push(element.key);\n      },\n      decorateElement: function (element, placements) {\n        var extras = [];\n        var finishers = [];\n\n        for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) {\n          var keys = placements[element.placement];\n          keys.splice(keys.indexOf(element.key), 1);\n          var elementObject = this.fromElementDescriptor(element);\n          var elementFinisherExtras = this.toElementFinisherExtras((0, decorators[i])(elementObject) || elementObject);\n          element = elementFinisherExtras.element;\n          this.addElementPlacement(element, placements);\n\n          if (elementFinisherExtras.finisher) {\n            finishers.push(elementFinisherExtras.finisher);\n          }\n\n          var newExtras = elementFinisherExtras.extras;\n\n          if (newExtras) {\n            for (var j = 0; j < newExtras.length; j++) {\n              this.addElementPlacement(newExtras[j], placements);\n            }\n\n            extras.push.apply(extras, newExtras);\n          }\n        }\n\n        return {\n          element: element,\n          finishers: finishers,\n          extras: extras\n        };\n      },\n      decorateConstructor: function (elements, decorators) {\n        var finishers = [];\n\n        for (var i = decorators.length - 1; i >= 0; i--) {\n          var obj = this.fromClassDescriptor(elements);\n          var elementsAndFinisher = this.toClassDescriptor((0, decorators[i])(obj) || obj);\n\n          if (elementsAndFinisher.finisher !== undefined) {\n            finishers.push(elementsAndFinisher.finisher);\n          }\n\n          if (elementsAndFinisher.elements !== undefined) {\n            elements = elementsAndFinisher.elements;\n\n            for (var j = 0; j < elements.length - 1; j++) {\n              for (var k = j + 1; k < elements.length; k++) {\n                if (elements[j].key === elements[k].key && elements[j].placement === elements[k].placement) {\n                  throw new TypeError(\"Duplicated element (\" + elements[j].key + \")\");\n                }\n              }\n            }\n          }\n        }\n\n        return {\n          elements: elements,\n          finishers: finishers\n        };\n      },\n      fromElementDescriptor: function (element) {\n        var obj = {\n          kind: element.kind,\n          key: element.key,\n          placement: element.placement,\n          descriptor: element.descriptor\n        };\n        var desc = {\n          value: \"Descriptor\",\n          configurable: true\n        };\n        Object.defineProperty(obj, Symbol.toStringTag, desc);\n        if (element.kind === \"field\") obj.initializer = element.initializer;\n        return obj;\n      },\n      toElementDescriptors: function (elementObjects) {\n        if (elementObjects === undefined) return;\n        return _toArray(elementObjects).map(function (elementObject) {\n          var element = this.toElementDescriptor(elementObject);\n          this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\");\n          this.disallowProperty(elementObject, \"extras\", \"An element descriptor\");\n          return element;\n        }, this);\n      },\n      toElementDescriptor: function (elementObject) {\n        var kind = String(elementObject.kind);\n\n        if (kind !== \"method\" && kind !== \"field\") {\n          throw new TypeError('An element descriptor\\'s .kind property must be either \"method\" or' + ' \"field\", but a decorator created an element descriptor with' + ' .kind \"' + kind + '\"');\n        }\n\n        var key = _toPropertyKey(elementObject.key);\n\n        var placement = String(elementObject.placement);\n\n        if (placement !== \"static\" && placement !== \"prototype\" && placement !== \"own\") {\n          throw new TypeError('An element descriptor\\'s .placement property must be one of \"static\",' + ' \"prototype\" or \"own\", but a decorator created an element descriptor' + ' with .placement \"' + placement + '\"');\n        }\n\n        var descriptor = elementObject.descriptor;\n        this.disallowProperty(elementObject, \"elements\", \"An element descriptor\");\n        var element = {\n          kind: kind,\n          key: key,\n          placement: placement,\n          descriptor: Object.assign({}, descriptor)\n        };\n\n        if (kind !== \"field\") {\n          this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\");\n        } else {\n          this.disallowProperty(descriptor, \"get\", \"The property descriptor of a field descriptor\");\n          this.disallowProperty(descriptor, \"set\", \"The property descriptor of a field descriptor\");\n          this.disallowProperty(descriptor, \"value\", \"The property descriptor of a field descriptor\");\n          element.initializer = elementObject.initializer;\n        }\n\n        return element;\n      },\n      toElementFinisherExtras: function (elementObject) {\n        var element = this.toElementDescriptor(elementObject);\n\n        var finisher = _optionalCallableProperty(elementObject, \"finisher\");\n\n        var extras = this.toElementDescriptors(elementObject.extras);\n        return {\n          element: element,\n          finisher: finisher,\n          extras: extras\n        };\n      },\n      fromClassDescriptor: function (elements) {\n        var obj = {\n          kind: \"class\",\n          elements: elements.map(this.fromElementDescriptor, this)\n        };\n        var desc = {\n          value: \"Descriptor\",\n          configurable: true\n        };\n        Object.defineProperty(obj, Symbol.toStringTag, desc);\n        return obj;\n      },\n      toClassDescriptor: function (obj) {\n        var kind = String(obj.kind);\n\n        if (kind !== \"class\") {\n          throw new TypeError('A class descriptor\\'s .kind property must be \"class\", but a decorator' + ' created a class descriptor with .kind \"' + kind + '\"');\n        }\n\n        this.disallowProperty(obj, \"key\", \"A class descriptor\");\n        this.disallowProperty(obj, \"placement\", \"A class descriptor\");\n        this.disallowProperty(obj, \"descriptor\", \"A class descriptor\");\n        this.disallowProperty(obj, \"initializer\", \"A class descriptor\");\n        this.disallowProperty(obj, \"extras\", \"A class descriptor\");\n\n        var finisher = _optionalCallableProperty(obj, \"finisher\");\n\n        var elements = this.toElementDescriptors(obj.elements);\n        return {\n          elements: elements,\n          finisher: finisher\n        };\n      },\n      runClassFinishers: function (constructor, finishers) {\n        for (var i = 0; i < finishers.length; i++) {\n          var newConstructor = (0, finishers[i])(constructor);\n\n          if (newConstructor !== undefined) {\n            if (typeof newConstructor !== \"function\") {\n              throw new TypeError(\"Finishers must return a constructor.\");\n            }\n\n            constructor = newConstructor;\n          }\n        }\n\n        return constructor;\n      },\n      disallowProperty: function (obj, name, objectType) {\n        if (obj[name] !== undefined) {\n          throw new TypeError(objectType + \" can't have a .\" + name + \" property.\");\n        }\n      }\n    };\n    return api;\n  }\n\n  function _createElementDescriptor(def) {\n    var key = _toPropertyKey(def.key);\n\n    var descriptor;\n\n    if (def.kind === \"method\") {\n      descriptor = {\n        value: def.value,\n        writable: true,\n        configurable: true,\n        enumerable: false\n      };\n    } else if (def.kind === \"get\") {\n      descriptor = {\n        get: def.value,\n        configurable: true,\n        enumerable: false\n      };\n    } else if (def.kind === \"set\") {\n      descriptor = {\n        set: def.value,\n        configurable: true,\n        enumerable: false\n      };\n    } else if (def.kind === \"field\") {\n      descriptor = {\n        configurable: true,\n        writable: true,\n        enumerable: true\n      };\n    }\n\n    var element = {\n      kind: def.kind === \"field\" ? \"field\" : \"method\",\n      key: key,\n      placement: def.static ? \"static\" : def.kind === \"field\" ? \"own\" : \"prototype\",\n      descriptor: descriptor\n    };\n    if (def.decorators) element.decorators = def.decorators;\n    if (def.kind === \"field\") element.initializer = def.value;\n    return element;\n  }\n\n  function _coalesceGetterSetter(element, other) {\n    if (element.descriptor.get !== undefined) {\n      other.descriptor.get = element.descriptor.get;\n    } else {\n      other.descriptor.set = element.descriptor.set;\n    }\n  }\n\n  function _coalesceClassElements(elements) {\n    var newElements = [];\n\n    var isSameElement = function (other) {\n      return other.kind === \"method\" && other.key === element.key && other.placement === element.placement;\n    };\n\n    for (var i = 0; i < elements.length; i++) {\n      var element = elements[i];\n      var other;\n\n      if (element.kind === \"method\" && (other = newElements.find(isSameElement))) {\n        if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) {\n          if (_hasDecorators(element) || _hasDecorators(other)) {\n            throw new ReferenceError(\"Duplicated methods (\" + element.key + \") can't be decorated.\");\n          }\n\n          other.descriptor = element.descriptor;\n        } else {\n          if (_hasDecorators(element)) {\n            if (_hasDecorators(other)) {\n              throw new ReferenceError(\"Decorators can't be placed on different accessors with for \" + \"the same property (\" + element.key + \").\");\n            }\n\n            other.decorators = element.decorators;\n          }\n\n          _coalesceGetterSetter(element, other);\n        }\n      } else {\n        newElements.push(element);\n      }\n    }\n\n    return newElements;\n  }\n\n  function _hasDecorators(element) {\n    return element.decorators && element.decorators.length;\n  }\n\n  function _isDataDescriptor(desc) {\n    return desc !== undefined && !(desc.value === undefined && desc.writable === undefined);\n  }\n\n  function _optionalCallableProperty(obj, name) {\n    var value = obj[name];\n\n    if (value !== undefined && typeof value !== \"function\") {\n      throw new TypeError(\"Expected '\" + name + \"' to be a function\");\n    }\n\n    return value;\n  }\n\n  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n  function createCommonjsModule(fn, module) {\n  \treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n  }\n\n  var index_min = createCommonjsModule(function (module, exports) {\n\n  function u() {\n    function t(t) {\n      this.opts = {\n        messages: x({}, w)\n      }, t && x(this.opts, t), this.messages = this.opts.messages, this.rules = {\n        any: b,\n        array: y,\n        boolean: g,\n        custom: v,\n        date: d,\n        email: m,\n        enum: h,\n        equal: p,\n        forbidden: c,\n        function: f,\n        multi: o,\n        number: l,\n        object: u,\n        string: s,\n        url: i,\n        uuid: a,\n        mac: r,\n        luhn: n\n      }, this.cache = new Map();\n    }\n\n    function e(t) {\n      return k || (k = S(), O = {\n        parser: \"babel\",\n        useTabs: !1,\n        printWidth: 120,\n        trailingComma: \"none\",\n        tabWidth: 4,\n        singleQuote: !1,\n        semi: !0,\n        bracketSpacing: !0\n      }, j = S(), _ = {\n        language: \"js\",\n        theme: j.fromJson({\n          keyword: [\"white\", \"bold\"],\n          built_in: \"magenta\",\n          literal: \"cyan\",\n          number: \"magenta\",\n          regexp: \"red\",\n          string: [\"yellow\", \"bold\"],\n          symbol: \"plain\",\n          class: \"blue\",\n          attr: \"plain\",\n          function: [\"white\", \"bold\"],\n          title: \"plain\",\n          params: \"green\",\n          comment: \"grey\"\n        })\n      }), t = k.format(t, O), j.highlight(t, _);\n    }\n\n    function n(t) {\n      return t = t.messages, {\n        source: '\\n\\t\\t\\tif (typeof value !== \"string\") {\\n\\t\\t\\t\\t' + this.makeError({\n          type: \"string\",\n          actual: \"value\",\n          messages: t\n        }) + '\\n\\t\\t\\t\\treturn value;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (typeof value !== \"string\")\\n\\t\\t\\t\\tvalue = String(value);\\n\\n\\t\\t\\tval = value.replace(/\\\\D+/g, \"\");\\n\\n\\t\\t\\tvar array = [0, 2, 4, 6, 8, 1, 3, 5, 7, 9];\\n\\t\\t\\tvar len = val ? val.length : 0,\\n\\t\\t\\t\\tbit = 1,\\n\\t\\t\\t\\tsum = 0;\\n\\t\\t\\twhile (len--) {\\n\\t\\t\\t\\tsum += !(bit ^= 1) ? parseInt(val[len], 10) : array[val[len]];\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (!(sum % 10 === 0 && sum > 0)) {\\n\\t\\t\\t\\t' + this.makeError({\n          type: \"luhn\",\n          actual: \"value\",\n          messages: t\n        }) + \"\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn value;\\n\\t\\t\"\n      };\n    }\n\n    function r(t) {\n      return t = t.messages, {\n        source: '\\n\\t\\t\\tif (typeof value !== \"string\") {\\n\\t\\t\\t\\t' + this.makeError({\n          type: \"string\",\n          actual: \"value\",\n          messages: t\n        }) + \"\\n\\t\\t\\t\\treturn value;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar v = value.toLowerCase();\\n\\t\\t\\tif (!\" + P.toString() + \".test(v)) {\\n\\t\\t\\t\\t\" + this.makeError({\n          type: \"mac\",\n          actual: \"value\",\n          messages: t\n        }) + \"\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn value;\\n\\t\\t\"\n      };\n    }\n\n    function a(t) {\n      var e = t.schema;\n      t = t.messages;\n      var n = [];\n      return n.push('\\n\\t\\tif (typeof value !== \"string\") {\\n\\t\\t\\t' + this.makeError({\n        type: \"string\",\n        actual: \"value\",\n        messages: t\n      }) + \"\\n\\t\\t\\treturn value;\\n\\t\\t}\\n\\n\\t\\tvar val = value.toLowerCase();\\n\\t\\tif (!\" + I.toString() + \".test(val)) {\\n\\t\\t\\t\" + this.makeError({\n        type: \"uuid\",\n        actual: \"value\",\n        messages: t\n      }) + \"\\n\\t\\t\\treturn value;\\n\\t\\t}\\n\\n\\t\\tconst version = val.charAt(14) | 0;\\n\\t\"), e.version && n.push(\"\\n\\t\\t\\tif (\" + e.version + \" !== version) {\\n\\t\\t\\t\\t\" + this.makeError({\n        type: \"uuidVersion\",\n        expected: e.version,\n        actual: \"version\",\n        messages: t\n      }) + \"\\n\\t\\t\\t\\treturn value;\\n\\t\\t\\t}\\n\\t\\t\"), n.push('\\n\\t\\tswitch (version) {\\n\\t\\tcase 1:\\n\\t\\tcase 2:\\n\\t\\t\\tbreak;\\n\\t\\tcase 3:\\n\\t\\tcase 4:\\n\\t\\tcase 5:\\n\\t\\t\\tif ([\"8\", \"9\", \"a\", \"b\"].indexOf(value.charAt(19)) === -1) {\\n\\t\\t\\t\\t' + this.makeError({\n        type: \"uuid\",\n        actual: \"value\",\n        messages: t\n      }) + \"\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn value;\\n\\t\"), {\n        source: n.join(\"\\n\")\n      };\n    }\n\n    function i(t) {\n      t = t.messages;\n      var e = [];\n      return e.push('\\n\\t\\tif (typeof value !== \"string\") {\\n\\t\\t\\t' + this.makeError({\n        type: \"string\",\n        actual: \"value\",\n        messages: t\n      }) + \"\\n\\t\\t\\treturn value;\\n\\t\\t}\\n\\n\\t\\tif (!\" + R.toString() + \".test(value)) {\\n\\t\\t\\t\" + this.makeError({\n        type: \"url\",\n        actual: \"value\",\n        messages: t\n      }) + \"\\n\\t\\t}\\n\\n\\t\\treturn value;\\n\\t\"), {\n        source: e.join(\"\\n\")\n      };\n    }\n\n    function s(t) {\n      var e = t.schema;\n      t = t.messages;\n      var n = [],\n          r = !1;\n\n      if (!0 === e.convert && (r = !0, n.push('\\n\\t\\t\\tif (typeof value !== \"string\") {\\n\\t\\t\\t\\tvalue = String(value);\\n\\t\\t\\t}\\n\\t\\t')), n.push('\\n\\t\\tif (typeof value !== \"string\") {\\n\\t\\t\\t' + this.makeError({\n        type: \"string\",\n        actual: \"value\",\n        messages: t\n      }) + \"\\n\\t\\t\\treturn value;\\n\\t\\t}\\n\\n\\t\\tvar origValue = value;\\n\\t\"), e.trim && (r = !0, n.push(\"\\n\\t\\t\\tvalue = value.trim();\\n\\t\\t\")), e.trimLeft && (r = !0, n.push(\"\\n\\t\\t\\tvalue = value.trimLeft();\\n\\t\\t\")), e.trimRight && (r = !0, n.push(\"\\n\\t\\t\\tvalue = value.trimRight();\\n\\t\\t\")), e.padStart && (r = !0, n.push(\"\\n\\t\\t\\tvalue = value.padStart(\" + e.padStart + \", \" + JSON.stringify(null != e.padChar ? e.padChar : \" \") + \");\\n\\t\\t\")), e.padEnd && (r = !0, n.push(\"\\n\\t\\t\\tvalue = value.padEnd(\" + e.padEnd + \", \" + JSON.stringify(null != e.padChar ? e.padChar : \" \") + \");\\n\\t\\t\")), e.lowercase && (r = !0, n.push(\"\\n\\t\\t\\tvalue = value.toLowerCase();\\n\\t\\t\")), e.uppercase && (r = !0, n.push(\"\\n\\t\\t\\tvalue = value.toUpperCase();\\n\\t\\t\")), e.localeLowercase && (r = !0, n.push(\"\\n\\t\\t\\tvalue = value.toLocaleLowerCase();\\n\\t\\t\")), e.localeUppercase && (r = !0, n.push(\"\\n\\t\\t\\tvalue = value.toLocaleUpperCase();\\n\\t\\t\")), n.push(\"\\n\\t\\t\\tvar len = value.length;\\n\\t\"), !1 === e.empty && n.push(\"\\n\\t\\t\\tif (len === 0) {\\n\\t\\t\\t\\t\" + this.makeError({\n        type: \"stringEmpty\",\n        actual: \"value\",\n        messages: t\n      }) + \"\\n\\t\\t\\t}\\n\\t\\t\"), null != e.min && n.push(\"\\n\\t\\t\\tif (len < \" + e.min + \") {\\n\\t\\t\\t\\t\" + this.makeError({\n        type: \"stringMin\",\n        expected: e.min,\n        actual: \"len\",\n        messages: t\n      }) + \"\\n\\t\\t\\t}\\n\\t\\t\"), null != e.max && n.push(\"\\n\\t\\t\\tif (len > \" + e.max + \") {\\n\\t\\t\\t\\t\" + this.makeError({\n        type: \"stringMax\",\n        expected: e.max,\n        actual: \"len\",\n        messages: t\n      }) + \"\\n\\t\\t\\t}\\n\\t\\t\"), null != e.length && n.push(\"\\n\\t\\t\\tif (len !== \" + e.length + \") {\\n\\t\\t\\t\\t\" + this.makeError({\n        type: \"stringLength\",\n        expected: e.length,\n        actual: \"len\",\n        messages: t\n      }) + \"\\n\\t\\t\\t}\\n\\t\\t\"), null != e.pattern) {\n        var a = e.pattern;\n        \"string\" == typeof e.pattern && (a = new RegExp(e.pattern, e.patternFlags)), n.push(\"\\n\\t\\t\\tif (!\" + a.toString() + \".test(value))\\n\\t\\t\\t\\t\" + this.makeError({\n          type: \"stringPattern\",\n          expected: '\"' + a.toString().replace('\"', '\\\\\"') + '\"',\n          actual: \"origValue\",\n          messages: t\n        }) + \"\\n\\t\\t\");\n      }\n\n      return null != e.contains && n.push('\\n\\t\\t\\tif (value.indexOf(\"' + e.contains + '\") === -1) {\\n\\t\\t\\t\\t' + this.makeError({\n        type: \"stringContains\",\n        expected: '\"' + e.contains + '\"',\n        actual: \"origValue\",\n        messages: t\n      }) + \"\\n\\t\\t\\t}\\n\\t\\t\"), null != e.enum && (a = JSON.stringify(e.enum), n.push(\"\\n\\t\\t\\tif (\" + a + \".indexOf(value) === -1) {\\n\\t\\t\\t\\t\" + this.makeError({\n        type: \"stringEnum\",\n        expected: '\"' + e.enum.join(\", \") + '\"',\n        actual: \"origValue\",\n        messages: t\n      }) + \"\\n\\t\\t\\t}\\n\\t\\t\")), !0 === e.numeric && n.push(\"\\n\\t\\t\\tif (!\" + V.toString() + \".test(value) ) {\\n\\t\\t\\t\\t\" + this.makeError({\n        type: \"stringNumeric\",\n        actual: \"origValue\",\n        messages: t\n      }) + \"\\n\\t\\t\\t}\\n\\t\\t\"), !0 === e.alpha && n.push(\"\\n\\t\\t\\tif(!\" + M.toString() + \".test(value)) {\\n\\t\\t\\t\\t\" + this.makeError({\n        type: \"stringAlpha\",\n        actual: \"origValue\",\n        messages: t\n      }) + \"\\n\\t\\t\\t}\\n\\t\\t\"), !0 === e.alphanum && n.push(\"\\n\\t\\t\\tif(!\" + q.toString() + \".test(value)) {\\n\\t\\t\\t\\t\" + this.makeError({\n        type: \"stringAlphanum\",\n        actual: \"origValue\",\n        messages: t\n      }) + \"\\n\\t\\t\\t}\\n\\t\\t\"), !0 === e.alphadash && n.push(\"\\n\\t\\t\\tif(!\" + F.toString() + \".test(value)) {\\n\\t\\t\\t\\t\" + this.makeError({\n        type: \"stringAlphadash\",\n        actual: \"origValue\",\n        messages: t\n      }) + \"\\n\\t\\t\\t}\\n\\t\\t\"), n.push(\"\\n\\t\\treturn value;\\n\\t\"), {\n        sanitized: r,\n        source: n.join(\"\\n\")\n      };\n    }\n\n    function u(t, e, n) {\n      var r = t.schema;\n      t = t.messages;\n      var a = [];\n      a.push('\\n\\t\\tif (typeof value !== \"object\" || value === null || Array.isArray(value)) {\\n\\t\\t\\t' + this.makeError({\n        type: \"object\",\n        actual: \"value\",\n        messages: t\n      }) + \"\\n\\t\\t\\treturn value;\\n\\t\\t}\\n\\t\");\n      var i = r.properties || r.props;\n\n      if (i) {\n        a.push(\"var parentObj = value;\"), a.push(\"var parentField = field;\");\n\n        for (var s = Object.keys(i), u = 0; u < s.length; u++) {\n          var l = s[u],\n              o = E(l),\n              f = A.test(o) ? \".\" + o : \"['\" + o + \"']\",\n              c = \"parentObj\" + f,\n              p = (e ? e + \".\" : \"\") + l;\n          a.push(\"\\n// Field: \" + E(p)), a.push('field = parentField ? parentField + \"' + f + '\" : \"' + o + '\";'), a.push(\"value = \" + c + \";\"), l = this.getRuleFromSchema(i[l]), a.push(this.compileRule(l, n, p, c + \" = context.fn[%%INDEX%%](value, field, parentObj, errors, context);\", c));\n        }\n\n        r.strict && (e = Object.keys(i), a.push(\"\\n\\t\\t\\t\\tfield = parentField;\\n\\t\\t\\t\\tvar invalidProps = [];\\n\\t\\t\\t\\tvar props = Object.keys(parentObj);\\n\\n\\t\\t\\t\\tfor (let i = 0; i < props.length; i++) {\\n\\t\\t\\t\\t\\tif (\" + JSON.stringify(e) + \".indexOf(props[i]) === -1) {\\n\\t\\t\\t\\t\\t\\tinvalidProps.push(props[i]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (invalidProps.length) {\\n\\t\\t\\t\"), \"remove\" == r.strict ? a.push(\"\\n\\t\\t\\t\\t\\tinvalidProps.forEach(function(field) {\\n\\t\\t\\t\\t\\t\\tdelete parentObj[field];\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\") : a.push(\"\\n\\t\\t\\t\\t\\t\" + this.makeError({\n          type: \"objectStrict\",\n          expected: '\"' + e.join(\", \") + '\"',\n          actual: \"invalidProps.join(', ')\",\n          messages: t\n        }) + \"\\n\\t\\t\\t\\t\"), a.push(\"\\n\\t\\t\\t\\t}\\n\\t\\t\\t\")), a.push(\"\\n\\t\\t\\treturn parentObj;\\n\\t\\t\");\n      } else a.push(\"\\n\\t\\t\\treturn value;\\n\\t\\t\");\n\n      return {\n        source: a.join(\"\\n\")\n      };\n    }\n\n    function l(t) {\n      var e = t.schema;\n      t = t.messages;\n      var n = [];\n      n.push(\"\\n\\t\\tvar origValue = value;\\n\\t\");\n      var r = !1;\n      return !0 === e.convert && (r = !0, n.push('\\n\\t\\t\\tif (typeof value !== \"number\") {\\n\\t\\t\\t\\tvalue = Number(value);\\n\\t\\t\\t}\\n\\t\\t')), n.push('\\n\\t\\tif (typeof value !== \"number\" || isNaN(value) || !isFinite(value)) {\\n\\t\\t\\t' + this.makeError({\n        type: \"number\",\n        actual: \"origValue\",\n        messages: t\n      }) + \"\\n\\t\\t\\treturn value;\\n\\t\\t}\\n\\t\"), null != e.min && n.push(\"\\n\\t\\t\\tif (value < \" + e.min + \") {\\n\\t\\t\\t\\t\" + this.makeError({\n        type: \"numberMin\",\n        expected: e.min,\n        actual: \"origValue\",\n        messages: t\n      }) + \"\\n\\t\\t\\t}\\n\\t\\t\"), null != e.max && n.push(\"\\n\\t\\t\\tif (value > \" + e.max + \") {\\n\\t\\t\\t\\t\" + this.makeError({\n        type: \"numberMax\",\n        expected: e.max,\n        actual: \"origValue\",\n        messages: t\n      }) + \"\\n\\t\\t\\t}\\n\\t\\t\"), null != e.equal && n.push(\"\\n\\t\\t\\tif (value !== \" + e.equal + \") {\\n\\t\\t\\t\\t\" + this.makeError({\n        type: \"numberEqual\",\n        expected: e.equal,\n        actual: \"origValue\",\n        messages: t\n      }) + \"\\n\\t\\t\\t}\\n\\t\\t\"), null != e.notEqual && n.push(\"\\n\\t\\t\\tif (value === \" + e.notEqual + \") {\\n\\t\\t\\t\\t\" + this.makeError({\n        type: \"numberNotEqual\",\n        expected: e.notEqual,\n        actual: \"origValue\",\n        messages: t\n      }) + \"\\n\\t\\t\\t}\\n\\t\\t\"), !0 === e.integer && n.push(\"\\n\\t\\t\\tif (value % 1 !== 0) {\\n\\t\\t\\t\\t\" + this.makeError({\n        type: \"numberInteger\",\n        actual: \"origValue\",\n        messages: t\n      }) + \"\\n\\t\\t\\t}\\n\\t\\t\"), !0 === e.positive && n.push(\"\\n\\t\\t\\tif (value <= 0) {\\n\\t\\t\\t\\t\" + this.makeError({\n        type: \"numberPositive\",\n        actual: \"origValue\",\n        messages: t\n      }) + \"\\n\\t\\t\\t}\\n\\t\\t\"), !0 === e.negative && n.push(\"\\n\\t\\t\\tif (value >= 0) {\\n\\t\\t\\t\\t\" + this.makeError({\n        type: \"numberNegative\",\n        actual: \"origValue\",\n        messages: t\n      }) + \"\\n\\t\\t\\t}\\n\\t\\t\"), n.push(\"\\n\\t\\treturn value;\\n\\t\"), {\n        sanitized: r,\n        source: n.join(\"\\n\")\n      };\n    }\n\n    function o(t, e, n) {\n      t = t.schema;\n      var r = [];\n      r.push(\"\\n\\t\\tvar prevErrLen = errors.length;\\n\\t\\tvar errBefore;\\n\\t\\tvar hasValid = false;\\n\\t\\tvar newVal = value;\\n\\t\");\n\n      for (var a = 0; a < t.rules.length; a++) {\n        r.push(\"\\n\\t\\t\\tif (!hasValid) {\\n\\t\\t\\t\\terrBefore = errors.length;\\n\\t\\t\");\n        var i = this.getRuleFromSchema(t.rules[a]);\n        r.push(this.compileRule(i, n, e, \"var tmpVal = context.fn[%%INDEX%%](value, field, parent, errors, context);\", \"tmpVal\")), r.push(\"\\n\\t\\t\\t\\tif (errors.length == errBefore) {\\n\\t\\t\\t\\t\\thasValid = true;\\n\\t\\t\\t\\t\\tnewVal = tmpVal;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\");\n      }\n\n      return r.push(\"\\n\\t\\tif (hasValid) {\\n\\t\\t\\terrors.length = prevErrLen;\\n\\t\\t}\\n\\n\\t\\treturn newVal;\\n\\t\"), {\n        source: r.join(\"\\n\")\n      };\n    }\n\n    function f(t) {\n      return {\n        source: '\\n\\t\\t\\tif (typeof value !== \"function\")\\n\\t\\t\\t\\t' + this.makeError({\n          type: \"function\",\n          actual: \"value\",\n          messages: t.messages\n        }) + \"\\n\\n\\t\\t\\treturn value;\\n\\t\\t\"\n      };\n    }\n\n    function c(t) {\n      var e = t.schema;\n      t = t.messages;\n      var n = [];\n      return n.push(\"\\n\\t\\tif (value !== null && value !== undefined) {\\n\\t\"), e.remove ? n.push(\"\\n\\t\\t\\treturn undefined;\\n\\t\\t\") : n.push(\"\\n\\t\\t\\t\" + this.makeError({\n        type: \"forbidden\",\n        actual: \"value\",\n        messages: t\n      }) + \"\\n\\t\\t\"), n.push(\"\\n\\t\\t}\\n\\t\\treturn value;\\n\\t\"), {\n        source: n.join(\"\\n\")\n      };\n    }\n\n    function p(t) {\n      var e = t.schema;\n      t = t.messages;\n      var n = [];\n      return e.field ? (e.strict ? n.push('\\n\\t\\t\\t\\tif (value !== parent[\"' + e.field + '\"])\\n\\t\\t\\t') : n.push('\\n\\t\\t\\t\\tif (value != parent[\"' + e.field + '\"])\\n\\t\\t\\t'), n.push(\"\\n\\t\\t\\t\\t\" + this.makeError({\n        type: \"equalField\",\n        actual: \"value\",\n        expected: JSON.stringify(e.field),\n        messages: t\n      }) + \"\\n\\t\\t\")) : (e.strict ? n.push(\"\\n\\t\\t\\t\\tif (value !== \" + JSON.stringify(e.value) + \")\\n\\t\\t\\t\") : n.push(\"\\n\\t\\t\\t\\tif (value != \" + JSON.stringify(e.value) + \")\\n\\t\\t\\t\"), n.push(\"\\n\\t\\t\\t\\t\" + this.makeError({\n        type: \"equalValue\",\n        actual: \"value\",\n        expected: JSON.stringify(e.value),\n        messages: t\n      }) + \"\\n\\t\\t\")), n.push(\"\\n\\t\\treturn value;\\n\\t\"), {\n        source: n.join(\"\\n\")\n      };\n    }\n\n    function h(t) {\n      var e = t.schema;\n      return t = t.messages, {\n        source: \"\\n\\t\\t\\tif (\" + JSON.stringify(e.values || []) + \".indexOf(value) === -1)\\n\\t\\t\\t\\t\" + this.makeError({\n          type: \"enumValue\",\n          expected: '\"' + e.values.join(\", \") + '\"',\n          actual: \"value\",\n          messages: t\n        }) + \"\\n\\n\\t\\t\\treturn value;\\n\\t\\t\"\n      };\n    }\n\n    function m(t) {\n      var e = t.schema;\n      t = t.messages;\n      var n = [],\n          r = \"precise\" == e.mode ? N : T,\n          a = !1;\n      return n.push('\\n\\t\\tif (typeof value !== \"string\") {\\n\\t\\t\\t' + this.makeError({\n        type: \"string\",\n        actual: \"value\",\n        messages: t\n      }) + \"\\n\\t\\t\\treturn value;\\n\\t\\t}\\n\\t\"), e.normalize && (a = !0, n.push(\"\\n\\t\\t\\tvalue = value.trim().toLowerCase();\\n\\t\\t\")), n.push(\"\\n\\t\\tif (!\" + r.toString() + \".test(value))\\n\\t\\t\\t\" + this.makeError({\n        type: \"email\",\n        actual: \"value\",\n        messages: t\n      }) + \"\\n\\n\\t\\treturn value;\\n\\t\"), {\n        sanitized: a,\n        source: n.join(\"\\n\")\n      };\n    }\n\n    function d(t) {\n      var e = t.schema;\n      t = t.messages;\n      var n = [],\n          r = !1;\n      return n.push(\"\\n\\t\\tvar origValue = value;\\n\\t\"), !0 === e.convert && (r = !0, n.push(\"\\n\\t\\t\\tif (!(value instanceof Date)) {\\n\\t\\t\\t\\tvalue = new Date(value);\\n\\t\\t\\t}\\n\\t\\t\")), n.push(\"\\n\\t\\tif (!(value instanceof Date) || isNaN(value.getTime()))\\n\\t\\t\\t\" + this.makeError({\n        type: \"date\",\n        actual: \"origValue\",\n        messages: t\n      }) + \"\\n\\n\\t\\treturn value;\\n\\t\"), {\n        sanitized: r,\n        source: n.join(\"\\n\")\n      };\n    }\n\n    function v(t, e, n) {\n      var r = t.schema;\n      t = t.messages;\n      var a = [];\n      return \"function\" == typeof r.check && (n.customs[e] = {\n        schema: r,\n        messages: t\n      }, a.push('\\n\\t\\t\\tconst rule = context.customs[\"' + e + '\"];\\n\\t\\t\\tconst res = rule.schema.check.call(this, value, rule.schema, \"' + e + '\", parent, context);\\n\\t\\t\\tif (Array.isArray(res)) {\\n\\t\\t\\t\\tres.forEach(err => errors.push(Object.assign({ message: rule.messages[err.type], field }, err)));\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn value;\\n\\t\\t')), {\n        source: a.join(\"\\n\")\n      };\n    }\n\n    function g(t) {\n      var e = t.schema;\n      t = t.messages;\n      var n = [],\n          r = !1;\n      return n.push(\"\\n\\t\\tvar origValue = value;\\n\\t\"), !0 === e.convert && (r = !0, n.push('\\n\\t\\t\\tif (typeof value !== \"boolean\") {\\n\\t\\t\\t\\tif (\\n\\t\\t\\t\\tvalue === 1\\n\\t\\t\\t\\t|| value === \"true\"\\n\\t\\t\\t\\t|| value === \"1\"\\n\\t\\t\\t\\t|| value === \"on\"\\n\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\tvalue = true;\\n\\t\\t\\t\\t} else if (\\n\\t\\t\\t\\tvalue === 0\\n\\t\\t\\t\\t|| value === \"false\"\\n\\t\\t\\t\\t|| value === \"0\"\\n\\t\\t\\t\\t|| value === \"off\"\\n\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\tvalue = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t')), n.push('\\n\\t\\tif (typeof value !== \"boolean\")\\n\\t\\t\\t' + this.makeError({\n        type: \"boolean\",\n        actual: \"origValue\",\n        messages: t\n      }) + \"\\n\\n\\t\\treturn value;\\n\\t\"), {\n        sanitized: r,\n        source: n.join(\"\\n\")\n      };\n    }\n\n    function y(t, e, n) {\n      var r = t.schema,\n          a = t.messages;\n\n      if ((t = []).push(\"\\n\\t\\tif (!Array.isArray(value)) {\\n\\t\\t\\t\" + this.makeError({\n        type: \"array\",\n        actual: \"value\",\n        messages: a\n      }) + \"\\n\\t\\t\\treturn value;\\n\\t\\t}\\n\\n\\t\\tvar len = value.length;\\n\\t\"), !1 === r.empty && t.push(\"\\n\\t\\t\\tif (len === 0) {\\n\\t\\t\\t\\t\" + this.makeError({\n        type: \"arrayEmpty\",\n        actual: \"value\",\n        messages: a\n      }) + \"\\n\\t\\t\\t}\\n\\t\\t\"), null != r.min && t.push(\"\\n\\t\\t\\tif (len < \" + r.min + \") {\\n\\t\\t\\t\\t\" + this.makeError({\n        type: \"arrayMin\",\n        expected: r.min,\n        actual: \"len\",\n        messages: a\n      }) + \"\\n\\t\\t\\t}\\n\\t\\t\"), null != r.max && t.push(\"\\n\\t\\t\\tif (len > \" + r.max + \") {\\n\\t\\t\\t\\t\" + this.makeError({\n        type: \"arrayMax\",\n        expected: r.max,\n        actual: \"len\",\n        messages: a\n      }) + \"\\n\\t\\t\\t}\\n\\t\\t\"), null != r.length && t.push(\"\\n\\t\\t\\tif (len !== \" + r.length + \") {\\n\\t\\t\\t\\t\" + this.makeError({\n        type: \"arrayLength\",\n        expected: r.length,\n        actual: \"len\",\n        messages: a\n      }) + \"\\n\\t\\t\\t}\\n\\t\\t\"), null != r.contains && t.push(\"\\n\\t\\t\\tif (value.indexOf(\" + JSON.stringify(r.contains) + \") === -1) {\\n\\t\\t\\t\\t\" + this.makeError({\n        type: \"arrayContains\",\n        expected: JSON.stringify(r.contains),\n        actual: \"value\",\n        messages: a\n      }) + \"\\n\\t\\t\\t}\\n\\t\\t\"), !0 === r.unique && t.push(\"\\n\\t\\t\\tif(len > (new Set(value)).size) {\\n\\t\\t\\t\\t\" + this.makeError({\n        type: \"arrayUnique\",\n        expected: \"Array.from(new Set(value.filter((item, index) => value.indexOf(item) !== index)))\",\n        actual: \"value\",\n        messages: a\n      }) + \"\\n\\t\\t\\t}\\n\\t\\t\"), null != r.enum) {\n        var i = JSON.stringify(r.enum);\n        t.push(\"\\n\\t\\t\\tfor (var i = 0; i < value.length; i++) {\\n\\t\\t\\t\\tif (\" + i + \".indexOf(value[i]) === -1) {\\n\\t\\t\\t\\t\\t\" + this.makeError({\n          type: \"arrayEnum\",\n          expected: '\"' + r.enum.join(\", \") + '\"',\n          actual: \"value[i]\",\n          messages: a\n        }) + \"\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\");\n      }\n\n      return null != r.items && (t.push(\"\\n\\t\\t\\tvar arr = value;\\n\\t\\t\\tvar parentField = field;\\n\\t\\t\\tfor (var i = 0; i < arr.length; i++) {\\n\\t\\t\"), r = this.getRuleFromSchema(r.items), t.push(this.compileRule(r, n, e, 'arr[i] = context.fn[%%INDEX%%](arr[i], (parentField ? parentField : \"\") + \"[\" + i + \"]\", parent, errors, context);', \"arr[i]\")), t.push(\"\\n\\t\\t\\t}\\n\\t\\t\")), t.push(\"\\n\\t\\treturn value;\\n\\t\"), {\n        source: t.join(\"\\n\")\n      };\n    }\n\n    function b() {\n      return {};\n    }\n\n    function x(t, e) {\n      for (var n in e) \"object\" == typeof e[n] && null !== e[n] ? (t[n] = t[n] || {}, x(t[n], e[n])) : t[n] = e[n];\n\n      return t;\n    }\n\n    function E(t) {\n      return t.replace(C, function (t) {\n        switch (t) {\n          case '\"':\n          case \"'\":\n          case \"\\\\\":\n            return \"\\\\\" + t;\n\n          case \"\\n\":\n            return \"\\\\n\";\n\n          case \"\\r\":\n            return \"\\\\r\";\n\n          case \"\\u2028\":\n            return \"\\\\u2028\";\n\n          case \"\\u2029\":\n            return \"\\\\u2029\";\n        }\n      });\n    }\n\n    function S() {\n      throw Error(\"Dynamic requires are not currently supported by rollup-plugin-commonjs\");\n    }\n\n    var k,\n        O,\n        j,\n        _,\n        w = {\n      required: \"The '{field}' field is required.\",\n      string: \"The '{field}' field must be a string.\",\n      stringEmpty: \"The '{field}' field must not be empty.\",\n      stringMin: \"The '{field}' field length must be greater than or equal to {expected} characters long.\",\n      stringMax: \"The '{field}' field length must be less than or equal to {expected} characters long.\",\n      stringLength: \"The '{field}' field length must be {expected} characters long.\",\n      stringPattern: \"The '{field}' field fails to match the required pattern.\",\n      stringContains: \"The '{field}' field must contain the '{expected}' text.\",\n      stringEnum: \"The '{field}' field does not match any of the allowed values.\",\n      stringNumeric: \"The '{field}' field must be a numeric string.\",\n      stringAlpha: \"The '{field}' field must be an alphabetic string.\",\n      stringAlphanum: \"The '{field}' field must be an alphanumeric string.\",\n      stringAlphadash: \"The '{field}' field must be an alphadash string.\",\n      number: \"The '{field}' field must be a number.\",\n      numberMin: \"The '{field}' field must be greater than or equal to {expected}.\",\n      numberMax: \"The '{field}' field must be less than or equal to {expected}.\",\n      numberEqual: \"The '{field}' field must be equal to {expected}.\",\n      numberNotEqual: \"The '{field}' field can't be equal to {expected}.\",\n      numberInteger: \"The '{field}' field must be an integer.\",\n      numberPositive: \"The '{field}' field must be a positive number.\",\n      numberNegative: \"The '{field}' field must be a negative number.\",\n      array: \"The '{field}' field must be an array.\",\n      arrayEmpty: \"The '{field}' field must not be an empty array.\",\n      arrayMin: \"The '{field}' field must contain at least {expected} items.\",\n      arrayMax: \"The '{field}' field must contain less than or equal to {expected} items.\",\n      arrayLength: \"The '{field}' field must contain {expected} items.\",\n      arrayContains: \"The '{field}' field must contain the '{expected}' item.\",\n      arrayUnique: \"The '{actual}' value in '{field}' field does not unique the '{expected}' values.\",\n      arrayEnum: \"The '{actual}' value in '{field}' field does not match any of the '{expected}' values.\",\n      boolean: \"The '{field}' field must be a boolean.\",\n      date: \"The '{field}' field must be a Date.\",\n      dateMin: \"The '{field}' field must be greater than or equal to {expected}.\",\n      dateMax: \"The '{field}' field must be less than or equal to {expected}.\",\n      enumValue: \"The '{field}' field value '{expected}' does not match any of the allowed values.\",\n      equalValue: \"The '{field}' field value must be equal to '{expected}'.\",\n      equalField: \"The '{field}' field value must be equal to '{expected}' field value.\",\n      forbidden: \"The '{field}' field is forbidden.\",\n      function: \"The '{field}' field must be a function.\",\n      email: \"The '{field}' field must be a valid e-mail.\",\n      luhn: \"The '{field}' field must be a valid checksum luhn.\",\n      mac: \"The '{field}' field must be a valid MAC address.\",\n      object: \"The '{field}' must be an Object.\",\n      objectStrict: \"The object '{field}' contains forbidden keys: '{actual}'.\",\n      url: \"The '{field}' field must be a valid URL.\",\n      uuid: \"The '{field}' field must be a valid UUID.\",\n      uuidVersion: \"The '{field}' field must be a valid UUID version provided.\"\n    },\n        N = /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/,\n        T = /^\\S+@\\S+\\.\\S+$/,\n        A = /^[_$a-zA-Z][_$a-zA-Z0-9]*$/,\n        C = /[\"'\\\\\\n\\r\\u2028\\u2029]/g,\n        V = /^-?[0-9]\\d*(\\.\\d+)?$/,\n        M = /^[a-zA-Z]+$/,\n        q = /^[a-zA-Z0-9]+$/,\n        F = /^[a-zA-Z0-9_-]+$/,\n        R = /^https?:\\/\\/\\S+/,\n        I = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[0-9a-f]{4}-[0-9a-f]{12}$/i,\n        P = /^((([a-f0-9][a-f0-9]+[-]){5}|([a-f0-9][a-f0-9]+[:]){5})([a-f0-9][a-f0-9])$)|(^([a-f0-9][a-f0-9][a-f0-9][a-f0-9]+[.]){2}([a-f0-9][a-f0-9][a-f0-9][a-f0-9]))$/i;\n\n    return t.prototype.validate = function (t, e) {\n      return this.compile(e)(t);\n    }, t.prototype.wrapRequiredCheckSourceCode = function (t, e, n) {\n      var r = [],\n          a = null != t.schema.default ? JSON.stringify(t.schema.default) : null;\n      return r.push(\"\\n\\t\\t\\tif (value === undefined || value === null) {\\n\\t\\t\"), !0 === t.schema.optional || \"forbidden\" == t.schema.type ? null != a && n ? r.push(n + \" = \" + a + \";\") : r.push(\"// Do nothing, it's an optional field\") : null != a && n ? r.push(n + \" = \" + a + \";\") : r.push(this.makeError({\n        type: \"required\",\n        actual: \"value\",\n        messages: t.messages\n      })), r.push(\"} else {\"), e && r.push(e), r.push(\"\\t\\t}\"), r.join(\"\\n\");\n    }, t.prototype.compile = function (t) {\n      if (null === t || \"object\" != typeof t) throw Error(\"Invalid schema.\");\n      var n = this,\n          r = {\n        index: 0,\n        rules: [],\n        fn: [],\n        customs: {}\n      };\n      if (this.cache.clear(), !0 !== t.$$root) if (Array.isArray(t)) t = this.getRuleFromSchema(t).schema;else {\n        var a = Object.assign({}, t);\n        t = {\n          type: \"object\",\n          strict: a.$$strict,\n          properties: a\n        }, delete a.$$strict;\n      }\n      a = [\"var errors = [];\", \"var field;\"], t = this.getRuleFromSchema(t), a.push(this.compileRule(t, r, null, \"context.fn[%%INDEX%%](value, field, null, errors, context);\", \"value\")), a.push(\"if (errors.length) {\"), a.push('\\n\\t\\t\\treturn errors.map(err => {\\n\\t\\t\\t\\tif (err.message)\\n\\t\\t\\t\\t\\terr.message = err.message\\n\\t\\t\\t\\t\\t\\t.replace(/\\\\{field\\\\}/g, err.field || \"\")\\n\\t\\t\\t\\t\\t\\t.replace(/\\\\{expected\\\\}/g, err.expected != null ? err.expected : \"\")\\n\\t\\t\\t\\t\\t\\t.replace(/\\\\{actual\\\\}/g, err.actual != null ? err.actual : \"\");\\n\\n\\t\\t\\t\\treturn err;\\n\\t\\t\\t});\\n\\t\\t'), a.push(\"}\"), a.push(\"return true;\"), t = a.join(\"\\n\");\n      var i = new Function(\"value\", \"context\", t);\n\n      if (this.opts.debug) {\n        var s = function (t) {\n          return t;\n        };\n\n        \"undefined\" == typeof window && (s = e), r.fn.forEach(function (t, e) {\n          return console.log(s(\"// Context.fn[\" + e + \"]\\n\" + t.toString()));\n        }), console.log(s(\"// Main check function\\n\" + i.toString()));\n      }\n\n      return this.cache.clear(), function (t) {\n        return r.data = t, i.call(n, t, r);\n      };\n    }, t.prototype.compileRule = function (t, e, n, r, a) {\n      var i = [],\n          s = this.cache.get(t.schema);\n      return s ? (t = s, t.cycle = !0, t.cycleStack = [], i.push(this.wrapRequiredCheckSourceCode(t, \"\\n\\t\\t\\t\\tvar rule = context.rules[\" + t.index + \"];\\n\\t\\t\\t\\tif (rule.cycleStack.indexOf(value) === -1) {\\n\\t\\t\\t\\t\\trule.cycleStack.push(value);\\n\\t\\t\\t\\t\\t\" + r.replace(\"%%INDEX%%\", t.index) + \"\\n\\t\\t\\t\\t\\trule.cycleStack.pop(value);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\", a))) : (this.cache.set(t.schema, t), t.index = e.index, e.rules[e.index] = t, e.index++, n = t.ruleFunction.call(this, t, n, e), n.source ? (n = new Function(\"value\", \"field\", \"parent\", \"errors\", \"context\", n.source), e.fn[t.index] = n, i.push(this.wrapRequiredCheckSourceCode(t, r.replace(\"%%INDEX%%\", t.index), a))) : i.push(this.wrapRequiredCheckSourceCode(t))), i.join(\"\\n\");\n    }, t.prototype.getRuleFromSchema = function (t) {\n      var e = this;\n\n      if (\"string\" == typeof t) {\n        var n = t.split(\"|\").map(function (t) {\n          return t.trim();\n        });\n        t = {\n          type: n[0]\n        }, n.slice(1).map(function (e) {\n          var n = e.indexOf(\":\");\n\n          if (-1 !== n) {\n            var r = e.substr(0, n).trim();\n            \"true\" === (e = e.substr(n + 1).trim()) || \"false\" === e ? e = \"true\" === e : Number.isNaN(Number(e)) || (e = Number(e)), t[r] = e;\n          } else e.startsWith(\"no-\") ? t[e.slice(3)] = !1 : t[e] = !0;\n        });\n      } else if (Array.isArray(t)) {\n        if (0 == t.length) throw Error(\"Invalid schema.\");\n        (t = {\n          type: \"multi\",\n          rules: t\n        }).rules.map(function (t) {\n          return e.getRuleFromSchema(t);\n        }).every(function (t) {\n          return 1 == t.schema.optional;\n        }) && (t.optional = !0);\n      }\n\n      if (!(n = this.rules[t.type])) throw Error(\"Invalid '\" + t.type + \"' type in validator schema.\");\n      return {\n        messages: Object.assign({}, this.messages, t.messages),\n        schema: t,\n        ruleFunction: n\n      };\n    }, t.prototype.makeError = function (t) {\n      var e = t.type,\n          n = t.field,\n          r = t.expected,\n          a = t.actual,\n          i = {\n        type: '\"' + e + '\"',\n        message: '\"' + t.messages[e] + '\"'\n      };\n      return i.field = n ? '\"' + n + '\"' : \"field\", r && (i.expected = r), a && (i.actual = a), \"errors.push({ \" + Object.keys(i).map(function (t) {\n        return t + \": \" + i[t];\n      }).join(\", \") + \" });\";\n    }, t.prototype.add = function (t, e) {\n      this.rules[t] = e;\n    }, t;\n  }\n\n  var f = f || {};\n  f.scope = {}, f.ASSUME_ES5 = !1, f.ASSUME_NO_NATIVE_MAP = !1, f.ASSUME_NO_NATIVE_SET = !1, f.defineProperty = f.ASSUME_ES5 || \"function\" == typeof Object.defineProperties ? Object.defineProperty : function (t, e, n) {\n    t != Array.prototype && t != Object.prototype && (t[e] = n.value);\n  }, f.getGlobal = function (t) {\n    return \"undefined\" != typeof window && window === t ? t : \"undefined\" != typeof commonjsGlobal && null != commonjsGlobal ? commonjsGlobal : t;\n  }, f.global = f.getGlobal(commonjsGlobal), f.SYMBOL_PREFIX = \"jscomp_symbol_\", f.initSymbol = function () {\n    f.initSymbol = function () {}, f.global.Symbol || (f.global.Symbol = f.Symbol);\n  }, f.Symbol = function () {\n    var t = 0;\n    return function (e) {\n      return f.SYMBOL_PREFIX + (e || \"\") + t++;\n    };\n  }(), f.initSymbolIterator = function () {\n    f.initSymbol();\n    var t = f.global.Symbol.iterator;\n    t || (t = f.global.Symbol.iterator = f.global.Symbol(\"iterator\")), \"function\" != typeof Array.prototype[t] && f.defineProperty(Array.prototype, t, {\n      configurable: !0,\n      writable: !0,\n      value: function () {\n        return f.arrayIterator(this);\n      }\n    }), f.initSymbolIterator = function () {};\n  }, f.arrayIterator = function (t) {\n    var e = 0;\n    return f.iteratorPrototype(function () {\n      return e < t.length ? {\n        done: !1,\n        value: t[e++]\n      } : {\n        done: !0\n      };\n    });\n  }, f.iteratorPrototype = function (t) {\n    return f.initSymbolIterator(), t = {\n      next: t\n    }, t[f.global.Symbol.iterator] = function () {\n      return this;\n    }, t;\n  }, f.iteratorFromArray = function (t, e) {\n    f.initSymbolIterator(), t instanceof String && (t += \"\");\n    var n = 0,\n        r = {\n      next: function () {\n        if (n < t.length) {\n          var a = n++;\n          return {\n            value: e(a, t[a]),\n            done: !1\n          };\n        }\n\n        return r.next = function () {\n          return {\n            done: !0,\n            value: void 0\n          };\n        }, r.next();\n      }\n    };\n    return r[Symbol.iterator] = function () {\n      return r;\n    }, r;\n  }, f.polyfill = function (t, e) {\n    if (e) {\n      var n = f.global;\n      t = t.split(\".\");\n\n      for (var r = 0; r < t.length - 1; r++) {\n        var a = t[r];\n        a in n || (n[a] = {}), n = n[a];\n      }\n\n      (e = e(r = n[t = t[t.length - 1]])) != r && null != e && f.defineProperty(n, t, {\n        configurable: !0,\n        writable: !0,\n        value: e\n      });\n    }\n  }, f.polyfill(\"Array.prototype.values\", function (t) {\n    return t || function () {\n      return f.iteratorFromArray(this, function (t, e) {\n        return e;\n      });\n    };\n  }, \"es8\", \"es3\"), f.polyfill(\"Array.prototype.keys\", function (t) {\n    return t || function () {\n      return f.iteratorFromArray(this, function (t) {\n        return t;\n      });\n    };\n  }, \"es6\", \"es3\"), f.checkEs6ConformanceViaProxy = function () {\n    try {\n      var t = {},\n          e = Object.create(new f.global.Proxy(t, {\n        get: function (n, r, a) {\n          return n == t && \"q\" == r && a == e;\n        }\n      }));\n      return !0 === e.q;\n    } catch (t) {\n      return !1;\n    }\n  }, f.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS = !1, f.ES6_CONFORMANCE = f.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS && f.checkEs6ConformanceViaProxy(), f.makeIterator = function (t) {\n    f.initSymbolIterator();\n    var e = t[Symbol.iterator];\n    return e ? e.call(t) : f.arrayIterator(t);\n  }, f.owns = function (t, e) {\n    return Object.prototype.hasOwnProperty.call(t, e);\n  }, f.polyfill(\"WeakMap\", function (t) {\n    function e(t) {\n      if (this.id_ = (i += Math.random() + 1).toString(), t) {\n        f.initSymbol(), f.initSymbolIterator(), t = f.makeIterator(t);\n\n        for (var e; !(e = t.next()).done;) e = e.value, this.set(e[0], e[1]);\n      }\n    }\n\n    function n(t) {\n      f.owns(t, a) || f.defineProperty(t, a, {\n        value: {}\n      });\n    }\n\n    function r(t) {\n      var e = Object[t];\n      e && (Object[t] = function (t) {\n        return n(t), e(t);\n      });\n    }\n\n    if (f.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS) {\n      if (t && f.ES6_CONFORMANCE) return t;\n    } else if (function () {\n      if (!t || !Object.seal) return !1;\n\n      try {\n        var e = Object.seal({}),\n            n = Object.seal({}),\n            r = new t([[e, 2], [n, 3]]);\n        return 2 == r.get(e) && 3 == r.get(n) && (r.delete(e), r.set(n, 4), !r.has(e) && 4 == r.get(n));\n      } catch (t) {\n        return !1;\n      }\n    }()) return t;\n\n    var a = \"$jscomp_hidden_\" + Math.random();\n    r(\"freeze\"), r(\"preventExtensions\"), r(\"seal\");\n    var i = 0;\n    return e.prototype.set = function (t, e) {\n      if (n(t), !f.owns(t, a)) throw Error(\"WeakMap key fail: \" + t);\n      return t[a][this.id_] = e, this;\n    }, e.prototype.get = function (t) {\n      return f.owns(t, a) ? t[a][this.id_] : void 0;\n    }, e.prototype.has = function (t) {\n      return f.owns(t, a) && f.owns(t[a], this.id_);\n    }, e.prototype.delete = function (t) {\n      return !(!f.owns(t, a) || !f.owns(t[a], this.id_)) && delete t[a][this.id_];\n    }, e;\n  }, \"es6\", \"es3\"), f.MapEntry = function () {}, f.polyfill(\"Map\", function (t) {\n    function e() {\n      var t = {};\n      return t.previous = t.next = t.head = t;\n    }\n\n    function n(t, e) {\n      var n = t.head_;\n      return f.iteratorPrototype(function () {\n        if (n) {\n          for (; n.head != t.head_;) n = n.previous;\n\n          for (; n.next != n.head;) return n = n.next, {\n            done: !1,\n            value: e(n)\n          };\n\n          n = null;\n        }\n\n        return {\n          done: !0,\n          value: void 0\n        };\n      });\n    }\n\n    function r(t, e) {\n      var n = e && typeof e;\n      \"object\" == n || \"function\" == n ? i.has(e) ? n = i.get(e) : (n = \"\" + ++s, i.set(e, n)) : n = \"p_\" + e;\n      var r = t.data_[n];\n      if (r && f.owns(t.data_, n)) for (t = 0; t < r.length; t++) {\n        var a = r[t];\n        if (e !== e && a.key !== a.key || e === a.key) return {\n          id: n,\n          list: r,\n          index: t,\n          entry: a\n        };\n      }\n      return {\n        id: n,\n        list: r,\n        index: -1,\n        entry: void 0\n      };\n    }\n\n    function a(t) {\n      if (this.data_ = {}, this.head_ = e(), this.size = 0, t) {\n        t = f.makeIterator(t);\n\n        for (var n; !(n = t.next()).done;) n = n.value, this.set(n[0], n[1]);\n      }\n    }\n\n    if (f.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS) {\n      if (t && f.ES6_CONFORMANCE) return t;\n    } else if (function () {\n      if (f.ASSUME_NO_NATIVE_MAP || !t || \"function\" != typeof t || !t.prototype.entries || \"function\" != typeof Object.seal) return !1;\n\n      try {\n        var e = Object.seal({\n          x: 4\n        }),\n            n = new t(f.makeIterator([[e, \"s\"]]));\n        if (\"s\" != n.get(e) || 1 != n.size || n.get({\n          x: 4\n        }) || n.set({\n          x: 4\n        }, \"t\") != n || 2 != n.size) return !1;\n        var r = n.entries(),\n            a = r.next();\n        return !a.done && a.value[0] == e && \"s\" == a.value[1] && !((a = r.next()).done || 4 != a.value[0].x || \"t\" != a.value[1] || !r.next().done);\n      } catch (t) {\n        return !1;\n      }\n    }()) return t;\n\n    f.initSymbol(), f.initSymbolIterator();\n    var i = new WeakMap();\n    a.prototype.set = function (t, e) {\n      var n = r(this, t);\n      return n.list || (n.list = this.data_[n.id] = []), n.entry ? n.entry.value = e : (n.entry = {\n        next: this.head_,\n        previous: this.head_.previous,\n        head: this.head_,\n        key: t,\n        value: e\n      }, n.list.push(n.entry), this.head_.previous.next = n.entry, this.head_.previous = n.entry, this.size++), this;\n    }, a.prototype.delete = function (t) {\n      return !(!(t = r(this, t)).entry || !t.list) && (t.list.splice(t.index, 1), t.list.length || delete this.data_[t.id], t.entry.previous.next = t.entry.next, t.entry.next.previous = t.entry.previous, t.entry.head = null, this.size--, !0);\n    }, a.prototype.clear = function () {\n      this.data_ = {}, this.head_ = this.head_.previous = e(), this.size = 0;\n    }, a.prototype.has = function (t) {\n      return !!r(this, t).entry;\n    }, a.prototype.get = function (t) {\n      return (t = r(this, t).entry) && t.value;\n    }, a.prototype.entries = function () {\n      return n(this, function (t) {\n        return [t.key, t.value];\n      });\n    }, a.prototype.keys = function () {\n      return n(this, function (t) {\n        return t.key;\n      });\n    }, a.prototype.values = function () {\n      return n(this, function (t) {\n        return t.value;\n      });\n    }, a.prototype.forEach = function (t, e) {\n      for (var n, r = this.entries(); !(n = r.next()).done;) n = n.value, t.call(e, n[1], n[0], this);\n    }, a.prototype[Symbol.iterator] = a.prototype.entries;\n    var s = 0;\n    return a;\n  }, \"es6\", \"es3\"), f.assign = \"function\" == typeof Object.assign ? Object.assign : function (t, e) {\n    for (var n = 1; n < arguments.length; n++) {\n      var r = arguments[n];\n      if (r) for (var a in r) f.owns(r, a) && (t[a] = r[a]);\n    }\n\n    return t;\n  }, f.polyfill(\"Object.assign\", function (t) {\n    return t || f.assign;\n  }, \"es6\", \"es3\"), f.polyfill(\"Number.isNaN\", function (t) {\n    return t || function (t) {\n      return \"number\" == typeof t && isNaN(t);\n    };\n  }, \"es6\", \"es3\"), f.checkStringArgs = function (t, e, n) {\n    if (null == t) throw new TypeError(\"The 'this' value for String.prototype.\" + n + \" must not be null or undefined\");\n    if (e instanceof RegExp) throw new TypeError(\"First argument to String.prototype.\" + n + \" must not be a regular expression\");\n    return t + \"\";\n  }, f.polyfill(\"String.prototype.startsWith\", function (t) {\n    return t || function (t, e) {\n      var n = f.checkStringArgs(this, t, \"startsWith\");\n      t += \"\";\n      var r = n.length,\n          a = t.length;\n      e = Math.max(0, Math.min(0 | e, n.length));\n\n      for (var i = 0; i < a && e < r;) if (n[e++] != t[i++]) return !1;\n\n      return i >= a;\n    };\n  }, \"es6\", \"es3\");\n   module.exports = u() ;\n  });\n\n  /*\n  known events:\n  - state-change / meta: the name of the new state\n  - attribute-rejection / meta: animationID, attributes\n  - animation-rejection / meta: animationID\n  - conflicts-on-edit\n  */\n  var logTypes = [{\n    key: 'info',\n    style: 'color: #666;',\n    level: 5\n  }, {\n    key: 'notice',\n    style: 'background: rgba(0, 0, 0, 0.8); color:white; padding:8px;',\n    level: 4\n  }, {\n    key: 'warning',\n    style: 'color: black; background: orange;',\n    level: 2\n  }, {\n    key: 'error',\n    style: 'color: black; background: red;',\n    level: 1\n  }];\n  var lanesMCIDattrsSeperator = '___';\n  var keyframe_sec_key = 'sec_';\n  var elements_data_attribute_name = 'data-motorcortex2-id';\n  var selfContainedContextHandler = 'closed';\n  var logLevel = 1;\n  var testMode = true;\n  var conf = {\n    keyframe_sec_key: keyframe_sec_key,\n    elements_data_attribute_name: elements_data_attribute_name,\n    selfContainedContextHandler: selfContainedContextHandler,\n    logLevel: logLevel,\n    testMode: testMode,\n    logTypes: logTypes\n  };\n\n  window.AudioContext = window.AudioContext || window.webkitAudioContext;\n  var audioContext = new window.AudioContext();\n  function isObject(test) {\n    return _typeof(test) === 'object';\n  }\n  function jsUcfirst(string) {\n    return string.charAt(0).toUpperCase() + string.slice(1);\n  }\n  /**\n   subdivision might be rounding the number to its:\n   - units (subdivision = 1)\n   - tenths (subdivision = 10)\n   - hundreds (subdivision = 100)\n   - thousands (subdivision = 1000)\n   @param {number} number\n   @param {number} subdivision\n   @returns {number} the rounded number\n   */\n\n  function roundNumberTo(number, subdivision) {\n    return Math.round(number / subdivision) * subdivision;\n  }\n  function getMCIDandAttrOutOfLaneKey(laneKey) {\n    var laneArray = laneKey.split(lanesMCIDattrsSeperator);\n    return {\n      mcid: laneArray[0],\n      attribute: laneArray[1]\n    };\n  }\n\n  function s4() {\n    return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n  }\n  /**\n   * @returns {string} in the form \"1bc45f78-ab23-jl59\"\n   */\n\n\n  function getAnId() {\n    var underscore = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var specialChar = underscore ? '_' : '-';\n    return s4() + s4() + specialChar + s4() + specialChar + s4();\n  }\n  function renderTemplate(templateString, templateVars) {\n    return new Function(\"return `\".concat(templateString, \"`;\")).call(templateVars); // eslint-disable-line no-new-func\n  }\n  function getLaneKey(mcid, attribute) {\n    return \"\".concat(mcid).concat(lanesMCIDattrsSeperator).concat(attribute);\n  }\n  /** @classdesc Helper maintains a number of helpful functions in a single point  */\n\n  var Helper =\n  /*#__PURE__*/\n  function () {\n    function Helper(configuration) {\n      _classCallCheck(this, Helper);\n\n      var logLevel = conf.logLevel;\n\n      if (configuration) {\n        if (Object.prototype.hasOwnProperty.call(configuration, 'logLevel')) {\n          logLevel = configuration.logLevel;\n        }\n      }\n\n      for (var i = 0; i < logTypes.length; i++) {\n        var logType = logTypes[i];\n\n        if (logLevel >= logType.level) {\n          {\n            this[logType.key] = window.console.log.bind(window.console, \"MotorCortex - \".concat(logType.key, \": \"));\n          }\n        } else this[logType.key] = function funct() {};\n      }\n\n      if (logLevel >= 3) {\n        this.log = window.console.log.bind(window.console, 'MotorCortex - ');\n      } else this.log = function funct() {};\n    }\n\n    _createClass(Helper, [{\n      key: \"validateProps\",\n      value: function validateProps(props, rules, constructor) {\n        var v = new index_min();\n        var validationResult = v.validate(props, rules);\n\n        if (validationResult.length > 0) {\n          var errorMessage = \"Error on plugin's \\\"\".concat(constructor.plugin_npm_name, \"\\\" \\\"\").concat(constructor.ClassName, \"\\\" instantiation. Errors (op props):\");\n\n          for (var i = 0; i < validationResult.length; i++) {\n            errorMessage += \"\\n - \".concat(validationResult[i].message, \". \").concat(validationResult[i].actual, \" provided\");\n          }\n\n          console.error(errorMessage); // eslint-disable-line no-console\n\n          return {\n            result: false,\n            errors: validationResult\n          };\n        }\n\n        return {\n          result: true\n        };\n      }\n    }, {\n      key: \"getElementByMCID\",\n      value: function getElementByMCID(context, mcid) {\n        return context.rootElement.querySelectorAll(\"[\".concat(elements_data_attribute_name, \"=\\\"\").concat(mcid, \"\\\"]\"))[0];\n      }\n      /**\n       * systole / diastole of the projections\n       * @returns {array} - collection of objects with keys: {id, start, end, startDelta}\n       * */\n\n    }, {\n      key: \"systoleDiastoleProjections\",\n      value: function systoleDiastoleProjections(projections, durationFraction, anchorPoint) {\n        var alteredProjections = [];\n\n        for (var i = 0; i < projections.length; i++) {\n          var projectedIncident = projections[i];\n          var msInResizedPortion = projectedIncident.parentMillisecond - anchorPoint;\n\n          if (durationFraction !== 1) {\n            alteredProjections.push({\n              id: projectedIncident.incident.id,\n              start: msInResizedPortion * durationFraction + anchorPoint,\n              end: msInResizedPortion * durationFraction + anchorPoint + projectedIncident.incident.duration * durationFraction,\n              startDelta: msInResizedPortion * durationFraction + anchorPoint - projectedIncident.millisecond\n            });\n          }\n        }\n\n        return alteredProjections;\n      }\n    }]);\n\n    return Helper;\n  }();\n  var helper = new Helper();\n\n  var Channel =\n  /*#__PURE__*/\n  function () {\n    function Channel(props) {\n      _classCallCheck(this, Channel);\n\n      this.runTimeInfo = props.runTimeInfo;\n      this.context = props.context;\n      this.onInitialise();\n      this.getIncidentById = props.getIncidentById; // this.type = \"plain\";\n    }\n\n    _createClass(Channel, [{\n      key: \"onInitialise\",\n      value: function onInitialise() {}\n    }, {\n      key: \"_resize\",\n      value: function _resize() {\n        helper.log('Please overwite the _resize method of the Channel');\n      }\n      /**\n       * @param {array} incidents - A collection of Incidents in the form:\n       * {\n       *  millisecond\n       *  incident\n       *  id\n       * }\n       * @returns either:\n       *   {\n       *       result:true,\n       *       execute: // an array of functions that when executed it will add the Incidents on the Channels\n       *   }\n       *   or\n       *   {\n       *       result: false,\n       *       errors\n       *   }\n       */\n\n    }, {\n      key: \"addIncidents\",\n      value: function addIncidents(incidents) {\n        // first check the Incidents addition directly using the checkAddition method of the class\n        var result = this.checkAddition(incidents);\n\n        if (result.result === false) {\n          return {\n            result: false,\n            errors: result.errors\n          };\n        }\n\n        return {\n          result: true,\n          execute: result.execute\n        };\n      }\n      /**\n         * It initially checks if the edit is allowed and if it is it retuns an array of executable functions\n         * that apply the change\n         * @param {array} incidents - the list of the incidents to edit in an array format [object, object, ...]\n         * @param {int} millisecondsDelta - the milliseconds delta to apply to the incidents\n         * @returns {object} -\n         * either:\n         {\n            result: true,\n            execute: // array of functions to be executed in order to apply the edit\n         }\n         or\n         {\n             result: false,\n             errors: // an array including all the errors / conflicts found on edit\n         }\n        */\n\n    }, {\n      key: \"editIncidents\",\n      value: function editIncidents(incidents, millisecondsDelta) {\n        // first check the Incidents addition directly using the checkAddition method of the class\n        var result = this.checkEdit(incidents, millisecondsDelta);\n\n        if (result.result === false) {\n          return {\n            result: false,\n            errors: result.errors\n          };\n        }\n\n        return {\n          result: true,\n          execute: result.execute\n        };\n      }\n      /**\n         * Method to remove incidents\n         * @param {array} incidents - the ids of the incidents to remove in an array format\n         * @param {object} props\n         * @retuns {object} -\n         * either:\n         {\n            result: true,\n            execute: // array of functions to be executed in order to apply the edit\n         }\n         or\n         {\n             result: false,\n             errors: // an array including all the errors / conflicts found on edit\n         }\n        */\n\n    }, {\n      key: \"removeIncidents\",\n      value: function removeIncidents(incidents) {\n        var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        // first check the Incidents addition directly using the checkAddition method of the class\n        var result = this.checkDelete(incidents, props);\n\n        if (result.result === false) {\n          return {\n            result: false,\n            errors: result.errors\n          };\n        }\n\n        return {\n          result: true,\n          execute: result.execute\n        };\n      }\n      /**\n       * This method is invoked whenever a CASI (the owner of the Channel) enters\n       * the tree of another clip, so the scratch values of all first Incidents of\n       * each channel should be recalculated based on the context. All Channels\n       * that extend Channel can rewrite this method accordingly\n       * @param {string} contextId - The id of the context of the Clip Copy according to which\n       *      we are going to recalc the scratch values\n       * */\n      // eslint-disable-next-line no-unused-vars\n\n    }, {\n      key: \"recalcScratchValues\",\n      value: function recalcScratchValues(contextId) {}\n      /**\n         * On this method the user defines the specific rules that apply on the plugin itself and on the Incidents of the plugin itself\n         * The method should either return {result: true} or {result: false, errors:[{error-object}]}, where error-object has the structure:\n         *  {\n                incident: // reference to the Incident object that has bee discarded\n                error: // text\n            }\n        * @param {array} incidents - a colleciton of all incidents to be added on the form:\n        *\n            {\n                id\n                millisecond\n                incident\n            }\n        * @returns {object} -\n        * either:\n            {\n                result:true,\n                execute: // a function that when executed it will add the Incidents on the Channels\n            }\n            or\n            {\n                result: false,\n                errors\n            }\n        */\n      // eslint-disable-next-line no-unused-vars\n\n    }, {\n      key: \"checkAddition\",\n      value: function checkAddition(incidents) {\n        return {\n          result: true,\n          execute: function execute() {}\n        };\n      } // eslint-disable-next-line no-unused-vars\n\n    }, {\n      key: \"checkEdit\",\n      value: function checkEdit(incidentsArray, millisecondsDelta) {\n        return {\n          result: true,\n          execute: function execute() {}\n        };\n      } // eslint-disable-next-line no-unused-vars\n\n    }, {\n      key: \"checkDelete\",\n      value: function checkDelete(incidentIds) {\n        return {\n          result: true,\n          execute: function execute() {}\n        };\n      } // eslint-disable-next-line no-unused-vars\n\n    }, {\n      key: \"checkResizedIncidents\",\n      value: function checkResizedIncidents(incidents) {\n        return {\n          result: true,\n          execute: function execute() {}\n        };\n      }\n    }, {\n      key: \"moveTo\",\n      value: function moveTo(from, to, contextId) {} // eslint-disable-line no-unused-vars\n\n    }], [{\n      key: \"type\",\n      get: function get() {\n        return 'plain';\n      }\n    }]);\n\n    return Channel;\n  }();\n\n  /**\n   * this method acts as a proxy to duration setter by taking a fraction and not\n   * an absolute number for the overall duration of the Leaf\n   * */\n  function systoleDiastole(payload) {\n    payload.descriptor.value = function systoleDiastoleFunct(durationFraction) {\n      this.duration = this.duration * durationFraction;\n    };\n  }\n\n  var _DIRECTIONS = {\n    _UP: 'up',\n    _DOWN: 'down'\n  };\n  var _BYPASS = 'native.tree.bypass';\n\n  var Leaf = _decorate(null, function (_initialize) {\n    var Leaf = function Leaf() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      _classCallCheck(this, Leaf);\n\n      _initialize(this);\n\n      // parentNode is a reference to the parent Node the Leaf is attached to (if any)\n      this.parentNode = null;\n      this.isNode = false;\n\n      if (Object.prototype.hasOwnProperty.call(props, 'id')) {\n        this.id = props.id;\n      } else {\n        this.id = getAnId();\n      }\n\n      this.props = props;\n    };\n\n    return {\n      F: Leaf,\n      d: [{\n        kind: \"get\",\n        key: \"delay\",\n        value: function delay() {\n          if (Object.prototype.hasOwnProperty.call(this.props, 'delay')) {\n            return this.props.delay;\n          }\n\n          return 0;\n        }\n      }, {\n        kind: \"set\",\n        key: \"delay\",\n        value: function delay(val) {\n          if (val !== 0) {\n            this.props.delay = val;\n          }\n        }\n      }, {\n        kind: \"get\",\n        key: \"hiatus\",\n        value: function hiatus() {\n          if (Object.prototype.hasOwnProperty.call(this.props, 'hiatus')) {\n            return this.props.hiatus;\n          }\n\n          return 0;\n        }\n      }, {\n        kind: \"set\",\n        key: \"hiatus\",\n        value: function hiatus(val) {\n          if (val !== 0) {\n            this.props.hiatus = val;\n          }\n        }\n      }, {\n        kind: \"get\",\n        key: \"repeats\",\n        value: function repeats() {\n          if (Object.prototype.hasOwnProperty.call(this.props, 'repeats')) {\n            return this.props.repeats;\n          }\n\n          return 1;\n        }\n      }, {\n        kind: \"set\",\n        key: \"repeats\",\n        value: function repeats(val) {\n          this.props.repeats = val;\n        }\n        /**\n         * the full duration of the Leaf taking in consideration all: delay, duration, hiatus and\n         * repeats factor\n         * */\n\n      }, {\n        kind: \"get\",\n        key: \"duration\",\n        value: function duration() {\n          return this.repeats * (this.delay + this.props.duration + this.hiatus);\n        }\n        /**\n         * the setter sets the overall duration of the Leaf by altering all\n         * delay, duration and hiatus properties of it\n         * */\n\n      }, {\n        kind: \"set\",\n        key: \"duration\",\n        value: function duration(milliseconds) {\n          var fraction = milliseconds / this.duration;\n          this.props.duration *= fraction;\n          this.hiatus *= fraction;\n          this.delay *= fraction;\n        }\n        /**\n         * setNewDuration method sets the new FULL duration as it derives from the\n         * delay, duration, hiatus and repeats factors\n         * */\n\n      }, {\n        kind: \"method\",\n        key: \"setNewDuration\",\n        value: function setNewDuration(newDuration) {\n          this.duration = newDuration;\n          this.putMessageOnPipe('recalcDuration', {}, 'Groups', {\n            selfExecute: false,\n            direction: _DIRECTIONS._UP\n          });\n        }\n      }, {\n        kind: \"method\",\n        decorators: [systoleDiastole],\n        key: \"systoleDiastole\",\n        value: function systoleDiastole() {}\n      }, {\n        kind: \"get\",\n        key: \"hasParent\",\n        value: function hasParent() {\n          if (this.parentNode === null) {\n            return false;\n          }\n\n          return true;\n        }\n      }, {\n        kind: \"method\",\n        key: \"attachToNode\",\n        value: function attachToNode(node) {\n          this.parentNode = node;\n        }\n      }, {\n        kind: \"method\",\n        key: \"detachFromParent\",\n        value: function detachFromParent() {\n          this.parentNode = null;\n        }\n        /**\n        @param {string} name - the name of the message\n        @param {object} payload - the payload of the message\n        @param {object} target - specifies the target of the message in a key-value pairs object\n        @param {object} options - in the form:\n        {\n            direction (either _UP or _DOWN)\n            selfExecute (either true which means the Leaf should try to handle the message itself or\n                false which means the Leaf should directly forward the message to its parent)\n        }\n        @returns The expected result of this method is on the form:\n        {\n            response: an object the structure of which depends on the name of the message\n                and maybe even on the payload\n            responder: a direct reference to the lead that actually responded\n            (only valid for direaction _DOWN) positionDelta: the position delta of the responder compared to the requester\n        }\n        * */\n\n      }, {\n        kind: \"method\",\n        key: \"putMessageOnPipe\",\n        value: function putMessageOnPipe(name, payload, target) {\n          var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n          // default direction: _DOWN\n          if (!Object.prototype.hasOwnProperty.call(options, 'direction')) {\n            options.direction = _DIRECTIONS._DOWN;\n          } // default positionDelta = 0\n\n\n          if (options.direction === _DIRECTIONS._DOWN && !Object.prototype.hasOwnProperty.call(options, 'positionDelta')) {\n            options.positionDelta = 0;\n          }\n\n          if (options.selfExecute === true) {\n            // if the Leaf has a \"handle<name>\" method with the first letter of\n            // name in Capital it runs it\n            var handlingMethodName = \"handle\".concat(jsUcfirst(name));\n            var capable = typeof this[handlingMethodName] === 'function';\n\n            if (capable) {\n              var response = this[handlingMethodName](target, payload);\n\n              if (response !== _BYPASS) {\n                var result = {\n                  response: response,\n                  responder: this\n                };\n\n                if (options.direction === _DIRECTIONS._UP) {\n                  return result;\n                }\n\n                return [_objectSpread2({}, result, {\n                  positionDelta: options.positionDelta\n                })];\n              }\n            }\n          }\n\n          if (options.direction === _DIRECTIONS._UP) {\n            if (this.hasParent) {\n              return this.parentNode.putMessageOnPipe(name, payload, target, {\n                selfExecute: true,\n                direction: _DIRECTIONS._UP\n              });\n            } // if the message reaches the top of the tree without finding any liable target\n\n\n            return {\n              response: false,\n              responder: null\n            };\n          } // _CONST._DIRECTIONS._DOWN\n\n\n          return [];\n        }\n      }, {\n        kind: \"method\",\n        key: \"bypass\",\n        value: function bypass() {\n          return _BYPASS;\n        } // Postion on Pyramidion\n        // \"Pyramidion\" is the uppermost piece or capstone of an Egyptian pyramid.\n        // To us \"Pyramidion\" is the top Node of the Tree to which this Leaf belongs to\n        // and the following infrastructure implements it\n\n      }, {\n        kind: \"get\",\n        key: \"positionOnPyramidion\",\n        value: function positionOnPyramidion() {\n          return this.getPositionOnPyramidion();\n        }\n      }, {\n        kind: \"method\",\n        key: \"getPositionOnPyramidion\",\n        value: function getPositionOnPyramidion() {\n          var delta = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n          if (!this.hasParent) {\n            return delta;\n          } else {\n            var result = this.putMessageOnPipe('getPositionOnPyramidion', {\n              delta: delta,\n              id: this.id\n            }, 'Parent', {\n              selfExecute: false,\n              direction: _DIRECTIONS._UP\n            });\n            return result.response;\n          }\n        }\n      }]\n    };\n  });\n\n  var _LEAFALREADYASSIGNED = 'Leaf has already been attached to another Node';\n  var _NEGATIVEPOSITIONNOTALLOWED = 'Negative positioning of childs on nodes is not allowed';\n  var _LEAFNOTFOUND = \"The Leaf with the requested id couldn't be found on the Tree\";\n\n  var Node = _decorate(null, function (_initialize, _Leaf) {\n    var Node =\n    /*#__PURE__*/\n    function (_Leaf2) {\n      _inherits(Node, _Leaf2);\n\n      function Node() {\n        var _this;\n\n        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, Node);\n\n        _this = _possibleConstructorReturn(this, _getPrototypeOf(Node).call(this, props));\n\n        _initialize(_assertThisInitialized(_this));\n\n        _this.isNode = true;\n        /**\n              The object holds the Incidents of the Scene on the format:\n              {\n                  <id>: {\n                        id // the id of the Incident object\n                        leaf // the incident object\n                        position // the position of the incident\n                  },\n                  ...\n              }\n               */\n\n        _this.children = {};\n        _this.calculatedDuration = 0;\n        return _this;\n      }\n\n      return Node;\n    }(_Leaf);\n\n    return {\n      F: Node,\n      d: [{\n        kind: \"get\",\n        key: \"duration\",\n        value: function duration() {\n          return this.calculatedDuration;\n        }\n      }, {\n        kind: \"set\",\n        key: \"duration\",\n        value: function duration(newDuration) {\n          var durationFraction = newDuration / this.duration;\n\n          if (this.props) {\n            if (Object.prototype.hasOwnProperty.call(this.props, 'duration')) {\n              this.props.duration = newDuration;\n            }\n          }\n\n          this.calculatedDuration = newDuration;\n\n          for (var childKey in this.children) {\n            var child = this.children[childKey];\n            this.editPosition(child.id, child.position * durationFraction, true);\n            child.leaf.systoleDiastole(durationFraction);\n          }\n        }\n      }, {\n        kind: \"method\",\n        key: \"setNewDuration\",\n        value: function setNewDuration(newDuration) {\n          this.duration = newDuration;\n          this.putMessageOnPipe('recalcDuration', {}, 'Groups', {\n            selfExecute: false,\n            direction: _DIRECTIONS._UP\n          });\n        }\n      }, {\n        kind: \"method\",\n        key: \"_calculateDuration\",\n        value: function _calculateDuration() {\n          var duration = 0;\n\n          for (var childKey in this.children) {\n            var child = this.children[childKey];\n\n            if (child.position + child.leaf.duration > duration) {\n              duration = child.position + child.leaf.duration;\n            }\n          }\n\n          if (duration === this.calculatedDuration) {\n            return false;\n          }\n\n          if (this.props) {\n            if (Object.prototype.hasOwnProperty.call(this.props, 'duration')) {\n              this.props.duration = duration;\n            }\n          }\n\n          this.calculatedDuration = duration;\n          return true;\n        }\n      }, {\n        kind: \"method\",\n        decorators: [systoleDiastole],\n        key: \"systoleDiastole\",\n        value: function systoleDiastole() {} // eslint-disable-next-line no-unused-vars\n\n      }, {\n        kind: \"method\",\n        key: \"handleRecalcDuration\",\n        value: function handleRecalcDuration(target, payload) {\n          if (this._calculateDuration()) {\n            return this.putMessageOnPipe('recalcDuration', {}, 'Groups', {\n              selfExecute: false,\n              direction: _DIRECTIONS._UP\n            });\n          }\n\n          return true;\n        }\n      }, {\n        kind: \"method\",\n        key: \"getLeafById\",\n        value: function getLeafById(id) {\n          var onlyDirectChild = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n          if (Object.prototype.hasOwnProperty.call(this.children, id)) {\n            return this.children[id].leaf;\n          }\n\n          if (onlyDirectChild === false) {\n            for (var child in this.children) {\n              var childLeaf = this.children[child].leaf;\n\n              if (childLeaf.isNode) {\n                var leaf = childLeaf.getLeafById(id);\n\n                if (leaf != null) {\n                  return leaf;\n                }\n              }\n            }\n          } else {\n            return null;\n          }\n\n          return null;\n        }\n      }, {\n        kind: \"method\",\n        key: \"getLeafPosition\",\n        value: function getLeafPosition(id) {\n          if (Object.prototype.hasOwnProperty.call(this.children, id)) {\n            return this.children[id].position;\n          }\n\n          var res = this.putMessageOnPipe('getLeafPosition', {\n            id: id\n          }, 'Groups', {\n            selfExecute: false,\n            direction: _DIRECTIONS._DOWN\n          });\n\n          if (res.length > 0) {\n            return res[0].positionDelta + res[0].response;\n          }\n        }\n      }, {\n        kind: \"method\",\n        key: \"handleGetLeafPosition\",\n        value: function handleGetLeafPosition(target, payload) {\n          return this.getLeafPosition(payload.id);\n        }\n      }, {\n        kind: \"method\",\n        key: \"checkAddition\",\n        value: function checkAddition(leaf, position) {\n          if (leaf.hasParent) {\n            return {\n              result: false,\n              reason: _LEAFALREADYASSIGNED\n            };\n          }\n\n          if (position < 0) {\n            return {\n              result: false,\n              reason: _NEGATIVEPOSITIONNOTALLOWED\n            };\n          }\n\n          return {\n            result: true\n          };\n        }\n      }, {\n        kind: \"method\",\n        key: \"addChild\",\n        value: function addChild(leaf, position) {\n          // this hasParent check occurs here as an extra security check so it\n          // gets executed regardless if the user wants to perform checks or not\n          if (leaf.hasParent) {\n            return {\n              result: false,\n              reason: _LEAFALREADYASSIGNED\n            };\n          }\n\n          this.children[leaf.id] = {\n            id: leaf.id,\n            leaf: leaf,\n            position: position\n          };\n          leaf.attachToNode(this);\n          this.putMessageOnPipe('recalcDuration', {}, 'Groups', {\n            selfExecute: true,\n            direction: _DIRECTIONS._UP\n          });\n          return {\n            result: true\n          };\n        }\n      }, {\n        kind: \"method\",\n        key: \"checkRemoveChild\",\n        value: function checkRemoveChild(id) {\n          if (!Object.prototype.hasOwnProperty.call(this.children, id)) {\n            return {\n              result: false,\n              reason: _LEAFNOTFOUND\n            };\n          }\n\n          return {\n            result: true\n          };\n        }\n      }, {\n        kind: \"method\",\n        key: \"removeChild\",\n        value: function removeChild(id) {\n          this.children[id].leaf.detachFromParent();\n          delete this.children[id];\n          this.putMessageOnPipe('recalcDuration', {}, 'Groups', {\n            selfExecute: true,\n            direction: _DIRECTIONS._UP\n          });\n          return {\n            result: true\n          };\n        }\n      }, {\n        kind: \"method\",\n        key: \"checkEditPosition\",\n        value: function checkEditPosition(id, position) {\n          if (position < 0) {\n            return {\n              result: false,\n              reason: _NEGATIVEPOSITIONNOTALLOWED\n            };\n          }\n\n          if (!Object.prototype.hasOwnProperty.call(this.children, id)) {\n            return {\n              result: false,\n              reason: _LEAFNOTFOUND\n            };\n          }\n\n          return {\n            result: true\n          };\n        }\n      }, {\n        kind: \"method\",\n        key: \"editPosition\",\n        value: function editPosition(id, position) {\n          var bypassRecalcDuration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n          if (Object.prototype.hasOwnProperty.call(this.children, id)) {\n            this.children[id].position = position;\n\n            if (bypassRecalcDuration === false) {\n              this.putMessageOnPipe('recalcDuration', {}, 'Groups', {\n                selfExecute: true,\n                direction: _DIRECTIONS._UP\n              });\n            }\n\n            return {\n              result: true\n            };\n          }\n        }\n        /**\n          The expected result of this method depends on the direction of the message\n          The direction might either be _UP or _DOWN.\n          In the case of _UP the expected result is identical as on Leaf:\n          {\n              response: an object the structure of which depends on the name of the message\n                  and maybe even on the payload\n              responder: a direct reference to the lead that actually responded\n          }\n          In the case of _DOWN though, where multiple Leafs might be eligible in the tree\n          for handling the message the result is on the form:\n          [\n              {\n                  response: an object the structure of which depends on the name of the message\n                      and maybe even on the payload\n                  responder: a direct reference to the lead that actually responded\n                  positionDelta: the position delta of the responder compared to the requester\n              }\n          ]\n          */\n\n      }, {\n        kind: \"method\",\n        key: \"putMessageOnPipe\",\n        value: function putMessageOnPipe(name, payload, target) {\n          var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n          // default direction: _DOWN\n          if (!Object.prototype.hasOwnProperty.call(options, 'direction')) {\n            options.direction = _DIRECTIONS._DOWN;\n          } // default positionDelta = 0\n\n\n          if (options.direction === _DIRECTIONS._DOWN && !Object.prototype.hasOwnProperty.call(options, 'positionDelta')) {\n            options.positionDelta = 0;\n          }\n\n          if (options.direction === _DIRECTIONS._UP) {\n            // if the direction is up\n            return _get(_getPrototypeOf(Node.prototype), \"putMessageOnPipe\", this).call(this, name, payload, target, options); // act exactly as any other Leaf\n          }\n\n          var result = _get(_getPrototypeOf(Node.prototype), \"putMessageOnPipe\", this).call(this, name, payload, target, options);\n\n          if (result.length > 0) {\n            return result;\n          }\n\n          for (var child in this.children) {\n            var leaf = this.children[child].leaf;\n\n            var newOptions = _objectSpread2({}, options, {\n              selfExecute: true,\n              positionDelta: options.positionDelta + this.children[child].position\n            });\n\n            result = result.concat(leaf.putMessageOnPipe(name, payload, target, newOptions));\n          }\n\n          return result;\n        }\n      }, {\n        kind: \"method\",\n        key: \"handleGetPositionOnPyramidion\",\n        value: function handleGetPositionOnPyramidion(target, payload) {\n          var delta = payload.delta + this.getLeafPosition(payload.id);\n          return this.getPositionOnPyramidion(delta);\n        }\n      }]\n    };\n  }, Leaf);\n\n  function block(pld) {\n    pld.descriptor.value = function blockfunct(description) {\n      if (this.blockID === undefined) {\n        this.blockID = getAnId();\n      }\n\n      this.DescriptiveIncident.putMessageOnPipe('setBlock', {\n        id: this.blockID,\n        description: description,\n        incidentId: this.DescriptiveIncident.id,\n        realIncidentId: this.id\n      }, 'rootClip', {\n        selfExecute: true,\n        direction: _DIRECTIONS._UP\n      });\n    };\n  }\n\n  function handleResize(pld) {\n    pld.descriptor.value = function handleResizeFunct(target) {\n      // eslint-disable-line no-unused-vars\n      if (this.id === target) {\n        return this;\n      }\n\n      return this.bypass();\n    };\n  }\n\n  function unblock(pld) {\n    pld.descriptor.value = function unblockFunct() {\n      // eslint-disable-line no-unused-vars\n      this.DescriptiveIncident.putMessageOnPipe('unBlock', {\n        id: this.blockID\n      }, 'rootClip', {\n        selfExecute: true,\n        direction: _DIRECTIONS._UP\n      });\n    };\n  }\n\n  var Group = _decorate(null, function (_initialize, _Node) {\n    var Group =\n    /*#__PURE__*/\n    function (_Node2) {\n      _inherits(Group, _Node2);\n\n      function Group(attrs, props) {\n        var _this;\n\n        _classCallCheck(this, Group);\n\n        _this = _possibleConstructorReturn(this, _getPrototypeOf(Group).call(this, props));\n\n        _initialize(_assertThisInitialized(_this));\n\n        _this.mc_plugin_npm_name = 'motor-cortex-js';\n        _this.plugin_channel_class = Channel;\n        _this.hasIncidents = true;\n\n        _this.onGroupInitialise();\n\n        _this.calculatedDuration = 0;\n        return _this;\n      }\n\n      return Group;\n    }(_Node);\n\n    return {\n      F: Group,\n      d: [{\n        kind: \"method\",\n        key: \"onGroupInitialise\",\n        value: function onGroupInitialise() {// called when group gets initialised\n        }\n      }, {\n        kind: \"method\",\n        key: \"handleAddIncident\",\n        value: function handleAddIncident(target, payload) {\n          if (this.id === target) {\n            var incidentFromDescription = payload.incidentFromDescription;\n            var theIncident = incidentFromDescription(payload.incident, payload.contextData, payload.audio); // in the case that an audio clip tries to process an non-audio incident or\n            // a non-audio incident tries to process an audio incident the result from incidentFromDescription is null\n            // in such a case there should be no candidate return, so this.bypass()\n\n            if (theIncident === null) {\n              return this.bypass();\n            }\n\n            return theIncident;\n          }\n\n          return this.bypass();\n        }\n      }, {\n        kind: \"method\",\n        key: \"handleMoveIncident\",\n        value: function handleMoveIncident(target, payload) {\n          if (this.id === target) {\n            var res = this.getLeafById(payload.incidentId, true);\n\n            if (res === null) {\n              return this.bypass();\n            }\n\n            return res;\n          }\n\n          return this.bypass();\n        }\n      }, {\n        kind: \"method\",\n        key: \"handleRemoveIncident\",\n        value: function handleRemoveIncident(target, payload) {\n          if (this.id === target) {\n            var res = this.getLeafById(payload.incidentId, true);\n\n            if (res === null) {\n              return this.bypass();\n            }\n\n            return res;\n          }\n\n          return this.bypass();\n        }\n      }, {\n        kind: \"method\",\n        decorators: [handleResize],\n        key: \"handleResize\",\n        value: function handleResize() {}\n      }, {\n        kind: \"method\",\n        key: \"removeChild\",\n        value: function removeChild(id) {\n          this.children[id].leaf.lastWish();\n\n          _get(_getPrototypeOf(Group.prototype), \"removeChild\", this).call(this, id);\n        }\n        /**\n         * Returns an object that has the key of the npm plugin name the Channel of which manages the specific Incident\n         * With the same logic all Incidents that belong to this Group as categorised by plugin / channel on the same object\n         */\n\n      }, {\n        kind: \"method\",\n        key: \"getIncidentsByChannel\",\n        value: function getIncidentsByChannel() {\n          var adjustMillisecond = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n          var parentMillisecond = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n          // initially it only puts itself onthe incidentsByPlugin array, exactly as the plain Incidents do\n          var incidentsByPlugin = {};\n          incidentsByPlugin['motor-cortex-js'] = [{\n            millisecond: adjustMillisecond,\n            parentMillisecond: parentMillisecond,\n            incident: this,\n            id: this.id\n          }]; // proceed to gather the contained incidents as well\n\n          for (var childId in this.children) {\n            var child = this.children[childId];\n            var incidentsToAdd = child.leaf.getIncidentsByChannel(adjustMillisecond + child.position, adjustMillisecond);\n\n            for (var key in incidentsToAdd) {\n              if (Object.prototype.hasOwnProperty.call(incidentsByPlugin, key)) {\n                incidentsByPlugin[key] = incidentsByPlugin[key].concat(incidentsToAdd[key]);\n              } else {\n                incidentsByPlugin[key] = incidentsToAdd[key];\n              }\n            }\n          }\n\n          return incidentsByPlugin;\n        }\n      }, {\n        kind: \"method\",\n        key: \"lastWish\",\n        value: function lastWish() {\n          for (var childId in this.children) {\n            this.children[childId].leaf.lastWish();\n          }\n        }\n      }, {\n        kind: \"method\",\n        decorators: [block],\n        key: \"setBlock\",\n        value: function setBlock() {}\n      }, {\n        kind: \"method\",\n        decorators: [unblock],\n        key: \"unblock\",\n        value: function unblock() {}\n      }]\n    };\n  }, Node);\n\n  var lodash_filter = createCommonjsModule(function (module, exports) {\n  /**\n   * Lodash (Custom Build) <https://lodash.com/>\n   * Build: `lodash modularize include=\"filter,sortBy,findIndex,find,forEach,cloneDeep\" exports=\"npm\"`\n   * Copyright JS Foundation and other contributors <https://js.foundation/>\n   * Released under MIT license <https://lodash.com/license>\n   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n   */\n\n  /** Used as the size to enable large array optimizations. */\n  var LARGE_ARRAY_SIZE = 200;\n  /** Error message constants. */\n\n  var FUNC_ERROR_TEXT = 'Expected a function';\n  /** Used to stand-in for `undefined` hash values. */\n\n  var HASH_UNDEFINED = '__lodash_hash_undefined__';\n  /** Used as the maximum memoize cache size. */\n\n  var MAX_MEMOIZE_SIZE = 500;\n  /** Used to compose bitmasks for value comparisons. */\n\n  var COMPARE_PARTIAL_FLAG = 1,\n      COMPARE_UNORDERED_FLAG = 2;\n  /** Used as references for various `Number` constants. */\n\n  var INFINITY = 1 / 0,\n      MAX_SAFE_INTEGER = 9007199254740991;\n  /** `Object#toString` result references. */\n\n  var argsTag = '[object Arguments]',\n      arrayTag = '[object Array]',\n      asyncTag = '[object AsyncFunction]',\n      boolTag = '[object Boolean]',\n      dateTag = '[object Date]',\n      errorTag = '[object Error]',\n      funcTag = '[object Function]',\n      genTag = '[object GeneratorFunction]',\n      mapTag = '[object Map]',\n      numberTag = '[object Number]',\n      nullTag = '[object Null]',\n      objectTag = '[object Object]',\n      promiseTag = '[object Promise]',\n      proxyTag = '[object Proxy]',\n      regexpTag = '[object RegExp]',\n      setTag = '[object Set]',\n      stringTag = '[object String]',\n      symbolTag = '[object Symbol]',\n      undefinedTag = '[object Undefined]',\n      weakMapTag = '[object WeakMap]';\n  var arrayBufferTag = '[object ArrayBuffer]',\n      dataViewTag = '[object DataView]',\n      float32Tag = '[object Float32Array]',\n      float64Tag = '[object Float64Array]',\n      int8Tag = '[object Int8Array]',\n      int16Tag = '[object Int16Array]',\n      int32Tag = '[object Int32Array]',\n      uint8Tag = '[object Uint8Array]',\n      uint8ClampedTag = '[object Uint8ClampedArray]',\n      uint16Tag = '[object Uint16Array]',\n      uint32Tag = '[object Uint32Array]';\n  /** Used to match property names within property paths. */\n\n  var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n      reIsPlainProp = /^\\w*$/,\n      rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n  /**\n   * Used to match `RegExp`\n   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n   */\n\n  var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n  /** Used to match backslashes in property paths. */\n\n  var reEscapeChar = /\\\\(\\\\)?/g;\n  /** Used to detect host constructors (Safari). */\n\n  var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n  /** Used to detect unsigned integer values. */\n\n  var reIsUint = /^(?:0|[1-9]\\d*)$/;\n  /** Used to identify `toStringTag` values of typed arrays. */\n\n  var typedArrayTags = {};\n  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;\n  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;\n  /** Detect free variable `global` from Node.js. */\n\n  var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;\n  /** Detect free variable `self`. */\n\n  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n  /** Used as a reference to the global object. */\n\n  var root = freeGlobal || freeSelf || Function('return this')();\n  /** Detect free variable `exports`. */\n\n  var freeExports =  exports && !exports.nodeType && exports;\n  /** Detect free variable `module`. */\n\n  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;\n  /** Detect the popular CommonJS extension `module.exports`. */\n\n  var moduleExports = freeModule && freeModule.exports === freeExports;\n  /** Detect free variable `process` from Node.js. */\n\n  var freeProcess = moduleExports && freeGlobal.process;\n  /** Used to access faster Node.js helpers. */\n\n  var nodeUtil = function () {\n    try {\n      return freeProcess && freeProcess.binding && freeProcess.binding('util');\n    } catch (e) {}\n  }();\n  /* Node.js helper references. */\n\n\n  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n  /**\n   * A specialized version of `_.filter` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {Array} Returns the new filtered array.\n   */\n\n  function arrayFilter(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length,\n        resIndex = 0,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index];\n\n      if (predicate(value, index, array)) {\n        result[resIndex++] = value;\n      }\n    }\n\n    return result;\n  }\n  /**\n   * A specialized version of `_.map` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the new mapped array.\n   */\n\n\n  function arrayMap(array, iteratee) {\n    var index = -1,\n        length = array == null ? 0 : array.length,\n        result = Array(length);\n\n    while (++index < length) {\n      result[index] = iteratee(array[index], index, array);\n    }\n\n    return result;\n  }\n  /**\n   * Appends the elements of `values` to `array`.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {Array} values The values to append.\n   * @returns {Array} Returns `array`.\n   */\n\n\n  function arrayPush(array, values) {\n    var index = -1,\n        length = values.length,\n        offset = array.length;\n\n    while (++index < length) {\n      array[offset + index] = values[index];\n    }\n\n    return array;\n  }\n  /**\n   * A specialized version of `_.some` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if any element passes the predicate check,\n   *  else `false`.\n   */\n\n\n  function arraySome(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (predicate(array[index], index, array)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n   * The base implementation of `_.property` without support for deep paths.\n   *\n   * @private\n   * @param {string} key The key of the property to get.\n   * @returns {Function} Returns the new accessor function.\n   */\n\n\n  function baseProperty(key) {\n    return function (object) {\n      return object == null ? undefined : object[key];\n    };\n  }\n  /**\n   * The base implementation of `_.times` without support for iteratee shorthands\n   * or max array length checks.\n   *\n   * @private\n   * @param {number} n The number of times to invoke `iteratee`.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the array of results.\n   */\n\n\n  function baseTimes(n, iteratee) {\n    var index = -1,\n        result = Array(n);\n\n    while (++index < n) {\n      result[index] = iteratee(index);\n    }\n\n    return result;\n  }\n  /**\n   * The base implementation of `_.unary` without support for storing metadata.\n   *\n   * @private\n   * @param {Function} func The function to cap arguments for.\n   * @returns {Function} Returns the new capped function.\n   */\n\n\n  function baseUnary(func) {\n    return function (value) {\n      return func(value);\n    };\n  }\n  /**\n   * Checks if a `cache` value for `key` exists.\n   *\n   * @private\n   * @param {Object} cache The cache to query.\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n\n\n  function cacheHas(cache, key) {\n    return cache.has(key);\n  }\n  /**\n   * Gets the value at `key` of `object`.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {string} key The key of the property to get.\n   * @returns {*} Returns the property value.\n   */\n\n\n  function getValue(object, key) {\n    return object == null ? undefined : object[key];\n  }\n  /**\n   * Converts `map` to its key-value pairs.\n   *\n   * @private\n   * @param {Object} map The map to convert.\n   * @returns {Array} Returns the key-value pairs.\n   */\n\n\n  function mapToArray(map) {\n    var index = -1,\n        result = Array(map.size);\n    map.forEach(function (value, key) {\n      result[++index] = [key, value];\n    });\n    return result;\n  }\n  /**\n   * Creates a unary function that invokes `func` with its argument transformed.\n   *\n   * @private\n   * @param {Function} func The function to wrap.\n   * @param {Function} transform The argument transform.\n   * @returns {Function} Returns the new function.\n   */\n\n\n  function overArg(func, transform) {\n    return function (arg) {\n      return func(transform(arg));\n    };\n  }\n  /**\n   * Converts `set` to an array of its values.\n   *\n   * @private\n   * @param {Object} set The set to convert.\n   * @returns {Array} Returns the values.\n   */\n\n\n  function setToArray(set) {\n    var index = -1,\n        result = Array(set.size);\n    set.forEach(function (value) {\n      result[++index] = value;\n    });\n    return result;\n  }\n  /** Used for built-in method references. */\n\n\n  var arrayProto = Array.prototype,\n      funcProto = Function.prototype,\n      objectProto = Object.prototype;\n  /** Used to detect overreaching core-js shims. */\n\n  var coreJsData = root['__core-js_shared__'];\n  /** Used to resolve the decompiled source of functions. */\n\n  var funcToString = funcProto.toString;\n  /** Used to check objects for own properties. */\n\n  var hasOwnProperty = objectProto.hasOwnProperty;\n  /** Used to detect methods masquerading as native. */\n\n  var maskSrcKey = function () {\n    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n    return uid ? 'Symbol(src)_1.' + uid : '';\n  }();\n  /**\n   * Used to resolve the\n   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n   * of values.\n   */\n\n\n  var nativeObjectToString = objectProto.toString;\n  /** Used to detect if a method is native. */\n\n  var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&').replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$');\n  /** Built-in value references. */\n\n  var Buffer = moduleExports ? root.Buffer : undefined,\n      Symbol = root.Symbol,\n      Uint8Array = root.Uint8Array,\n      propertyIsEnumerable = objectProto.propertyIsEnumerable,\n      splice = arrayProto.splice,\n      symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n\n  var nativeGetSymbols = Object.getOwnPropertySymbols,\n      nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n      nativeKeys = overArg(Object.keys, Object);\n  /* Built-in method references that are verified to be native. */\n\n  var DataView = getNative(root, 'DataView'),\n      Map = getNative(root, 'Map'),\n      Promise = getNative(root, 'Promise'),\n      Set = getNative(root, 'Set'),\n      WeakMap = getNative(root, 'WeakMap'),\n      nativeCreate = getNative(Object, 'create');\n  /** Used to detect maps, sets, and weakmaps. */\n\n  var dataViewCtorString = toSource(DataView),\n      mapCtorString = toSource(Map),\n      promiseCtorString = toSource(Promise),\n      setCtorString = toSource(Set),\n      weakMapCtorString = toSource(WeakMap);\n  /** Used to convert symbols to primitives and strings. */\n\n  var symbolProto = Symbol ? Symbol.prototype : undefined,\n      symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n      symbolToString = symbolProto ? symbolProto.toString : undefined;\n  /**\n   * Creates a hash object.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n\n  function Hash(entries) {\n    var index = -1,\n        length = entries == null ? 0 : entries.length;\n    this.clear();\n\n    while (++index < length) {\n      var entry = entries[index];\n      this.set(entry[0], entry[1]);\n    }\n  }\n  /**\n   * Removes all key-value entries from the hash.\n   *\n   * @private\n   * @name clear\n   * @memberOf Hash\n   */\n\n\n  function hashClear() {\n    this.__data__ = nativeCreate ? nativeCreate(null) : {};\n    this.size = 0;\n  }\n  /**\n   * Removes `key` and its value from the hash.\n   *\n   * @private\n   * @name delete\n   * @memberOf Hash\n   * @param {Object} hash The hash to modify.\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n\n\n  function hashDelete(key) {\n    var result = this.has(key) && delete this.__data__[key];\n    this.size -= result ? 1 : 0;\n    return result;\n  }\n  /**\n   * Gets the hash value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf Hash\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n\n\n  function hashGet(key) {\n    var data = this.__data__;\n\n    if (nativeCreate) {\n      var result = data[key];\n      return result === HASH_UNDEFINED ? undefined : result;\n    }\n\n    return hasOwnProperty.call(data, key) ? data[key] : undefined;\n  }\n  /**\n   * Checks if a hash value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf Hash\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n\n\n  function hashHas(key) {\n    var data = this.__data__;\n    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n  }\n  /**\n   * Sets the hash `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf Hash\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the hash instance.\n   */\n\n\n  function hashSet(key, value) {\n    var data = this.__data__;\n    this.size += this.has(key) ? 0 : 1;\n    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;\n    return this;\n  } // Add methods to `Hash`.\n\n\n  Hash.prototype.clear = hashClear;\n  Hash.prototype['delete'] = hashDelete;\n  Hash.prototype.get = hashGet;\n  Hash.prototype.has = hashHas;\n  Hash.prototype.set = hashSet;\n  /**\n   * Creates an list cache object.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n\n  function ListCache(entries) {\n    var index = -1,\n        length = entries == null ? 0 : entries.length;\n    this.clear();\n\n    while (++index < length) {\n      var entry = entries[index];\n      this.set(entry[0], entry[1]);\n    }\n  }\n  /**\n   * Removes all key-value entries from the list cache.\n   *\n   * @private\n   * @name clear\n   * @memberOf ListCache\n   */\n\n\n  function listCacheClear() {\n    this.__data__ = [];\n    this.size = 0;\n  }\n  /**\n   * Removes `key` and its value from the list cache.\n   *\n   * @private\n   * @name delete\n   * @memberOf ListCache\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n\n\n  function listCacheDelete(key) {\n    var data = this.__data__,\n        index = assocIndexOf(data, key);\n\n    if (index < 0) {\n      return false;\n    }\n\n    var lastIndex = data.length - 1;\n\n    if (index == lastIndex) {\n      data.pop();\n    } else {\n      splice.call(data, index, 1);\n    }\n\n    --this.size;\n    return true;\n  }\n  /**\n   * Gets the list cache value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf ListCache\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n\n\n  function listCacheGet(key) {\n    var data = this.__data__,\n        index = assocIndexOf(data, key);\n    return index < 0 ? undefined : data[index][1];\n  }\n  /**\n   * Checks if a list cache value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf ListCache\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n\n\n  function listCacheHas(key) {\n    return assocIndexOf(this.__data__, key) > -1;\n  }\n  /**\n   * Sets the list cache `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf ListCache\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the list cache instance.\n   */\n\n\n  function listCacheSet(key, value) {\n    var data = this.__data__,\n        index = assocIndexOf(data, key);\n\n    if (index < 0) {\n      ++this.size;\n      data.push([key, value]);\n    } else {\n      data[index][1] = value;\n    }\n\n    return this;\n  } // Add methods to `ListCache`.\n\n\n  ListCache.prototype.clear = listCacheClear;\n  ListCache.prototype['delete'] = listCacheDelete;\n  ListCache.prototype.get = listCacheGet;\n  ListCache.prototype.has = listCacheHas;\n  ListCache.prototype.set = listCacheSet;\n  /**\n   * Creates a map cache object to store key-value pairs.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n\n  function MapCache(entries) {\n    var index = -1,\n        length = entries == null ? 0 : entries.length;\n    this.clear();\n\n    while (++index < length) {\n      var entry = entries[index];\n      this.set(entry[0], entry[1]);\n    }\n  }\n  /**\n   * Removes all key-value entries from the map.\n   *\n   * @private\n   * @name clear\n   * @memberOf MapCache\n   */\n\n\n  function mapCacheClear() {\n    this.size = 0;\n    this.__data__ = {\n      'hash': new Hash(),\n      'map': new (Map || ListCache)(),\n      'string': new Hash()\n    };\n  }\n  /**\n   * Removes `key` and its value from the map.\n   *\n   * @private\n   * @name delete\n   * @memberOf MapCache\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n\n\n  function mapCacheDelete(key) {\n    var result = getMapData(this, key)['delete'](key);\n    this.size -= result ? 1 : 0;\n    return result;\n  }\n  /**\n   * Gets the map value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf MapCache\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n\n\n  function mapCacheGet(key) {\n    return getMapData(this, key).get(key);\n  }\n  /**\n   * Checks if a map value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf MapCache\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n\n\n  function mapCacheHas(key) {\n    return getMapData(this, key).has(key);\n  }\n  /**\n   * Sets the map `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf MapCache\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the map cache instance.\n   */\n\n\n  function mapCacheSet(key, value) {\n    var data = getMapData(this, key),\n        size = data.size;\n    data.set(key, value);\n    this.size += data.size == size ? 0 : 1;\n    return this;\n  } // Add methods to `MapCache`.\n\n\n  MapCache.prototype.clear = mapCacheClear;\n  MapCache.prototype['delete'] = mapCacheDelete;\n  MapCache.prototype.get = mapCacheGet;\n  MapCache.prototype.has = mapCacheHas;\n  MapCache.prototype.set = mapCacheSet;\n  /**\n   *\n   * Creates an array cache object to store unique values.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [values] The values to cache.\n   */\n\n  function SetCache(values) {\n    var index = -1,\n        length = values == null ? 0 : values.length;\n    this.__data__ = new MapCache();\n\n    while (++index < length) {\n      this.add(values[index]);\n    }\n  }\n  /**\n   * Adds `value` to the array cache.\n   *\n   * @private\n   * @name add\n   * @memberOf SetCache\n   * @alias push\n   * @param {*} value The value to cache.\n   * @returns {Object} Returns the cache instance.\n   */\n\n\n  function setCacheAdd(value) {\n    this.__data__.set(value, HASH_UNDEFINED);\n\n    return this;\n  }\n  /**\n   * Checks if `value` is in the array cache.\n   *\n   * @private\n   * @name has\n   * @memberOf SetCache\n   * @param {*} value The value to search for.\n   * @returns {number} Returns `true` if `value` is found, else `false`.\n   */\n\n\n  function setCacheHas(value) {\n    return this.__data__.has(value);\n  } // Add methods to `SetCache`.\n\n\n  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\n  SetCache.prototype.has = setCacheHas;\n  /**\n   * Creates a stack cache object to store key-value pairs.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n\n  function Stack(entries) {\n    var data = this.__data__ = new ListCache(entries);\n    this.size = data.size;\n  }\n  /**\n   * Removes all key-value entries from the stack.\n   *\n   * @private\n   * @name clear\n   * @memberOf Stack\n   */\n\n\n  function stackClear() {\n    this.__data__ = new ListCache();\n    this.size = 0;\n  }\n  /**\n   * Removes `key` and its value from the stack.\n   *\n   * @private\n   * @name delete\n   * @memberOf Stack\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n\n\n  function stackDelete(key) {\n    var data = this.__data__,\n        result = data['delete'](key);\n    this.size = data.size;\n    return result;\n  }\n  /**\n   * Gets the stack value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf Stack\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n\n\n  function stackGet(key) {\n    return this.__data__.get(key);\n  }\n  /**\n   * Checks if a stack value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf Stack\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n\n\n  function stackHas(key) {\n    return this.__data__.has(key);\n  }\n  /**\n   * Sets the stack `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf Stack\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the stack cache instance.\n   */\n\n\n  function stackSet(key, value) {\n    var data = this.__data__;\n\n    if (data instanceof ListCache) {\n      var pairs = data.__data__;\n\n      if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {\n        pairs.push([key, value]);\n        this.size = ++data.size;\n        return this;\n      }\n\n      data = this.__data__ = new MapCache(pairs);\n    }\n\n    data.set(key, value);\n    this.size = data.size;\n    return this;\n  } // Add methods to `Stack`.\n\n\n  Stack.prototype.clear = stackClear;\n  Stack.prototype['delete'] = stackDelete;\n  Stack.prototype.get = stackGet;\n  Stack.prototype.has = stackHas;\n  Stack.prototype.set = stackSet;\n  /**\n   * Creates an array of the enumerable property names of the array-like `value`.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @param {boolean} inherited Specify returning inherited property names.\n   * @returns {Array} Returns the array of property names.\n   */\n\n  function arrayLikeKeys(value, inherited) {\n    var isArr = isArray(value),\n        isArg = !isArr && isArguments(value),\n        isBuff = !isArr && !isArg && isBuffer(value),\n        isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n        skipIndexes = isArr || isArg || isBuff || isType,\n        result = skipIndexes ? baseTimes(value.length, String) : [],\n        length = result.length;\n\n    for (var key in value) {\n      if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.\n      key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.\n      isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.\n      isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.\n      isIndex(key, length)))) {\n        result.push(key);\n      }\n    }\n\n    return result;\n  }\n  /**\n   * Gets the index at which the `key` is found in `array` of key-value pairs.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} key The key to search for.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n\n\n  function assocIndexOf(array, key) {\n    var length = array.length;\n\n    while (length--) {\n      if (eq(array[length][0], key)) {\n        return length;\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * The base implementation of `_.forEach` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array|Object} Returns `collection`.\n   */\n\n\n  var baseEach = createBaseEach(baseForOwn);\n  /**\n   * The base implementation of `_.filter` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {Array} Returns the new filtered array.\n   */\n\n  function baseFilter(collection, predicate) {\n    var result = [];\n    baseEach(collection, function (value, index, collection) {\n      if (predicate(value, index, collection)) {\n        result.push(value);\n      }\n    });\n    return result;\n  }\n  /**\n   * The base implementation of `baseForOwn` which iterates over `object`\n   * properties returned by `keysFunc` and invokes `iteratee` for each property.\n   * Iteratee functions may exit iteration early by explicitly returning `false`.\n   *\n   * @private\n   * @param {Object} object The object to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {Function} keysFunc The function to get the keys of `object`.\n   * @returns {Object} Returns `object`.\n   */\n\n\n  var baseFor = createBaseFor();\n  /**\n   * The base implementation of `_.forOwn` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Object} object The object to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Object} Returns `object`.\n   */\n\n  function baseForOwn(object, iteratee) {\n    return object && baseFor(object, iteratee, keys);\n  }\n  /**\n   * The base implementation of `_.get` without support for default values.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path of the property to get.\n   * @returns {*} Returns the resolved value.\n   */\n\n\n  function baseGet(object, path) {\n    path = castPath(path, object);\n    var index = 0,\n        length = path.length;\n\n    while (object != null && index < length) {\n      object = object[toKey(path[index++])];\n    }\n\n    return index && index == length ? object : undefined;\n  }\n  /**\n   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n   * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n   * symbols of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Function} keysFunc The function to get the keys of `object`.\n   * @param {Function} symbolsFunc The function to get the symbols of `object`.\n   * @returns {Array} Returns the array of property names and symbols.\n   */\n\n\n  function baseGetAllKeys(object, keysFunc, symbolsFunc) {\n    var result = keysFunc(object);\n    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n  }\n  /**\n   * The base implementation of `getTag` without fallbacks for buggy environments.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @returns {string} Returns the `toStringTag`.\n   */\n\n\n  function baseGetTag(value) {\n    if (value == null) {\n      return value === undefined ? undefinedTag : nullTag;\n    }\n\n    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);\n  }\n  /**\n   * The base implementation of `_.hasIn` without support for deep paths.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {Array|string} key The key to check.\n   * @returns {boolean} Returns `true` if `key` exists, else `false`.\n   */\n\n\n  function baseHasIn(object, key) {\n    return object != null && key in Object(object);\n  }\n  /**\n   * The base implementation of `_.isArguments`.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n   */\n\n\n  function baseIsArguments(value) {\n    return isObjectLike(value) && baseGetTag(value) == argsTag;\n  }\n  /**\n   * The base implementation of `_.isEqual` which supports partial comparisons\n   * and tracks traversed objects.\n   *\n   * @private\n   * @param {*} value The value to compare.\n   * @param {*} other The other value to compare.\n   * @param {boolean} bitmask The bitmask flags.\n   *  1 - Unordered comparison\n   *  2 - Partial comparison\n   * @param {Function} [customizer] The function to customize comparisons.\n   * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n   */\n\n\n  function baseIsEqual(value, other, bitmask, customizer, stack) {\n    if (value === other) {\n      return true;\n    }\n\n    if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {\n      return value !== value && other !== other;\n    }\n\n    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n  }\n  /**\n   * A specialized version of `baseIsEqual` for arrays and objects which performs\n   * deep comparisons and tracks traversed objects enabling objects with circular\n   * references to be compared.\n   *\n   * @private\n   * @param {Object} object The object to compare.\n   * @param {Object} other The other object to compare.\n   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n   * @param {Function} customizer The function to customize comparisons.\n   * @param {Function} equalFunc The function to determine equivalents of values.\n   * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n   */\n\n\n  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n    var objIsArr = isArray(object),\n        othIsArr = isArray(other),\n        objTag = objIsArr ? arrayTag : getTag(object),\n        othTag = othIsArr ? arrayTag : getTag(other);\n    objTag = objTag == argsTag ? objectTag : objTag;\n    othTag = othTag == argsTag ? objectTag : othTag;\n    var objIsObj = objTag == objectTag,\n        othIsObj = othTag == objectTag,\n        isSameTag = objTag == othTag;\n\n    if (isSameTag && isBuffer(object)) {\n      if (!isBuffer(other)) {\n        return false;\n      }\n\n      objIsArr = true;\n      objIsObj = false;\n    }\n\n    if (isSameTag && !objIsObj) {\n      stack || (stack = new Stack());\n      return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n    }\n\n    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n      var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n          othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n      if (objIsWrapped || othIsWrapped) {\n        var objUnwrapped = objIsWrapped ? object.value() : object,\n            othUnwrapped = othIsWrapped ? other.value() : other;\n        stack || (stack = new Stack());\n        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n      }\n    }\n\n    if (!isSameTag) {\n      return false;\n    }\n\n    stack || (stack = new Stack());\n    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n  }\n  /**\n   * The base implementation of `_.isMatch` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Object} object The object to inspect.\n   * @param {Object} source The object of property values to match.\n   * @param {Array} matchData The property names, values, and compare flags to match.\n   * @param {Function} [customizer] The function to customize comparisons.\n   * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n   */\n\n\n  function baseIsMatch(object, source, matchData, customizer) {\n    var index = matchData.length,\n        length = index,\n        noCustomizer = !customizer;\n\n    if (object == null) {\n      return !length;\n    }\n\n    object = Object(object);\n\n    while (index--) {\n      var data = matchData[index];\n\n      if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {\n        return false;\n      }\n    }\n\n    while (++index < length) {\n      data = matchData[index];\n      var key = data[0],\n          objValue = object[key],\n          srcValue = data[1];\n\n      if (noCustomizer && data[2]) {\n        if (objValue === undefined && !(key in object)) {\n          return false;\n        }\n      } else {\n        var stack = new Stack();\n\n        if (customizer) {\n          var result = customizer(objValue, srcValue, key, object, source, stack);\n        }\n\n        if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n  /**\n   * The base implementation of `_.isNative` without bad shim checks.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a native function,\n   *  else `false`.\n   */\n\n\n  function baseIsNative(value) {\n    if (!isObject(value) || isMasked(value)) {\n      return false;\n    }\n\n    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n    return pattern.test(toSource(value));\n  }\n  /**\n   * The base implementation of `_.isTypedArray` without Node.js optimizations.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n   */\n\n\n  function baseIsTypedArray(value) {\n    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n  }\n  /**\n   * The base implementation of `_.iteratee`.\n   *\n   * @private\n   * @param {*} [value=_.identity] The value to convert to an iteratee.\n   * @returns {Function} Returns the iteratee.\n   */\n\n\n  function baseIteratee(value) {\n    // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n    // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n    if (typeof value == 'function') {\n      return value;\n    }\n\n    if (value == null) {\n      return identity;\n    }\n\n    if (typeof value == 'object') {\n      return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);\n    }\n\n    return property(value);\n  }\n  /**\n   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names.\n   */\n\n\n  function baseKeys(object) {\n    if (!isPrototype(object)) {\n      return nativeKeys(object);\n    }\n\n    var result = [];\n\n    for (var key in Object(object)) {\n      if (hasOwnProperty.call(object, key) && key != 'constructor') {\n        result.push(key);\n      }\n    }\n\n    return result;\n  }\n  /**\n   * The base implementation of `_.matches` which doesn't clone `source`.\n   *\n   * @private\n   * @param {Object} source The object of property values to match.\n   * @returns {Function} Returns the new spec function.\n   */\n\n\n  function baseMatches(source) {\n    var matchData = getMatchData(source);\n\n    if (matchData.length == 1 && matchData[0][2]) {\n      return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n    }\n\n    return function (object) {\n      return object === source || baseIsMatch(object, source, matchData);\n    };\n  }\n  /**\n   * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n   *\n   * @private\n   * @param {string} path The path of the property to get.\n   * @param {*} srcValue The value to match.\n   * @returns {Function} Returns the new spec function.\n   */\n\n\n  function baseMatchesProperty(path, srcValue) {\n    if (isKey(path) && isStrictComparable(srcValue)) {\n      return matchesStrictComparable(toKey(path), srcValue);\n    }\n\n    return function (object) {\n      var objValue = get(object, path);\n      return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n    };\n  }\n  /**\n   * A specialized version of `baseProperty` which supports deep paths.\n   *\n   * @private\n   * @param {Array|string} path The path of the property to get.\n   * @returns {Function} Returns the new accessor function.\n   */\n\n\n  function basePropertyDeep(path) {\n    return function (object) {\n      return baseGet(object, path);\n    };\n  }\n  /**\n   * The base implementation of `_.toString` which doesn't convert nullish\n   * values to empty strings.\n   *\n   * @private\n   * @param {*} value The value to process.\n   * @returns {string} Returns the string.\n   */\n\n\n  function baseToString(value) {\n    // Exit early for strings to avoid a performance hit in some environments.\n    if (typeof value == 'string') {\n      return value;\n    }\n\n    if (isArray(value)) {\n      // Recursively convert values (susceptible to call stack limits).\n      return arrayMap(value, baseToString) + '';\n    }\n\n    if (isSymbol(value)) {\n      return symbolToString ? symbolToString.call(value) : '';\n    }\n\n    var result = value + '';\n    return result == '0' && 1 / value == -INFINITY ? '-0' : result;\n  }\n  /**\n   * Casts `value` to a path array if it's not one.\n   *\n   * @private\n   * @param {*} value The value to inspect.\n   * @param {Object} [object] The object to query keys on.\n   * @returns {Array} Returns the cast property path array.\n   */\n\n\n  function castPath(value, object) {\n    if (isArray(value)) {\n      return value;\n    }\n\n    return isKey(value, object) ? [value] : stringToPath(toString(value));\n  }\n  /**\n   * Creates a `baseEach` or `baseEachRight` function.\n   *\n   * @private\n   * @param {Function} eachFunc The function to iterate over a collection.\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {Function} Returns the new base function.\n   */\n\n\n  function createBaseEach(eachFunc, fromRight) {\n    return function (collection, iteratee) {\n      if (collection == null) {\n        return collection;\n      }\n\n      if (!isArrayLike(collection)) {\n        return eachFunc(collection, iteratee);\n      }\n\n      var length = collection.length,\n          index = fromRight ? length : -1,\n          iterable = Object(collection);\n\n      while (fromRight ? index-- : ++index < length) {\n        if (iteratee(iterable[index], index, iterable) === false) {\n          break;\n        }\n      }\n\n      return collection;\n    };\n  }\n  /**\n   * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n   *\n   * @private\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {Function} Returns the new base function.\n   */\n\n\n  function createBaseFor(fromRight) {\n    return function (object, iteratee, keysFunc) {\n      var index = -1,\n          iterable = Object(object),\n          props = keysFunc(object),\n          length = props.length;\n\n      while (length--) {\n        var key = props[fromRight ? length : ++index];\n\n        if (iteratee(iterable[key], key, iterable) === false) {\n          break;\n        }\n      }\n\n      return object;\n    };\n  }\n  /**\n   * A specialized version of `baseIsEqualDeep` for arrays with support for\n   * partial deep comparisons.\n   *\n   * @private\n   * @param {Array} array The array to compare.\n   * @param {Array} other The other array to compare.\n   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n   * @param {Function} customizer The function to customize comparisons.\n   * @param {Function} equalFunc The function to determine equivalents of values.\n   * @param {Object} stack Tracks traversed `array` and `other` objects.\n   * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n   */\n\n\n  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n        arrLength = array.length,\n        othLength = other.length;\n\n    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n      return false;\n    } // Assume cyclic values are equal.\n\n\n    var stacked = stack.get(array);\n\n    if (stacked && stack.get(other)) {\n      return stacked == other;\n    }\n\n    var index = -1,\n        result = true,\n        seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;\n    stack.set(array, other);\n    stack.set(other, array); // Ignore non-index properties.\n\n    while (++index < arrLength) {\n      var arrValue = array[index],\n          othValue = other[index];\n\n      if (customizer) {\n        var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);\n      }\n\n      if (compared !== undefined) {\n        if (compared) {\n          continue;\n        }\n\n        result = false;\n        break;\n      } // Recursively compare arrays (susceptible to call stack limits).\n\n\n      if (seen) {\n        if (!arraySome(other, function (othValue, othIndex) {\n          if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n            return seen.push(othIndex);\n          }\n        })) {\n          result = false;\n          break;\n        }\n      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n        result = false;\n        break;\n      }\n    }\n\n    stack['delete'](array);\n    stack['delete'](other);\n    return result;\n  }\n  /**\n   * A specialized version of `baseIsEqualDeep` for comparing objects of\n   * the same `toStringTag`.\n   *\n   * **Note:** This function only supports comparing values with tags of\n   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n   *\n   * @private\n   * @param {Object} object The object to compare.\n   * @param {Object} other The other object to compare.\n   * @param {string} tag The `toStringTag` of the objects to compare.\n   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n   * @param {Function} customizer The function to customize comparisons.\n   * @param {Function} equalFunc The function to determine equivalents of values.\n   * @param {Object} stack Tracks traversed `object` and `other` objects.\n   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n   */\n\n\n  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n    switch (tag) {\n      case dataViewTag:\n        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {\n          return false;\n        }\n\n        object = object.buffer;\n        other = other.buffer;\n\n      case arrayBufferTag:\n        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n          return false;\n        }\n\n        return true;\n\n      case boolTag:\n      case dateTag:\n      case numberTag:\n        // Coerce booleans to `1` or `0` and dates to milliseconds.\n        // Invalid dates are coerced to `NaN`.\n        return eq(+object, +other);\n\n      case errorTag:\n        return object.name == other.name && object.message == other.message;\n\n      case regexpTag:\n      case stringTag:\n        // Coerce regexes to strings and treat strings, primitives and objects,\n        // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n        // for more details.\n        return object == other + '';\n\n      case mapTag:\n        var convert = mapToArray;\n\n      case setTag:\n        var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n        convert || (convert = setToArray);\n\n        if (object.size != other.size && !isPartial) {\n          return false;\n        } // Assume cyclic values are equal.\n\n\n        var stacked = stack.get(object);\n\n        if (stacked) {\n          return stacked == other;\n        }\n\n        bitmask |= COMPARE_UNORDERED_FLAG; // Recursively compare objects (susceptible to call stack limits).\n\n        stack.set(object, other);\n        var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n        stack['delete'](object);\n        return result;\n\n      case symbolTag:\n        if (symbolValueOf) {\n          return symbolValueOf.call(object) == symbolValueOf.call(other);\n        }\n\n    }\n\n    return false;\n  }\n  /**\n   * A specialized version of `baseIsEqualDeep` for objects with support for\n   * partial deep comparisons.\n   *\n   * @private\n   * @param {Object} object The object to compare.\n   * @param {Object} other The other object to compare.\n   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n   * @param {Function} customizer The function to customize comparisons.\n   * @param {Function} equalFunc The function to determine equivalents of values.\n   * @param {Object} stack Tracks traversed `object` and `other` objects.\n   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n   */\n\n\n  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n        objProps = getAllKeys(object),\n        objLength = objProps.length,\n        othProps = getAllKeys(other),\n        othLength = othProps.length;\n\n    if (objLength != othLength && !isPartial) {\n      return false;\n    }\n\n    var index = objLength;\n\n    while (index--) {\n      var key = objProps[index];\n\n      if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n        return false;\n      }\n    } // Assume cyclic values are equal.\n\n\n    var stacked = stack.get(object);\n\n    if (stacked && stack.get(other)) {\n      return stacked == other;\n    }\n\n    var result = true;\n    stack.set(object, other);\n    stack.set(other, object);\n    var skipCtor = isPartial;\n\n    while (++index < objLength) {\n      key = objProps[index];\n      var objValue = object[key],\n          othValue = other[key];\n\n      if (customizer) {\n        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);\n      } // Recursively compare objects (susceptible to call stack limits).\n\n\n      if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {\n        result = false;\n        break;\n      }\n\n      skipCtor || (skipCtor = key == 'constructor');\n    }\n\n    if (result && !skipCtor) {\n      var objCtor = object.constructor,\n          othCtor = other.constructor; // Non `Object` object instances with different constructors are not equal.\n\n      if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n        result = false;\n      }\n    }\n\n    stack['delete'](object);\n    stack['delete'](other);\n    return result;\n  }\n  /**\n   * Creates an array of own enumerable property names and symbols of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names and symbols.\n   */\n\n\n  function getAllKeys(object) {\n    return baseGetAllKeys(object, keys, getSymbols);\n  }\n  /**\n   * Gets the data for `map`.\n   *\n   * @private\n   * @param {Object} map The map to query.\n   * @param {string} key The reference key.\n   * @returns {*} Returns the map data.\n   */\n\n\n  function getMapData(map, key) {\n    var data = map.__data__;\n    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;\n  }\n  /**\n   * Gets the property names, values, and compare flags of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the match data of `object`.\n   */\n\n\n  function getMatchData(object) {\n    var result = keys(object),\n        length = result.length;\n\n    while (length--) {\n      var key = result[length],\n          value = object[key];\n      result[length] = [key, value, isStrictComparable(value)];\n    }\n\n    return result;\n  }\n  /**\n   * Gets the native function at `key` of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {string} key The key of the method to get.\n   * @returns {*} Returns the function if it's native, else `undefined`.\n   */\n\n\n  function getNative(object, key) {\n    var value = getValue(object, key);\n    return baseIsNative(value) ? value : undefined;\n  }\n  /**\n   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @returns {string} Returns the raw `toStringTag`.\n   */\n\n\n  function getRawTag(value) {\n    var isOwn = hasOwnProperty.call(value, symToStringTag),\n        tag = value[symToStringTag];\n\n    try {\n      value[symToStringTag] = undefined;\n      var unmasked = true;\n    } catch (e) {}\n\n    var result = nativeObjectToString.call(value);\n\n    if (unmasked) {\n      if (isOwn) {\n        value[symToStringTag] = tag;\n      } else {\n        delete value[symToStringTag];\n      }\n    }\n\n    return result;\n  }\n  /**\n   * Creates an array of the own enumerable symbols of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of symbols.\n   */\n\n\n  var getSymbols = !nativeGetSymbols ? stubArray : function (object) {\n    if (object == null) {\n      return [];\n    }\n\n    object = Object(object);\n    return arrayFilter(nativeGetSymbols(object), function (symbol) {\n      return propertyIsEnumerable.call(object, symbol);\n    });\n  };\n  /**\n   * Gets the `toStringTag` of `value`.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @returns {string} Returns the `toStringTag`.\n   */\n\n  var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\n\n  if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {\n    getTag = function (value) {\n      var result = baseGetTag(value),\n          Ctor = result == objectTag ? value.constructor : undefined,\n          ctorString = Ctor ? toSource(Ctor) : '';\n\n      if (ctorString) {\n        switch (ctorString) {\n          case dataViewCtorString:\n            return dataViewTag;\n\n          case mapCtorString:\n            return mapTag;\n\n          case promiseCtorString:\n            return promiseTag;\n\n          case setCtorString:\n            return setTag;\n\n          case weakMapCtorString:\n            return weakMapTag;\n        }\n      }\n\n      return result;\n    };\n  }\n  /**\n   * Checks if `path` exists on `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path to check.\n   * @param {Function} hasFunc The function to check properties.\n   * @returns {boolean} Returns `true` if `path` exists, else `false`.\n   */\n\n\n  function hasPath(object, path, hasFunc) {\n    path = castPath(path, object);\n    var index = -1,\n        length = path.length,\n        result = false;\n\n    while (++index < length) {\n      var key = toKey(path[index]);\n\n      if (!(result = object != null && hasFunc(object, key))) {\n        break;\n      }\n\n      object = object[key];\n    }\n\n    if (result || ++index != length) {\n      return result;\n    }\n\n    length = object == null ? 0 : object.length;\n    return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));\n  }\n  /**\n   * Checks if `value` is a valid array-like index.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n   */\n\n\n  function isIndex(value, length) {\n    var type = typeof value;\n    length = length == null ? MAX_SAFE_INTEGER : length;\n    return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;\n  }\n  /**\n   * Checks if `value` is a property name and not a property path.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @param {Object} [object] The object to query keys on.\n   * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n   */\n\n\n  function isKey(value, object) {\n    if (isArray(value)) {\n      return false;\n    }\n\n    var type = typeof value;\n\n    if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {\n      return true;\n    }\n\n    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);\n  }\n  /**\n   * Checks if `value` is suitable for use as unique object key.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n   */\n\n\n  function isKeyable(value) {\n    var type = typeof value;\n    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;\n  }\n  /**\n   * Checks if `func` has its source masked.\n   *\n   * @private\n   * @param {Function} func The function to check.\n   * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n   */\n\n\n  function isMasked(func) {\n    return !!maskSrcKey && maskSrcKey in func;\n  }\n  /**\n   * Checks if `value` is likely a prototype object.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n   */\n\n\n  function isPrototype(value) {\n    var Ctor = value && value.constructor,\n        proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;\n    return value === proto;\n  }\n  /**\n   * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` if suitable for strict\n   *  equality comparisons, else `false`.\n   */\n\n\n  function isStrictComparable(value) {\n    return value === value && !isObject(value);\n  }\n  /**\n   * A specialized version of `matchesProperty` for source values suitable\n   * for strict equality comparisons, i.e. `===`.\n   *\n   * @private\n   * @param {string} key The key of the property to get.\n   * @param {*} srcValue The value to match.\n   * @returns {Function} Returns the new spec function.\n   */\n\n\n  function matchesStrictComparable(key, srcValue) {\n    return function (object) {\n      if (object == null) {\n        return false;\n      }\n\n      return object[key] === srcValue && (srcValue !== undefined || key in Object(object));\n    };\n  }\n  /**\n   * A specialized version of `_.memoize` which clears the memoized function's\n   * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n   *\n   * @private\n   * @param {Function} func The function to have its output memoized.\n   * @returns {Function} Returns the new memoized function.\n   */\n\n\n  function memoizeCapped(func) {\n    var result = memoize(func, function (key) {\n      if (cache.size === MAX_MEMOIZE_SIZE) {\n        cache.clear();\n      }\n\n      return key;\n    });\n    var cache = result.cache;\n    return result;\n  }\n  /**\n   * Converts `value` to a string using `Object.prototype.toString`.\n   *\n   * @private\n   * @param {*} value The value to convert.\n   * @returns {string} Returns the converted string.\n   */\n\n\n  function objectToString(value) {\n    return nativeObjectToString.call(value);\n  }\n  /**\n   * Converts `string` to a property path array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the property path array.\n   */\n\n\n  var stringToPath = memoizeCapped(function (string) {\n    var result = [];\n\n    if (string.charCodeAt(0) === 46\n    /* . */\n    ) {\n        result.push('');\n      }\n\n    string.replace(rePropName, function (match, number, quote, subString) {\n      result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);\n    });\n    return result;\n  });\n  /**\n   * Converts `value` to a string key if it's not a string or symbol.\n   *\n   * @private\n   * @param {*} value The value to inspect.\n   * @returns {string|symbol} Returns the key.\n   */\n\n  function toKey(value) {\n    if (typeof value == 'string' || isSymbol(value)) {\n      return value;\n    }\n\n    var result = value + '';\n    return result == '0' && 1 / value == -INFINITY ? '-0' : result;\n  }\n  /**\n   * Converts `func` to its source code.\n   *\n   * @private\n   * @param {Function} func The function to convert.\n   * @returns {string} Returns the source code.\n   */\n\n\n  function toSource(func) {\n    if (func != null) {\n      try {\n        return funcToString.call(func);\n      } catch (e) {}\n\n      try {\n        return func + '';\n      } catch (e) {}\n    }\n\n    return '';\n  }\n  /**\n   * Iterates over elements of `collection`, returning an array of all elements\n   * `predicate` returns truthy for. The predicate is invoked with three\n   * arguments: (value, index|key, collection).\n   *\n   * **Note:** Unlike `_.remove`, this method returns a new array.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Collection\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} [predicate=_.identity] The function invoked per iteration.\n   * @returns {Array} Returns the new filtered array.\n   * @see _.reject\n   * @example\n   *\n   * var users = [\n   *   { 'user': 'barney', 'age': 36, 'active': true },\n   *   { 'user': 'fred',   'age': 40, 'active': false }\n   * ];\n   *\n   * _.filter(users, function(o) { return !o.active; });\n   * // => objects for ['fred']\n   *\n   * // The `_.matches` iteratee shorthand.\n   * _.filter(users, { 'age': 36, 'active': true });\n   * // => objects for ['barney']\n   *\n   * // The `_.matchesProperty` iteratee shorthand.\n   * _.filter(users, ['active', false]);\n   * // => objects for ['fred']\n   *\n   * // The `_.property` iteratee shorthand.\n   * _.filter(users, 'active');\n   * // => objects for ['barney']\n   */\n\n\n  function filter(collection, predicate) {\n    var func = isArray(collection) ? arrayFilter : baseFilter;\n    return func(collection, baseIteratee(predicate));\n  }\n  /**\n   * Creates a function that memoizes the result of `func`. If `resolver` is\n   * provided, it determines the cache key for storing the result based on the\n   * arguments provided to the memoized function. By default, the first argument\n   * provided to the memoized function is used as the map cache key. The `func`\n   * is invoked with the `this` binding of the memoized function.\n   *\n   * **Note:** The cache is exposed as the `cache` property on the memoized\n   * function. Its creation may be customized by replacing the `_.memoize.Cache`\n   * constructor with one whose instances implement the\n   * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n   * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Function\n   * @param {Function} func The function to have its output memoized.\n   * @param {Function} [resolver] The function to resolve the cache key.\n   * @returns {Function} Returns the new memoized function.\n   * @example\n   *\n   * var object = { 'a': 1, 'b': 2 };\n   * var other = { 'c': 3, 'd': 4 };\n   *\n   * var values = _.memoize(_.values);\n   * values(object);\n   * // => [1, 2]\n   *\n   * values(other);\n   * // => [3, 4]\n   *\n   * object.a = 2;\n   * values(object);\n   * // => [1, 2]\n   *\n   * // Modify the result cache.\n   * values.cache.set(object, ['a', 'b']);\n   * values(object);\n   * // => ['a', 'b']\n   *\n   * // Replace `_.memoize.Cache`.\n   * _.memoize.Cache = WeakMap;\n   */\n\n\n  function memoize(func, resolver) {\n    if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {\n      throw new TypeError(FUNC_ERROR_TEXT);\n    }\n\n    var memoized = function () {\n      var args = arguments,\n          key = resolver ? resolver.apply(this, args) : args[0],\n          cache = memoized.cache;\n\n      if (cache.has(key)) {\n        return cache.get(key);\n      }\n\n      var result = func.apply(this, args);\n      memoized.cache = cache.set(key, result) || cache;\n      return result;\n    };\n\n    memoized.cache = new (memoize.Cache || MapCache)();\n    return memoized;\n  } // Expose `MapCache`.\n\n\n  memoize.Cache = MapCache;\n  /**\n   * Performs a\n   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n   * comparison between two values to determine if they are equivalent.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to compare.\n   * @param {*} other The other value to compare.\n   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n   * @example\n   *\n   * var object = { 'a': 1 };\n   * var other = { 'a': 1 };\n   *\n   * _.eq(object, object);\n   * // => true\n   *\n   * _.eq(object, other);\n   * // => false\n   *\n   * _.eq('a', 'a');\n   * // => true\n   *\n   * _.eq('a', Object('a'));\n   * // => false\n   *\n   * _.eq(NaN, NaN);\n   * // => true\n   */\n\n  function eq(value, other) {\n    return value === other || value !== value && other !== other;\n  }\n  /**\n   * Checks if `value` is likely an `arguments` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n   *  else `false`.\n   * @example\n   *\n   * _.isArguments(function() { return arguments; }());\n   * // => true\n   *\n   * _.isArguments([1, 2, 3]);\n   * // => false\n   */\n\n\n  var isArguments = baseIsArguments(function () {\n    return arguments;\n  }()) ? baseIsArguments : function (value) {\n    return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');\n  };\n  /**\n   * Checks if `value` is classified as an `Array` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n   * @example\n   *\n   * _.isArray([1, 2, 3]);\n   * // => true\n   *\n   * _.isArray(document.body.children);\n   * // => false\n   *\n   * _.isArray('abc');\n   * // => false\n   *\n   * _.isArray(_.noop);\n   * // => false\n   */\n\n  var isArray = Array.isArray;\n  /**\n   * Checks if `value` is array-like. A value is considered array-like if it's\n   * not a function and has a `value.length` that's an integer greater than or\n   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n   * @example\n   *\n   * _.isArrayLike([1, 2, 3]);\n   * // => true\n   *\n   * _.isArrayLike(document.body.children);\n   * // => true\n   *\n   * _.isArrayLike('abc');\n   * // => true\n   *\n   * _.isArrayLike(_.noop);\n   * // => false\n   */\n\n  function isArrayLike(value) {\n    return value != null && isLength(value.length) && !isFunction(value);\n  }\n  /**\n   * Checks if `value` is a buffer.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.3.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n   * @example\n   *\n   * _.isBuffer(new Buffer(2));\n   * // => true\n   *\n   * _.isBuffer(new Uint8Array(2));\n   * // => false\n   */\n\n\n  var isBuffer = nativeIsBuffer || stubFalse;\n  /**\n   * Checks if `value` is classified as a `Function` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n   * @example\n   *\n   * _.isFunction(_);\n   * // => true\n   *\n   * _.isFunction(/abc/);\n   * // => false\n   */\n\n  function isFunction(value) {\n    if (!isObject(value)) {\n      return false;\n    } // The use of `Object#toString` avoids issues with the `typeof` operator\n    // in Safari 9 which returns 'object' for typed arrays and other constructors.\n\n\n    var tag = baseGetTag(value);\n    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n  }\n  /**\n   * Checks if `value` is a valid array-like length.\n   *\n   * **Note:** This method is loosely based on\n   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n   * @example\n   *\n   * _.isLength(3);\n   * // => true\n   *\n   * _.isLength(Number.MIN_VALUE);\n   * // => false\n   *\n   * _.isLength(Infinity);\n   * // => false\n   *\n   * _.isLength('3');\n   * // => false\n   */\n\n\n  function isLength(value) {\n    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n  }\n  /**\n   * Checks if `value` is the\n   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n   * @example\n   *\n   * _.isObject({});\n   * // => true\n   *\n   * _.isObject([1, 2, 3]);\n   * // => true\n   *\n   * _.isObject(_.noop);\n   * // => true\n   *\n   * _.isObject(null);\n   * // => false\n   */\n\n\n  function isObject(value) {\n    var type = typeof value;\n    return value != null && (type == 'object' || type == 'function');\n  }\n  /**\n   * Checks if `value` is object-like. A value is object-like if it's not `null`\n   * and has a `typeof` result of \"object\".\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n   * @example\n   *\n   * _.isObjectLike({});\n   * // => true\n   *\n   * _.isObjectLike([1, 2, 3]);\n   * // => true\n   *\n   * _.isObjectLike(_.noop);\n   * // => false\n   *\n   * _.isObjectLike(null);\n   * // => false\n   */\n\n\n  function isObjectLike(value) {\n    return value != null && typeof value == 'object';\n  }\n  /**\n   * Checks if `value` is classified as a `Symbol` primitive or object.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n   * @example\n   *\n   * _.isSymbol(Symbol.iterator);\n   * // => true\n   *\n   * _.isSymbol('abc');\n   * // => false\n   */\n\n\n  function isSymbol(value) {\n    return typeof value == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;\n  }\n  /**\n   * Checks if `value` is classified as a typed array.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n   * @example\n   *\n   * _.isTypedArray(new Uint8Array);\n   * // => true\n   *\n   * _.isTypedArray([]);\n   * // => false\n   */\n\n\n  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n  /**\n   * Converts `value` to a string. An empty string is returned for `null`\n   * and `undefined` values. The sign of `-0` is preserved.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to convert.\n   * @returns {string} Returns the converted string.\n   * @example\n   *\n   * _.toString(null);\n   * // => ''\n   *\n   * _.toString(-0);\n   * // => '-0'\n   *\n   * _.toString([1, 2, 3]);\n   * // => '1,2,3'\n   */\n\n  function toString(value) {\n    return value == null ? '' : baseToString(value);\n  }\n  /**\n   * Gets the value at `path` of `object`. If the resolved value is\n   * `undefined`, the `defaultValue` is returned in its place.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.7.0\n   * @category Object\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path of the property to get.\n   * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n   * @returns {*} Returns the resolved value.\n   * @example\n   *\n   * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n   *\n   * _.get(object, 'a[0].b.c');\n   * // => 3\n   *\n   * _.get(object, ['a', '0', 'b', 'c']);\n   * // => 3\n   *\n   * _.get(object, 'a.b.c', 'default');\n   * // => 'default'\n   */\n\n\n  function get(object, path, defaultValue) {\n    var result = object == null ? undefined : baseGet(object, path);\n    return result === undefined ? defaultValue : result;\n  }\n  /**\n   * Checks if `path` is a direct or inherited property of `object`.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Object\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path to check.\n   * @returns {boolean} Returns `true` if `path` exists, else `false`.\n   * @example\n   *\n   * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n   *\n   * _.hasIn(object, 'a');\n   * // => true\n   *\n   * _.hasIn(object, 'a.b');\n   * // => true\n   *\n   * _.hasIn(object, ['a', 'b']);\n   * // => true\n   *\n   * _.hasIn(object, 'b');\n   * // => false\n   */\n\n\n  function hasIn(object, path) {\n    return object != null && hasPath(object, path, baseHasIn);\n  }\n  /**\n   * Creates an array of the own enumerable property names of `object`.\n   *\n   * **Note:** Non-object values are coerced to objects. See the\n   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n   * for more details.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Object\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names.\n   * @example\n   *\n   * function Foo() {\n   *   this.a = 1;\n   *   this.b = 2;\n   * }\n   *\n   * Foo.prototype.c = 3;\n   *\n   * _.keys(new Foo);\n   * // => ['a', 'b'] (iteration order is not guaranteed)\n   *\n   * _.keys('hi');\n   * // => ['0', '1']\n   */\n\n\n  function keys(object) {\n    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n  }\n  /**\n   * This method returns the first argument it receives.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Util\n   * @param {*} value Any value.\n   * @returns {*} Returns `value`.\n   * @example\n   *\n   * var object = { 'a': 1 };\n   *\n   * console.log(_.identity(object) === object);\n   * // => true\n   */\n\n\n  function identity(value) {\n    return value;\n  }\n  /**\n   * Creates a function that returns the value at `path` of a given object.\n   *\n   * @static\n   * @memberOf _\n   * @since 2.4.0\n   * @category Util\n   * @param {Array|string} path The path of the property to get.\n   * @returns {Function} Returns the new accessor function.\n   * @example\n   *\n   * var objects = [\n   *   { 'a': { 'b': 2 } },\n   *   { 'a': { 'b': 1 } }\n   * ];\n   *\n   * _.map(objects, _.property('a.b'));\n   * // => [2, 1]\n   *\n   * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n   * // => [1, 2]\n   */\n\n\n  function property(path) {\n    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n  }\n  /**\n   * This method returns a new empty array.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.13.0\n   * @category Util\n   * @returns {Array} Returns the new empty array.\n   * @example\n   *\n   * var arrays = _.times(2, _.stubArray);\n   *\n   * console.log(arrays);\n   * // => [[], []]\n   *\n   * console.log(arrays[0] === arrays[1]);\n   * // => false\n   */\n\n\n  function stubArray() {\n    return [];\n  }\n  /**\n   * This method returns `false`.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.13.0\n   * @category Util\n   * @returns {boolean} Returns `false`.\n   * @example\n   *\n   * _.times(2, _.stubFalse);\n   * // => [false, false]\n   */\n\n\n  function stubFalse() {\n    return false;\n  }\n\n  module.exports = filter;\n  });\n\n  var lodash_sortby = createCommonjsModule(function (module, exports) {\n  /**\n   * Lodash (Custom Build) <https://lodash.com/>\n   * Build: `lodash modularize include=\"filter,sortBy,findIndex,find,forEach,cloneDeep\" exports=\"npm\"`\n   * Copyright JS Foundation and other contributors <https://js.foundation/>\n   * Released under MIT license <https://lodash.com/license>\n   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n   */\n\n  /** Used as the size to enable large array optimizations. */\n  var LARGE_ARRAY_SIZE = 200;\n  /** Error message constants. */\n\n  var FUNC_ERROR_TEXT = 'Expected a function';\n  /** Used to stand-in for `undefined` hash values. */\n\n  var HASH_UNDEFINED = '__lodash_hash_undefined__';\n  /** Used as the maximum memoize cache size. */\n\n  var MAX_MEMOIZE_SIZE = 500;\n  /** Used to compose bitmasks for value comparisons. */\n\n  var COMPARE_PARTIAL_FLAG = 1,\n      COMPARE_UNORDERED_FLAG = 2;\n  /** Used to detect hot functions by number of calls within a span of milliseconds. */\n\n  var HOT_COUNT = 800,\n      HOT_SPAN = 16;\n  /** Used as references for various `Number` constants. */\n\n  var INFINITY = 1 / 0,\n      MAX_SAFE_INTEGER = 9007199254740991;\n  /** `Object#toString` result references. */\n\n  var argsTag = '[object Arguments]',\n      arrayTag = '[object Array]',\n      asyncTag = '[object AsyncFunction]',\n      boolTag = '[object Boolean]',\n      dateTag = '[object Date]',\n      errorTag = '[object Error]',\n      funcTag = '[object Function]',\n      genTag = '[object GeneratorFunction]',\n      mapTag = '[object Map]',\n      numberTag = '[object Number]',\n      nullTag = '[object Null]',\n      objectTag = '[object Object]',\n      promiseTag = '[object Promise]',\n      proxyTag = '[object Proxy]',\n      regexpTag = '[object RegExp]',\n      setTag = '[object Set]',\n      stringTag = '[object String]',\n      symbolTag = '[object Symbol]',\n      undefinedTag = '[object Undefined]',\n      weakMapTag = '[object WeakMap]';\n  var arrayBufferTag = '[object ArrayBuffer]',\n      dataViewTag = '[object DataView]',\n      float32Tag = '[object Float32Array]',\n      float64Tag = '[object Float64Array]',\n      int8Tag = '[object Int8Array]',\n      int16Tag = '[object Int16Array]',\n      int32Tag = '[object Int32Array]',\n      uint8Tag = '[object Uint8Array]',\n      uint8ClampedTag = '[object Uint8ClampedArray]',\n      uint16Tag = '[object Uint16Array]',\n      uint32Tag = '[object Uint32Array]';\n  /** Used to match property names within property paths. */\n\n  var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n      reIsPlainProp = /^\\w*$/,\n      rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n  /**\n   * Used to match `RegExp`\n   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n   */\n\n  var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n  /** Used to match backslashes in property paths. */\n\n  var reEscapeChar = /\\\\(\\\\)?/g;\n  /** Used to detect host constructors (Safari). */\n\n  var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n  /** Used to detect unsigned integer values. */\n\n  var reIsUint = /^(?:0|[1-9]\\d*)$/;\n  /** Used to identify `toStringTag` values of typed arrays. */\n\n  var typedArrayTags = {};\n  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;\n  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;\n  /** Detect free variable `global` from Node.js. */\n\n  var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;\n  /** Detect free variable `self`. */\n\n  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n  /** Used as a reference to the global object. */\n\n  var root = freeGlobal || freeSelf || Function('return this')();\n  /** Detect free variable `exports`. */\n\n  var freeExports =  exports && !exports.nodeType && exports;\n  /** Detect free variable `module`. */\n\n  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;\n  /** Detect the popular CommonJS extension `module.exports`. */\n\n  var moduleExports = freeModule && freeModule.exports === freeExports;\n  /** Detect free variable `process` from Node.js. */\n\n  var freeProcess = moduleExports && freeGlobal.process;\n  /** Used to access faster Node.js helpers. */\n\n  var nodeUtil = function () {\n    try {\n      return freeProcess && freeProcess.binding && freeProcess.binding('util');\n    } catch (e) {}\n  }();\n  /* Node.js helper references. */\n\n\n  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n  /**\n   * A faster alternative to `Function#apply`, this function invokes `func`\n   * with the `this` binding of `thisArg` and the arguments of `args`.\n   *\n   * @private\n   * @param {Function} func The function to invoke.\n   * @param {*} thisArg The `this` binding of `func`.\n   * @param {Array} args The arguments to invoke `func` with.\n   * @returns {*} Returns the result of `func`.\n   */\n\n  function apply(func, thisArg, args) {\n    switch (args.length) {\n      case 0:\n        return func.call(thisArg);\n\n      case 1:\n        return func.call(thisArg, args[0]);\n\n      case 2:\n        return func.call(thisArg, args[0], args[1]);\n\n      case 3:\n        return func.call(thisArg, args[0], args[1], args[2]);\n    }\n\n    return func.apply(thisArg, args);\n  }\n  /**\n   * A specialized version of `_.filter` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {Array} Returns the new filtered array.\n   */\n\n\n  function arrayFilter(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length,\n        resIndex = 0,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index];\n\n      if (predicate(value, index, array)) {\n        result[resIndex++] = value;\n      }\n    }\n\n    return result;\n  }\n  /**\n   * A specialized version of `_.map` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the new mapped array.\n   */\n\n\n  function arrayMap(array, iteratee) {\n    var index = -1,\n        length = array == null ? 0 : array.length,\n        result = Array(length);\n\n    while (++index < length) {\n      result[index] = iteratee(array[index], index, array);\n    }\n\n    return result;\n  }\n  /**\n   * Appends the elements of `values` to `array`.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {Array} values The values to append.\n   * @returns {Array} Returns `array`.\n   */\n\n\n  function arrayPush(array, values) {\n    var index = -1,\n        length = values.length,\n        offset = array.length;\n\n    while (++index < length) {\n      array[offset + index] = values[index];\n    }\n\n    return array;\n  }\n  /**\n   * A specialized version of `_.some` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if any element passes the predicate check,\n   *  else `false`.\n   */\n\n\n  function arraySome(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (predicate(array[index], index, array)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n   * The base implementation of `_.property` without support for deep paths.\n   *\n   * @private\n   * @param {string} key The key of the property to get.\n   * @returns {Function} Returns the new accessor function.\n   */\n\n\n  function baseProperty(key) {\n    return function (object) {\n      return object == null ? undefined : object[key];\n    };\n  }\n  /**\n   * The base implementation of `_.sortBy` which uses `comparer` to define the\n   * sort order of `array` and replaces criteria objects with their corresponding\n   * values.\n   *\n   * @private\n   * @param {Array} array The array to sort.\n   * @param {Function} comparer The function to define sort order.\n   * @returns {Array} Returns `array`.\n   */\n\n\n  function baseSortBy(array, comparer) {\n    var length = array.length;\n    array.sort(comparer);\n\n    while (length--) {\n      array[length] = array[length].value;\n    }\n\n    return array;\n  }\n  /**\n   * The base implementation of `_.times` without support for iteratee shorthands\n   * or max array length checks.\n   *\n   * @private\n   * @param {number} n The number of times to invoke `iteratee`.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the array of results.\n   */\n\n\n  function baseTimes(n, iteratee) {\n    var index = -1,\n        result = Array(n);\n\n    while (++index < n) {\n      result[index] = iteratee(index);\n    }\n\n    return result;\n  }\n  /**\n   * The base implementation of `_.unary` without support for storing metadata.\n   *\n   * @private\n   * @param {Function} func The function to cap arguments for.\n   * @returns {Function} Returns the new capped function.\n   */\n\n\n  function baseUnary(func) {\n    return function (value) {\n      return func(value);\n    };\n  }\n  /**\n   * Checks if a `cache` value for `key` exists.\n   *\n   * @private\n   * @param {Object} cache The cache to query.\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n\n\n  function cacheHas(cache, key) {\n    return cache.has(key);\n  }\n  /**\n   * Gets the value at `key` of `object`.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {string} key The key of the property to get.\n   * @returns {*} Returns the property value.\n   */\n\n\n  function getValue(object, key) {\n    return object == null ? undefined : object[key];\n  }\n  /**\n   * Converts `map` to its key-value pairs.\n   *\n   * @private\n   * @param {Object} map The map to convert.\n   * @returns {Array} Returns the key-value pairs.\n   */\n\n\n  function mapToArray(map) {\n    var index = -1,\n        result = Array(map.size);\n    map.forEach(function (value, key) {\n      result[++index] = [key, value];\n    });\n    return result;\n  }\n  /**\n   * Creates a unary function that invokes `func` with its argument transformed.\n   *\n   * @private\n   * @param {Function} func The function to wrap.\n   * @param {Function} transform The argument transform.\n   * @returns {Function} Returns the new function.\n   */\n\n\n  function overArg(func, transform) {\n    return function (arg) {\n      return func(transform(arg));\n    };\n  }\n  /**\n   * Converts `set` to an array of its values.\n   *\n   * @private\n   * @param {Object} set The set to convert.\n   * @returns {Array} Returns the values.\n   */\n\n\n  function setToArray(set) {\n    var index = -1,\n        result = Array(set.size);\n    set.forEach(function (value) {\n      result[++index] = value;\n    });\n    return result;\n  }\n  /** Used for built-in method references. */\n\n\n  var arrayProto = Array.prototype,\n      funcProto = Function.prototype,\n      objectProto = Object.prototype;\n  /** Used to detect overreaching core-js shims. */\n\n  var coreJsData = root['__core-js_shared__'];\n  /** Used to resolve the decompiled source of functions. */\n\n  var funcToString = funcProto.toString;\n  /** Used to check objects for own properties. */\n\n  var hasOwnProperty = objectProto.hasOwnProperty;\n  /** Used to detect methods masquerading as native. */\n\n  var maskSrcKey = function () {\n    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n    return uid ? 'Symbol(src)_1.' + uid : '';\n  }();\n  /**\n   * Used to resolve the\n   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n   * of values.\n   */\n\n\n  var nativeObjectToString = objectProto.toString;\n  /** Used to detect if a method is native. */\n\n  var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&').replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$');\n  /** Built-in value references. */\n\n  var Buffer = moduleExports ? root.Buffer : undefined,\n      Symbol = root.Symbol,\n      Uint8Array = root.Uint8Array,\n      propertyIsEnumerable = objectProto.propertyIsEnumerable,\n      splice = arrayProto.splice,\n      spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,\n      symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n  var defineProperty = function () {\n    try {\n      var func = getNative(Object, 'defineProperty');\n      func({}, '', {});\n      return func;\n    } catch (e) {}\n  }();\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n\n\n  var nativeGetSymbols = Object.getOwnPropertySymbols,\n      nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n      nativeKeys = overArg(Object.keys, Object),\n      nativeMax = Math.max,\n      nativeNow = Date.now;\n  /* Built-in method references that are verified to be native. */\n\n  var DataView = getNative(root, 'DataView'),\n      Map = getNative(root, 'Map'),\n      Promise = getNative(root, 'Promise'),\n      Set = getNative(root, 'Set'),\n      WeakMap = getNative(root, 'WeakMap'),\n      nativeCreate = getNative(Object, 'create');\n  /** Used to detect maps, sets, and weakmaps. */\n\n  var dataViewCtorString = toSource(DataView),\n      mapCtorString = toSource(Map),\n      promiseCtorString = toSource(Promise),\n      setCtorString = toSource(Set),\n      weakMapCtorString = toSource(WeakMap);\n  /** Used to convert symbols to primitives and strings. */\n\n  var symbolProto = Symbol ? Symbol.prototype : undefined,\n      symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n      symbolToString = symbolProto ? symbolProto.toString : undefined;\n  /**\n   * Creates a hash object.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n\n  function Hash(entries) {\n    var index = -1,\n        length = entries == null ? 0 : entries.length;\n    this.clear();\n\n    while (++index < length) {\n      var entry = entries[index];\n      this.set(entry[0], entry[1]);\n    }\n  }\n  /**\n   * Removes all key-value entries from the hash.\n   *\n   * @private\n   * @name clear\n   * @memberOf Hash\n   */\n\n\n  function hashClear() {\n    this.__data__ = nativeCreate ? nativeCreate(null) : {};\n    this.size = 0;\n  }\n  /**\n   * Removes `key` and its value from the hash.\n   *\n   * @private\n   * @name delete\n   * @memberOf Hash\n   * @param {Object} hash The hash to modify.\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n\n\n  function hashDelete(key) {\n    var result = this.has(key) && delete this.__data__[key];\n    this.size -= result ? 1 : 0;\n    return result;\n  }\n  /**\n   * Gets the hash value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf Hash\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n\n\n  function hashGet(key) {\n    var data = this.__data__;\n\n    if (nativeCreate) {\n      var result = data[key];\n      return result === HASH_UNDEFINED ? undefined : result;\n    }\n\n    return hasOwnProperty.call(data, key) ? data[key] : undefined;\n  }\n  /**\n   * Checks if a hash value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf Hash\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n\n\n  function hashHas(key) {\n    var data = this.__data__;\n    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n  }\n  /**\n   * Sets the hash `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf Hash\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the hash instance.\n   */\n\n\n  function hashSet(key, value) {\n    var data = this.__data__;\n    this.size += this.has(key) ? 0 : 1;\n    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;\n    return this;\n  } // Add methods to `Hash`.\n\n\n  Hash.prototype.clear = hashClear;\n  Hash.prototype['delete'] = hashDelete;\n  Hash.prototype.get = hashGet;\n  Hash.prototype.has = hashHas;\n  Hash.prototype.set = hashSet;\n  /**\n   * Creates an list cache object.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n\n  function ListCache(entries) {\n    var index = -1,\n        length = entries == null ? 0 : entries.length;\n    this.clear();\n\n    while (++index < length) {\n      var entry = entries[index];\n      this.set(entry[0], entry[1]);\n    }\n  }\n  /**\n   * Removes all key-value entries from the list cache.\n   *\n   * @private\n   * @name clear\n   * @memberOf ListCache\n   */\n\n\n  function listCacheClear() {\n    this.__data__ = [];\n    this.size = 0;\n  }\n  /**\n   * Removes `key` and its value from the list cache.\n   *\n   * @private\n   * @name delete\n   * @memberOf ListCache\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n\n\n  function listCacheDelete(key) {\n    var data = this.__data__,\n        index = assocIndexOf(data, key);\n\n    if (index < 0) {\n      return false;\n    }\n\n    var lastIndex = data.length - 1;\n\n    if (index == lastIndex) {\n      data.pop();\n    } else {\n      splice.call(data, index, 1);\n    }\n\n    --this.size;\n    return true;\n  }\n  /**\n   * Gets the list cache value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf ListCache\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n\n\n  function listCacheGet(key) {\n    var data = this.__data__,\n        index = assocIndexOf(data, key);\n    return index < 0 ? undefined : data[index][1];\n  }\n  /**\n   * Checks if a list cache value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf ListCache\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n\n\n  function listCacheHas(key) {\n    return assocIndexOf(this.__data__, key) > -1;\n  }\n  /**\n   * Sets the list cache `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf ListCache\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the list cache instance.\n   */\n\n\n  function listCacheSet(key, value) {\n    var data = this.__data__,\n        index = assocIndexOf(data, key);\n\n    if (index < 0) {\n      ++this.size;\n      data.push([key, value]);\n    } else {\n      data[index][1] = value;\n    }\n\n    return this;\n  } // Add methods to `ListCache`.\n\n\n  ListCache.prototype.clear = listCacheClear;\n  ListCache.prototype['delete'] = listCacheDelete;\n  ListCache.prototype.get = listCacheGet;\n  ListCache.prototype.has = listCacheHas;\n  ListCache.prototype.set = listCacheSet;\n  /**\n   * Creates a map cache object to store key-value pairs.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n\n  function MapCache(entries) {\n    var index = -1,\n        length = entries == null ? 0 : entries.length;\n    this.clear();\n\n    while (++index < length) {\n      var entry = entries[index];\n      this.set(entry[0], entry[1]);\n    }\n  }\n  /**\n   * Removes all key-value entries from the map.\n   *\n   * @private\n   * @name clear\n   * @memberOf MapCache\n   */\n\n\n  function mapCacheClear() {\n    this.size = 0;\n    this.__data__ = {\n      'hash': new Hash(),\n      'map': new (Map || ListCache)(),\n      'string': new Hash()\n    };\n  }\n  /**\n   * Removes `key` and its value from the map.\n   *\n   * @private\n   * @name delete\n   * @memberOf MapCache\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n\n\n  function mapCacheDelete(key) {\n    var result = getMapData(this, key)['delete'](key);\n    this.size -= result ? 1 : 0;\n    return result;\n  }\n  /**\n   * Gets the map value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf MapCache\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n\n\n  function mapCacheGet(key) {\n    return getMapData(this, key).get(key);\n  }\n  /**\n   * Checks if a map value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf MapCache\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n\n\n  function mapCacheHas(key) {\n    return getMapData(this, key).has(key);\n  }\n  /**\n   * Sets the map `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf MapCache\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the map cache instance.\n   */\n\n\n  function mapCacheSet(key, value) {\n    var data = getMapData(this, key),\n        size = data.size;\n    data.set(key, value);\n    this.size += data.size == size ? 0 : 1;\n    return this;\n  } // Add methods to `MapCache`.\n\n\n  MapCache.prototype.clear = mapCacheClear;\n  MapCache.prototype['delete'] = mapCacheDelete;\n  MapCache.prototype.get = mapCacheGet;\n  MapCache.prototype.has = mapCacheHas;\n  MapCache.prototype.set = mapCacheSet;\n  /**\n   *\n   * Creates an array cache object to store unique values.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [values] The values to cache.\n   */\n\n  function SetCache(values) {\n    var index = -1,\n        length = values == null ? 0 : values.length;\n    this.__data__ = new MapCache();\n\n    while (++index < length) {\n      this.add(values[index]);\n    }\n  }\n  /**\n   * Adds `value` to the array cache.\n   *\n   * @private\n   * @name add\n   * @memberOf SetCache\n   * @alias push\n   * @param {*} value The value to cache.\n   * @returns {Object} Returns the cache instance.\n   */\n\n\n  function setCacheAdd(value) {\n    this.__data__.set(value, HASH_UNDEFINED);\n\n    return this;\n  }\n  /**\n   * Checks if `value` is in the array cache.\n   *\n   * @private\n   * @name has\n   * @memberOf SetCache\n   * @param {*} value The value to search for.\n   * @returns {number} Returns `true` if `value` is found, else `false`.\n   */\n\n\n  function setCacheHas(value) {\n    return this.__data__.has(value);\n  } // Add methods to `SetCache`.\n\n\n  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\n  SetCache.prototype.has = setCacheHas;\n  /**\n   * Creates a stack cache object to store key-value pairs.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n\n  function Stack(entries) {\n    var data = this.__data__ = new ListCache(entries);\n    this.size = data.size;\n  }\n  /**\n   * Removes all key-value entries from the stack.\n   *\n   * @private\n   * @name clear\n   * @memberOf Stack\n   */\n\n\n  function stackClear() {\n    this.__data__ = new ListCache();\n    this.size = 0;\n  }\n  /**\n   * Removes `key` and its value from the stack.\n   *\n   * @private\n   * @name delete\n   * @memberOf Stack\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n\n\n  function stackDelete(key) {\n    var data = this.__data__,\n        result = data['delete'](key);\n    this.size = data.size;\n    return result;\n  }\n  /**\n   * Gets the stack value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf Stack\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n\n\n  function stackGet(key) {\n    return this.__data__.get(key);\n  }\n  /**\n   * Checks if a stack value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf Stack\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n\n\n  function stackHas(key) {\n    return this.__data__.has(key);\n  }\n  /**\n   * Sets the stack `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf Stack\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the stack cache instance.\n   */\n\n\n  function stackSet(key, value) {\n    var data = this.__data__;\n\n    if (data instanceof ListCache) {\n      var pairs = data.__data__;\n\n      if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {\n        pairs.push([key, value]);\n        this.size = ++data.size;\n        return this;\n      }\n\n      data = this.__data__ = new MapCache(pairs);\n    }\n\n    data.set(key, value);\n    this.size = data.size;\n    return this;\n  } // Add methods to `Stack`.\n\n\n  Stack.prototype.clear = stackClear;\n  Stack.prototype['delete'] = stackDelete;\n  Stack.prototype.get = stackGet;\n  Stack.prototype.has = stackHas;\n  Stack.prototype.set = stackSet;\n  /**\n   * Creates an array of the enumerable property names of the array-like `value`.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @param {boolean} inherited Specify returning inherited property names.\n   * @returns {Array} Returns the array of property names.\n   */\n\n  function arrayLikeKeys(value, inherited) {\n    var isArr = isArray(value),\n        isArg = !isArr && isArguments(value),\n        isBuff = !isArr && !isArg && isBuffer(value),\n        isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n        skipIndexes = isArr || isArg || isBuff || isType,\n        result = skipIndexes ? baseTimes(value.length, String) : [],\n        length = result.length;\n\n    for (var key in value) {\n      if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.\n      key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.\n      isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.\n      isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.\n      isIndex(key, length)))) {\n        result.push(key);\n      }\n    }\n\n    return result;\n  }\n  /**\n   * Gets the index at which the `key` is found in `array` of key-value pairs.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} key The key to search for.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n\n\n  function assocIndexOf(array, key) {\n    var length = array.length;\n\n    while (length--) {\n      if (eq(array[length][0], key)) {\n        return length;\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * The base implementation of `_.forEach` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array|Object} Returns `collection`.\n   */\n\n\n  var baseEach = createBaseEach(baseForOwn);\n  /**\n   * The base implementation of `_.flatten` with support for restricting flattening.\n   *\n   * @private\n   * @param {Array} array The array to flatten.\n   * @param {number} depth The maximum recursion depth.\n   * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n   * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n   * @param {Array} [result=[]] The initial result value.\n   * @returns {Array} Returns the new flattened array.\n   */\n\n  function baseFlatten(array, depth, predicate, isStrict, result) {\n    var index = -1,\n        length = array.length;\n    predicate || (predicate = isFlattenable);\n    result || (result = []);\n\n    while (++index < length) {\n      var value = array[index];\n\n      if (depth > 0 && predicate(value)) {\n        if (depth > 1) {\n          // Recursively flatten arrays (susceptible to call stack limits).\n          baseFlatten(value, depth - 1, predicate, isStrict, result);\n        } else {\n          arrayPush(result, value);\n        }\n      } else if (!isStrict) {\n        result[result.length] = value;\n      }\n    }\n\n    return result;\n  }\n  /**\n   * The base implementation of `baseForOwn` which iterates over `object`\n   * properties returned by `keysFunc` and invokes `iteratee` for each property.\n   * Iteratee functions may exit iteration early by explicitly returning `false`.\n   *\n   * @private\n   * @param {Object} object The object to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {Function} keysFunc The function to get the keys of `object`.\n   * @returns {Object} Returns `object`.\n   */\n\n\n  var baseFor = createBaseFor();\n  /**\n   * The base implementation of `_.forOwn` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Object} object The object to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Object} Returns `object`.\n   */\n\n  function baseForOwn(object, iteratee) {\n    return object && baseFor(object, iteratee, keys);\n  }\n  /**\n   * The base implementation of `_.get` without support for default values.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path of the property to get.\n   * @returns {*} Returns the resolved value.\n   */\n\n\n  function baseGet(object, path) {\n    path = castPath(path, object);\n    var index = 0,\n        length = path.length;\n\n    while (object != null && index < length) {\n      object = object[toKey(path[index++])];\n    }\n\n    return index && index == length ? object : undefined;\n  }\n  /**\n   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n   * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n   * symbols of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Function} keysFunc The function to get the keys of `object`.\n   * @param {Function} symbolsFunc The function to get the symbols of `object`.\n   * @returns {Array} Returns the array of property names and symbols.\n   */\n\n\n  function baseGetAllKeys(object, keysFunc, symbolsFunc) {\n    var result = keysFunc(object);\n    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n  }\n  /**\n   * The base implementation of `getTag` without fallbacks for buggy environments.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @returns {string} Returns the `toStringTag`.\n   */\n\n\n  function baseGetTag(value) {\n    if (value == null) {\n      return value === undefined ? undefinedTag : nullTag;\n    }\n\n    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);\n  }\n  /**\n   * The base implementation of `_.hasIn` without support for deep paths.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {Array|string} key The key to check.\n   * @returns {boolean} Returns `true` if `key` exists, else `false`.\n   */\n\n\n  function baseHasIn(object, key) {\n    return object != null && key in Object(object);\n  }\n  /**\n   * The base implementation of `_.isArguments`.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n   */\n\n\n  function baseIsArguments(value) {\n    return isObjectLike(value) && baseGetTag(value) == argsTag;\n  }\n  /**\n   * The base implementation of `_.isEqual` which supports partial comparisons\n   * and tracks traversed objects.\n   *\n   * @private\n   * @param {*} value The value to compare.\n   * @param {*} other The other value to compare.\n   * @param {boolean} bitmask The bitmask flags.\n   *  1 - Unordered comparison\n   *  2 - Partial comparison\n   * @param {Function} [customizer] The function to customize comparisons.\n   * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n   */\n\n\n  function baseIsEqual(value, other, bitmask, customizer, stack) {\n    if (value === other) {\n      return true;\n    }\n\n    if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {\n      return value !== value && other !== other;\n    }\n\n    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n  }\n  /**\n   * A specialized version of `baseIsEqual` for arrays and objects which performs\n   * deep comparisons and tracks traversed objects enabling objects with circular\n   * references to be compared.\n   *\n   * @private\n   * @param {Object} object The object to compare.\n   * @param {Object} other The other object to compare.\n   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n   * @param {Function} customizer The function to customize comparisons.\n   * @param {Function} equalFunc The function to determine equivalents of values.\n   * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n   */\n\n\n  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n    var objIsArr = isArray(object),\n        othIsArr = isArray(other),\n        objTag = objIsArr ? arrayTag : getTag(object),\n        othTag = othIsArr ? arrayTag : getTag(other);\n    objTag = objTag == argsTag ? objectTag : objTag;\n    othTag = othTag == argsTag ? objectTag : othTag;\n    var objIsObj = objTag == objectTag,\n        othIsObj = othTag == objectTag,\n        isSameTag = objTag == othTag;\n\n    if (isSameTag && isBuffer(object)) {\n      if (!isBuffer(other)) {\n        return false;\n      }\n\n      objIsArr = true;\n      objIsObj = false;\n    }\n\n    if (isSameTag && !objIsObj) {\n      stack || (stack = new Stack());\n      return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n    }\n\n    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n      var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n          othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n      if (objIsWrapped || othIsWrapped) {\n        var objUnwrapped = objIsWrapped ? object.value() : object,\n            othUnwrapped = othIsWrapped ? other.value() : other;\n        stack || (stack = new Stack());\n        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n      }\n    }\n\n    if (!isSameTag) {\n      return false;\n    }\n\n    stack || (stack = new Stack());\n    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n  }\n  /**\n   * The base implementation of `_.isMatch` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Object} object The object to inspect.\n   * @param {Object} source The object of property values to match.\n   * @param {Array} matchData The property names, values, and compare flags to match.\n   * @param {Function} [customizer] The function to customize comparisons.\n   * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n   */\n\n\n  function baseIsMatch(object, source, matchData, customizer) {\n    var index = matchData.length,\n        length = index,\n        noCustomizer = !customizer;\n\n    if (object == null) {\n      return !length;\n    }\n\n    object = Object(object);\n\n    while (index--) {\n      var data = matchData[index];\n\n      if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {\n        return false;\n      }\n    }\n\n    while (++index < length) {\n      data = matchData[index];\n      var key = data[0],\n          objValue = object[key],\n          srcValue = data[1];\n\n      if (noCustomizer && data[2]) {\n        if (objValue === undefined && !(key in object)) {\n          return false;\n        }\n      } else {\n        var stack = new Stack();\n\n        if (customizer) {\n          var result = customizer(objValue, srcValue, key, object, source, stack);\n        }\n\n        if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n  /**\n   * The base implementation of `_.isNative` without bad shim checks.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a native function,\n   *  else `false`.\n   */\n\n\n  function baseIsNative(value) {\n    if (!isObject(value) || isMasked(value)) {\n      return false;\n    }\n\n    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n    return pattern.test(toSource(value));\n  }\n  /**\n   * The base implementation of `_.isTypedArray` without Node.js optimizations.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n   */\n\n\n  function baseIsTypedArray(value) {\n    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n  }\n  /**\n   * The base implementation of `_.iteratee`.\n   *\n   * @private\n   * @param {*} [value=_.identity] The value to convert to an iteratee.\n   * @returns {Function} Returns the iteratee.\n   */\n\n\n  function baseIteratee(value) {\n    // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n    // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n    if (typeof value == 'function') {\n      return value;\n    }\n\n    if (value == null) {\n      return identity;\n    }\n\n    if (typeof value == 'object') {\n      return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);\n    }\n\n    return property(value);\n  }\n  /**\n   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names.\n   */\n\n\n  function baseKeys(object) {\n    if (!isPrototype(object)) {\n      return nativeKeys(object);\n    }\n\n    var result = [];\n\n    for (var key in Object(object)) {\n      if (hasOwnProperty.call(object, key) && key != 'constructor') {\n        result.push(key);\n      }\n    }\n\n    return result;\n  }\n  /**\n   * The base implementation of `_.map` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the new mapped array.\n   */\n\n\n  function baseMap(collection, iteratee) {\n    var index = -1,\n        result = isArrayLike(collection) ? Array(collection.length) : [];\n    baseEach(collection, function (value, key, collection) {\n      result[++index] = iteratee(value, key, collection);\n    });\n    return result;\n  }\n  /**\n   * The base implementation of `_.matches` which doesn't clone `source`.\n   *\n   * @private\n   * @param {Object} source The object of property values to match.\n   * @returns {Function} Returns the new spec function.\n   */\n\n\n  function baseMatches(source) {\n    var matchData = getMatchData(source);\n\n    if (matchData.length == 1 && matchData[0][2]) {\n      return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n    }\n\n    return function (object) {\n      return object === source || baseIsMatch(object, source, matchData);\n    };\n  }\n  /**\n   * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n   *\n   * @private\n   * @param {string} path The path of the property to get.\n   * @param {*} srcValue The value to match.\n   * @returns {Function} Returns the new spec function.\n   */\n\n\n  function baseMatchesProperty(path, srcValue) {\n    if (isKey(path) && isStrictComparable(srcValue)) {\n      return matchesStrictComparable(toKey(path), srcValue);\n    }\n\n    return function (object) {\n      var objValue = get(object, path);\n      return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n    };\n  }\n  /**\n   * The base implementation of `_.orderBy` without param guards.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n   * @param {string[]} orders The sort orders of `iteratees`.\n   * @returns {Array} Returns the new sorted array.\n   */\n\n\n  function baseOrderBy(collection, iteratees, orders) {\n    var index = -1;\n    iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(baseIteratee));\n    var result = baseMap(collection, function (value, key, collection) {\n      var criteria = arrayMap(iteratees, function (iteratee) {\n        return iteratee(value);\n      });\n      return {\n        'criteria': criteria,\n        'index': ++index,\n        'value': value\n      };\n    });\n    return baseSortBy(result, function (object, other) {\n      return compareMultiple(object, other, orders);\n    });\n  }\n  /**\n   * A specialized version of `baseProperty` which supports deep paths.\n   *\n   * @private\n   * @param {Array|string} path The path of the property to get.\n   * @returns {Function} Returns the new accessor function.\n   */\n\n\n  function basePropertyDeep(path) {\n    return function (object) {\n      return baseGet(object, path);\n    };\n  }\n  /**\n   * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n   *\n   * @private\n   * @param {Function} func The function to apply a rest parameter to.\n   * @param {number} [start=func.length-1] The start position of the rest parameter.\n   * @returns {Function} Returns the new function.\n   */\n\n\n  function baseRest(func, start) {\n    return setToString(overRest(func, start, identity), func + '');\n  }\n  /**\n   * The base implementation of `setToString` without support for hot loop shorting.\n   *\n   * @private\n   * @param {Function} func The function to modify.\n   * @param {Function} string The `toString` result.\n   * @returns {Function} Returns `func`.\n   */\n\n\n  var baseSetToString = !defineProperty ? identity : function (func, string) {\n    return defineProperty(func, 'toString', {\n      'configurable': true,\n      'enumerable': false,\n      'value': constant(string),\n      'writable': true\n    });\n  };\n  /**\n   * The base implementation of `_.toString` which doesn't convert nullish\n   * values to empty strings.\n   *\n   * @private\n   * @param {*} value The value to process.\n   * @returns {string} Returns the string.\n   */\n\n  function baseToString(value) {\n    // Exit early for strings to avoid a performance hit in some environments.\n    if (typeof value == 'string') {\n      return value;\n    }\n\n    if (isArray(value)) {\n      // Recursively convert values (susceptible to call stack limits).\n      return arrayMap(value, baseToString) + '';\n    }\n\n    if (isSymbol(value)) {\n      return symbolToString ? symbolToString.call(value) : '';\n    }\n\n    var result = value + '';\n    return result == '0' && 1 / value == -INFINITY ? '-0' : result;\n  }\n  /**\n   * Casts `value` to a path array if it's not one.\n   *\n   * @private\n   * @param {*} value The value to inspect.\n   * @param {Object} [object] The object to query keys on.\n   * @returns {Array} Returns the cast property path array.\n   */\n\n\n  function castPath(value, object) {\n    if (isArray(value)) {\n      return value;\n    }\n\n    return isKey(value, object) ? [value] : stringToPath(toString(value));\n  }\n  /**\n   * Compares values to sort them in ascending order.\n   *\n   * @private\n   * @param {*} value The value to compare.\n   * @param {*} other The other value to compare.\n   * @returns {number} Returns the sort order indicator for `value`.\n   */\n\n\n  function compareAscending(value, other) {\n    if (value !== other) {\n      var valIsDefined = value !== undefined,\n          valIsNull = value === null,\n          valIsReflexive = value === value,\n          valIsSymbol = isSymbol(value);\n      var othIsDefined = other !== undefined,\n          othIsNull = other === null,\n          othIsReflexive = other === other,\n          othIsSymbol = isSymbol(other);\n\n      if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {\n        return 1;\n      }\n\n      if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {\n        return -1;\n      }\n    }\n\n    return 0;\n  }\n  /**\n   * Used by `_.orderBy` to compare multiple properties of a value to another\n   * and stable sort them.\n   *\n   * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,\n   * specify an order of \"desc\" for descending or \"asc\" for ascending sort order\n   * of corresponding values.\n   *\n   * @private\n   * @param {Object} object The object to compare.\n   * @param {Object} other The other object to compare.\n   * @param {boolean[]|string[]} orders The order to sort by for each property.\n   * @returns {number} Returns the sort order indicator for `object`.\n   */\n\n\n  function compareMultiple(object, other, orders) {\n    var index = -1,\n        objCriteria = object.criteria,\n        othCriteria = other.criteria,\n        length = objCriteria.length,\n        ordersLength = orders.length;\n\n    while (++index < length) {\n      var result = compareAscending(objCriteria[index], othCriteria[index]);\n\n      if (result) {\n        if (index >= ordersLength) {\n          return result;\n        }\n\n        var order = orders[index];\n        return result * (order == 'desc' ? -1 : 1);\n      }\n    } // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n    // that causes it, under certain circumstances, to provide the same value for\n    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n    // for more details.\n    //\n    // This also ensures a stable sort in V8 and other engines.\n    // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.\n\n\n    return object.index - other.index;\n  }\n  /**\n   * Creates a `baseEach` or `baseEachRight` function.\n   *\n   * @private\n   * @param {Function} eachFunc The function to iterate over a collection.\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {Function} Returns the new base function.\n   */\n\n\n  function createBaseEach(eachFunc, fromRight) {\n    return function (collection, iteratee) {\n      if (collection == null) {\n        return collection;\n      }\n\n      if (!isArrayLike(collection)) {\n        return eachFunc(collection, iteratee);\n      }\n\n      var length = collection.length,\n          index = fromRight ? length : -1,\n          iterable = Object(collection);\n\n      while (fromRight ? index-- : ++index < length) {\n        if (iteratee(iterable[index], index, iterable) === false) {\n          break;\n        }\n      }\n\n      return collection;\n    };\n  }\n  /**\n   * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n   *\n   * @private\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {Function} Returns the new base function.\n   */\n\n\n  function createBaseFor(fromRight) {\n    return function (object, iteratee, keysFunc) {\n      var index = -1,\n          iterable = Object(object),\n          props = keysFunc(object),\n          length = props.length;\n\n      while (length--) {\n        var key = props[fromRight ? length : ++index];\n\n        if (iteratee(iterable[key], key, iterable) === false) {\n          break;\n        }\n      }\n\n      return object;\n    };\n  }\n  /**\n   * A specialized version of `baseIsEqualDeep` for arrays with support for\n   * partial deep comparisons.\n   *\n   * @private\n   * @param {Array} array The array to compare.\n   * @param {Array} other The other array to compare.\n   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n   * @param {Function} customizer The function to customize comparisons.\n   * @param {Function} equalFunc The function to determine equivalents of values.\n   * @param {Object} stack Tracks traversed `array` and `other` objects.\n   * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n   */\n\n\n  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n        arrLength = array.length,\n        othLength = other.length;\n\n    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n      return false;\n    } // Assume cyclic values are equal.\n\n\n    var stacked = stack.get(array);\n\n    if (stacked && stack.get(other)) {\n      return stacked == other;\n    }\n\n    var index = -1,\n        result = true,\n        seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;\n    stack.set(array, other);\n    stack.set(other, array); // Ignore non-index properties.\n\n    while (++index < arrLength) {\n      var arrValue = array[index],\n          othValue = other[index];\n\n      if (customizer) {\n        var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);\n      }\n\n      if (compared !== undefined) {\n        if (compared) {\n          continue;\n        }\n\n        result = false;\n        break;\n      } // Recursively compare arrays (susceptible to call stack limits).\n\n\n      if (seen) {\n        if (!arraySome(other, function (othValue, othIndex) {\n          if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n            return seen.push(othIndex);\n          }\n        })) {\n          result = false;\n          break;\n        }\n      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n        result = false;\n        break;\n      }\n    }\n\n    stack['delete'](array);\n    stack['delete'](other);\n    return result;\n  }\n  /**\n   * A specialized version of `baseIsEqualDeep` for comparing objects of\n   * the same `toStringTag`.\n   *\n   * **Note:** This function only supports comparing values with tags of\n   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n   *\n   * @private\n   * @param {Object} object The object to compare.\n   * @param {Object} other The other object to compare.\n   * @param {string} tag The `toStringTag` of the objects to compare.\n   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n   * @param {Function} customizer The function to customize comparisons.\n   * @param {Function} equalFunc The function to determine equivalents of values.\n   * @param {Object} stack Tracks traversed `object` and `other` objects.\n   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n   */\n\n\n  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n    switch (tag) {\n      case dataViewTag:\n        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {\n          return false;\n        }\n\n        object = object.buffer;\n        other = other.buffer;\n\n      case arrayBufferTag:\n        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n          return false;\n        }\n\n        return true;\n\n      case boolTag:\n      case dateTag:\n      case numberTag:\n        // Coerce booleans to `1` or `0` and dates to milliseconds.\n        // Invalid dates are coerced to `NaN`.\n        return eq(+object, +other);\n\n      case errorTag:\n        return object.name == other.name && object.message == other.message;\n\n      case regexpTag:\n      case stringTag:\n        // Coerce regexes to strings and treat strings, primitives and objects,\n        // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n        // for more details.\n        return object == other + '';\n\n      case mapTag:\n        var convert = mapToArray;\n\n      case setTag:\n        var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n        convert || (convert = setToArray);\n\n        if (object.size != other.size && !isPartial) {\n          return false;\n        } // Assume cyclic values are equal.\n\n\n        var stacked = stack.get(object);\n\n        if (stacked) {\n          return stacked == other;\n        }\n\n        bitmask |= COMPARE_UNORDERED_FLAG; // Recursively compare objects (susceptible to call stack limits).\n\n        stack.set(object, other);\n        var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n        stack['delete'](object);\n        return result;\n\n      case symbolTag:\n        if (symbolValueOf) {\n          return symbolValueOf.call(object) == symbolValueOf.call(other);\n        }\n\n    }\n\n    return false;\n  }\n  /**\n   * A specialized version of `baseIsEqualDeep` for objects with support for\n   * partial deep comparisons.\n   *\n   * @private\n   * @param {Object} object The object to compare.\n   * @param {Object} other The other object to compare.\n   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n   * @param {Function} customizer The function to customize comparisons.\n   * @param {Function} equalFunc The function to determine equivalents of values.\n   * @param {Object} stack Tracks traversed `object` and `other` objects.\n   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n   */\n\n\n  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n        objProps = getAllKeys(object),\n        objLength = objProps.length,\n        othProps = getAllKeys(other),\n        othLength = othProps.length;\n\n    if (objLength != othLength && !isPartial) {\n      return false;\n    }\n\n    var index = objLength;\n\n    while (index--) {\n      var key = objProps[index];\n\n      if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n        return false;\n      }\n    } // Assume cyclic values are equal.\n\n\n    var stacked = stack.get(object);\n\n    if (stacked && stack.get(other)) {\n      return stacked == other;\n    }\n\n    var result = true;\n    stack.set(object, other);\n    stack.set(other, object);\n    var skipCtor = isPartial;\n\n    while (++index < objLength) {\n      key = objProps[index];\n      var objValue = object[key],\n          othValue = other[key];\n\n      if (customizer) {\n        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);\n      } // Recursively compare objects (susceptible to call stack limits).\n\n\n      if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {\n        result = false;\n        break;\n      }\n\n      skipCtor || (skipCtor = key == 'constructor');\n    }\n\n    if (result && !skipCtor) {\n      var objCtor = object.constructor,\n          othCtor = other.constructor; // Non `Object` object instances with different constructors are not equal.\n\n      if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n        result = false;\n      }\n    }\n\n    stack['delete'](object);\n    stack['delete'](other);\n    return result;\n  }\n  /**\n   * Creates an array of own enumerable property names and symbols of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names and symbols.\n   */\n\n\n  function getAllKeys(object) {\n    return baseGetAllKeys(object, keys, getSymbols);\n  }\n  /**\n   * Gets the data for `map`.\n   *\n   * @private\n   * @param {Object} map The map to query.\n   * @param {string} key The reference key.\n   * @returns {*} Returns the map data.\n   */\n\n\n  function getMapData(map, key) {\n    var data = map.__data__;\n    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;\n  }\n  /**\n   * Gets the property names, values, and compare flags of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the match data of `object`.\n   */\n\n\n  function getMatchData(object) {\n    var result = keys(object),\n        length = result.length;\n\n    while (length--) {\n      var key = result[length],\n          value = object[key];\n      result[length] = [key, value, isStrictComparable(value)];\n    }\n\n    return result;\n  }\n  /**\n   * Gets the native function at `key` of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {string} key The key of the method to get.\n   * @returns {*} Returns the function if it's native, else `undefined`.\n   */\n\n\n  function getNative(object, key) {\n    var value = getValue(object, key);\n    return baseIsNative(value) ? value : undefined;\n  }\n  /**\n   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @returns {string} Returns the raw `toStringTag`.\n   */\n\n\n  function getRawTag(value) {\n    var isOwn = hasOwnProperty.call(value, symToStringTag),\n        tag = value[symToStringTag];\n\n    try {\n      value[symToStringTag] = undefined;\n      var unmasked = true;\n    } catch (e) {}\n\n    var result = nativeObjectToString.call(value);\n\n    if (unmasked) {\n      if (isOwn) {\n        value[symToStringTag] = tag;\n      } else {\n        delete value[symToStringTag];\n      }\n    }\n\n    return result;\n  }\n  /**\n   * Creates an array of the own enumerable symbols of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of symbols.\n   */\n\n\n  var getSymbols = !nativeGetSymbols ? stubArray : function (object) {\n    if (object == null) {\n      return [];\n    }\n\n    object = Object(object);\n    return arrayFilter(nativeGetSymbols(object), function (symbol) {\n      return propertyIsEnumerable.call(object, symbol);\n    });\n  };\n  /**\n   * Gets the `toStringTag` of `value`.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @returns {string} Returns the `toStringTag`.\n   */\n\n  var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\n\n  if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {\n    getTag = function (value) {\n      var result = baseGetTag(value),\n          Ctor = result == objectTag ? value.constructor : undefined,\n          ctorString = Ctor ? toSource(Ctor) : '';\n\n      if (ctorString) {\n        switch (ctorString) {\n          case dataViewCtorString:\n            return dataViewTag;\n\n          case mapCtorString:\n            return mapTag;\n\n          case promiseCtorString:\n            return promiseTag;\n\n          case setCtorString:\n            return setTag;\n\n          case weakMapCtorString:\n            return weakMapTag;\n        }\n      }\n\n      return result;\n    };\n  }\n  /**\n   * Checks if `path` exists on `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path to check.\n   * @param {Function} hasFunc The function to check properties.\n   * @returns {boolean} Returns `true` if `path` exists, else `false`.\n   */\n\n\n  function hasPath(object, path, hasFunc) {\n    path = castPath(path, object);\n    var index = -1,\n        length = path.length,\n        result = false;\n\n    while (++index < length) {\n      var key = toKey(path[index]);\n\n      if (!(result = object != null && hasFunc(object, key))) {\n        break;\n      }\n\n      object = object[key];\n    }\n\n    if (result || ++index != length) {\n      return result;\n    }\n\n    length = object == null ? 0 : object.length;\n    return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));\n  }\n  /**\n   * Checks if `value` is a flattenable `arguments` object or array.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n   */\n\n\n  function isFlattenable(value) {\n    return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);\n  }\n  /**\n   * Checks if `value` is a valid array-like index.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n   */\n\n\n  function isIndex(value, length) {\n    var type = typeof value;\n    length = length == null ? MAX_SAFE_INTEGER : length;\n    return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;\n  }\n  /**\n   * Checks if the given arguments are from an iteratee call.\n   *\n   * @private\n   * @param {*} value The potential iteratee value argument.\n   * @param {*} index The potential iteratee index or key argument.\n   * @param {*} object The potential iteratee object argument.\n   * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n   *  else `false`.\n   */\n\n\n  function isIterateeCall(value, index, object) {\n    if (!isObject(object)) {\n      return false;\n    }\n\n    var type = typeof index;\n\n    if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {\n      return eq(object[index], value);\n    }\n\n    return false;\n  }\n  /**\n   * Checks if `value` is a property name and not a property path.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @param {Object} [object] The object to query keys on.\n   * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n   */\n\n\n  function isKey(value, object) {\n    if (isArray(value)) {\n      return false;\n    }\n\n    var type = typeof value;\n\n    if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {\n      return true;\n    }\n\n    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);\n  }\n  /**\n   * Checks if `value` is suitable for use as unique object key.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n   */\n\n\n  function isKeyable(value) {\n    var type = typeof value;\n    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;\n  }\n  /**\n   * Checks if `func` has its source masked.\n   *\n   * @private\n   * @param {Function} func The function to check.\n   * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n   */\n\n\n  function isMasked(func) {\n    return !!maskSrcKey && maskSrcKey in func;\n  }\n  /**\n   * Checks if `value` is likely a prototype object.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n   */\n\n\n  function isPrototype(value) {\n    var Ctor = value && value.constructor,\n        proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;\n    return value === proto;\n  }\n  /**\n   * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` if suitable for strict\n   *  equality comparisons, else `false`.\n   */\n\n\n  function isStrictComparable(value) {\n    return value === value && !isObject(value);\n  }\n  /**\n   * A specialized version of `matchesProperty` for source values suitable\n   * for strict equality comparisons, i.e. `===`.\n   *\n   * @private\n   * @param {string} key The key of the property to get.\n   * @param {*} srcValue The value to match.\n   * @returns {Function} Returns the new spec function.\n   */\n\n\n  function matchesStrictComparable(key, srcValue) {\n    return function (object) {\n      if (object == null) {\n        return false;\n      }\n\n      return object[key] === srcValue && (srcValue !== undefined || key in Object(object));\n    };\n  }\n  /**\n   * A specialized version of `_.memoize` which clears the memoized function's\n   * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n   *\n   * @private\n   * @param {Function} func The function to have its output memoized.\n   * @returns {Function} Returns the new memoized function.\n   */\n\n\n  function memoizeCapped(func) {\n    var result = memoize(func, function (key) {\n      if (cache.size === MAX_MEMOIZE_SIZE) {\n        cache.clear();\n      }\n\n      return key;\n    });\n    var cache = result.cache;\n    return result;\n  }\n  /**\n   * Converts `value` to a string using `Object.prototype.toString`.\n   *\n   * @private\n   * @param {*} value The value to convert.\n   * @returns {string} Returns the converted string.\n   */\n\n\n  function objectToString(value) {\n    return nativeObjectToString.call(value);\n  }\n  /**\n   * A specialized version of `baseRest` which transforms the rest array.\n   *\n   * @private\n   * @param {Function} func The function to apply a rest parameter to.\n   * @param {number} [start=func.length-1] The start position of the rest parameter.\n   * @param {Function} transform The rest array transform.\n   * @returns {Function} Returns the new function.\n   */\n\n\n  function overRest(func, start, transform) {\n    start = nativeMax(start === undefined ? func.length - 1 : start, 0);\n    return function () {\n      var args = arguments,\n          index = -1,\n          length = nativeMax(args.length - start, 0),\n          array = Array(length);\n\n      while (++index < length) {\n        array[index] = args[start + index];\n      }\n\n      index = -1;\n      var otherArgs = Array(start + 1);\n\n      while (++index < start) {\n        otherArgs[index] = args[index];\n      }\n\n      otherArgs[start] = transform(array);\n      return apply(func, this, otherArgs);\n    };\n  }\n  /**\n   * Sets the `toString` method of `func` to return `string`.\n   *\n   * @private\n   * @param {Function} func The function to modify.\n   * @param {Function} string The `toString` result.\n   * @returns {Function} Returns `func`.\n   */\n\n\n  var setToString = shortOut(baseSetToString);\n  /**\n   * Creates a function that'll short out and invoke `identity` instead\n   * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n   * milliseconds.\n   *\n   * @private\n   * @param {Function} func The function to restrict.\n   * @returns {Function} Returns the new shortable function.\n   */\n\n  function shortOut(func) {\n    var count = 0,\n        lastCalled = 0;\n    return function () {\n      var stamp = nativeNow(),\n          remaining = HOT_SPAN - (stamp - lastCalled);\n      lastCalled = stamp;\n\n      if (remaining > 0) {\n        if (++count >= HOT_COUNT) {\n          return arguments[0];\n        }\n      } else {\n        count = 0;\n      }\n\n      return func.apply(undefined, arguments);\n    };\n  }\n  /**\n   * Converts `string` to a property path array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the property path array.\n   */\n\n\n  var stringToPath = memoizeCapped(function (string) {\n    var result = [];\n\n    if (string.charCodeAt(0) === 46\n    /* . */\n    ) {\n        result.push('');\n      }\n\n    string.replace(rePropName, function (match, number, quote, subString) {\n      result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);\n    });\n    return result;\n  });\n  /**\n   * Converts `value` to a string key if it's not a string or symbol.\n   *\n   * @private\n   * @param {*} value The value to inspect.\n   * @returns {string|symbol} Returns the key.\n   */\n\n  function toKey(value) {\n    if (typeof value == 'string' || isSymbol(value)) {\n      return value;\n    }\n\n    var result = value + '';\n    return result == '0' && 1 / value == -INFINITY ? '-0' : result;\n  }\n  /**\n   * Converts `func` to its source code.\n   *\n   * @private\n   * @param {Function} func The function to convert.\n   * @returns {string} Returns the source code.\n   */\n\n\n  function toSource(func) {\n    if (func != null) {\n      try {\n        return funcToString.call(func);\n      } catch (e) {}\n\n      try {\n        return func + '';\n      } catch (e) {}\n    }\n\n    return '';\n  }\n  /**\n   * Creates an array of elements, sorted in ascending order by the results of\n   * running each element in a collection thru each iteratee. This method\n   * performs a stable sort, that is, it preserves the original sort order of\n   * equal elements. The iteratees are invoked with one argument: (value).\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Collection\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {...(Function|Function[])} [iteratees=[_.identity]]\n   *  The iteratees to sort by.\n   * @returns {Array} Returns the new sorted array.\n   * @example\n   *\n   * var users = [\n   *   { 'user': 'fred',   'age': 48 },\n   *   { 'user': 'barney', 'age': 36 },\n   *   { 'user': 'fred',   'age': 40 },\n   *   { 'user': 'barney', 'age': 34 }\n   * ];\n   *\n   * _.sortBy(users, [function(o) { return o.user; }]);\n   * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\n   *\n   * _.sortBy(users, ['user', 'age']);\n   * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]\n   */\n\n\n  var sortBy = baseRest(function (collection, iteratees) {\n    if (collection == null) {\n      return [];\n    }\n\n    var length = iteratees.length;\n\n    if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n      iteratees = [];\n    } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n      iteratees = [iteratees[0]];\n    }\n\n    return baseOrderBy(collection, baseFlatten(iteratees, 1), []);\n  });\n  /**\n   * Creates a function that memoizes the result of `func`. If `resolver` is\n   * provided, it determines the cache key for storing the result based on the\n   * arguments provided to the memoized function. By default, the first argument\n   * provided to the memoized function is used as the map cache key. The `func`\n   * is invoked with the `this` binding of the memoized function.\n   *\n   * **Note:** The cache is exposed as the `cache` property on the memoized\n   * function. Its creation may be customized by replacing the `_.memoize.Cache`\n   * constructor with one whose instances implement the\n   * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n   * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Function\n   * @param {Function} func The function to have its output memoized.\n   * @param {Function} [resolver] The function to resolve the cache key.\n   * @returns {Function} Returns the new memoized function.\n   * @example\n   *\n   * var object = { 'a': 1, 'b': 2 };\n   * var other = { 'c': 3, 'd': 4 };\n   *\n   * var values = _.memoize(_.values);\n   * values(object);\n   * // => [1, 2]\n   *\n   * values(other);\n   * // => [3, 4]\n   *\n   * object.a = 2;\n   * values(object);\n   * // => [1, 2]\n   *\n   * // Modify the result cache.\n   * values.cache.set(object, ['a', 'b']);\n   * values(object);\n   * // => ['a', 'b']\n   *\n   * // Replace `_.memoize.Cache`.\n   * _.memoize.Cache = WeakMap;\n   */\n\n  function memoize(func, resolver) {\n    if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {\n      throw new TypeError(FUNC_ERROR_TEXT);\n    }\n\n    var memoized = function () {\n      var args = arguments,\n          key = resolver ? resolver.apply(this, args) : args[0],\n          cache = memoized.cache;\n\n      if (cache.has(key)) {\n        return cache.get(key);\n      }\n\n      var result = func.apply(this, args);\n      memoized.cache = cache.set(key, result) || cache;\n      return result;\n    };\n\n    memoized.cache = new (memoize.Cache || MapCache)();\n    return memoized;\n  } // Expose `MapCache`.\n\n\n  memoize.Cache = MapCache;\n  /**\n   * Performs a\n   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n   * comparison between two values to determine if they are equivalent.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to compare.\n   * @param {*} other The other value to compare.\n   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n   * @example\n   *\n   * var object = { 'a': 1 };\n   * var other = { 'a': 1 };\n   *\n   * _.eq(object, object);\n   * // => true\n   *\n   * _.eq(object, other);\n   * // => false\n   *\n   * _.eq('a', 'a');\n   * // => true\n   *\n   * _.eq('a', Object('a'));\n   * // => false\n   *\n   * _.eq(NaN, NaN);\n   * // => true\n   */\n\n  function eq(value, other) {\n    return value === other || value !== value && other !== other;\n  }\n  /**\n   * Checks if `value` is likely an `arguments` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n   *  else `false`.\n   * @example\n   *\n   * _.isArguments(function() { return arguments; }());\n   * // => true\n   *\n   * _.isArguments([1, 2, 3]);\n   * // => false\n   */\n\n\n  var isArguments = baseIsArguments(function () {\n    return arguments;\n  }()) ? baseIsArguments : function (value) {\n    return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');\n  };\n  /**\n   * Checks if `value` is classified as an `Array` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n   * @example\n   *\n   * _.isArray([1, 2, 3]);\n   * // => true\n   *\n   * _.isArray(document.body.children);\n   * // => false\n   *\n   * _.isArray('abc');\n   * // => false\n   *\n   * _.isArray(_.noop);\n   * // => false\n   */\n\n  var isArray = Array.isArray;\n  /**\n   * Checks if `value` is array-like. A value is considered array-like if it's\n   * not a function and has a `value.length` that's an integer greater than or\n   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n   * @example\n   *\n   * _.isArrayLike([1, 2, 3]);\n   * // => true\n   *\n   * _.isArrayLike(document.body.children);\n   * // => true\n   *\n   * _.isArrayLike('abc');\n   * // => true\n   *\n   * _.isArrayLike(_.noop);\n   * // => false\n   */\n\n  function isArrayLike(value) {\n    return value != null && isLength(value.length) && !isFunction(value);\n  }\n  /**\n   * Checks if `value` is a buffer.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.3.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n   * @example\n   *\n   * _.isBuffer(new Buffer(2));\n   * // => true\n   *\n   * _.isBuffer(new Uint8Array(2));\n   * // => false\n   */\n\n\n  var isBuffer = nativeIsBuffer || stubFalse;\n  /**\n   * Checks if `value` is classified as a `Function` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n   * @example\n   *\n   * _.isFunction(_);\n   * // => true\n   *\n   * _.isFunction(/abc/);\n   * // => false\n   */\n\n  function isFunction(value) {\n    if (!isObject(value)) {\n      return false;\n    } // The use of `Object#toString` avoids issues with the `typeof` operator\n    // in Safari 9 which returns 'object' for typed arrays and other constructors.\n\n\n    var tag = baseGetTag(value);\n    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n  }\n  /**\n   * Checks if `value` is a valid array-like length.\n   *\n   * **Note:** This method is loosely based on\n   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n   * @example\n   *\n   * _.isLength(3);\n   * // => true\n   *\n   * _.isLength(Number.MIN_VALUE);\n   * // => false\n   *\n   * _.isLength(Infinity);\n   * // => false\n   *\n   * _.isLength('3');\n   * // => false\n   */\n\n\n  function isLength(value) {\n    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n  }\n  /**\n   * Checks if `value` is the\n   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n   * @example\n   *\n   * _.isObject({});\n   * // => true\n   *\n   * _.isObject([1, 2, 3]);\n   * // => true\n   *\n   * _.isObject(_.noop);\n   * // => true\n   *\n   * _.isObject(null);\n   * // => false\n   */\n\n\n  function isObject(value) {\n    var type = typeof value;\n    return value != null && (type == 'object' || type == 'function');\n  }\n  /**\n   * Checks if `value` is object-like. A value is object-like if it's not `null`\n   * and has a `typeof` result of \"object\".\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n   * @example\n   *\n   * _.isObjectLike({});\n   * // => true\n   *\n   * _.isObjectLike([1, 2, 3]);\n   * // => true\n   *\n   * _.isObjectLike(_.noop);\n   * // => false\n   *\n   * _.isObjectLike(null);\n   * // => false\n   */\n\n\n  function isObjectLike(value) {\n    return value != null && typeof value == 'object';\n  }\n  /**\n   * Checks if `value` is classified as a `Symbol` primitive or object.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n   * @example\n   *\n   * _.isSymbol(Symbol.iterator);\n   * // => true\n   *\n   * _.isSymbol('abc');\n   * // => false\n   */\n\n\n  function isSymbol(value) {\n    return typeof value == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;\n  }\n  /**\n   * Checks if `value` is classified as a typed array.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n   * @example\n   *\n   * _.isTypedArray(new Uint8Array);\n   * // => true\n   *\n   * _.isTypedArray([]);\n   * // => false\n   */\n\n\n  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n  /**\n   * Converts `value` to a string. An empty string is returned for `null`\n   * and `undefined` values. The sign of `-0` is preserved.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to convert.\n   * @returns {string} Returns the converted string.\n   * @example\n   *\n   * _.toString(null);\n   * // => ''\n   *\n   * _.toString(-0);\n   * // => '-0'\n   *\n   * _.toString([1, 2, 3]);\n   * // => '1,2,3'\n   */\n\n  function toString(value) {\n    return value == null ? '' : baseToString(value);\n  }\n  /**\n   * Gets the value at `path` of `object`. If the resolved value is\n   * `undefined`, the `defaultValue` is returned in its place.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.7.0\n   * @category Object\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path of the property to get.\n   * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n   * @returns {*} Returns the resolved value.\n   * @example\n   *\n   * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n   *\n   * _.get(object, 'a[0].b.c');\n   * // => 3\n   *\n   * _.get(object, ['a', '0', 'b', 'c']);\n   * // => 3\n   *\n   * _.get(object, 'a.b.c', 'default');\n   * // => 'default'\n   */\n\n\n  function get(object, path, defaultValue) {\n    var result = object == null ? undefined : baseGet(object, path);\n    return result === undefined ? defaultValue : result;\n  }\n  /**\n   * Checks if `path` is a direct or inherited property of `object`.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Object\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path to check.\n   * @returns {boolean} Returns `true` if `path` exists, else `false`.\n   * @example\n   *\n   * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n   *\n   * _.hasIn(object, 'a');\n   * // => true\n   *\n   * _.hasIn(object, 'a.b');\n   * // => true\n   *\n   * _.hasIn(object, ['a', 'b']);\n   * // => true\n   *\n   * _.hasIn(object, 'b');\n   * // => false\n   */\n\n\n  function hasIn(object, path) {\n    return object != null && hasPath(object, path, baseHasIn);\n  }\n  /**\n   * Creates an array of the own enumerable property names of `object`.\n   *\n   * **Note:** Non-object values are coerced to objects. See the\n   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n   * for more details.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Object\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names.\n   * @example\n   *\n   * function Foo() {\n   *   this.a = 1;\n   *   this.b = 2;\n   * }\n   *\n   * Foo.prototype.c = 3;\n   *\n   * _.keys(new Foo);\n   * // => ['a', 'b'] (iteration order is not guaranteed)\n   *\n   * _.keys('hi');\n   * // => ['0', '1']\n   */\n\n\n  function keys(object) {\n    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n  }\n  /**\n   * Creates a function that returns `value`.\n   *\n   * @static\n   * @memberOf _\n   * @since 2.4.0\n   * @category Util\n   * @param {*} value The value to return from the new function.\n   * @returns {Function} Returns the new constant function.\n   * @example\n   *\n   * var objects = _.times(2, _.constant({ 'a': 1 }));\n   *\n   * console.log(objects);\n   * // => [{ 'a': 1 }, { 'a': 1 }]\n   *\n   * console.log(objects[0] === objects[1]);\n   * // => true\n   */\n\n\n  function constant(value) {\n    return function () {\n      return value;\n    };\n  }\n  /**\n   * This method returns the first argument it receives.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Util\n   * @param {*} value Any value.\n   * @returns {*} Returns `value`.\n   * @example\n   *\n   * var object = { 'a': 1 };\n   *\n   * console.log(_.identity(object) === object);\n   * // => true\n   */\n\n\n  function identity(value) {\n    return value;\n  }\n  /**\n   * Creates a function that returns the value at `path` of a given object.\n   *\n   * @static\n   * @memberOf _\n   * @since 2.4.0\n   * @category Util\n   * @param {Array|string} path The path of the property to get.\n   * @returns {Function} Returns the new accessor function.\n   * @example\n   *\n   * var objects = [\n   *   { 'a': { 'b': 2 } },\n   *   { 'a': { 'b': 1 } }\n   * ];\n   *\n   * _.map(objects, _.property('a.b'));\n   * // => [2, 1]\n   *\n   * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n   * // => [1, 2]\n   */\n\n\n  function property(path) {\n    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n  }\n  /**\n   * This method returns a new empty array.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.13.0\n   * @category Util\n   * @returns {Array} Returns the new empty array.\n   * @example\n   *\n   * var arrays = _.times(2, _.stubArray);\n   *\n   * console.log(arrays);\n   * // => [[], []]\n   *\n   * console.log(arrays[0] === arrays[1]);\n   * // => false\n   */\n\n\n  function stubArray() {\n    return [];\n  }\n  /**\n   * This method returns `false`.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.13.0\n   * @category Util\n   * @returns {boolean} Returns `false`.\n   * @example\n   *\n   * _.times(2, _.stubFalse);\n   * // => [false, false]\n   */\n\n\n  function stubFalse() {\n    return false;\n  }\n\n  module.exports = sortBy;\n  });\n\n  var ClipChannel =\n  /*#__PURE__*/\n  function (_Channel) {\n    _inherits(ClipChannel, _Channel);\n\n    function ClipChannel() {\n      _classCallCheck(this, ClipChannel);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(ClipChannel).apply(this, arguments));\n    }\n\n    _createClass(ClipChannel, [{\n      key: \"onInitialise\",\n\n      /*\n        this.incidents is a collection of {incident, id, millisecond} objects always kept in order\n            from lower to higher millisecond\n        this.incidetnsById is an index of the incidents kept by id (this.incidents[incident-id] = Incident)\n        */\n      value: function onInitialise() {\n        this.incidents = [];\n        this.incidentsById = {};\n      }\n    }, {\n      key: \"_incidentById\",\n      value: function _incidentById(id) {\n        return this.incidentsById[id];\n      }\n    }, {\n      key: \"_resize\",\n      value: function _resize(durationFraction) {\n        for (var i = 0; i < this.incidents.length; i++) {\n          this.incidents[i].millisecond = this.incidents[i].millisecond * durationFraction;\n        }\n      }\n      /**\n        * @param {array} incidents - a colleciton of all incidents to be added on the form:\n        *\n            {\n                id\n                millisecond\n                incident\n            }\n        * @returns {object} -\n        * either:\n            {\n                result:true,\n                execute: // a function that when executed it will add the Incidents on the Channels\n            }\n            or\n            {\n                result: false,\n                errors\n            }\n        */\n\n    }, {\n      key: \"checkAddition\",\n      value: function checkAddition(incidents) {\n        var errors = [];\n        var candidateIncidentsById = {};\n        var incidentsToConcat = [];\n\n        for (var i = 0; i < incidents.length; i++) {\n          candidateIncidentsById[incidents[i].id] = incidents[i].incident;\n          incidentsToConcat.push({\n            id: incidents[i].id,\n            millisecond: incidents[i].millisecond\n          });\n\n          if (Object.prototype.hasOwnProperty.call(this.incidentsById, incidents[i].id)) {\n            helper.error(\"Incident with the id \".concat(incidents[i].id, \" already exists. Addition is rejected.\"));\n            errors.push({\n              type: 'Already existing id',\n              meta: {\n                id: incidents[i].id\n              }\n            });\n          }\n        }\n\n        if (errors.length > 0) {\n          return {\n            result: false,\n            errors: errors\n          };\n        }\n\n        var that = this;\n\n        var exec = function execFunct() {\n          that.incidentsById = Object.assign(that.incidentsById, candidateIncidentsById);\n          that.incidents = that.incidents.concat(incidentsToConcat);\n          that.incidents = lodash_sortby(that.incidents, [function (laneItem) {\n            return laneItem.millisecond;\n          }]);\n\n          for (var _i = 0; _i < incidents.length; _i++) {\n            that._incidentById(incidents[_i].id)._onGetContextOnce(that.context);\n          }\n        };\n\n        return {\n          result: true,\n          execute: exec\n        };\n      }\n      /**\n        @param {array} incidentsArray - A collection of the Incidetns to get edited in the form:\n        {\n            id\n            millisecond\n            incident\n        }\n        @param {int} millisecondsDelta- the delta of the star point of the provided incidents\n        */\n\n    }, {\n      key: \"checkEdit\",\n      value: function checkEdit(incidentsArray, millisecondsDelta) {\n        var that = this;\n\n        var exec = function execFunct() {\n          for (var i = 0; i < incidentsArray.length; i++) {\n            for (var j = 0; j < that.incidents.length; j++) {\n              if (that.incidents[j].id === incidentsArray[i].id) {\n                that.incidents[j].millisecond += millisecondsDelta;\n                break;\n              }\n            }\n          }\n\n          that.incidents = lodash_sortby(that.incidents, [function (laneItem) {\n            return laneItem.millisecond;\n          }]);\n        };\n\n        return {\n          result: true,\n          execute: exec\n        };\n      }\n    }, {\n      key: \"checkDelete\",\n      value: function checkDelete(incidentsArray) {\n        var that = this;\n        var incidentIds = [];\n\n        for (var i = 0; i < incidentsArray.length; i++) {\n          incidentIds.push(incidentsArray[i].id);\n        }\n\n        var exec = function execFunct() {\n          var newIncidents = lodash_filter(that.incidents, function (incident) {\n            return incidentIds.indexOf(incident.id) === -1;\n          });\n\n          that.incidents = newIncidents;\n\n          for (var _i2 = 0; _i2 < incidentIds.length; _i2++) {\n            delete that.incidentsById[incidentIds[_i2]];\n          }\n        };\n\n        return {\n          result: true,\n          execute: exec\n        };\n      }\n      /**\n       * @param {array} incidents - [{id, start, end, startDelta}]\n       */\n\n    }, {\n      key: \"checkResizedIncidents\",\n      value: function checkResizedIncidents(incidents) {\n        var that = this;\n\n        var exec = function execFunct() {\n          for (var i = 0; i < incidents.length; i++) {\n            for (var j = 0; j < that.incidents.length; j++) {\n              if (that.incidents[j].id === incidents[i].id) {\n                that.incidents[j].millisecond += incidents[i].startDelta;\n                break;\n              }\n            }\n          }\n\n          that.incidents = lodash_sortby(that.incidents, [function (laneItem) {\n            return laneItem.millisecond;\n          }]);\n        };\n\n        return {\n          result: true,\n          execute: exec\n        };\n      }\n      /**\n         @param {int} from - the millisecond to start from\n         @param {int} to - the millisecond to go to\n         @param {string} contextId - the context id to move\n         @param {boolean} forceReset - set to true when we want full flash\n         */\n\n    }, {\n      key: \"moveTo\",\n      value: function moveTo(from, to, contextId) {\n        var forceReset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n        if (forceReset === true) {\n          // incidents: [{id, millisecond}, {}, {}...]\n          for (var i = 0; i < this.incidents.length; i++) {\n            var laneItem = this.incidents[i];\n\n            var incident = this._incidentById(laneItem.id);\n\n            if (to < laneItem.millisecond) {\n              incident.onProgress(0, 0, contextId, true);\n            } else if (to > laneItem.millisecond + incident.duration) {\n              incident.onProgress(1, incident.duration, contextId, true);\n            } else {\n              incident.onProgress((to - laneItem.millisecond) / incident.duration, to - laneItem.millisecond, contextId, true);\n            }\n          }\n        } else {\n          var that = this;\n          var participatingItems;\n\n          if (to > from) {\n            participatingItems = lodash_filter(this.incidents, function (laneItem) {\n              return (// it ends after from and before to millisecond\n                // or it ends after the target millisecond but also starts before it\n                laneItem.millisecond + that._incidentById(laneItem.id).duration >= from && laneItem.millisecond + that._incidentById(laneItem.id).duration <= to || that._incidentById(laneItem.id).duration + laneItem.millisecond >= to && laneItem.millisecond <= to\n              );\n            });\n          } else {\n            participatingItems = lodash_filter(this.incidents, function (laneItem) {\n              return (// it ends after from and before to millisecond\n                // or it ends after the target millisecond but also starts before it\n                laneItem.millisecond + that._incidentById(laneItem.id).duration >= to && laneItem.millisecond + that._incidentById(laneItem.id).duration <= from || that._incidentById(laneItem.id).duration + laneItem.millisecond >= from && laneItem.millisecond <= from\n              );\n            });\n          }\n\n          for (var _i3 = 0; _i3 < participatingItems.length; _i3++) {\n            var _laneItem = participatingItems[_i3];\n\n            var contextAwareClipIncident = this._incidentById(_laneItem.id); // onProgress(fraction, milliseconds, contextId, forceReset = false) {\n\n\n            var overcameEnd = (to - _laneItem.millisecond) / contextAwareClipIncident.duration >= 1;\n            var fraction = overcameEnd ? 1 : (to - _laneItem.millisecond) / contextAwareClipIncident.duration;\n            var millisecond = overcameEnd ? contextAwareClipIncident.duration : to - _laneItem.millisecond;\n            contextAwareClipIncident.onProgress(fraction, millisecond, contextId, false);\n          }\n        } // this.runTimeInfo.currentMillisecond = to;\n\n      }\n    }]);\n\n    return ClipChannel;\n  }(Channel);\n\n  /**\n   * https://github.com/gre/bezier-easing\n   * BezierEasing - use bezier curve for transition easing function\n   * by Gatan Renaudeau 2014 - 2015  MIT License\n   */\n  // These values are established by empiricism with tests (tradeoff: performance VS precision)\n  var NEWTON_ITERATIONS = 4;\n  var NEWTON_MIN_SLOPE = 0.001;\n  var SUBDIVISION_PRECISION = 0.0000001;\n  var SUBDIVISION_MAX_ITERATIONS = 10;\n  var kSplineTableSize = 11;\n  var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\n  var float32ArraySupported = typeof Float32Array === 'function';\n\n  function A(aA1, aA2) {\n    return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n  }\n\n  function B(aA1, aA2) {\n    return 3.0 * aA2 - 6.0 * aA1;\n  }\n\n  function C(aA1) {\n    return 3.0 * aA1;\n  } // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\n\n\n  function calcBezier(aT, aA1, aA2) {\n    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n  } // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\n\n\n  function getSlope(aT, aA1, aA2) {\n    return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n  }\n\n  function binarySubdivide(aX, aA, aB, mX1, mX2) {\n    var currentX,\n        currentT,\n        i = 0;\n\n    do {\n      currentT = aA + (aB - aA) / 2.0;\n      currentX = calcBezier(currentT, mX1, mX2) - aX;\n\n      if (currentX > 0.0) {\n        aB = currentT;\n      } else {\n        aA = currentT;\n      }\n    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n\n    return currentT;\n  }\n\n  function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n    for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\n      var currentSlope = getSlope(aGuessT, mX1, mX2);\n\n      if (currentSlope === 0.0) {\n        return aGuessT;\n      }\n\n      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n      aGuessT -= currentX / currentSlope;\n    }\n\n    return aGuessT;\n  }\n\n  function LinearEasing(x) {\n    return x;\n  }\n\n  var src = function bezier(mX1, mY1, mX2, mY2) {\n    if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {\n      throw new Error('bezier x values must be in [0, 1] range');\n    }\n\n    if (mX1 === mY1 && mX2 === mY2) {\n      return LinearEasing;\n    } // Precompute samples table\n\n\n    var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n\n    for (var i = 0; i < kSplineTableSize; ++i) {\n      sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n    }\n\n    function getTForX(aX) {\n      var intervalStart = 0.0;\n      var currentSample = 1;\n      var lastSample = kSplineTableSize - 1;\n\n      for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n        intervalStart += kSampleStepSize;\n      }\n\n      --currentSample; // Interpolate to provide an initial guess for t\n\n      var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n      var guessForT = intervalStart + dist * kSampleStepSize;\n      var initialSlope = getSlope(guessForT, mX1, mX2);\n\n      if (initialSlope >= NEWTON_MIN_SLOPE) {\n        return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n      } else if (initialSlope === 0.0) {\n        return guessForT;\n      } else {\n        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n      }\n    }\n\n    return function BezierEasing(x) {\n      // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n      if (x === 0) {\n        return 0;\n      }\n\n      if (x === 1) {\n        return 1;\n      }\n\n      return calcBezier(getTForX(x), mY1, mY2);\n    };\n  };\n\n  function getIncidentsByChannel(pld) {\n    pld.descriptor.value = function getIncidentsByChannelFunct() {\n      var adjustMillisecond = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var parentMillisecond = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var incidentsByPlugin = {};\n      incidentsByPlugin[this.mc_plugin_npm_name] = [{\n        millisecond: adjustMillisecond,\n        parentMillisecond: parentMillisecond,\n        incident: this,\n        id: this.id\n      }];\n      return incidentsByPlugin;\n    };\n  }\n\n  /*\n  dna:\n  - originalId\n  - context\n  */\n\n  var MonoIncident = _decorate(null, function (_initialize) {\n    var MonoIncident = function MonoIncident() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var dna = arguments.length > 2 ? arguments[2] : undefined;\n\n      _classCallCheck(this, MonoIncident);\n\n      _initialize(this);\n\n      // super(props);\n      this.attrs = attrs;\n      this.props = props;\n      this.dna = dna;\n      this.context = dna.context;\n      this.mcid = dna.mcid;\n      this.id = props.id || getAnId();\n      this.modelId = props.modelId; // this parameter is initialised to false. Once the onGetContext method gets invoked this parameter\n      // is set to true so we prevent multiple executions of the onGetContext method\n\n      this.gotContext = false;\n      /*\n          these are the default values that define channeling for the default Incidents. These values get ovewriden through\n          the loadPlugin method of MC with the values found on the main.js file of the plugin\n          */\n\n      this.plugin_channel_class = Channel;\n      this.mc_plugin_npm_name = 'motor-cortex-js';\n\n      if (Object.prototype.hasOwnProperty.call(props, 'plugin_channel_class')) {\n        this.plugin_channel_class = props.plugin_channel_class;\n      }\n\n      if (Object.prototype.hasOwnProperty.call(props, 'mc_plugin_npm_name')) {\n        this.mc_plugin_npm_name = props.mc_plugin_npm_name;\n      }\n\n      this.hasIncidents = false;\n      /*\n          initialValues is an object holding the automatically computed initial values of the animatedAttrs\n          (if any). The initialValues are calculated by the AttributesChannel (only Incidents belonging to\n          an AttributesChannel have initialValues).\n          The keys set of this object is identical to the object attrs.animatedAttrs\n          The only thing the generic AttributesChannel can't calculate is the initial value of an animated attr\n          of a specific element when there are no other Incidents entered on its lanes yet. These values are\n          the \"scratchValues\" and they are strongly dependend on the nature of the lib. E.g. for a CSS animation\n          what we are looking for can be found on the computedStyle.\n          The initialValues are the values that are actually going to be used by\n          the MonoIncident in the real execution of them\n          */\n\n      this.initialValues = {};\n      /*\n          The initial values defined by the user via the initialValues key on the\n          attributes (if present)\n          */\n\n      this.userDefinedInitialValues = attrs.initialValues || {};\n      /*\n          The initialValues of the Incident as passed by the Attribute Channel.\n          These values are been altered by the userDefinedInitialValues (if any)\n          but we need them for passing them on other Incidents on edit and delete operations\n          */\n\n      this.pureInitialValues = null;\n      /**\n       * @member {boolean} - if autoGenerated is set to true, it means that this MonoIncident has been auto-generated by its parent on initialisation.\n       * This happens when plugins export Incidents that on initialisation they automatically create other incidents and automatically put them\n       * on specific points on their timeline.\n       */\n\n      this.autoGenerated = false;\n      this.onInitialise(attrs, props);\n    };\n\n    return {\n      F: MonoIncident,\n      d: [{\n        kind: \"get\",\n        key: \"selector\",\n        value: function selector() {\n          return this.props.selector;\n        }\n        /* shortcuts for attrs.attrs and attrs.animatedAttrs */\n\n      }, {\n        kind: \"get\",\n        key: \"animAttributes\",\n        value: function animAttributes() {\n          return this.attrs.animatedAttrs;\n        }\n      }, {\n        kind: \"set\",\n        key: \"animAttributes\",\n        value: function animAttributes(value) {\n          this.attrs.animatedAttrs[this.attributeKey] = value;\n        }\n        /**\n          This method shoudl be overwritten by the Incidents of the plugins. The method returns\n          the initial value that the element of it has as the library calculates / defines them. The\n          returned value represents the very initial value of the element's attribute before\n          any Incident that alters it gets added.\n           @returns {mixed} - the initial value of the element's attribute just when the HTML & CSS\n          of the Clip gets rendered\n          */\n\n      }, {\n        kind: \"method\",\n        key: \"getScratchValue\",\n        value: function getScratchValue() {\n          return 0;\n        }\n      }, {\n        kind: \"get\",\n        key: \"element\",\n        value: function element() {\n          if (this.contex === null) {\n            return [];\n          }\n\n          if (this.context.getElementByMCID) {\n            return this.context.getElementByMCID(this.mcid);\n          }\n\n          return this.context.getElements(this.selector)[0];\n        }\n      }, {\n        kind: \"get\",\n        key: \"attributeKey\",\n        value: function attributeKey() {\n          return Object.keys(this.attrs.animatedAttrs)[0];\n        }\n      }, {\n        kind: \"get\",\n        key: \"targetValue\",\n        value: function targetValue() {\n          return this.animAttributes[this.attributeKey];\n        }\n      }, {\n        kind: \"method\",\n        key: \"getElementAttribute\",\n        value: function getElementAttribute(attr) {\n          return this.element.getAttribute(attr);\n        }\n      }, {\n        kind: \"method\",\n        decorators: [getIncidentsByChannel],\n        key: \"getIncidentsByChannel\",\n        value: function getIncidentsByChannel() {}\n      }, {\n        kind: \"method\",\n        key: \"hasUserDefinedInitialValue\",\n        value: function hasUserDefinedInitialValue() {\n          if (Object.prototype.hasOwnProperty.call(this.userDefinedInitialValues, this.attributeKey)) {\n            return true;\n          }\n\n          return false;\n        }\n      }, {\n        kind: \"method\",\n        key: \"setInitialValue\",\n        value: function setInitialValue(value) {\n          var storePure = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n          if (storePure === true) {\n            this.pureInitialValues = JSON.parse(JSON.stringify(value)); // keep a copy of the\n            // passed initial values\n          }\n\n          if (!this.hasUserDefinedInitialValue()) {\n            this.initialValues[this.attributeKey] = value;\n            return;\n          }\n\n          if (_typeof(this.targetValue) === 'object') {\n            // if it is a combo attribute\n            for (var key in this.userDefinedInitialValues[this.attributeKey]) {\n              value[key] = this.userDefinedInitialValues[this.attributeKey][key];\n            }\n\n            this.initialValues[this.attributeKey] = value;\n          } else {\n            this.initialValues[this.attributeKey] = this.userDefinedInitialValues[this.attributeKey];\n          }\n        }\n      }, {\n        kind: \"get\",\n        key: \"initialValue\",\n        value: function initialValue() {\n          return this.initialValues[this.attributeKey];\n        }\n      }, {\n        kind: \"method\",\n        key: \"getInitialValue\",\n        value: function getInitialValue() {\n          return this.initialValues[this.attributeKey];\n        }\n      }, {\n        kind: \"method\",\n        key: \"_onGetContextOnce\",\n        value: function _onGetContextOnce() {\n          // if the MonoIncident belongs to a fragmented context there absolutely\n          // no reason to run the getContext method of it\n          try {\n            if (this.context.fragment === true) {\n              return;\n            }\n\n            if (!this.gotContext) {\n              this.onGetContext();\n              this.gotContext = true;\n            }\n          } catch (e) {\n            console.log(e); // eslint-disable-line no-console\n\n            console.log(this.mcid); // eslint-disable-line no-console\n            // console.log(this.context);\n          }\n        }\n      }, {\n        kind: \"method\",\n        key: \"onGetContext\",\n        value: function onGetContext() {\n          helper.info('Overwritte the \"onGetContext\" method with the code you want to get executed', 'info');\n        }\n      }, {\n        kind: \"method\",\n        key: \"lastWish\",\n        value: function lastWish() {}\n      }, {\n        kind: \"method\",\n        key: \"onInitialise\",\n        value: function onInitialise() {\n          helper.info('Overwritte the \"onInialise\" method with the code you want to get executed', 'info');\n        }\n        /**\n         * Method called on progress of the timed incident.\n         * @param {float} fraction - a number from 0 to 1 representing the fraction of duration covered\n         * @param {int} milliseconds - the number of milliseconds passed from start of the incident\n         */\n        // eslint-disable-next-line no-unused-vars\n\n      }, {\n        kind: \"method\",\n        key: \"onProgress\",\n        value: function onProgress(fraction, milliseconds) {}\n      }, {\n        kind: \"method\",\n        decorators: [block],\n        key: \"setBlock\",\n        value: function setBlock() {}\n      }, {\n        kind: \"method\",\n        decorators: [unblock],\n        key: \"unblock\",\n        value: function unblock() {}\n      }]\n    };\n  });\n\n  var ClipCopy =\n  /*#__PURE__*/\n  function (_MonoIncident) {\n    _inherits(ClipCopy, _MonoIncident);\n\n    function ClipCopy(attrs, props, dna) {\n      var _this;\n\n      _classCallCheck(this, ClipCopy);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(ClipCopy).call(this, attrs, props, dna));\n      _this.runTimeInfo = {\n        currentMillisecond: 0\n      };\n      return _this;\n    }\n\n    _createClass(ClipCopy, [{\n      key: \"lastWish\",\n      value: function lastWish() {\n        this.ownClip.ownContext.unmount();\n      }\n    }, {\n      key: \"onGetContext\",\n      value: function onGetContext() {\n        // In order to render itself on the given element first it needs the props (including html and css)\n        // from the real Clip it copies\n        var constructionArgs = this.DescriptiveIncident.realClip.exportConstructionArguments(); // it properly sets its own host on the props to use to initialise its own clip\n\n        var host = helper.getElementByMCID(this.context, this.mcid);\n\n        var hostedProps = _objectSpread2({}, constructionArgs.props, {\n          selector: undefined,\n          host: host\n        }); // we create a clip because Clips on creation render and thus have their own context\n        // this.dna.descriptiveIncident.constructor.Incident keeps a reference to the non-audio real Clip\n        // Class. No audio is involved on this process\n\n\n        this.ownClip = new this.DescriptiveIncident.constructor.Incident(constructionArgs.attrs, hostedProps);\n        this.ownClip.DescriptiveIncident = this.DescriptiveIncident;\n        this.ownClip.contextLoaded = this.contextLoaded.bind(this); // console.log(this.ownClip);\n        // flushes the realClip with its ownClip's context\n\n        this.DescriptiveIncident.realClip.addContext({\n          clipId: this.id,\n          context: this.ownClip.ownContext\n        }, true); // even though we have created an own clip, we have made no checks at all neither\n        // we added the incidents of the real clip to it. That is becuase playing and moving\n        // this clip copy means directly moving the real clip on the context of the own clip.\n        // So the only thing we need here is the context and nothing more.\n\n        this.contextReady = true;\n      }\n    }, {\n      key: \"contextLoaded\",\n      value: function contextLoaded() {\n        this.contextReady = true;\n        this.unblock();\n      }\n    }, {\n      key: \"onProgress\",\n      value: function onProgress(fraction, milliseconds) {\n        var forceReset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n        if (this.ownClip.ownContext.loading === true) {\n          this.setBlock();\n          return;\n        }\n\n        for (var key in this.DescriptiveIncident.realClip.instantiatedChannels) {\n          var channel = this.DescriptiveIncident.realClip.instantiatedChannels[key];\n          channel.moveTo(this.runTimeInfo.currentMillisecond, milliseconds, this.id, forceReset);\n        }\n\n        this.runTimeInfo.currentMillisecond = milliseconds;\n        this.ownClip.onAfterProgress(fraction, milliseconds);\n      }\n    }, {\n      key: \"duration\",\n      get: function get() {\n        return this.DescriptiveIncident.realClip.duration;\n      },\n      set: function set(milliseconds) {\n        this.DescriptiveIncident.realClip._resize(milliseconds / this.realClip.duration);\n      }\n    }]);\n\n    return ClipCopy;\n  }(MonoIncident);\n\n  /**\n   * @param {object} ingredients -\n   * {\n   *      id\n   *      attrs\n   *      props\n   *      Incident\n   *      plugin_npm_name\n   *      Channel\n   *      context (optional)\n   *      mcid (optional)\n   *      dnaExtras\n   * }\n   * */\n\n  function incidentFromIngredients(ingredients) {\n    if (!Object.prototype.hasOwnProperty.call(ingredients, 'dnaExtras')) {\n      ingredients.dnaExtras = {};\n    }\n\n    var incident = new ingredients.Incident(ingredients.attrs, _objectSpread2({}, ingredients.props, {\n      id: ingredients.id || getAnId()\n    }), _objectSpread2({}, ingredients.dnaExtras, {\n      context: ingredients.context,\n      mcid: ingredients.mcid\n    }));\n    incident.mc_plugin_npm_name = ingredients.plugin_npm_name;\n    incident.plugin_channel_class = ingredients.Channel;\n    incident.DescriptiveIncident = ingredients.DescriptiveIncident;\n    return incident;\n  }\n\n  var easing = {\n    linear: function linear(fraction) {\n      return fraction;\n    },\n    easeInQuad: function easeInQuad(fraction) {\n      return fraction * fraction;\n    },\n    easeOutQuad: function easeOutQuad(fraction) {\n      return fraction * (2 - fraction);\n    },\n    easeInOutQuad: function easeInOutQuad(fraction) {\n      return fraction < 0.5 ? 2 * fraction * fraction : -1 + (4 - 2 * fraction) * fraction;\n    },\n    easeInCubic: function easeInCubic(fraction) {\n      return fraction * fraction * fraction;\n    },\n    easeOutCubic: function easeOutCubic(fraction) {\n      return --fraction * fraction * fraction + 1;\n    },\n    easeInOutCubic: function easeInOutCubic(fraction) {\n      return fraction < 0.5 ? 4 * fraction * fraction * fraction : (fraction - 1) * (2 * fraction - 2) * (2 * fraction - 2) + 1;\n    },\n    easeInQuart: function easeInQuart(fraction) {\n      return fraction * fraction * fraction * fraction;\n    },\n    easeOutQuart: function easeOutQuart(fraction) {\n      return 1 - --fraction * fraction * fraction * fraction;\n    },\n    easeInOutQuart: function easeInOutQuart(fraction) {\n      return fraction < 0.5 ? 8 * fraction * fraction * fraction * fraction : 1 - 8 * --fraction * fraction * fraction * fraction;\n    },\n    easeInQuint: function easeInQuint(fraction) {\n      return fraction * fraction * fraction * fraction * fraction;\n    },\n    easeOutQuint: function easeOutQuint(fraction) {\n      return 1 + --fraction * fraction * fraction * fraction * fraction;\n    },\n    easeInOutQuint: function easeInOutQuint(fraction) {\n      return fraction < 0.5 ? 16 * fraction * fraction * fraction * fraction * fraction : 1 + 16 * --fraction * fraction * fraction * fraction * fraction;\n    },\n    easeInSine: function easeInSine(fraction) {\n      return -1 * Math.cos(fraction / 1 * (Math.PI / 2)) + 1;\n    },\n    easeOutSine: function easeOutSine(fraction) {\n      return 1 * Math.sin(fraction / 1 * (Math.PI / 2));\n    },\n    easeInOutSine: function easeInOutSine(fraction) {\n      return -1 / 2 * (Math.cos(Math.PI * fraction / 1) - 1);\n    },\n    easeInExpo: function easeInExpo(fraction) {\n      return fraction == 0 ? 1 : 1 * Math.pow(2, 10 * (fraction / 1 - 1));\n    },\n    easeOutExpo: function easeOutExpo(fraction) {\n      return fraction == 1 ? 1 : 1 * (-Math.pow(2, -10 * fraction / 1) + 1);\n    },\n    easeInOutExpo: function easeInOutExpo(fraction) {\n      if (fraction == 0) return 0;\n      if (fraction == 1) return 1;\n      if ((fraction /= 1 / 2) < 1) return 1 / 2 * Math.pow(2, 10 * (fraction - 1));\n      return 1 / 2 * (-Math.pow(2, -10 * --fraction) + 2);\n    },\n    easeInCirc: function easeInCirc(fraction) {\n      if (fraction >= 1) return fraction;\n      return -1 * (Math.sqrt(1 - (fraction /= 1) * fraction) - 1);\n    },\n    easeOutCirc: function easeOutCirc(fraction) {\n      return 1 * Math.sqrt(1 - (fraction = fraction / 1 - 1) * fraction);\n    },\n    easeInOutCirc: function easeInOutCirc(fraction) {\n      if ((fraction /= 1 / 2) < 1) return -1 / 2 * (Math.sqrt(1 - fraction * fraction) - 1);\n      return 1 / 2 * (Math.sqrt(1 - (fraction -= 2) * fraction) + 1);\n    },\n    easeInElastic: function easeInElastic(fraction) {\n      var s = 1.70158;\n      var p = 0;\n      var a = 1;\n      if (fraction == 0) return 0;\n      if ((fraction /= 1) == 1) return 1;\n      if (!p) p = 1 * 0.3;\n\n      if (a < Math.abs(1)) {\n        a = 1;\n        s = p / 4;\n      } else s = p / (2 * Math.PI) * Math.asin(1 / a);\n\n      return -(a * Math.pow(2, 10 * (fraction -= 1)) * Math.sin((fraction * 1 - s) * (2 * Math.PI) / p));\n    },\n    easeOutElastic: function easeOutElastic(fraction) {\n      var s = 1.70158;\n      var p = 0;\n      var a = 1;\n      if (fraction == 0) return 0;\n      if ((fraction /= 1) == 1) return 1;\n      if (!p) p = 1 * 0.3;\n\n      if (a < Math.abs(1)) {\n        a = 1;\n        s = p / 4;\n      } else s = p / (2 * Math.PI) * Math.asin(1 / a);\n\n      return a * Math.pow(2, -10 * fraction) * Math.sin((fraction * 1 - s) * (2 * Math.PI) / p) + 1;\n    },\n    easeInOutElastic: function easeInOutElastic(fraction) {\n      var s = 1.70158;\n      var p = 0;\n      var a = 1;\n      if (fraction == 0) return 0;\n      if ((fraction /= 1 / 2) == 2) return 1;\n      if (!p) p = 1 * (0.3 * 1.5);\n\n      if (a < Math.abs(1)) {\n        a = 1;\n        s = p / 4;\n      } else s = p / (2 * Math.PI) * Math.asin(1 / a);\n\n      if (fraction < 1) return -0.5 * (a * Math.pow(2, 10 * (fraction -= 1)) * Math.sin((fraction * 1 - s) * (2 * Math.PI) / p));\n      return a * Math.pow(2, -10 * (fraction -= 1)) * Math.sin((fraction * 1 - s) * (2 * Math.PI) / p) * 0.5 + 1;\n    },\n    easeInBack: function easeInBack(fraction) {\n      var s = 1.70158;\n      return 1 * (fraction /= 1) * fraction * ((s + 1) * fraction - s);\n    },\n    easeOutBack: function easeOutBack(fraction) {\n      var s = 1.70158;\n      return 1 * ((fraction = fraction / 1 - 1) * fraction * ((s + 1) * fraction + s) + 1);\n    },\n    easeInOutBack: function easeInOutBack(fraction) {\n      var s = 1.70158;\n      if ((fraction /= 1 / 2) < 1) return 1 / 2 * (fraction * fraction * (((s *= 1.525) + 1) * fraction - s));\n      return 1 / 2 * ((fraction -= 2) * fraction * (((s *= 1.525) + 1) * fraction + s) + 2);\n    },\n    easeInBounce: function easeInBounce(fraction) {\n      return 1 - easing.easeOutBounce(1 - fraction);\n    },\n    easeOutBounce: function easeOutBounce(fraction) {\n      if ((fraction /= 1) < 1 / 2.75) {\n        return 1 * (7.5625 * fraction * fraction);\n      }\n\n      if (fraction < 2 / 2.75) {\n        return 1 * (7.5625 * (fraction -= 1.5 / 2.75) * fraction + 0.75);\n      }\n\n      if (fraction < 2.5 / 2.75) {\n        return 1 * (7.5625 * (fraction -= 2.25 / 2.75) * fraction + 0.9375);\n      }\n\n      return 1 * (7.5625 * (fraction -= 2.625 / 2.75) * fraction + 0.984375);\n    },\n    easeInOutBounce: function easeInOutBounce(fraction) {\n      if (fraction < 1 / 2) return easing.easeInBounce(fraction * 2) * 0.5;\n      return easing.easeOutBounce(fraction * 2 - 1) * 0.5 + 1 * 0.5;\n    }\n  };\n\n  var ContextAwareClipIncident = _decorate(null, function (_initialize, _Leaf) {\n    var ContextAwareClipIncident =\n    /*#__PURE__*/\n    function (_Leaf2) {\n      _inherits(ContextAwareClipIncident, _Leaf2);\n\n      function ContextAwareClipIncident(constructionIngredients, contextData, mcid, descriptiveIncident) {\n        var _this;\n\n        _classCallCheck(this, ContextAwareClipIncident);\n\n        // console.log(constructionIngredients.props);\n        _this = _possibleConstructorReturn(this, _getPrototypeOf(ContextAwareClipIncident).call(this, {\n          id: \"\".concat(constructionIngredients.incidentId, \"_\").concat(mcid)\n        })); // a property to hold all of the contexts\n\n        _initialize(_assertThisInitialized(_this));\n\n        _this.contexts = {};\n        _this.constructionIngredients = constructionIngredients;\n        _this.mcid = mcid;\n        _this._duration = descriptiveIncident.realClip.duration;\n        _this.DescriptiveIncident = descriptiveIncident;\n        _this.mc_plugin_npm_name = constructionIngredients.plugin_npm_name;\n        _this.plugin_channel_class = constructionIngredients.Channel;\n\n        _this.addContext(contextData);\n\n        descriptiveIncident.realClip.subscribeToDurationChange(function (newDuration) {\n          _this._duration = newDuration;\n\n          _this.putMessageOnPipe('recalcDuration', {}, 'Groups', {\n            selfExecute: true,\n            direction: _DIRECTIONS._UP\n          });\n        });\n        _this.easing = easing.linear;\n\n        if (Object.prototype.hasOwnProperty.call(_this.props, 'easing')) {\n          if (Array.isArray(_this.props.easing)) {\n            _this.easing = src(_this.props.easing[0], _this.props.easing[1], _this.props.easing[2], _this.props.easing[3]);\n          } else {\n            _this.easing = easing[_this.props.easing];\n          }\n        }\n\n        return _this;\n      }\n\n      return ContextAwareClipIncident;\n    }(_Leaf);\n\n    return {\n      F: ContextAwareClipIncident,\n      d: [{\n        kind: \"get\",\n        key: \"originalContext\",\n        value: function originalContext() {\n          return this.contexts[this.originalContextKey];\n        }\n      }, {\n        kind: \"get\",\n        key: \"duration\",\n        value: function duration() {\n          return this._duration;\n        }\n      }, {\n        kind: \"method\",\n        key: \"onProgress\",\n        value: function onProgress(fraction, milliseconds, contextId) {\n          var forceReset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n          var eased_MI_fraction = this.easing(fraction) || 0;\n          var eased_MI_millisecond = eased_MI_fraction * this.duration; // console.log(fraction, eased_MI_fraction, milliseconds, eased_MI_millisecond);\n\n          this.contexts[contextId].onProgress(eased_MI_fraction, eased_MI_millisecond, forceReset);\n        }\n      }, {\n        kind: \"method\",\n        key: \"addContext\",\n        value: function addContext(contextData) {\n          var forceGetContext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n          // if it's the first context to be added then it's the original\n          if (Object.keys(this.contexts).length === 0) {\n            this.originalContextKey = contextData.clipId;\n          } // instantiates the Clip so it renders\n\n\n          var ingredientsToPass = _objectSpread2({}, this.constructionIngredients, {\n            context: contextData.context,\n            mcid: this.mcid,\n            Incident: ClipCopy,\n            DescriptiveIncident: this.DescriptiveIncident\n          }); // and puts it on the corresponding context key\n\n\n          this.contexts[contextData.clipId] = incidentFromIngredients(ingredientsToPass);\n\n          if (forceGetContext === true) {\n            this.contexts[contextData.clipId]._onGetContextOnce();\n          }\n        }\n      }, {\n        kind: \"method\",\n        key: \"handleAddContext\",\n        value: function handleAddContext(target, payload) {\n          this.addContext(payload, true);\n          return true;\n        }\n      }, {\n        kind: \"method\",\n        decorators: [getIncidentsByChannel],\n        key: \"getIncidentsByChannel\",\n        value: function getIncidentsByChannel() {} // massive editing methods that apply the request massively to all of the\n        // Incidents of all of the contexts\n\n      }, {\n        kind: \"method\",\n        key: \"gotContext\",\n        value: function gotContext() {\n          for (var context in this.contexts) {\n            this.contexts[context].gotContext();\n          }\n        }\n      }, {\n        kind: \"method\",\n        key: \"_onGetContextOnce\",\n        value: function _onGetContextOnce() {\n          for (var context in this.contexts) {\n            this.contexts[context]._onGetContextOnce();\n          }\n        }\n      }, {\n        kind: \"method\",\n        key: \"lastWish\",\n        value: function lastWish() {\n          for (var context in this.contexts) {\n            this.contexts[context].lastWish();\n          }\n        }\n      }, {\n        kind: \"method\",\n        key: \"onGetContext\",\n        value: function onGetContext() {\n          for (var context in this.contexts) {\n            this.contexts[context].onGetContext();\n          }\n        }\n      }]\n    };\n  }, Leaf);\n\n  var ContextAwareIncident = _decorate(null, function (_initialize, _Leaf) {\n    var ContextAwareIncident =\n    /*#__PURE__*/\n    function (_Leaf2) {\n      _inherits(ContextAwareIncident, _Leaf2);\n\n      function ContextAwareIncident(constructionIngredients, contextData, mcid, attribute) {\n        var _this;\n\n        _classCallCheck(this, ContextAwareIncident);\n\n        _this = _possibleConstructorReturn(this, _getPrototypeOf(ContextAwareIncident).call(this, _objectSpread2({}, constructionIngredients.props, {\n          id: attribute !== null ? \"\".concat(constructionIngredients.incidentId, \"_\").concat(mcid, \"_\").concat(attribute) : \"\".concat(constructionIngredients.incidentId, \"_\").concat(mcid)\n        }))); // a property to hold all of the contexts\n\n        _initialize(_assertThisInitialized(_this));\n\n        _this.contexts = {};\n        _this.constructionIngredients = constructionIngredients;\n        _this.mcid = mcid;\n        _this.attribute = attribute; // this._duration = constructionIngredients.props.duration;\n\n        _this.mc_plugin_npm_name = constructionIngredients.plugin_npm_name;\n        _this.plugin_channel_class = constructionIngredients.Channel;\n        _this.DescriptiveIncident = constructionIngredients.DescriptiveIncident;\n\n        _this.addContext(contextData);\n\n        if (attribute !== null) {\n          if (_typeof(_this.constructionIngredients.attrs.animatedAttrs[_this.attribute]) === 'object') {\n            _this.originalAnimatedAttributeValue = _objectSpread2({}, _this.constructionIngredients.attrs.animatedAttrs[_this.attribute]);\n          } else {\n            _this.originalAnimatedAttributeValue = _this.constructionIngredients.attrs.animatedAttrs[_this.attribute];\n          }\n        }\n\n        _this.easing = easing.linear;\n\n        if (Object.prototype.hasOwnProperty.call(_this.props, 'easing')) {\n          if (Array.isArray(_this.props.easing)) {\n            _this.easing = src(_this.props.easing[0], _this.props.easing[1], _this.props.easing[2], _this.props.easing[3]);\n          } else {\n            _this.easing = easing[_this.props.easing];\n          }\n        }\n\n        return _this;\n      }\n\n      return ContextAwareIncident;\n    }(_Leaf);\n\n    return {\n      F: ContextAwareIncident,\n      d: [{\n        kind: \"get\",\n        key: \"originalContext\",\n        value: function originalContext() {\n          return this.contexts[this.originalContextKey];\n        }\n      }, {\n        kind: \"get\",\n        key: \"duration\",\n        value: function duration() {\n          return _get(_getPrototypeOf(ContextAwareIncident.prototype), \"duration\", this);\n        }\n      }, {\n        kind: \"set\",\n        key: \"duration\",\n        value: function duration(milliseconds) {\n          _set(_getPrototypeOf(ContextAwareIncident.prototype), \"duration\", milliseconds, this, true);\n\n          for (var context in this.contexts) {\n            this.contexts[context].duration = milliseconds;\n          }\n        }\n      }, {\n        kind: \"method\",\n        key: \"addContext\",\n        value: function addContext(contextData) {\n          var forceGetContext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n          // if it's the first context to be added then it's the original\n          var isTheOriginalContext = false;\n\n          if (Object.keys(this.contexts).length === 0) {\n            this.originalContextKey = contextData.clipId;\n            this.originalClipContext = contextData.context;\n            isTheOriginalContext = true;\n          }\n\n          var ingredientsToPass = _objectSpread2({}, this.constructionIngredients, {\n            context: contextData.context,\n            mcid: this.mcid\n          });\n\n          var whatToAdd = incidentFromIngredients(ingredientsToPass);\n          this.contexts[contextData.clipId] = whatToAdd; // when we add a new context we must set the inital value of the newly added Incidents\n          // but only for Incidents with animatedAttrs\n\n          if (!isTheOriginalContext && this.attribute !== null) {\n            this.contexts[contextData.clipId].setInitialValue(this.getInitialValue());\n          }\n\n          if (forceGetContext === true) {\n            this.contexts[contextData.clipId]._onGetContextOnce();\n          }\n        }\n      }, {\n        kind: \"method\",\n        key: \"handleAddContext\",\n        value: function handleAddContext(target, payload) {\n          this.addContext(payload, true);\n          return true;\n        }\n      }, {\n        kind: \"method\",\n        decorators: [getIncidentsByChannel],\n        key: \"getIncidentsByChannel\",\n        value: function getIncidentsByChannel() {}\n      }, {\n        kind: \"method\",\n        key: \"onProgress\",\n        value: function onProgress(fraction, milliseconds, contextId) {\n          /* MonoIncidents are totally agnostic about delay, hiatus and repeats.\n              CAI is not that's exactly the point where these properties management occurs.\n              Having alredy set the duration of the ContextAwareIncident according to\n              all of these props, here the CAI decides on the progress that its MonoIncidents\n              are to on at the given millisecond and according to the given props.\n              */\n          // step 1: find the full delay-duration-hiatus duration of one repeat\n          var repeatDuration = this.delay + this.props.duration + this.hiatus; // step 2.a: find the running repeat and millisecond of this repeat\n\n          var millisecondWithinRepeat = milliseconds % repeatDuration; // step 2.b: decide between 0 and 1\n\n          if (milliseconds !== 0 && millisecondWithinRepeat === 0) {\n            millisecondWithinRepeat = this.delay + this.props.duration;\n          } // step 3: find the millisecond of the MonoIncident\n\n\n          var MI_millisecond = millisecondWithinRepeat - this.delay;\n\n          if (MI_millisecond < 0) {\n            MI_millisecond = 0;\n          } else if (MI_millisecond > this.props.duration) {\n            // if it has stepped into hiatus\n            MI_millisecond = this.props.duration;\n          }\n\n          var MI_fraction = MI_millisecond / this.props.duration;\n          var eased_MI_fraction = this.easing(MI_fraction);\n          var eased_MI_millisecond = eased_MI_fraction * this.props.duration;\n\n          if (contextId === undefined) {\n            for (var context in this.contexts) {\n              this.contexts[context].onProgress(eased_MI_fraction, eased_MI_millisecond);\n            }\n\n            return;\n          }\n\n          this.contexts[contextId].onProgress(eased_MI_fraction, eased_MI_millisecond);\n        }\n        /** METHODS THAT ACT AS \"PROXY\" TO ALL OF THE INCIDENTS BELONGING TO\n         * THE INCIDENTS COLLECTION OF THE CONTEXT AWARE INCIDENT\n         * */\n\n      }, {\n        kind: \"get\",\n        key: \"animatedAttributeValue\",\n        value: function animatedAttributeValue() {\n          return this.constructionIngredients.attrs.animatedAttrs[this.attribute];\n        }\n      }, {\n        kind: \"set\",\n        key: \"animatedAttributeValue\",\n        value: function animatedAttributeValue(value) {\n          this.constructionIngredients.attrs.animatedAttrs[this.attribute] = value;\n        } // massive editing methods that apply the request massively to all of the\n        // Incidents of all of the contexts\n\n      }, {\n        kind: \"method\",\n        key: \"gotContext\",\n        value: function gotContext() {\n          for (var context in this.contexts) {\n            this.contexts[context].gotContext();\n          }\n        }\n      }, {\n        kind: \"method\",\n        key: \"_onGetContextOnce\",\n        value: function _onGetContextOnce() {\n          for (var context in this.contexts) {\n            this.contexts[context]._onGetContextOnce();\n          }\n        }\n      }, {\n        kind: \"method\",\n        key: \"lastWish\",\n        value: function lastWish() {\n          for (var context in this.contexts) {\n            this.contexts[context].lastWish();\n          }\n        }\n      }, {\n        kind: \"method\",\n        key: \"onGetContext\",\n        value: function onGetContext() {\n          for (var context in this.contexts) {\n            this.contexts[context].onGetContext();\n          }\n        }\n      }, {\n        kind: \"method\",\n        key: \"getInitialValue\",\n        value: function getInitialValue() {\n          var attribute = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n          if (attribute === null) {\n            attribute = this.attribute;\n          }\n\n          return this.originalContext.getInitialValue();\n        }\n      }, {\n        kind: \"get\",\n        key: \"initialValue\",\n        value: function initialValue() {\n          return this.getInitialValue();\n        }\n      }, {\n        kind: \"get\",\n        key: \"scratchValue\",\n        value: function scratchValue() {\n          return this.originalContext.scratchValue;\n        }\n      }, {\n        kind: \"get\",\n        key: \"pureInitialValues\",\n        value: function pureInitialValues() {\n          return this.originalContext.pureInitialValues;\n        }\n      }, {\n        kind: \"method\",\n        key: \"setInitialValue\",\n        value: function setInitialValue() {\n          var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n          var store = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n          if (value === null) {\n            value = this.getScratchValue();\n          }\n\n          for (var context in this.contexts) {\n            this.contexts[context].setInitialValue(JSON.parse(JSON.stringify(value)), store);\n          }\n        }\n      }, {\n        kind: \"method\",\n        key: \"getScratchValue\",\n        value: function getScratchValue() {\n          var contextId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n          if (contextId === null) {\n            var contextsKeys = Object.keys(this.contexts);\n\n            if (Object.prototype.hasOwnProperty.call(this.originalClipContext, 'nonFragmentedContext')) {\n              var ingredientsToPass = _objectSpread2({}, this.constructionIngredients, {\n                context: this.originalClipContext.nonFragmentedContext,\n                mcid: this.mcid\n              });\n\n              var tempIncident = incidentFromIngredients(ingredientsToPass);\n              return tempIncident.getScratchValue();\n            }\n\n            if (contextsKeys.length === 1) {\n              return this.originalContext.getScratchValue();\n            } // prefer another (not the original) context to provide scratch values\n\n\n            return this.contexts[contextsKeys[1]].getScratchValue();\n          }\n\n          return this.contexts[contextId].getScratchValue();\n        }\n      }, {\n        kind: \"method\",\n        key: \"setCompoAttrKeyValue\",\n        value: function setCompoAttrKeyValue(key, value) {\n          for (var context in this.contexts) {\n            this.contexts[context].attrs.animatedAttrs[this.attribute][key] = value;\n            this.contexts[context].lastWish();\n            this.contexts[context].onGetContext();\n          }\n        }\n      }, {\n        kind: \"method\",\n        key: \"play\",\n        value: function play(fraction, ms, contextId) {\n          return this.contexts[contextId].play(ms);\n        }\n      }, {\n        kind: \"method\",\n        key: \"stop\",\n        value: function stop(contextId) {\n          this.contexts[contextId].stop();\n        }\n      }]\n    };\n  }, Leaf);\n\n  var AnimatedAttributesSplitter =\n  /*#__PURE__*/\n  function (_Group) {\n    _inherits(AnimatedAttributesSplitter, _Group);\n\n    function AnimatedAttributesSplitter(descriptiveIncident, contextData, mcid, selector) {\n      var _this;\n\n      _classCallCheck(this, AnimatedAttributesSplitter);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(AnimatedAttributesSplitter).call(this, {}, {\n        id: \"\".concat(descriptiveIncident.id, \"_\").concat(mcid)\n      }));\n      _this.mcid = mcid;\n      _this.selector = selector;\n\n      _this.setUp(descriptiveIncident, contextData);\n\n      return _this;\n    }\n\n    _createClass(AnimatedAttributesSplitter, [{\n      key: \"setUp\",\n      value: function setUp(descriptiveIncident, contextData) {\n        for (var attr in descriptiveIncident.attrs.animatedAttrs) {\n          var singleAnimatedAttrs = {};\n          singleAnimatedAttrs[attr] = descriptiveIncident.attrs.animatedAttrs[attr];\n\n          var attrsToPass = _objectSpread2({}, descriptiveIncident.attrs, {\n            animatedAttrs: singleAnimatedAttrs\n          });\n\n          var propsToPass = _objectSpread2({}, descriptiveIncident.props, {\n            selector: this.selector\n          });\n\n          var constructionIngredients = {\n            incidentId: descriptiveIncident.id,\n            attrs: attrsToPass,\n            props: propsToPass,\n            Incident: descriptiveIncident.constructor.Incident,\n            plugin_npm_name: descriptiveIncident.constructor.plugin_npm_name,\n            Channel: descriptiveIncident.constructor.Channel,\n            DescriptiveIncident: descriptiveIncident\n          };\n          var contextAwareIncident = new ContextAwareIncident(constructionIngredients, contextData, this.mcid, attr);\n          this.addChild(contextAwareIncident, 0);\n        }\n      }\n    }]);\n\n    return AnimatedAttributesSplitter;\n  }(Group);\n\n  var ElementSplitter =\n  /*#__PURE__*/\n  function (_Group) {\n    _inherits(ElementSplitter, _Group);\n\n    function ElementSplitter(descriptiveIncident, contextData) {\n      var _this;\n\n      _classCallCheck(this, ElementSplitter);\n\n      // we make sure the DOMAwareIncident takes the same id as the Descriptive Incident\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(ElementSplitter).call(this, {}, {\n        id: descriptiveIncident.id\n      })); // a property to hold all of the contexts\n\n      _this.contexts = {};\n      _this.contexts[contextData.clipId] = contextData.context;\n      _this.originalContextKey = contextData.clipId;\n      _this.instantiatedCopiesContexts = contextData.instantiatedCopiesContexts;\n\n      _this.setUp(descriptiveIncident, contextData);\n\n      return _this;\n    }\n\n    _createClass(ElementSplitter, [{\n      key: \"setUp\",\n      value: function setUp(descriptiveIncident, contextData) {\n        // the elements of the original context\n        var elements = this.originalContext.getElements(descriptiveIncident.selector()); // the elements for each of the copied contexts\n        // const copiesElements = {};\n        // for (let contextKey in this.instantiatedCopiesContexts) {\n        //     copiesElements[contextKey] = Array.from(this.instantiatedCopiesContexts[contextKey].rootElement.querySelectorAll(descriptiveIncident.props.selector));\n        // }\n\n        var totalElements = elements.length;\n        var element, mcid;\n\n        for (var i = 0; i < totalElements; i++) {\n          element = elements[i]; // set the mcid of the element on index i of the original context\n\n          mcid = this._getElementMCID(element); // set the same mcid for the elements of the same context in all of the instantiatedCopiesContexts\n\n          for (var contextKey in this.instantiatedCopiesContexts) {\n            // TODO perfrormance improvement via selecting once elements per context\n            this._setElementMCID(this.instantiatedCopiesContexts[contextKey], this.instantiatedCopiesContexts[contextKey].getElements(descriptiveIncident.selector())[i], mcid);\n          }\n\n          this._createElementIncident(element, descriptiveIncident, contextData, i, totalElements, mcid);\n        }\n      }\n    }, {\n      key: \"_getElementMCID\",\n      value: function _getElementMCID(element) {\n        var mcid = this.originalContext.getMCID(element);\n\n        if (!mcid) {\n          mcid = getAnId(true);\n          this.originalContext.setMCID(element, mcid);\n        }\n\n        return mcid;\n      }\n    }, {\n      key: \"_setElementMCID\",\n      value: function _setElementMCID(context, element, mcid) {\n        var existingMCID = context.getMCID(element);\n\n        if (!existingMCID) {\n          context.setMCID(element, mcid);\n        }\n      }\n    }, {\n      key: \"_createElementIncident\",\n      value: function _createElementIncident(element, descriptiveIncident, contextData, elementIndex, totalElements, mcid) {\n        /* elements splitter might handle either attribute Incidents (that have animatedAttrs) or Incidents\n            that do not have animatedAttrs such as MediaPlayback Incidents.\n            In the case of an attributed Incident we proceed by creating one AttributeSplitter for each\n            while on the case of an non-attribured Incident we go ahead and\n            */\n        if (Object.prototype.hasOwnProperty.call(descriptiveIncident.attrs, 'animatedAttrs')) {\n          var animatedAttributeSplitter = new AnimatedAttributesSplitter(descriptiveIncident, contextData, mcid, contextData.context.getElementSelectorByMCID(mcid));\n          this.addChild(animatedAttributeSplitter, 0);\n        } else if (Object.prototype.hasOwnProperty.call(descriptiveIncident.attrs, 'keyframes')) ; else {\n          var attrsToPass = descriptiveIncident.attrs;\n\n          var propsToPass = _objectSpread2({}, descriptiveIncident.props, {\n            selector: this.selector\n          });\n\n          var constructionIngredients = {\n            incidentId: descriptiveIncident.id,\n            attrs: attrsToPass,\n            props: propsToPass,\n            Incident: descriptiveIncident.constructor.Incident,\n            plugin_npm_name: descriptiveIncident.constructor.plugin_npm_name,\n            Channel: descriptiveIncident.constructor.Channel,\n            DescriptiveIncident: descriptiveIncident\n          };\n          var contextAwareIncident = new ContextAwareIncident(constructionIngredients, contextData, mcid, null);\n          this.addChild(contextAwareIncident, 0);\n        }\n      }\n    }, {\n      key: \"originalContext\",\n      get: function get() {\n        return this.contexts[this.originalContextKey];\n      }\n    }]);\n\n    return ElementSplitter;\n  }(Group);\n\n  /**\n   * This Class acts as the DOM Aware Incident for Clips. When constructed the Incident passed to\n   * it is a Clip with FragmentHTML context handler.\n   * On addition, edit or deletion of Incidents on the Fragmented Clip's tree, of the\n   * Descriptive Clip this ElementClipSplitter implements, all updates on lanes\n   * and everything that these clips need in order to run are made directly to the\n   * ContextAwareIncidents of the DescriptiveClip's real Clip.\n   */\n\n  var ElementClipSplitter =\n  /*#__PURE__*/\n  function (_DWI) {\n    _inherits(ElementClipSplitter, _DWI);\n\n    function ElementClipSplitter(descriptiveIncident, contextData) {\n      var _this;\n\n      _classCallCheck(this, ElementClipSplitter);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(ElementClipSplitter).call(this, descriptiveIncident, contextData));\n      _this.realClip = descriptiveIncident.realClip;\n      return _this;\n    }\n\n    _createClass(ElementClipSplitter, [{\n      key: \"_createElementIncident\",\n      value: function _createElementIncident(element, descriptiveIncident, contextData, elementIndex, totalElements, mcid) {\n        var constructionArguments = descriptiveIncident.realClip.exportConstructionArguments();\n        var constructionIngredients = {\n          incidentId: descriptiveIncident.id,\n          attrs: constructionArguments.attrs,\n          props: _objectSpread2({}, constructionArguments.props, {\n            selector: contextData.context.getElementSelectorByMCID(mcid),\n            runTimeInfo: descriptiveIncident.runTimeInfo\n          }),\n          Incident: descriptiveIncident.constructor.Incident,\n          plugin_npm_name: descriptiveIncident.constructor.plugin_npm_name,\n          Channel: ClipChannel,\n          DescriptiveIncident: descriptiveIncident\n        };\n        var contextAwareClipIncident = new ContextAwareClipIncident(constructionIngredients, contextData, mcid, descriptiveIncident);\n        this.addChild(contextAwareClipIncident, 0);\n      }\n    }, {\n      key: \"duration\",\n      get: function get() {\n        return _get(_getPrototypeOf(ElementClipSplitter.prototype), \"duration\", this);\n      }\n      /*\n        ElementClipSplitter split the DescriptiveClip to element ContextAwareIncidents\n        All of the element ContextAwareClipIncidents instantiated share the same\n        DescriptiveClip and thus the same realClip. So ElementClipSplitter are\n        the Node from where a realClip starts to get copies.\n        Resizing though means resizing the realClip. In order to avoid redunduncy we\n        manage the resize here and we don't pass further down to the ContextAwareClipIncidents\n        the resizing command.\n        */\n      ,\n      set: function set(milliseconds) {\n        this.realClip._resize(milliseconds / this.realClip.duration);\n\n        this._duration = milliseconds;\n      }\n    }]);\n\n    return ElementClipSplitter;\n  }(ElementSplitter);\n\n  /**\n   * Creates a real Incident (with all of its real tree) out of the Descriptive Incident.\n   * @param {object} descriptiveIncident - the Descriptive Incident that defines the Incident\n   * @param {contextData} - the context data (object containing id and actual context) to be used for real\n   *      Incidents init\n   * @param {boolean} audio - defaults to false. It defines whether the method is been used\n   *      by a real Clip or the Audio clip\n   * @returns {object} - the real Incident\n   * */\n\n  function incidentFromDescription(descriptiveIncident, contextData) {\n    var audio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    /*\n      RULES:\n      - Clips can only have selectors (and not hosts) as they participate on a Desc. Tree\n          and thus they are Clips As Incidents. The DescriptiveClips are treated a bit\n          different compared to the rest of the Incidents as they copy all of the\n          Description channels and lanes\n      - Descriptive Incidents can either have or not have selectors\n      - Descriptive Compos always have selectors\n       All Incidents of the tree, no matter their type have the static properties:\n      - Incident (which is the Incident class they need to initialise)\n      - plugin_npm_name (the plugin name they bolong to)\n      - Channel (the Channel class to handle the instance)\n      */\n\n    /* check for the descriptive incident and audio compatibility. If audio is true then we're\n          working on the audioClip and we need incidents that are at least \"on\" while if the audio==false\n          and we are working on the real tree then we reject the cases that the incident is audio \"only\"\n      */\n    if (audio === true && descriptiveIncident.audio === 'off' || audio === false && descriptiveIncident.audio === 'only') {\n      return null;\n    }\n\n    var incidentToReturn;\n\n    if (Object.prototype.hasOwnProperty.call(descriptiveIncident.props, 'selector')) {\n      if (audio === false && descriptiveIncident.props.selector.charAt(0) === '~' || audio === true && descriptiveIncident.props.selector.charAt(0) !== '~' && descriptiveIncident.constructor.isClip === false) {\n        return null;\n      }\n    }\n\n    if (descriptiveIncident.constructor.isClip === true) {\n      if (Object.prototype.hasOwnProperty.call(descriptiveIncident.props, 'selector') && audio === false) {\n        incidentToReturn = new ElementClipSplitter(descriptiveIncident, contextData);\n        incidentToReturn.plugin_channel_class = Channel;\n      } else {\n        if (audio === true) {\n          return descriptiveIncident.audioClip;\n        }\n\n        return descriptiveIncident.realClip;\n      }\n    } // else if (descriptiveIncident.constructor.Incident === Group) {\n    else if (descriptiveIncident.constructor.isGroup === true) {\n        incidentToReturn = incidentFromIngredients({\n          id: descriptiveIncident.id,\n          attrs: descriptiveIncident.attrs,\n          props: descriptiveIncident.props,\n          Incident: descriptiveIncident.constructor.Incident,\n          plugin_npm_name: descriptiveIncident.constructor.plugin_npm_name,\n          Channel: descriptiveIncident.constructor.Channel,\n          DescriptiveIncident: descriptiveIncident\n        });\n\n        for (var incId in descriptiveIncident.children) {\n          var childIncident = incidentFromDescription(descriptiveIncident.children[incId].leaf, contextData);\n\n          if (childIncident === null) {\n            continue;\n          }\n\n          incidentToReturn.addChild(childIncident, descriptiveIncident.children[incId].position);\n        }\n      } else {\n        // if it is an Incident that extends the Incident (not a Group) then\n        // we should anaylse it to its element/attribute Incidents starting from\n        // the elements, that's why we create an ElementSplitter. It is our\n        // starting point to which the Incident will be analysed to its\n        // element/attributes children.\n        incidentToReturn = new ElementSplitter(descriptiveIncident, contextData);\n      }\n\n    return incidentToReturn;\n  }\n\n  var selfContainedIncidentsNpmName = '@kissmybutton/self-contained-incidents';\n\n  var ExtendableClip =\n  /*#__PURE__*/\n  function (_Group) {\n    _inherits(ExtendableClip, _Group);\n\n    /**\n     * @param {object} props - an object that should contain all of the following keys:\n     * - html (the html template to render)\n     * - css (the css template of the isolated tree)\n     * - initParams (optional / the initialisation parameteres that will be passed both on the css and the html templates in order to render)\n     * - host (an Element object that will host the isolated tree)\n     * - containerParams (an object that holds parameters to affect the container of the isolated tree, e.g. width, height etc)\n     * - type (optional, defaults to \"iframe\") the type of the Clip. It can be one of the:\n     *  - iframe\n     *  - plain\n     */\n    function ExtendableClip(attrs, props) {\n      var _this;\n\n      _classCallCheck(this, ExtendableClip);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(ExtendableClip).call(this, attrs, props));\n      _this.attrs = attrs;\n      _this.props = props;\n      _this.isTheClip = true;\n      _this.blockingWaitings = {};\n      /**\n       * The cnannels attribute holds a list of all intantiated Channels of the Incidents belonging to the clip\n       * this attribute is only valuable when the Group becomes the Clip\n       * The format of the attribute is:\n       *  key-value pairs in the manner:\n       * <mc_plugin_npm_name>: Channel object\n       */\n\n      _this.instantiatedChannels = {};\n      _this.isHostedClip = true;\n      /**\n       * The instantiatedCopiesContexts is a key-value pairs colleciton holding the\n       * contexts of all instantiated ClipCopies\n       * */\n\n      _this.instantiatedCopiesContexts = {};\n\n      _this.onClipInitialise();\n\n      _this.runTimeInfo = _this.props.runTimeInfo;\n      _this.durationSubs = []; // the audioClip property defines wether the Clip is Audio or not. Defaults to false\n      // and should be overiten to true on Audio Clip\n\n      _this.audioClip = false;\n      _this.contextReady = true;\n      return _this;\n    }\n\n    _createClass(ExtendableClip, [{\n      key: \"onClipInitialise\",\n      value: function onClipInitialise() {// called when group gets initialised\n      }\n    }, {\n      key: \"contextLoading\",\n      value: function contextLoading() {\n        this.contextReady = false;\n      }\n    }, {\n      key: \"contextLoaded\",\n      value: function contextLoaded() {\n        this.contextReady = true;\n        this.unblock();\n      }\n    }, {\n      key: \"getElements\",\n      value: function getElements(selector) {\n        if (this.props.host !== null && this.props.host !== undefined) {\n          return this.context.getElements(selector);\n        }\n\n        var elements = [];\n\n        for (var contextKey in this.instantiatedCopiesContexts) {\n          var contextElements = this.instantiatedCopiesContexts[contextKey].getElements(selector);\n\n          for (var i = 0; i < contextElements.length; i++) {\n            elements.push(contextElements[i]);\n          }\n        }\n\n        return elements;\n      }\n      /**\n       * This method is been called when a new ClipCopy enters the real tree successfully.\n       * @param {object} contextData - keys: clipId, context\n       * */\n\n    }, {\n      key: \"addContext\",\n      value: function addContext(contextData) {\n        this.instantiatedCopiesContexts[contextData.clipId] = contextData.context;\n        contextData.instantiatedCopiesContexts = this.instantiatedCopiesContexts;\n        var res = this.putMessageOnPipe('addContext', contextData, {}, {\n          selfExecute: false,\n          direction: _DIRECTIONS._DOWN\n        }); // if the added context is the first one to enter the realClip we must\n        // recalculate the scratch values of all of our first Incidents on our instantiatedChannels\n\n        if (Object.keys(this.instantiatedCopiesContexts).length === 1) {\n          // if it is the first one to be added\n          for (var key in this.instantiatedChannels) {\n            this.instantiatedChannels[key].recalcScratchValues(contextData.clipId);\n          } // also we store this non fragmented context on our context so it can be\n          // used on Incidents addition for calculating scratch values\n\n\n          this.context.nonFragmentedContext = contextData.context;\n        }\n\n        return res;\n      }\n      /*\n        ExtendableClip (as its name implies) is a Class that should be extended by\n        any specific kind of Clip, such as Fragmented or SCGroup. This method must\n        be overitten by the new Classes. This definition here is just for reference / help\n        purposes\n        */\n\n    }, {\n      key: \"exportConstructionArguments\",\n      value: function exportConstructionArguments() {\n        return {\n          attrs: this.attrs,\n          props: this.props\n        };\n      }\n      /**\n       * completely resizes the Clip without any checks\n       */\n\n    }, {\n      key: \"_resize\",\n      value: function _resize(durationFraction) {\n        for (var key in this.instantiatedChannels) {\n          this.instantiatedChannels[key]._resize(durationFraction);\n        }\n\n        this.setNewDuration(this.duration * durationFraction);\n\n        for (var i = 0; i < this.durationSubs.length; i++) {\n          this.durationSubs[i](this.duration);\n        }\n      }\n      /** *******************************************************\n        Editing commands input methods\n        ******************************************************** */\n\n      /**\n       * This command comes form the Clip's parent Descriptor class. The payload\n       * is identical to the payload that comes to the Description class:\n       * {\n       *  incident: the Descriptive Incident to be added\n       *  millisecond: the millisecond to add it\n       *  parentGroupId: the id of the Group to which we want to the Incident to\n       * }\n       */\n\n    }, {\n      key: \"addIncident\",\n      value: function addIncident(payload) {\n        var _this2 = this;\n\n        var candidates = this.putMessageOnPipe('addIncident', {\n          incident: payload.incident,\n          millisecond: payload.millisecond,\n          parentGroupId: payload.parentGroupId,\n          incidentFromDescription: incidentFromDescription,\n          contextData: {\n            clipId: this.id,\n            context: this.context,\n            instantiatedCopiesContexts: this.instantiatedCopiesContexts\n          },\n          audio: this.audioClip\n        }, payload.parentGroupId, {\n          selfExecute: true,\n          direction: _DIRECTIONS._DOWN\n        }); // concatenate candidates\n        // console.log(candidates);\n\n        var totalIncidentsByPlugin = {};\n\n        for (var i = 0; i < candidates.length; i++) {\n          var incidentsByPlugin = candidates[i].response.getIncidentsByChannel(candidates[i].positionDelta + payload.millisecond);\n\n          for (var pluginName in incidentsByPlugin) {\n            var _totalIncidentsByPlug;\n\n            if (!Object.prototype.hasOwnProperty.call(totalIncidentsByPlugin, pluginName)) {\n              totalIncidentsByPlugin[pluginName] = [];\n            }\n\n            (_totalIncidentsByPlug = totalIncidentsByPlugin[pluginName]).push.apply(_totalIncidentsByPlug, _toConsumableArray(incidentsByPlugin[pluginName]));\n          }\n        } // console.log(totalIncidentsByPlugin);\n\n\n        var res = this.checkAddition(totalIncidentsByPlugin);\n\n        if (res.result === true) {\n          var successCallback = function successCallback() {\n            res.execute(); // up to that point the only context Incident that has been initialised on the\n            // ContextAwareIncidents of the candidates is the original context of the\n            // ExtendableClip.\n\n            for (var _i = 0; _i < candidates.length; _i++) {\n              candidates[_i].responder.addChild(candidates[_i].response, payload.millisecond); // recalculate duration the groups that we added\n              // the incidents to along with their parents\n\n\n              candidates[_i].responder.putMessageOnPipe('recalcDuration', {}, 'Groups', {\n                selfExecute: true,\n                direction: _DIRECTIONS._UP\n              }); // we also need to add every existing (copied) context to the ContextAwareIncidents\n              // created on the candidates process\n\n\n              for (var contextKey in _this2.instantiatedCopiesContexts) {\n                candidates[_i].responder.putMessageOnPipe('addContext', {\n                  clipId: contextKey,\n                  context: _this2.instantiatedCopiesContexts[contextKey]\n                }, 'ContextAwareIncidents', {\n                  selfExecute: false,\n                  direction: _DIRECTIONS._DOWN\n                });\n              }\n            }\n          };\n\n          return {\n            result: true,\n            execute: successCallback\n          };\n        }\n\n        return res;\n      } // *******************************************************\n      // INCIDENTS MANAGEMENT METHODS\n      // POLYMORPHISM APPLIED. IF THE GROUP HAS NO PARENT IT ACTS AS A SCENE. IF THE GROUP HAS PARENT IT ACTS AS\n      // A \"TRANSPARENT GROUP\"\n\n      /**\n         * The method returns either:\n            {\n                result:true,\n                execute: // an array of functions that when executed it will add the Incidents on the Channels\n            }\n            or\n            {\n                result: false,\n                errors\n            }\n        */\n\n    }, {\n      key: \"checkAddition\",\n      value: function checkAddition(incidentsById) {\n        var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'all-or-nothing';\n        // prepare the return payload\n        var toReturnResult = true;\n        var toReturnErrors = [];\n        var toReturnExecutables = []; // for each key of the incidentsById object perform the check\n\n        for (var key in incidentsById) {\n          // if the clip had no channel instantiated for the specific key (plugin id) yet create it\n          if (!Object.prototype.hasOwnProperty.call(this.instantiatedChannels, key)) {\n            // intstantiate the channel of the plugin by using the reference to the class definition stored on\n            // the very first incident of the array\n            // console.log(incidentsById[key][0].incident.plugin_channel_class);\n            this.instantiatedChannels[key] = new incidentsById[key][0].incident.plugin_channel_class({\n              runTimeInfo: this.runTimeInfo,\n              context: this.context,\n              subscribe: this.props.subscribe // all channels can subscribe to state or current millisecond changes\n\n            });\n          } // perform the check\n\n\n          var pluginResult = this.instantiatedChannels[key].addIncidents(incidentsById[key], type);\n          toReturnResult = toReturnResult && pluginResult.result;\n\n          if (pluginResult.result === false) {\n            toReturnErrors = toReturnErrors.concat(pluginResult.errors);\n          } else {\n            toReturnExecutables.push(pluginResult.execute);\n          }\n        } // enf of iteration on the incidentsById keys\n\n\n        var toReturnExecute = function toReturnExecuteFunct() {\n          for (var i = 0; i < toReturnExecutables.length; i++) {\n            toReturnExecutables[i]();\n          }\n        };\n\n        var additionResult = {\n          result: toReturnResult,\n          errors: toReturnErrors,\n          execute: toReturnExecute\n        };\n        return additionResult;\n      }\n      /**\n       * This command comes form the Clip's parent Descriptor class. The payload\n       * is identical to the payload that comes to the Description class:\n       * {\n       *  incident: the Descriptive Incident to be repositioned\n       *  millisecond: the new millisecond to put it\n       *  parentGroupId: the id of the\n       * }\n       */\n\n    }, {\n      key: \"moveIncident\",\n      value: function moveIncident(payload) {\n        var candidates = this.putMessageOnPipe('moveIncident', {\n          incidentId: payload.id,\n          millisecond: payload.millisecond,\n          parentGroupId: payload.parentGroupId,\n          contextData: {\n            clipId: this.id,\n            context: this.context\n          },\n          audio: this.audioClip\n        }, payload.parentGroupId, {\n          selfExecute: true,\n          direction: _DIRECTIONS._DOWN\n        });\n        var totalIncidentsByPlugin = {};\n\n        for (var i = 0; i < candidates.length; i++) {\n          var incidentsByPlugin = candidates[i].response.getIncidentsByChannel(candidates[i].positionDelta + payload.millisecond);\n\n          for (var pluginName in incidentsByPlugin) {\n            var _totalIncidentsByPlug2;\n\n            if (!Object.prototype.hasOwnProperty.call(totalIncidentsByPlugin, pluginName)) {\n              totalIncidentsByPlugin[pluginName] = [];\n            }\n\n            (_totalIncidentsByPlug2 = totalIncidentsByPlugin[pluginName]).push.apply(_totalIncidentsByPlug2, _toConsumableArray(incidentsByPlugin[pluginName]));\n          }\n        }\n\n        var res = this.checkMove(totalIncidentsByPlugin, payload.positionDelta);\n\n        if (res.result === true) {\n          var successCallback = function successCallback() {\n            res.execute();\n\n            for (var _i2 = 0; _i2 < candidates.length; _i2++) {\n              candidates[_i2].responder.editPosition(candidates[_i2].response.id, payload.millisecond); // recalculate duration the groups that we added\n              // the incidents to along with their parents\n\n\n              candidates[_i2].responder.putMessageOnPipe('recalcDuration', {}, 'Groups', {\n                selfExecute: true,\n                direction: _DIRECTIONS._UP\n              });\n            }\n          };\n\n          return {\n            result: true,\n            execute: successCallback\n          };\n        }\n\n        return res;\n      }\n      /**\n         * The checkEdit method serves exactly what its name implies. To check if the edit of an Incident (edit of Incident's position given in milliseconds delta)\n         * is valid and accepted, according to the rules defined on the channels.\n         * The method boobles up until it reaches the Clip.\n         * @param {object} incident - the incident to edit\n         * @param {int} millisecondsDelta - the milliseconds delta of the Incident's start time\n         The method should return either:\n            {\n                result:true,\n                execute: // an array of functions that when executed it will edit the Incidents on the Channels\n            }\n            or\n            {\n                result: false,\n                errors\n            }\n        */\n\n    }, {\n      key: \"checkMove\",\n      value: function checkMove(incidentsById, millisecondsDelta) {\n        // prepare the return payload\n        var toReturnResult = true;\n        var toReturnErrors = [];\n        var toReturnExecutables = []; // for each key of the incidentsById object perform the check\n\n        for (var key in incidentsById) {\n          // perform the check\n          var pluginResult = this.instantiatedChannels[key].editIncidents(incidentsById[key], millisecondsDelta);\n          toReturnResult = toReturnResult && pluginResult.result;\n\n          if (pluginResult.result === false) {\n            toReturnErrors = toReturnErrors.concat(pluginResult.errors);\n          } else {\n            toReturnExecutables.push(pluginResult.execute);\n          }\n        } // enf of iteration on the incidentsById keys\n\n\n        var toReturnExecute = function toReturnExecuteFunct() {\n          for (var i = 0; i < toReturnExecutables.length; i++) {\n            toReturnExecutables[i]();\n          }\n        };\n\n        var editResult = {\n          result: toReturnResult,\n          errors: toReturnErrors,\n          execute: toReturnExecute\n        };\n        return editResult;\n      }\n    }, {\n      key: \"removeIncident\",\n      value: function removeIncident(payload) {\n        var candidates = this.putMessageOnPipe('removeIncident', {\n          incidentId: payload.id,\n          parentGroupId: payload.parentGroupId,\n          contextData: {\n            clipId: this.id,\n            context: this.context\n          },\n          audio: this.audioClip\n        }, payload.parentGroupId, {\n          selfExecute: true,\n          direction: _DIRECTIONS._DOWN\n        });\n        var totalIncidentsByPlugin = {};\n\n        for (var i = 0; i < candidates.length; i++) {\n          var incidentsByPlugin = candidates[i].response.getIncidentsByChannel();\n\n          for (var pluginName in incidentsByPlugin) {\n            var _totalIncidentsByPlug3;\n\n            if (!Object.prototype.hasOwnProperty.call(totalIncidentsByPlugin, pluginName)) {\n              totalIncidentsByPlugin[pluginName] = [];\n            }\n\n            (_totalIncidentsByPlug3 = totalIncidentsByPlugin[pluginName]).push.apply(_totalIncidentsByPlug3, _toConsumableArray(incidentsByPlugin[pluginName]));\n          }\n        }\n\n        var res = this.checkDelete(totalIncidentsByPlugin);\n\n        if (res.result === true) {\n          var successCallback = function successCallback() {\n            res.execute();\n\n            for (var _i3 = 0; _i3 < candidates.length; _i3++) {\n              candidates[_i3].responder.removeChild(candidates[_i3].response.id); // recalculate duration the groups that we added\n              // the incidents to along with their parents\n\n\n              candidates[_i3].responder.putMessageOnPipe('recalcDuration', {}, 'Groups', {\n                selfExecute: true,\n                direction: _DIRECTIONS._UP\n              });\n            }\n          };\n\n          return {\n            result: true,\n            execute: successCallback\n          };\n        }\n\n        return res;\n      }\n      /**\n         * The checkDelete method serves exactly what its name implies. To check if the deletion of an Incident\n         * is valid and accepted, according to the rules defined on the channels.\n         * The method boobles up until it reaches the Clip.\n         * @param {object} incident - the incident to edit\n          The result might be either:\n            {\n                result:true,\n                execute: // an array of functions that when executed it will remove the Incident on the Channels\n            }\n            or\n            {\n                result: false,\n                errors\n            }\n        */\n\n    }, {\n      key: \"checkDelete\",\n      value: function checkDelete(incidentsById) {\n        // prepare the return payload\n        var toReturnResult = true;\n        var toReturnErrors = [];\n        var toReturnExecutables = []; // for each key of the incidentsById object perform the check\n\n        for (var key in incidentsById) {\n          // perform the check\n          var pluginResult = this.instantiatedChannels[key].removeIncidents(incidentsById[key]);\n          toReturnResult = toReturnResult && pluginResult.result;\n\n          if (pluginResult.result === false) {\n            toReturnErrors = toReturnErrors.concat(pluginResult.errors);\n          } else {\n            toReturnExecutables.push(pluginResult.execute);\n          }\n        } // enf of iteration on the incidentsById keys\n\n\n        var toReturnExecute = function toReturnExecuteFunct() {\n          for (var i = 0; i < toReturnExecutables.length; i++) {\n            toReturnExecutables[i]();\n          }\n        };\n\n        var removeResult = {\n          result: toReturnResult,\n          errors: toReturnErrors,\n          execute: toReturnExecute\n        };\n        return removeResult;\n      }\n      /**\n       * This command is invoked by the Clip's parent Descriptor class. The payload\n       * is identical to the payload that comes to the Description class:\n       * {\n       *  id: the id of the Incident to resize\n       *  newSize: the milliseconds of the new duration\n       *  fraction: the division of the new duration to the current\n       * }\n       */\n\n    }, {\n      key: \"resizeIncident\",\n      value: function resizeIncident(payload) {\n        var candidates = this.putMessageOnPipe('resize', {\n          incidentId: payload.id,\n          newSize: payload.newSize,\n          fraction: payload.fraction,\n          contextData: {\n            clipId: this.id,\n            context: this.context\n          },\n          audio: this.audioClip\n        }, payload.id, {\n          selfExecute: false,\n          direction: _DIRECTIONS._DOWN\n        });\n        var totalIncidentsByPlugin = {};\n\n        for (var i = 0; i < candidates.length; i++) {\n          var incidentsByPlugin = candidates[i].response.getIncidentsByChannel(candidates[i].positionDelta);\n\n          for (var pluginName in incidentsByPlugin) {\n            var _totalIncidentsByPlug4;\n\n            if (!Object.prototype.hasOwnProperty.call(totalIncidentsByPlugin, pluginName)) {\n              totalIncidentsByPlugin[pluginName] = [];\n            }\n\n            (_totalIncidentsByPlug4 = totalIncidentsByPlugin[pluginName]).push.apply(_totalIncidentsByPlug4, _toConsumableArray(incidentsByPlugin[pluginName]));\n          }\n        }\n\n        var positionDelta = 0;\n\n        if (candidates.length > 0) {\n          positionDelta = candidates[0].positionDelta;\n        }\n\n        var res = this.checkResize(payload.fraction, totalIncidentsByPlugin, positionDelta);\n\n        if (res.result === true) {\n          var successCallback = function successCallback() {\n            res.execute();\n\n            for (var _i4 = 0; _i4 < candidates.length; _i4++) {\n              candidates[_i4].responder.setNewDuration(payload.newSize);\n            }\n          };\n\n          return {\n            result: true,\n            execute: successCallback\n          };\n        }\n\n        return res;\n      }\n      /**\n       * checks if a duration edit is feasible and doesn't cause conflicts\n       * @param {int} duration - the new duration\n       * */\n\n    }, {\n      key: \"checkResize\",\n      value: function checkResize(durationFraction, incidentsById) {\n        var adjustMillisecond = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n        // prepare the return payload\n        var toReturnResult = true;\n        var toReturnErrors = [];\n        var toReturnExecutables = []; // for each key of the incidentsById object perform the check\n\n        for (var key in incidentsById) {\n          // perform the check\n          var adjustedIncidents = helper.systoleDiastoleProjections(incidentsById[key], durationFraction, adjustMillisecond);\n          var pluginResult = this.instantiatedChannels[key].checkResizedIncidents(adjustedIncidents);\n          toReturnResult = toReturnResult && pluginResult.result;\n\n          if (pluginResult.result === false) {\n            toReturnErrors = toReturnErrors.concat(pluginResult.errors);\n          } else {\n            toReturnExecutables.push(pluginResult.execute);\n          }\n        } // enf of iteration on the incidentsById keys\n\n\n        var toReturnExecute = function toReturnExecuteFunct() {\n          for (var i = 0; i < toReturnExecutables.length; i++) {\n            toReturnExecutables[i]();\n          }\n        };\n\n        var editResult = {\n          result: toReturnResult,\n          errors: toReturnErrors,\n          execute: toReturnExecute\n        };\n        return editResult;\n      }\n    }, {\n      key: \"getIncidentsByChannel\",\n\n      /**\n       * Returns an object with keys the keys of all the plugins Incidents of which appear in the\n       * tree of the Group. All Incidents are projected to the Group's timeline.\n       * The array includes the Group's projection too\n       */\n      value: function getIncidentsByChannel() {\n        var adjustMillisecond = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        var incidentsByPlugin = {};\n        incidentsByPlugin[selfContainedIncidentsNpmName] = [{\n          millisecond: adjustMillisecond,\n          incident: this,\n          id: this.id\n        }];\n        return incidentsByPlugin;\n      }\n    }, {\n      key: \"setVolume\",\n      value: function setVolume(newVal) {\n        this.volume = parseFloat(newVal); // this.putMessageOnPipe(pipeMessages._GAIN_CHANGE, { gain: newVal }, false, \"down\");\n      }\n      /**\n       * Eventhough Clips have their own context, still they might belong to another Clip's\n       * tree (CASI). In such a case this method gives the oportunity to set things up\n       * and do operations related with their parent's context (such as subscribing to audio effect nodes)\n       * */\n      // eslint-disable-next-line no-unused-vars\n\n    }, {\n      key: \"_onGetContextOnce\",\n      value: function _onGetContextOnce(parentClipContext) {} // special recalcDuration handling so any potential clip copies update their trees\n      // eslint-disable-next-line no-unused-vars\n\n    }, {\n      key: \"handleRecalcDuration\",\n      value: function handleRecalcDuration(target, payload) {\n        if (this._calculateDuration()) {\n          for (var i = 0; i < this.durationSubs.length; i++) {\n            this.durationSubs[i](this.duration);\n          }\n        }\n\n        return true;\n      }\n      /**\n       * Method called on progress of the timed incident.\n       * @param {float} fraction - a number from 0 to 1 representing the fraction of duration covered\n       * @param {int} milliseconds - the number of milliseconds passed from start of the incident\n       * @param {string} contextId - defaults to the id of the realClip itself. Don't forget that a realClip\n       *      might belong to a selector Clip (so it's a Fragmented Clip), with many \"real\" ClipCopies. All ClipCopies hold\n       *      a reference to this Clip via their \"realClip\" property. Whenever any\n       *      of these ClipCopies progresses (via the onProgress method) calls\n       *      the \"onProgress\" of the realClip, passing their id so the ContextAwareIncidents\n       *      that will also progress via the Channels know which specific Incident to progress.\n       *      That's the result of keeping just one real tree, belonging always to the realClip\n       *      (either Fragmented or Hosted) ending to ContextAwareIncident leafs that\n       *      are the ones to hold the ClipCopies instances.\n       * @param {boolean} forceReset - set to true in cases we want full flash of the state\n       */\n\n    }, {\n      key: \"onProgress\",\n      value: function onProgress(fraction, milliseconds, contextId) {\n        var forceReset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n        if (this.contextReady === false) {\n          this.setBlock();\n          return;\n        }\n\n        if (!contextId) {\n          contextId = this.id;\n        }\n\n        for (var key in this.instantiatedChannels) {\n          var channel = this.instantiatedChannels[key];\n          channel.moveTo(this.runTimeInfo.currentMillisecond, milliseconds, contextId, forceReset);\n        }\n\n        this.onAfterProgress(fraction, milliseconds);\n      } // eslint-disable-next-line no-unused-vars\n\n    }, {\n      key: \"onAfterProgress\",\n      value: function onAfterProgress(fraction, milliseconds) {}\n    }, {\n      key: \"flash\",\n      value: function flash() {\n        for (var key in this.instantiatedChannels) {\n          var channel = this.instantiatedChannels[key];\n          channel.moveTo(0, this.runTimeInfo.currentMillisecond, this.id, true);\n        }\n      } // duration changes pub/sub\n\n    }, {\n      key: \"subscribeToDurationChange\",\n      value: function subscribeToDurationChange(method) {\n        this.durationSubs.push(method);\n      }\n      /** ***************************************************** */\n\n      /** ****** BLOCKING WAITINGS SET / REMOVE ************** */\n      // eslint-disable-next-line no-unused-vars\n\n    }, {\n      key: \"handleSetBlockingWaiting\",\n      value: function handleSetBlockingWaiting(target, payload) {} // eslint-disable-next-line no-unused-vars\n\n    }, {\n      key: \"handleRemoveBlockingWaiting\",\n      value: function handleRemoveBlockingWaiting(target, payload) {}\n    }, {\n      key: \"context\",\n      get: function get() {\n        return this.ownContext;\n      }\n    }]);\n\n    return ExtendableClip;\n  }(Group);\n\n  var AudioNode =\n  /*#__PURE__*/\n  function () {\n    function AudioNode() {\n      _classCallCheck(this, AudioNode);\n\n      // audio context initialisation\n      this.output = audioContext.createGain();\n      this.gainNode = audioContext.createGain();\n\n      if (audioContext.createStereoPanner) {\n        this.pannerNode = audioContext.createStereoPanner(); // if it is supported by the browser\n      } // this.highpassNode = audioContext.createBiquadFilter();\n      // this.lowpassNode = audioContext.createBiquadFilter();\n      // this.lowpassNode.connect(this.highpassNode);\n      // this.highpassNode.connect(this.pannerNode);\n\n\n      if (audioContext.createStereoPanner) {\n        this.pannerNode.connect(this.gainNode);\n        this.gainNode.connect(this.output);\n        this.input = this.pannerNode;\n      } else {\n        this.gainNode.connect(this.output);\n        this.input = this.gainNode;\n      }\n    }\n\n    _createClass(AudioNode, [{\n      key: \"connect\",\n      value: function connect(master) {\n        this.output.connect(master);\n      }\n    }, {\n      key: \"disconnect\",\n      value: function disconnect() {\n        // eslint-disable-line no-unused-vars\n        this.output.disconnect();\n      }\n    }]);\n\n    return AudioNode;\n  }();\n\n  function _base64ToArrayBuffer(base64) {\n    var binary_string = window.atob(base64);\n    var len = binary_string.length;\n    var bytes = new Uint8Array(len);\n\n    for (var i = 0; i < len; i++) {\n      bytes[i] = binary_string.charCodeAt(i);\n    }\n\n    return bytes.buffer;\n  }\n\n  var datamcidRegex = /\\[data(-mcid=\"+\\w+\")+\\]/g;\n\n  var PubSub =\n  /*#__PURE__*/\n  function () {\n    function PubSub() {\n      _classCallCheck(this, PubSub);\n\n      this.subscribers = [];\n    }\n\n    _createClass(PubSub, [{\n      key: \"sub\",\n      value: function sub(id, method) {\n        this.subscribers.push(method);\n      }\n    }, {\n      key: \"pub\",\n      value: function pub(argument) {\n        for (var i = 0; i < this.subscribers.length; i++) {\n          this.subscribers[i](argument);\n        }\n      }\n    }]);\n\n    return PubSub;\n  }();\n  /**\n   * Specs:\n   * AudioContext Handler keeps all the audio sources.\n   * The audio sources are passed in the following format:\n   * - src (the source of the sound)\n   * - base64 (boolean, defaults to false. If the sound is base64 it's been treated\n   *      in a different way)\n   * - id (must be unique)\n   * - classes (an array of belonging classes)\n   *\n   * The SoundContextHanlder creates a media element of the following format:\n   * media: {\n   *  src\n   *  id\n   *  classes\n   *  base64\n   *  buffer\n   *  nodes: {\n   *      stereo\n   *      highpass\n   *      lowpass\n   *      gain\n   *      audioNode\n   *  }\n   * }\n   *\n   * Finally the SoundContextHandler has its own nodes (the master) which look like this:\n   * master: {\n   *      stereo\n   *      highpass\n   *      lowpass\n   *      gain\n   * }\n   * */\n\n\n  var AudioContextHandler =\n  /*#__PURE__*/\n  function () {\n    function AudioContextHandler() {\n      var _this = this;\n\n      var audioSources = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var masterNode = arguments.length > 1 ? arguments[1] : undefined;\n\n      _classCallCheck(this, AudioContextHandler);\n\n      // variables to be used for checking context rediness\n      this.totalSources = audioSources.length; // initialisation of the final audio resources colleciton\n\n      this.audioSources = {};\n      this.elementsByMCID = {}; // iterate on audioSource to create the audioSources collection\n\n      var _loop = function _loop(i) {\n        var audioSource = audioSources[i];\n        var audioResource = {\n          mcid: audioSource.mcid || getAnId(),\n          id: audioSource.id,\n          src: audioSource.src,\n          classes: audioSource.classes || [],\n          base64: audioSource.base64 || false,\n          pubSub: new PubSub(),\n          soundLoaded: false,\n          startValues: audioSource.startValues || {}\n        };\n        _this.audioSources[audioResource.id] = audioResource;\n        _this.elementsByMCID[audioResource.mcid] = audioResource;\n\n        if (audioSource.base64 === true) {\n          audioContext.decodeAudioData(_base64ToArrayBuffer(audioSource.src), function (buffer) {\n            _this._setBuffer(audioResource, buffer, masterNode);\n          });\n        } else {\n          var request = new XMLHttpRequest();\n          request.open('GET', audioResource.src, true);\n          request.responseType = 'arraybuffer'; // Decode asynchronously\n\n          _this.soundLoaded = false;\n\n          request.onload = function () {\n            audioContext.decodeAudioData(request.response, function (buffer) {\n              _this._setBuffer(audioResource, buffer, masterNode);\n            }, _this.onError);\n          };\n\n          request.send();\n        }\n      };\n\n      for (var i = 0; i < audioSources.length; i++) {\n        _loop(i);\n      }\n\n      this.context = {\n        document: document,\n        window: window,\n        rootElement: document.body,\n        unmount: function unmount() {},\n        masterNode: masterNode,\n        audioContext: audioContext,\n        getElements: this.getElements.bind(this),\n        getMCID: this.getMCID.bind(this),\n        setMCID: this.setMCID.bind(this),\n        getElementSelectorByMCID: this.getElementSelectorByMCID.bind(this),\n        getElementByMCID: this.getElementByMCID.bind(this)\n      };\n    }\n\n    _createClass(AudioContextHandler, [{\n      key: \"_setBuffer\",\n      value: function _setBuffer(audioResource, buffer, masterNode) {\n        audioResource.soundLoaded = true;\n        audioResource.buffer = buffer;\n        audioResource.effectsAudioNode = new AudioNode();\n        audioResource.effectsAudioNode.connect(masterNode.input);\n        audioResource.pubSub.pub();\n      }\n    }, {\n      key: \"getElementByMCID\",\n      value: function getElementByMCID(mcid) {\n        if (Object.prototype.hasOwnProperty.call(this.elementsByMCID, mcid)) {\n          return this.elementsByMCID[mcid];\n        }\n\n        return null;\n      }\n    }, {\n      key: \"getElements\",\n      value: function getElements(selector) {\n        if (selector.charAt(0) === '~') {\n          selector = selector.substr(1);\n\n          if (selector.charAt(0) === '#') {\n            if (Object.prototype.hasOwnProperty.call(this.audioSources, selector.substr(1))) {\n              return [this.audioSources[selector.substr(1)]];\n            }\n\n            return [];\n          }\n\n          if (selector.charAt(0) === '.') {\n            var className = selector.substr(1);\n            var toReturn = [];\n\n            for (var source in this.audioSources) {\n              if (source.classes.indexOf(className) >= 0) {\n                toReturn.push(source);\n              }\n            }\n\n            return toReturn;\n          }\n        } else if (datamcidRegex.exec(selector)) {\n          var mcid = selector.split('\"')[1];\n          return this.elementsByMCID[mcid];\n        } else {\n          return [];\n        }\n      }\n    }, {\n      key: \"getMCID\",\n      value: function getMCID(element) {\n        return element.mcid;\n      }\n    }, {\n      key: \"setMCID\",\n      value: function setMCID(element, mcid) {\n        element.mcid = mcid;\n      }\n    }, {\n      key: \"getElementSelectorByMCID\",\n      value: function getElementSelectorByMCID(mcid) {\n        return \"[data-mcid=\\\"\".concat(mcid, \"\\\"]\");\n      }\n    }]);\n\n    return AudioContextHandler;\n  }();\n\n  var AudioClip =\n  /*#__PURE__*/\n  function (_ExtendableClip) {\n    _inherits(AudioClip, _ExtendableClip);\n\n    function AudioClip(attrs, props) {\n      var _this;\n\n      _classCallCheck(this, AudioClip);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(AudioClip).call(this, attrs, props));\n      _this.audioNode = new AudioNode();\n\n      _this.audioNode.connect(audioContext.destination);\n\n      var contextHanlder = new AudioContextHandler(_this.props.audioSources, _this.audioNode);\n      _this.ownContext = _objectSpread2({}, contextHanlder.context, {\n        isHostedClip: true\n      });\n      _this.audioClip = true;\n      return _this;\n    }\n\n    _createClass(AudioClip, [{\n      key: \"onProgress\",\n      value: function onProgress(fraction, ms, contextId) {\n        var forceReset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n        _get(_getPrototypeOf(AudioClip.prototype), \"onProgress\", this).call(this, fraction, ms, this.id, forceReset);\n      }\n    }, {\n      key: \"_onGetContextOnce\",\n      value: function _onGetContextOnce(parentClipContext) {\n        /*\n            context.master {gain, pan, highpass, lowpass}\n            */\n        // as highpass is the first node of master in row\n        this.audioNode.disconnect();\n        this.parentClipContext = parentClipContext;\n        this.audioNode.connect(parentClipContext.masterNode.input);\n      }\n    }, {\n      key: \"lastWish\",\n      value: function lastWish() {\n        this.audioNode.output.disconnect();\n        this.audioNode.output.connect(audioContext.destination);\n      }\n    }, {\n      key: \"setVolume\",\n      value: function setVolume(vol) {\n        this.audioNode.output.gain.value = vol;\n      }\n    }]);\n\n    return AudioClip;\n  }(ExtendableClip);\n\n  /**\n   * Effect class takes on constructor:\n   * attrs:\n   *  - animatedAttrs: valid animated attributes are \"gain\", \"pan\"\n   *  -\n   * */\n\n  var Effect =\n  /*#__PURE__*/\n  function (_MonoIncident) {\n    _inherits(Effect, _MonoIncident);\n\n    function Effect() {\n      _classCallCheck(this, Effect);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(Effect).apply(this, arguments));\n    }\n\n    _createClass(Effect, [{\n      key: \"onProgress\",\n      value: function onProgress(fraction) {\n        var _this = this;\n\n        // eslint-disable-line no-unused-vars\n        if (this.element.soundLoaded === false) {\n          this.setBlock('loading sound');\n          this.element.pubSub.sub(this.id, function () {\n            _this.unblock();\n          });\n          return false;\n        }\n\n        if (this.attributeKey === 'gain') {\n          var gain = (this.targetValue - this.getInitialValue()) * fraction + this.getInitialValue(); // console.log(this.props.nodes.stereoPan.pan.value);\n\n          this.element.effectsAudioNode.gainNode.gain.value = gain;\n        } else if (this.attributeKey === 'pan') {\n          var pan = (this.targetValue - this.getInitialValue()) * fraction + this.getInitialValue(); // console.log(this.props.nodes.stereoPan.pan.value);\n\n          this.element.effectsAudioNode.pannerNode.pan.value = pan;\n        }\n      }\n    }, {\n      key: \"getScratchValue\",\n      value: function getScratchValue() {\n        if (this.attributeKey === 'pan') {\n          if (Object.prototype.hasOwnProperty.call(this.element.startValues, 'pan')) {\n            return this.element.startValues.pan;\n          }\n\n          return 0;\n        }\n\n        if (this.attributeKey === 'gain') {\n          if (Object.prototype.hasOwnProperty.call(this.element.startValues, 'gain')) {\n            return this.element.startValues.gain;\n          }\n\n          return 1;\n        }\n      }\n    }]);\n\n    return Effect;\n  }(MonoIncident);\n\n  var dataSeparator = '|||';\n\n  var AudioPlaybackChannel =\n  /*#__PURE__*/\n  function (_ClipsChannel) {\n    _inherits(AudioPlaybackChannel, _ClipsChannel);\n\n    function AudioPlaybackChannel(props) {\n      var _this;\n\n      _classCallCheck(this, AudioPlaybackChannel);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(AudioPlaybackChannel).call(this, props)); // keeps the list of the ids of MediaIncidents that are currently been played\n      // in the form `${id}|||$[contextId}`\n\n      _this.playingIncidentsIds = []; // when the Channel's Clip enters the transitional state the Channel ignores\n      // moveTos. When the transition ends though, no matter the currentMillisecond\n      // its Clip was it should recalc which sources to play as if we were going from\n      // 0 to the the target millisecond because of the different way the Playback operates\n      // (it has no onProgress). For this, it's very important to store the information\n      // that it entered the transitional state so on the next playing state moveTo\n      // to force as from ms 0.\n\n      _this.transitioned = false;\n      props.subscribe(getAnId(), _this._stateChange.bind(_assertThisInitialized(_this)), 0, 1, true);\n      return _this;\n    }\n\n    _createClass(AudioPlaybackChannel, [{\n      key: \"_stateChange\",\n      value: function _stateChange(ms, state) {\n        if (state === 'paused' || state === 'idle' || state === 'blocked') {\n          this._stopPlayingIncidents();\n\n          this.transitioned = true;\n        }\n      }\n    }, {\n      key: \"_stopPlayingIncidents\",\n      value: function _stopPlayingIncidents() {\n        for (var i = 0; i < this.playingIncidentsIds.length; i++) {\n          var incidentInfo = this.playingIncidentsIds[i].split(dataSeparator);\n\n          this._incidentById(incidentInfo[0]).stop(incidentInfo[1]);\n        }\n\n        this.playingIncidentsIds = [];\n      }\n      /**\n         @param {int} from - the millisecond to start from\n         @param {int} to - the millisecond to go to\n         @param {string} contextId - the context id to move\n         @param {boolean} forceReset - set to true when we want full flash\n         */\n\n    }, {\n      key: \"moveTo\",\n      value: function moveTo(from, to, contextId) {\n        var forceReset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n        if (this.runTimeInfo.state === 'transitional' || forceReset === true) {\n          this.transitioned = true;\n\n          this._stopPlayingIncidents();\n\n          for (var i = 0; i < this.incidents.length; i++) {\n            var laneItem = this.incidents[i];\n\n            var incident = this._incidentById(laneItem.id);\n\n            if (to < laneItem.millisecond) {\n              incident.onProgress(0, 0, contextId, true);\n            } else if (to > laneItem.millisecond + incident.duration) {\n              incident.onProgress(1, incident.duration, contextId, true);\n            } else {\n              incident.onProgress((to - laneItem.millisecond) / incident.duration, to - laneItem.millisecond, contextId, true);\n            }\n          }\n\n          return;\n        }\n\n        if (this.transitioned === true) {\n          from = 0;\n          this.transitioned = false;\n        }\n\n        var that = this;\n\n        var startingAnims = lodash_filter(this.incidents, function (laneItem) {\n          return laneItem.millisecond >= from && laneItem.millisecond < to && laneItem.millisecond + that._incidentById(laneItem.id).duration > to;\n        });\n\n        var finishingAnims = lodash_filter(this.incidents, function (laneItem) {\n          return that._incidentById(laneItem.id).duration + laneItem.millisecond > from && that._incidentById(laneItem.id).duration + laneItem.millisecond <= to;\n        });\n\n        for (var _i = 0; _i < startingAnims.length; _i++) {\n          var _laneItem = startingAnims[_i];\n\n          var MediaIncident = this._incidentById(_laneItem.id); // onProgress(fraction, milliseconds, contextId, forceReset = false) {\n\n\n          var overcameEnd = (to - _laneItem.millisecond) / MediaIncident.duration >= 1;\n          var fraction = overcameEnd ? 1 : (to - _laneItem.millisecond) / MediaIncident.duration;\n          var millisecond = overcameEnd ? MediaIncident.duration : to - _laneItem.millisecond;\n          var startAttempt = MediaIncident.play(fraction, millisecond, contextId);\n\n          if (startAttempt === true) {\n            this.playingIncidentsIds.push(\"\".concat(_laneItem.id).concat(dataSeparator).concat(contextId));\n          }\n        }\n\n        for (var _i2 = 0; _i2 < finishingAnims.length; _i2++) {\n          var _laneItem2 = finishingAnims[_i2];\n\n          var _MediaIncident = this._incidentById(_laneItem2.id);\n\n          _MediaIncident.stop(contextId);\n\n          var index = this.playingIncidentsIds.indexOf(\"\".concat(_laneItem2.id).concat(dataSeparator).concat(contextId));\n\n          if (index > -1) {\n            this.playingIncidentsIds.splice(index, 1);\n          }\n        }\n\n        this.runTimeInfo.currentMillisecond = to;\n      }\n    }]);\n\n    return AudioPlaybackChannel;\n  }(ClipChannel);\n\n  /*\n  dna:\n  - originalId\n  - context\n  */\n\n  var MediaPlay = _decorate(null, function (_initialize) {\n    var MediaPlay = function MediaPlay() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var dna = arguments.length > 2 ? arguments[2] : undefined;\n\n      _classCallCheck(this, MediaPlay);\n\n      _initialize(this);\n\n      // super(props);\n      this.attrs = attrs;\n      this.props = props;\n      this.dna = dna;\n      this.context = dna.context;\n      this.mcid = dna.mcid;\n      this.id = props.id || getAnId();\n      this.modelId = props.modelId; // this parameter is initialised to false. Once the onGetContext method gets invoked this parameter\n      // is set to true so we prevent multiple executions of the onGetContext method\n\n      this.gotContext = false;\n      /*\n          these are the default values that define channeling for the default Incidents. These values get ovewriden through\n          the loadPlugin method of MC with the values found on the main.js file of the plugin\n          */\n\n      this.plugin_channel_class = AudioPlaybackChannel;\n      this.mc_plugin_npm_name = 'motor-cortex-js-media-playback';\n\n      if (Object.prototype.hasOwnProperty.call(props, 'plugin_channel_class')) {\n        this.plugin_channel_class = props.plugin_channel_class;\n      }\n\n      if (Object.prototype.hasOwnProperty.call(props, 'mc_plugin_npm_name')) {\n        this.mc_plugin_npm_name = props.mc_plugin_npm_name;\n      }\n\n      this.hasIncidents = false;\n      /**\n       * @member {boolean} - if autoGenerated is set to true, it means that this Incident has been auto-generated by its parent on initialisation.\n       * This happens when plugins export Incidents that on initialisation they automatically create other incidents and automatically put them\n       * on specific points on their timeline.\n       */\n\n      this.autoGenerated = false;\n      this.onInitialise(attrs, props);\n    };\n\n    return {\n      F: MediaPlay,\n      d: [{\n        kind: \"get\",\n        key: \"selector\",\n        value: function selector() {\n          return this.props.selector;\n        }\n      }, {\n        kind: \"get\",\n        key: \"element\",\n        value: function element() {\n          return this.context.getElementByMCID(this.mcid);\n        }\n      }, {\n        kind: \"method\",\n        decorators: [getIncidentsByChannel],\n        key: \"getIncidentsByChannel\",\n        value: function getIncidentsByChannel() {}\n      }, {\n        kind: \"method\",\n        key: \"_onGetContextOnce\",\n        value: function _onGetContextOnce() {\n          // if the Incident belongs to a fragmented context there absolutely\n          // no reason to run the getContext method of it\n          try {\n            if (this.context.fragment === true) {\n              return;\n            }\n\n            if (!this.gotContext) {\n              this.onGetContext();\n              this.gotContext = true;\n            }\n          } catch (e) {\n            console.log(e); // eslint-disable-line no-console\n\n            console.log(this.mcid); // eslint-disable-line no-console\n            // console.log(this.context);\n          }\n        }\n      }, {\n        kind: \"method\",\n        key: \"onGetContext\",\n        value: function onGetContext() {\n          helper.info('Overwritte the \"onGetContext\" method with the code you want to get executed', 'info');\n        }\n      }, {\n        kind: \"method\",\n        key: \"lastWish\",\n        value: function lastWish() {}\n      }, {\n        kind: \"method\",\n        key: \"onInitialise\",\n        value: function onInitialise() {\n          helper.info('Overwritte the \"onInialise\" method with the code you want to get executed', 'info');\n        }\n        /**\n         * Method called on progress of the timed incident.\n         * @param {float} fraction - a number from 0 to 1 representing the fraction of duration covered\n         * @param {int} milliseconds - the number of milliseconds passed from start of the incident\n         */\n        // eslint-disable-next-line no-unused-vars\n\n      }, {\n        kind: \"method\",\n        key: \"onProgress\",\n        value: function onProgress(fraction, milliseconds) {}\n        /**\n         * starts the execution of the media from the specified millisecond\n         * */\n        // eslint-disable-next-line no-unused-vars\n\n      }, {\n        kind: \"method\",\n        key: \"play\",\n        value: function play(millisecond) {\n          return true;\n        }\n        /**\n         * stops the execution of the media\n         * */\n\n      }, {\n        kind: \"method\",\n        key: \"stop\",\n        value: function stop() {}\n      }, {\n        kind: \"method\",\n        decorators: [block],\n        key: \"setBlock\",\n        value: function setBlock() {}\n      }, {\n        kind: \"method\",\n        decorators: [unblock],\n        key: \"unblock\",\n        value: function unblock() {}\n      }]\n    };\n  });\n\n  /**\n   * expects on its props:\n   * - selector\n   * - duration\n   * - startFrom (optional)\n   * */\n\n  var AudioPlayback =\n  /*#__PURE__*/\n  function (_MediaPlayIncident) {\n    _inherits(AudioPlayback, _MediaPlayIncident);\n\n    function AudioPlayback() {\n      _classCallCheck(this, AudioPlayback);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(AudioPlayback).apply(this, arguments));\n    }\n\n    _createClass(AudioPlayback, [{\n      key: \"play\",\n      value: function play(millisecond) {\n        var _this = this;\n\n        if (this.element.soundLoaded === false) {\n          this.setBlock('loading sound');\n          this.element.pubSub.sub(this.id, function () {\n            _this.unblock();\n          });\n          return false;\n        }\n\n        var startFrom = 0;\n\n        if (Object.prototype.hasOwnProperty.call(this.props, 'startFrom')) {\n          startFrom = this.props.startFrom;\n        }\n\n        this.audioNode = audioContext.createBufferSource();\n        this.audioNode.buffer = this.element.buffer;\n        this.audioNode.connect(this.element.effectsAudioNode.input);\n        this.audioNode.start(0, (millisecond + startFrom) / 1000);\n        return true;\n      }\n    }, {\n      key: \"stop\",\n      value: function stop() {\n        this.audioNode.stop();\n      }\n    }]);\n\n    return AudioPlayback;\n  }(MediaPlay);\n\n  var npm_name = '@kissmybutton/motorcortex-soundsystem';\n  var incidents = [{\n    exportable: AudioPlayback,\n    name: 'AudioPlayback'\n  }, {\n    exportable: Effect,\n    name: 'AudioEffect'\n  }];\n  var Clip = AudioClip;\n  var audio = 'only';\n  var audioPluginMain = {\n    npm_name: npm_name,\n    incidents: incidents,\n    Clip: Clip,\n    audio: audio\n  };\n\n  var lodash_findindex = createCommonjsModule(function (module, exports) {\n  /**\n   * Lodash (Custom Build) <https://lodash.com/>\n   * Build: `lodash modularize include=\"filter,sortBy,findIndex,find,forEach,cloneDeep\" exports=\"npm\"`\n   * Copyright JS Foundation and other contributors <https://js.foundation/>\n   * Released under MIT license <https://lodash.com/license>\n   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n   */\n\n  /** Used as the size to enable large array optimizations. */\n  var LARGE_ARRAY_SIZE = 200;\n  /** Error message constants. */\n\n  var FUNC_ERROR_TEXT = 'Expected a function';\n  /** Used to stand-in for `undefined` hash values. */\n\n  var HASH_UNDEFINED = '__lodash_hash_undefined__';\n  /** Used as the maximum memoize cache size. */\n\n  var MAX_MEMOIZE_SIZE = 500;\n  /** Used to compose bitmasks for value comparisons. */\n\n  var COMPARE_PARTIAL_FLAG = 1,\n      COMPARE_UNORDERED_FLAG = 2;\n  /** Used as references for various `Number` constants. */\n\n  var INFINITY = 1 / 0,\n      MAX_SAFE_INTEGER = 9007199254740991,\n      MAX_INTEGER = 1.7976931348623157e+308,\n      NAN = 0 / 0;\n  /** `Object#toString` result references. */\n\n  var argsTag = '[object Arguments]',\n      arrayTag = '[object Array]',\n      asyncTag = '[object AsyncFunction]',\n      boolTag = '[object Boolean]',\n      dateTag = '[object Date]',\n      errorTag = '[object Error]',\n      funcTag = '[object Function]',\n      genTag = '[object GeneratorFunction]',\n      mapTag = '[object Map]',\n      numberTag = '[object Number]',\n      nullTag = '[object Null]',\n      objectTag = '[object Object]',\n      promiseTag = '[object Promise]',\n      proxyTag = '[object Proxy]',\n      regexpTag = '[object RegExp]',\n      setTag = '[object Set]',\n      stringTag = '[object String]',\n      symbolTag = '[object Symbol]',\n      undefinedTag = '[object Undefined]',\n      weakMapTag = '[object WeakMap]';\n  var arrayBufferTag = '[object ArrayBuffer]',\n      dataViewTag = '[object DataView]',\n      float32Tag = '[object Float32Array]',\n      float64Tag = '[object Float64Array]',\n      int8Tag = '[object Int8Array]',\n      int16Tag = '[object Int16Array]',\n      int32Tag = '[object Int32Array]',\n      uint8Tag = '[object Uint8Array]',\n      uint8ClampedTag = '[object Uint8ClampedArray]',\n      uint16Tag = '[object Uint16Array]',\n      uint32Tag = '[object Uint32Array]';\n  /** Used to match property names within property paths. */\n\n  var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n      reIsPlainProp = /^\\w*$/,\n      rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n  /**\n   * Used to match `RegExp`\n   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n   */\n\n  var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n  /** Used to match leading and trailing whitespace. */\n\n  var reTrim = /^\\s+|\\s+$/g;\n  /** Used to match backslashes in property paths. */\n\n  var reEscapeChar = /\\\\(\\\\)?/g;\n  /** Used to detect bad signed hexadecimal string values. */\n\n  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n  /** Used to detect binary string values. */\n\n  var reIsBinary = /^0b[01]+$/i;\n  /** Used to detect host constructors (Safari). */\n\n  var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n  /** Used to detect octal string values. */\n\n  var reIsOctal = /^0o[0-7]+$/i;\n  /** Used to detect unsigned integer values. */\n\n  var reIsUint = /^(?:0|[1-9]\\d*)$/;\n  /** Used to identify `toStringTag` values of typed arrays. */\n\n  var typedArrayTags = {};\n  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;\n  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;\n  /** Built-in method references without a dependency on `root`. */\n\n  var freeParseInt = parseInt;\n  /** Detect free variable `global` from Node.js. */\n\n  var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;\n  /** Detect free variable `self`. */\n\n  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n  /** Used as a reference to the global object. */\n\n  var root = freeGlobal || freeSelf || Function('return this')();\n  /** Detect free variable `exports`. */\n\n  var freeExports =  exports && !exports.nodeType && exports;\n  /** Detect free variable `module`. */\n\n  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;\n  /** Detect the popular CommonJS extension `module.exports`. */\n\n  var moduleExports = freeModule && freeModule.exports === freeExports;\n  /** Detect free variable `process` from Node.js. */\n\n  var freeProcess = moduleExports && freeGlobal.process;\n  /** Used to access faster Node.js helpers. */\n\n  var nodeUtil = function () {\n    try {\n      return freeProcess && freeProcess.binding && freeProcess.binding('util');\n    } catch (e) {}\n  }();\n  /* Node.js helper references. */\n\n\n  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n  /**\n   * A specialized version of `_.filter` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {Array} Returns the new filtered array.\n   */\n\n  function arrayFilter(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length,\n        resIndex = 0,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index];\n\n      if (predicate(value, index, array)) {\n        result[resIndex++] = value;\n      }\n    }\n\n    return result;\n  }\n  /**\n   * A specialized version of `_.map` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the new mapped array.\n   */\n\n\n  function arrayMap(array, iteratee) {\n    var index = -1,\n        length = array == null ? 0 : array.length,\n        result = Array(length);\n\n    while (++index < length) {\n      result[index] = iteratee(array[index], index, array);\n    }\n\n    return result;\n  }\n  /**\n   * Appends the elements of `values` to `array`.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {Array} values The values to append.\n   * @returns {Array} Returns `array`.\n   */\n\n\n  function arrayPush(array, values) {\n    var index = -1,\n        length = values.length,\n        offset = array.length;\n\n    while (++index < length) {\n      array[offset + index] = values[index];\n    }\n\n    return array;\n  }\n  /**\n   * A specialized version of `_.some` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if any element passes the predicate check,\n   *  else `false`.\n   */\n\n\n  function arraySome(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (predicate(array[index], index, array)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n   * The base implementation of `_.findIndex` and `_.findLastIndex` without\n   * support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {number} fromIndex The index to search from.\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n\n\n  function baseFindIndex(array, predicate, fromIndex, fromRight) {\n    var length = array.length,\n        index = fromIndex + (fromRight ? 1 : -1);\n\n    while (fromRight ? index-- : ++index < length) {\n      if (predicate(array[index], index, array)) {\n        return index;\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * The base implementation of `_.property` without support for deep paths.\n   *\n   * @private\n   * @param {string} key The key of the property to get.\n   * @returns {Function} Returns the new accessor function.\n   */\n\n\n  function baseProperty(key) {\n    return function (object) {\n      return object == null ? undefined : object[key];\n    };\n  }\n  /**\n   * The base implementation of `_.times` without support for iteratee shorthands\n   * or max array length checks.\n   *\n   * @private\n   * @param {number} n The number of times to invoke `iteratee`.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the array of results.\n   */\n\n\n  function baseTimes(n, iteratee) {\n    var index = -1,\n        result = Array(n);\n\n    while (++index < n) {\n      result[index] = iteratee(index);\n    }\n\n    return result;\n  }\n  /**\n   * The base implementation of `_.unary` without support for storing metadata.\n   *\n   * @private\n   * @param {Function} func The function to cap arguments for.\n   * @returns {Function} Returns the new capped function.\n   */\n\n\n  function baseUnary(func) {\n    return function (value) {\n      return func(value);\n    };\n  }\n  /**\n   * Checks if a `cache` value for `key` exists.\n   *\n   * @private\n   * @param {Object} cache The cache to query.\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n\n\n  function cacheHas(cache, key) {\n    return cache.has(key);\n  }\n  /**\n   * Gets the value at `key` of `object`.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {string} key The key of the property to get.\n   * @returns {*} Returns the property value.\n   */\n\n\n  function getValue(object, key) {\n    return object == null ? undefined : object[key];\n  }\n  /**\n   * Converts `map` to its key-value pairs.\n   *\n   * @private\n   * @param {Object} map The map to convert.\n   * @returns {Array} Returns the key-value pairs.\n   */\n\n\n  function mapToArray(map) {\n    var index = -1,\n        result = Array(map.size);\n    map.forEach(function (value, key) {\n      result[++index] = [key, value];\n    });\n    return result;\n  }\n  /**\n   * Creates a unary function that invokes `func` with its argument transformed.\n   *\n   * @private\n   * @param {Function} func The function to wrap.\n   * @param {Function} transform The argument transform.\n   * @returns {Function} Returns the new function.\n   */\n\n\n  function overArg(func, transform) {\n    return function (arg) {\n      return func(transform(arg));\n    };\n  }\n  /**\n   * Converts `set` to an array of its values.\n   *\n   * @private\n   * @param {Object} set The set to convert.\n   * @returns {Array} Returns the values.\n   */\n\n\n  function setToArray(set) {\n    var index = -1,\n        result = Array(set.size);\n    set.forEach(function (value) {\n      result[++index] = value;\n    });\n    return result;\n  }\n  /** Used for built-in method references. */\n\n\n  var arrayProto = Array.prototype,\n      funcProto = Function.prototype,\n      objectProto = Object.prototype;\n  /** Used to detect overreaching core-js shims. */\n\n  var coreJsData = root['__core-js_shared__'];\n  /** Used to resolve the decompiled source of functions. */\n\n  var funcToString = funcProto.toString;\n  /** Used to check objects for own properties. */\n\n  var hasOwnProperty = objectProto.hasOwnProperty;\n  /** Used to detect methods masquerading as native. */\n\n  var maskSrcKey = function () {\n    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n    return uid ? 'Symbol(src)_1.' + uid : '';\n  }();\n  /**\n   * Used to resolve the\n   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n   * of values.\n   */\n\n\n  var nativeObjectToString = objectProto.toString;\n  /** Used to detect if a method is native. */\n\n  var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&').replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$');\n  /** Built-in value references. */\n\n  var Buffer = moduleExports ? root.Buffer : undefined,\n      Symbol = root.Symbol,\n      Uint8Array = root.Uint8Array,\n      propertyIsEnumerable = objectProto.propertyIsEnumerable,\n      splice = arrayProto.splice,\n      symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n\n  var nativeGetSymbols = Object.getOwnPropertySymbols,\n      nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n      nativeKeys = overArg(Object.keys, Object),\n      nativeMax = Math.max;\n  /* Built-in method references that are verified to be native. */\n\n  var DataView = getNative(root, 'DataView'),\n      Map = getNative(root, 'Map'),\n      Promise = getNative(root, 'Promise'),\n      Set = getNative(root, 'Set'),\n      WeakMap = getNative(root, 'WeakMap'),\n      nativeCreate = getNative(Object, 'create');\n  /** Used to detect maps, sets, and weakmaps. */\n\n  var dataViewCtorString = toSource(DataView),\n      mapCtorString = toSource(Map),\n      promiseCtorString = toSource(Promise),\n      setCtorString = toSource(Set),\n      weakMapCtorString = toSource(WeakMap);\n  /** Used to convert symbols to primitives and strings. */\n\n  var symbolProto = Symbol ? Symbol.prototype : undefined,\n      symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n      symbolToString = symbolProto ? symbolProto.toString : undefined;\n  /**\n   * Creates a hash object.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n\n  function Hash(entries) {\n    var index = -1,\n        length = entries == null ? 0 : entries.length;\n    this.clear();\n\n    while (++index < length) {\n      var entry = entries[index];\n      this.set(entry[0], entry[1]);\n    }\n  }\n  /**\n   * Removes all key-value entries from the hash.\n   *\n   * @private\n   * @name clear\n   * @memberOf Hash\n   */\n\n\n  function hashClear() {\n    this.__data__ = nativeCreate ? nativeCreate(null) : {};\n    this.size = 0;\n  }\n  /**\n   * Removes `key` and its value from the hash.\n   *\n   * @private\n   * @name delete\n   * @memberOf Hash\n   * @param {Object} hash The hash to modify.\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n\n\n  function hashDelete(key) {\n    var result = this.has(key) && delete this.__data__[key];\n    this.size -= result ? 1 : 0;\n    return result;\n  }\n  /**\n   * Gets the hash value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf Hash\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n\n\n  function hashGet(key) {\n    var data = this.__data__;\n\n    if (nativeCreate) {\n      var result = data[key];\n      return result === HASH_UNDEFINED ? undefined : result;\n    }\n\n    return hasOwnProperty.call(data, key) ? data[key] : undefined;\n  }\n  /**\n   * Checks if a hash value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf Hash\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n\n\n  function hashHas(key) {\n    var data = this.__data__;\n    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n  }\n  /**\n   * Sets the hash `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf Hash\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the hash instance.\n   */\n\n\n  function hashSet(key, value) {\n    var data = this.__data__;\n    this.size += this.has(key) ? 0 : 1;\n    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;\n    return this;\n  } // Add methods to `Hash`.\n\n\n  Hash.prototype.clear = hashClear;\n  Hash.prototype['delete'] = hashDelete;\n  Hash.prototype.get = hashGet;\n  Hash.prototype.has = hashHas;\n  Hash.prototype.set = hashSet;\n  /**\n   * Creates an list cache object.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n\n  function ListCache(entries) {\n    var index = -1,\n        length = entries == null ? 0 : entries.length;\n    this.clear();\n\n    while (++index < length) {\n      var entry = entries[index];\n      this.set(entry[0], entry[1]);\n    }\n  }\n  /**\n   * Removes all key-value entries from the list cache.\n   *\n   * @private\n   * @name clear\n   * @memberOf ListCache\n   */\n\n\n  function listCacheClear() {\n    this.__data__ = [];\n    this.size = 0;\n  }\n  /**\n   * Removes `key` and its value from the list cache.\n   *\n   * @private\n   * @name delete\n   * @memberOf ListCache\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n\n\n  function listCacheDelete(key) {\n    var data = this.__data__,\n        index = assocIndexOf(data, key);\n\n    if (index < 0) {\n      return false;\n    }\n\n    var lastIndex = data.length - 1;\n\n    if (index == lastIndex) {\n      data.pop();\n    } else {\n      splice.call(data, index, 1);\n    }\n\n    --this.size;\n    return true;\n  }\n  /**\n   * Gets the list cache value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf ListCache\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n\n\n  function listCacheGet(key) {\n    var data = this.__data__,\n        index = assocIndexOf(data, key);\n    return index < 0 ? undefined : data[index][1];\n  }\n  /**\n   * Checks if a list cache value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf ListCache\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n\n\n  function listCacheHas(key) {\n    return assocIndexOf(this.__data__, key) > -1;\n  }\n  /**\n   * Sets the list cache `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf ListCache\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the list cache instance.\n   */\n\n\n  function listCacheSet(key, value) {\n    var data = this.__data__,\n        index = assocIndexOf(data, key);\n\n    if (index < 0) {\n      ++this.size;\n      data.push([key, value]);\n    } else {\n      data[index][1] = value;\n    }\n\n    return this;\n  } // Add methods to `ListCache`.\n\n\n  ListCache.prototype.clear = listCacheClear;\n  ListCache.prototype['delete'] = listCacheDelete;\n  ListCache.prototype.get = listCacheGet;\n  ListCache.prototype.has = listCacheHas;\n  ListCache.prototype.set = listCacheSet;\n  /**\n   * Creates a map cache object to store key-value pairs.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n\n  function MapCache(entries) {\n    var index = -1,\n        length = entries == null ? 0 : entries.length;\n    this.clear();\n\n    while (++index < length) {\n      var entry = entries[index];\n      this.set(entry[0], entry[1]);\n    }\n  }\n  /**\n   * Removes all key-value entries from the map.\n   *\n   * @private\n   * @name clear\n   * @memberOf MapCache\n   */\n\n\n  function mapCacheClear() {\n    this.size = 0;\n    this.__data__ = {\n      'hash': new Hash(),\n      'map': new (Map || ListCache)(),\n      'string': new Hash()\n    };\n  }\n  /**\n   * Removes `key` and its value from the map.\n   *\n   * @private\n   * @name delete\n   * @memberOf MapCache\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n\n\n  function mapCacheDelete(key) {\n    var result = getMapData(this, key)['delete'](key);\n    this.size -= result ? 1 : 0;\n    return result;\n  }\n  /**\n   * Gets the map value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf MapCache\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n\n\n  function mapCacheGet(key) {\n    return getMapData(this, key).get(key);\n  }\n  /**\n   * Checks if a map value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf MapCache\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n\n\n  function mapCacheHas(key) {\n    return getMapData(this, key).has(key);\n  }\n  /**\n   * Sets the map `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf MapCache\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the map cache instance.\n   */\n\n\n  function mapCacheSet(key, value) {\n    var data = getMapData(this, key),\n        size = data.size;\n    data.set(key, value);\n    this.size += data.size == size ? 0 : 1;\n    return this;\n  } // Add methods to `MapCache`.\n\n\n  MapCache.prototype.clear = mapCacheClear;\n  MapCache.prototype['delete'] = mapCacheDelete;\n  MapCache.prototype.get = mapCacheGet;\n  MapCache.prototype.has = mapCacheHas;\n  MapCache.prototype.set = mapCacheSet;\n  /**\n   *\n   * Creates an array cache object to store unique values.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [values] The values to cache.\n   */\n\n  function SetCache(values) {\n    var index = -1,\n        length = values == null ? 0 : values.length;\n    this.__data__ = new MapCache();\n\n    while (++index < length) {\n      this.add(values[index]);\n    }\n  }\n  /**\n   * Adds `value` to the array cache.\n   *\n   * @private\n   * @name add\n   * @memberOf SetCache\n   * @alias push\n   * @param {*} value The value to cache.\n   * @returns {Object} Returns the cache instance.\n   */\n\n\n  function setCacheAdd(value) {\n    this.__data__.set(value, HASH_UNDEFINED);\n\n    return this;\n  }\n  /**\n   * Checks if `value` is in the array cache.\n   *\n   * @private\n   * @name has\n   * @memberOf SetCache\n   * @param {*} value The value to search for.\n   * @returns {number} Returns `true` if `value` is found, else `false`.\n   */\n\n\n  function setCacheHas(value) {\n    return this.__data__.has(value);\n  } // Add methods to `SetCache`.\n\n\n  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\n  SetCache.prototype.has = setCacheHas;\n  /**\n   * Creates a stack cache object to store key-value pairs.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n\n  function Stack(entries) {\n    var data = this.__data__ = new ListCache(entries);\n    this.size = data.size;\n  }\n  /**\n   * Removes all key-value entries from the stack.\n   *\n   * @private\n   * @name clear\n   * @memberOf Stack\n   */\n\n\n  function stackClear() {\n    this.__data__ = new ListCache();\n    this.size = 0;\n  }\n  /**\n   * Removes `key` and its value from the stack.\n   *\n   * @private\n   * @name delete\n   * @memberOf Stack\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n\n\n  function stackDelete(key) {\n    var data = this.__data__,\n        result = data['delete'](key);\n    this.size = data.size;\n    return result;\n  }\n  /**\n   * Gets the stack value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf Stack\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n\n\n  function stackGet(key) {\n    return this.__data__.get(key);\n  }\n  /**\n   * Checks if a stack value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf Stack\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n\n\n  function stackHas(key) {\n    return this.__data__.has(key);\n  }\n  /**\n   * Sets the stack `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf Stack\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the stack cache instance.\n   */\n\n\n  function stackSet(key, value) {\n    var data = this.__data__;\n\n    if (data instanceof ListCache) {\n      var pairs = data.__data__;\n\n      if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {\n        pairs.push([key, value]);\n        this.size = ++data.size;\n        return this;\n      }\n\n      data = this.__data__ = new MapCache(pairs);\n    }\n\n    data.set(key, value);\n    this.size = data.size;\n    return this;\n  } // Add methods to `Stack`.\n\n\n  Stack.prototype.clear = stackClear;\n  Stack.prototype['delete'] = stackDelete;\n  Stack.prototype.get = stackGet;\n  Stack.prototype.has = stackHas;\n  Stack.prototype.set = stackSet;\n  /**\n   * Creates an array of the enumerable property names of the array-like `value`.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @param {boolean} inherited Specify returning inherited property names.\n   * @returns {Array} Returns the array of property names.\n   */\n\n  function arrayLikeKeys(value, inherited) {\n    var isArr = isArray(value),\n        isArg = !isArr && isArguments(value),\n        isBuff = !isArr && !isArg && isBuffer(value),\n        isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n        skipIndexes = isArr || isArg || isBuff || isType,\n        result = skipIndexes ? baseTimes(value.length, String) : [],\n        length = result.length;\n\n    for (var key in value) {\n      if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.\n      key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.\n      isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.\n      isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.\n      isIndex(key, length)))) {\n        result.push(key);\n      }\n    }\n\n    return result;\n  }\n  /**\n   * Gets the index at which the `key` is found in `array` of key-value pairs.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} key The key to search for.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n\n\n  function assocIndexOf(array, key) {\n    var length = array.length;\n\n    while (length--) {\n      if (eq(array[length][0], key)) {\n        return length;\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * The base implementation of `_.get` without support for default values.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path of the property to get.\n   * @returns {*} Returns the resolved value.\n   */\n\n\n  function baseGet(object, path) {\n    path = castPath(path, object);\n    var index = 0,\n        length = path.length;\n\n    while (object != null && index < length) {\n      object = object[toKey(path[index++])];\n    }\n\n    return index && index == length ? object : undefined;\n  }\n  /**\n   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n   * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n   * symbols of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Function} keysFunc The function to get the keys of `object`.\n   * @param {Function} symbolsFunc The function to get the symbols of `object`.\n   * @returns {Array} Returns the array of property names and symbols.\n   */\n\n\n  function baseGetAllKeys(object, keysFunc, symbolsFunc) {\n    var result = keysFunc(object);\n    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n  }\n  /**\n   * The base implementation of `getTag` without fallbacks for buggy environments.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @returns {string} Returns the `toStringTag`.\n   */\n\n\n  function baseGetTag(value) {\n    if (value == null) {\n      return value === undefined ? undefinedTag : nullTag;\n    }\n\n    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);\n  }\n  /**\n   * The base implementation of `_.hasIn` without support for deep paths.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {Array|string} key The key to check.\n   * @returns {boolean} Returns `true` if `key` exists, else `false`.\n   */\n\n\n  function baseHasIn(object, key) {\n    return object != null && key in Object(object);\n  }\n  /**\n   * The base implementation of `_.isArguments`.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n   */\n\n\n  function baseIsArguments(value) {\n    return isObjectLike(value) && baseGetTag(value) == argsTag;\n  }\n  /**\n   * The base implementation of `_.isEqual` which supports partial comparisons\n   * and tracks traversed objects.\n   *\n   * @private\n   * @param {*} value The value to compare.\n   * @param {*} other The other value to compare.\n   * @param {boolean} bitmask The bitmask flags.\n   *  1 - Unordered comparison\n   *  2 - Partial comparison\n   * @param {Function} [customizer] The function to customize comparisons.\n   * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n   */\n\n\n  function baseIsEqual(value, other, bitmask, customizer, stack) {\n    if (value === other) {\n      return true;\n    }\n\n    if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {\n      return value !== value && other !== other;\n    }\n\n    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n  }\n  /**\n   * A specialized version of `baseIsEqual` for arrays and objects which performs\n   * deep comparisons and tracks traversed objects enabling objects with circular\n   * references to be compared.\n   *\n   * @private\n   * @param {Object} object The object to compare.\n   * @param {Object} other The other object to compare.\n   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n   * @param {Function} customizer The function to customize comparisons.\n   * @param {Function} equalFunc The function to determine equivalents of values.\n   * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n   */\n\n\n  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n    var objIsArr = isArray(object),\n        othIsArr = isArray(other),\n        objTag = objIsArr ? arrayTag : getTag(object),\n        othTag = othIsArr ? arrayTag : getTag(other);\n    objTag = objTag == argsTag ? objectTag : objTag;\n    othTag = othTag == argsTag ? objectTag : othTag;\n    var objIsObj = objTag == objectTag,\n        othIsObj = othTag == objectTag,\n        isSameTag = objTag == othTag;\n\n    if (isSameTag && isBuffer(object)) {\n      if (!isBuffer(other)) {\n        return false;\n      }\n\n      objIsArr = true;\n      objIsObj = false;\n    }\n\n    if (isSameTag && !objIsObj) {\n      stack || (stack = new Stack());\n      return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n    }\n\n    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n      var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n          othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n      if (objIsWrapped || othIsWrapped) {\n        var objUnwrapped = objIsWrapped ? object.value() : object,\n            othUnwrapped = othIsWrapped ? other.value() : other;\n        stack || (stack = new Stack());\n        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n      }\n    }\n\n    if (!isSameTag) {\n      return false;\n    }\n\n    stack || (stack = new Stack());\n    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n  }\n  /**\n   * The base implementation of `_.isMatch` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Object} object The object to inspect.\n   * @param {Object} source The object of property values to match.\n   * @param {Array} matchData The property names, values, and compare flags to match.\n   * @param {Function} [customizer] The function to customize comparisons.\n   * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n   */\n\n\n  function baseIsMatch(object, source, matchData, customizer) {\n    var index = matchData.length,\n        length = index,\n        noCustomizer = !customizer;\n\n    if (object == null) {\n      return !length;\n    }\n\n    object = Object(object);\n\n    while (index--) {\n      var data = matchData[index];\n\n      if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {\n        return false;\n      }\n    }\n\n    while (++index < length) {\n      data = matchData[index];\n      var key = data[0],\n          objValue = object[key],\n          srcValue = data[1];\n\n      if (noCustomizer && data[2]) {\n        if (objValue === undefined && !(key in object)) {\n          return false;\n        }\n      } else {\n        var stack = new Stack();\n\n        if (customizer) {\n          var result = customizer(objValue, srcValue, key, object, source, stack);\n        }\n\n        if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n  /**\n   * The base implementation of `_.isNative` without bad shim checks.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a native function,\n   *  else `false`.\n   */\n\n\n  function baseIsNative(value) {\n    if (!isObject(value) || isMasked(value)) {\n      return false;\n    }\n\n    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n    return pattern.test(toSource(value));\n  }\n  /**\n   * The base implementation of `_.isTypedArray` without Node.js optimizations.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n   */\n\n\n  function baseIsTypedArray(value) {\n    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n  }\n  /**\n   * The base implementation of `_.iteratee`.\n   *\n   * @private\n   * @param {*} [value=_.identity] The value to convert to an iteratee.\n   * @returns {Function} Returns the iteratee.\n   */\n\n\n  function baseIteratee(value) {\n    // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n    // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n    if (typeof value == 'function') {\n      return value;\n    }\n\n    if (value == null) {\n      return identity;\n    }\n\n    if (typeof value == 'object') {\n      return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);\n    }\n\n    return property(value);\n  }\n  /**\n   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names.\n   */\n\n\n  function baseKeys(object) {\n    if (!isPrototype(object)) {\n      return nativeKeys(object);\n    }\n\n    var result = [];\n\n    for (var key in Object(object)) {\n      if (hasOwnProperty.call(object, key) && key != 'constructor') {\n        result.push(key);\n      }\n    }\n\n    return result;\n  }\n  /**\n   * The base implementation of `_.matches` which doesn't clone `source`.\n   *\n   * @private\n   * @param {Object} source The object of property values to match.\n   * @returns {Function} Returns the new spec function.\n   */\n\n\n  function baseMatches(source) {\n    var matchData = getMatchData(source);\n\n    if (matchData.length == 1 && matchData[0][2]) {\n      return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n    }\n\n    return function (object) {\n      return object === source || baseIsMatch(object, source, matchData);\n    };\n  }\n  /**\n   * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n   *\n   * @private\n   * @param {string} path The path of the property to get.\n   * @param {*} srcValue The value to match.\n   * @returns {Function} Returns the new spec function.\n   */\n\n\n  function baseMatchesProperty(path, srcValue) {\n    if (isKey(path) && isStrictComparable(srcValue)) {\n      return matchesStrictComparable(toKey(path), srcValue);\n    }\n\n    return function (object) {\n      var objValue = get(object, path);\n      return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n    };\n  }\n  /**\n   * A specialized version of `baseProperty` which supports deep paths.\n   *\n   * @private\n   * @param {Array|string} path The path of the property to get.\n   * @returns {Function} Returns the new accessor function.\n   */\n\n\n  function basePropertyDeep(path) {\n    return function (object) {\n      return baseGet(object, path);\n    };\n  }\n  /**\n   * The base implementation of `_.toString` which doesn't convert nullish\n   * values to empty strings.\n   *\n   * @private\n   * @param {*} value The value to process.\n   * @returns {string} Returns the string.\n   */\n\n\n  function baseToString(value) {\n    // Exit early for strings to avoid a performance hit in some environments.\n    if (typeof value == 'string') {\n      return value;\n    }\n\n    if (isArray(value)) {\n      // Recursively convert values (susceptible to call stack limits).\n      return arrayMap(value, baseToString) + '';\n    }\n\n    if (isSymbol(value)) {\n      return symbolToString ? symbolToString.call(value) : '';\n    }\n\n    var result = value + '';\n    return result == '0' && 1 / value == -INFINITY ? '-0' : result;\n  }\n  /**\n   * Casts `value` to a path array if it's not one.\n   *\n   * @private\n   * @param {*} value The value to inspect.\n   * @param {Object} [object] The object to query keys on.\n   * @returns {Array} Returns the cast property path array.\n   */\n\n\n  function castPath(value, object) {\n    if (isArray(value)) {\n      return value;\n    }\n\n    return isKey(value, object) ? [value] : stringToPath(toString(value));\n  }\n  /**\n   * A specialized version of `baseIsEqualDeep` for arrays with support for\n   * partial deep comparisons.\n   *\n   * @private\n   * @param {Array} array The array to compare.\n   * @param {Array} other The other array to compare.\n   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n   * @param {Function} customizer The function to customize comparisons.\n   * @param {Function} equalFunc The function to determine equivalents of values.\n   * @param {Object} stack Tracks traversed `array` and `other` objects.\n   * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n   */\n\n\n  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n        arrLength = array.length,\n        othLength = other.length;\n\n    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n      return false;\n    } // Assume cyclic values are equal.\n\n\n    var stacked = stack.get(array);\n\n    if (stacked && stack.get(other)) {\n      return stacked == other;\n    }\n\n    var index = -1,\n        result = true,\n        seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;\n    stack.set(array, other);\n    stack.set(other, array); // Ignore non-index properties.\n\n    while (++index < arrLength) {\n      var arrValue = array[index],\n          othValue = other[index];\n\n      if (customizer) {\n        var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);\n      }\n\n      if (compared !== undefined) {\n        if (compared) {\n          continue;\n        }\n\n        result = false;\n        break;\n      } // Recursively compare arrays (susceptible to call stack limits).\n\n\n      if (seen) {\n        if (!arraySome(other, function (othValue, othIndex) {\n          if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n            return seen.push(othIndex);\n          }\n        })) {\n          result = false;\n          break;\n        }\n      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n        result = false;\n        break;\n      }\n    }\n\n    stack['delete'](array);\n    stack['delete'](other);\n    return result;\n  }\n  /**\n   * A specialized version of `baseIsEqualDeep` for comparing objects of\n   * the same `toStringTag`.\n   *\n   * **Note:** This function only supports comparing values with tags of\n   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n   *\n   * @private\n   * @param {Object} object The object to compare.\n   * @param {Object} other The other object to compare.\n   * @param {string} tag The `toStringTag` of the objects to compare.\n   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n   * @param {Function} customizer The function to customize comparisons.\n   * @param {Function} equalFunc The function to determine equivalents of values.\n   * @param {Object} stack Tracks traversed `object` and `other` objects.\n   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n   */\n\n\n  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n    switch (tag) {\n      case dataViewTag:\n        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {\n          return false;\n        }\n\n        object = object.buffer;\n        other = other.buffer;\n\n      case arrayBufferTag:\n        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n          return false;\n        }\n\n        return true;\n\n      case boolTag:\n      case dateTag:\n      case numberTag:\n        // Coerce booleans to `1` or `0` and dates to milliseconds.\n        // Invalid dates are coerced to `NaN`.\n        return eq(+object, +other);\n\n      case errorTag:\n        return object.name == other.name && object.message == other.message;\n\n      case regexpTag:\n      case stringTag:\n        // Coerce regexes to strings and treat strings, primitives and objects,\n        // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n        // for more details.\n        return object == other + '';\n\n      case mapTag:\n        var convert = mapToArray;\n\n      case setTag:\n        var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n        convert || (convert = setToArray);\n\n        if (object.size != other.size && !isPartial) {\n          return false;\n        } // Assume cyclic values are equal.\n\n\n        var stacked = stack.get(object);\n\n        if (stacked) {\n          return stacked == other;\n        }\n\n        bitmask |= COMPARE_UNORDERED_FLAG; // Recursively compare objects (susceptible to call stack limits).\n\n        stack.set(object, other);\n        var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n        stack['delete'](object);\n        return result;\n\n      case symbolTag:\n        if (symbolValueOf) {\n          return symbolValueOf.call(object) == symbolValueOf.call(other);\n        }\n\n    }\n\n    return false;\n  }\n  /**\n   * A specialized version of `baseIsEqualDeep` for objects with support for\n   * partial deep comparisons.\n   *\n   * @private\n   * @param {Object} object The object to compare.\n   * @param {Object} other The other object to compare.\n   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n   * @param {Function} customizer The function to customize comparisons.\n   * @param {Function} equalFunc The function to determine equivalents of values.\n   * @param {Object} stack Tracks traversed `object` and `other` objects.\n   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n   */\n\n\n  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n        objProps = getAllKeys(object),\n        objLength = objProps.length,\n        othProps = getAllKeys(other),\n        othLength = othProps.length;\n\n    if (objLength != othLength && !isPartial) {\n      return false;\n    }\n\n    var index = objLength;\n\n    while (index--) {\n      var key = objProps[index];\n\n      if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n        return false;\n      }\n    } // Assume cyclic values are equal.\n\n\n    var stacked = stack.get(object);\n\n    if (stacked && stack.get(other)) {\n      return stacked == other;\n    }\n\n    var result = true;\n    stack.set(object, other);\n    stack.set(other, object);\n    var skipCtor = isPartial;\n\n    while (++index < objLength) {\n      key = objProps[index];\n      var objValue = object[key],\n          othValue = other[key];\n\n      if (customizer) {\n        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);\n      } // Recursively compare objects (susceptible to call stack limits).\n\n\n      if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {\n        result = false;\n        break;\n      }\n\n      skipCtor || (skipCtor = key == 'constructor');\n    }\n\n    if (result && !skipCtor) {\n      var objCtor = object.constructor,\n          othCtor = other.constructor; // Non `Object` object instances with different constructors are not equal.\n\n      if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n        result = false;\n      }\n    }\n\n    stack['delete'](object);\n    stack['delete'](other);\n    return result;\n  }\n  /**\n   * Creates an array of own enumerable property names and symbols of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names and symbols.\n   */\n\n\n  function getAllKeys(object) {\n    return baseGetAllKeys(object, keys, getSymbols);\n  }\n  /**\n   * Gets the data for `map`.\n   *\n   * @private\n   * @param {Object} map The map to query.\n   * @param {string} key The reference key.\n   * @returns {*} Returns the map data.\n   */\n\n\n  function getMapData(map, key) {\n    var data = map.__data__;\n    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;\n  }\n  /**\n   * Gets the property names, values, and compare flags of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the match data of `object`.\n   */\n\n\n  function getMatchData(object) {\n    var result = keys(object),\n        length = result.length;\n\n    while (length--) {\n      var key = result[length],\n          value = object[key];\n      result[length] = [key, value, isStrictComparable(value)];\n    }\n\n    return result;\n  }\n  /**\n   * Gets the native function at `key` of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {string} key The key of the method to get.\n   * @returns {*} Returns the function if it's native, else `undefined`.\n   */\n\n\n  function getNative(object, key) {\n    var value = getValue(object, key);\n    return baseIsNative(value) ? value : undefined;\n  }\n  /**\n   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @returns {string} Returns the raw `toStringTag`.\n   */\n\n\n  function getRawTag(value) {\n    var isOwn = hasOwnProperty.call(value, symToStringTag),\n        tag = value[symToStringTag];\n\n    try {\n      value[symToStringTag] = undefined;\n      var unmasked = true;\n    } catch (e) {}\n\n    var result = nativeObjectToString.call(value);\n\n    if (unmasked) {\n      if (isOwn) {\n        value[symToStringTag] = tag;\n      } else {\n        delete value[symToStringTag];\n      }\n    }\n\n    return result;\n  }\n  /**\n   * Creates an array of the own enumerable symbols of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of symbols.\n   */\n\n\n  var getSymbols = !nativeGetSymbols ? stubArray : function (object) {\n    if (object == null) {\n      return [];\n    }\n\n    object = Object(object);\n    return arrayFilter(nativeGetSymbols(object), function (symbol) {\n      return propertyIsEnumerable.call(object, symbol);\n    });\n  };\n  /**\n   * Gets the `toStringTag` of `value`.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @returns {string} Returns the `toStringTag`.\n   */\n\n  var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\n\n  if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {\n    getTag = function (value) {\n      var result = baseGetTag(value),\n          Ctor = result == objectTag ? value.constructor : undefined,\n          ctorString = Ctor ? toSource(Ctor) : '';\n\n      if (ctorString) {\n        switch (ctorString) {\n          case dataViewCtorString:\n            return dataViewTag;\n\n          case mapCtorString:\n            return mapTag;\n\n          case promiseCtorString:\n            return promiseTag;\n\n          case setCtorString:\n            return setTag;\n\n          case weakMapCtorString:\n            return weakMapTag;\n        }\n      }\n\n      return result;\n    };\n  }\n  /**\n   * Checks if `path` exists on `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path to check.\n   * @param {Function} hasFunc The function to check properties.\n   * @returns {boolean} Returns `true` if `path` exists, else `false`.\n   */\n\n\n  function hasPath(object, path, hasFunc) {\n    path = castPath(path, object);\n    var index = -1,\n        length = path.length,\n        result = false;\n\n    while (++index < length) {\n      var key = toKey(path[index]);\n\n      if (!(result = object != null && hasFunc(object, key))) {\n        break;\n      }\n\n      object = object[key];\n    }\n\n    if (result || ++index != length) {\n      return result;\n    }\n\n    length = object == null ? 0 : object.length;\n    return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));\n  }\n  /**\n   * Checks if `value` is a valid array-like index.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n   */\n\n\n  function isIndex(value, length) {\n    var type = typeof value;\n    length = length == null ? MAX_SAFE_INTEGER : length;\n    return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;\n  }\n  /**\n   * Checks if `value` is a property name and not a property path.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @param {Object} [object] The object to query keys on.\n   * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n   */\n\n\n  function isKey(value, object) {\n    if (isArray(value)) {\n      return false;\n    }\n\n    var type = typeof value;\n\n    if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {\n      return true;\n    }\n\n    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);\n  }\n  /**\n   * Checks if `value` is suitable for use as unique object key.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n   */\n\n\n  function isKeyable(value) {\n    var type = typeof value;\n    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;\n  }\n  /**\n   * Checks if `func` has its source masked.\n   *\n   * @private\n   * @param {Function} func The function to check.\n   * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n   */\n\n\n  function isMasked(func) {\n    return !!maskSrcKey && maskSrcKey in func;\n  }\n  /**\n   * Checks if `value` is likely a prototype object.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n   */\n\n\n  function isPrototype(value) {\n    var Ctor = value && value.constructor,\n        proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;\n    return value === proto;\n  }\n  /**\n   * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` if suitable for strict\n   *  equality comparisons, else `false`.\n   */\n\n\n  function isStrictComparable(value) {\n    return value === value && !isObject(value);\n  }\n  /**\n   * A specialized version of `matchesProperty` for source values suitable\n   * for strict equality comparisons, i.e. `===`.\n   *\n   * @private\n   * @param {string} key The key of the property to get.\n   * @param {*} srcValue The value to match.\n   * @returns {Function} Returns the new spec function.\n   */\n\n\n  function matchesStrictComparable(key, srcValue) {\n    return function (object) {\n      if (object == null) {\n        return false;\n      }\n\n      return object[key] === srcValue && (srcValue !== undefined || key in Object(object));\n    };\n  }\n  /**\n   * A specialized version of `_.memoize` which clears the memoized function's\n   * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n   *\n   * @private\n   * @param {Function} func The function to have its output memoized.\n   * @returns {Function} Returns the new memoized function.\n   */\n\n\n  function memoizeCapped(func) {\n    var result = memoize(func, function (key) {\n      if (cache.size === MAX_MEMOIZE_SIZE) {\n        cache.clear();\n      }\n\n      return key;\n    });\n    var cache = result.cache;\n    return result;\n  }\n  /**\n   * Converts `value` to a string using `Object.prototype.toString`.\n   *\n   * @private\n   * @param {*} value The value to convert.\n   * @returns {string} Returns the converted string.\n   */\n\n\n  function objectToString(value) {\n    return nativeObjectToString.call(value);\n  }\n  /**\n   * Converts `string` to a property path array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the property path array.\n   */\n\n\n  var stringToPath = memoizeCapped(function (string) {\n    var result = [];\n\n    if (string.charCodeAt(0) === 46\n    /* . */\n    ) {\n        result.push('');\n      }\n\n    string.replace(rePropName, function (match, number, quote, subString) {\n      result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);\n    });\n    return result;\n  });\n  /**\n   * Converts `value` to a string key if it's not a string or symbol.\n   *\n   * @private\n   * @param {*} value The value to inspect.\n   * @returns {string|symbol} Returns the key.\n   */\n\n  function toKey(value) {\n    if (typeof value == 'string' || isSymbol(value)) {\n      return value;\n    }\n\n    var result = value + '';\n    return result == '0' && 1 / value == -INFINITY ? '-0' : result;\n  }\n  /**\n   * Converts `func` to its source code.\n   *\n   * @private\n   * @param {Function} func The function to convert.\n   * @returns {string} Returns the source code.\n   */\n\n\n  function toSource(func) {\n    if (func != null) {\n      try {\n        return funcToString.call(func);\n      } catch (e) {}\n\n      try {\n        return func + '';\n      } catch (e) {}\n    }\n\n    return '';\n  }\n  /**\n   * This method is like `_.find` except that it returns the index of the first\n   * element `predicate` returns truthy for instead of the element itself.\n   *\n   * @static\n   * @memberOf _\n   * @since 1.1.0\n   * @category Array\n   * @param {Array} array The array to inspect.\n   * @param {Function} [predicate=_.identity] The function invoked per iteration.\n   * @param {number} [fromIndex=0] The index to search from.\n   * @returns {number} Returns the index of the found element, else `-1`.\n   * @example\n   *\n   * var users = [\n   *   { 'user': 'barney',  'active': false },\n   *   { 'user': 'fred',    'active': false },\n   *   { 'user': 'pebbles', 'active': true }\n   * ];\n   *\n   * _.findIndex(users, function(o) { return o.user == 'barney'; });\n   * // => 0\n   *\n   * // The `_.matches` iteratee shorthand.\n   * _.findIndex(users, { 'user': 'fred', 'active': false });\n   * // => 1\n   *\n   * // The `_.matchesProperty` iteratee shorthand.\n   * _.findIndex(users, ['active', false]);\n   * // => 0\n   *\n   * // The `_.property` iteratee shorthand.\n   * _.findIndex(users, 'active');\n   * // => 2\n   */\n\n\n  function findIndex(array, predicate, fromIndex) {\n    var length = array == null ? 0 : array.length;\n\n    if (!length) {\n      return -1;\n    }\n\n    var index = fromIndex == null ? 0 : toInteger(fromIndex);\n\n    if (index < 0) {\n      index = nativeMax(length + index, 0);\n    }\n\n    return baseFindIndex(array, baseIteratee(predicate), index);\n  }\n  /**\n   * Creates a function that memoizes the result of `func`. If `resolver` is\n   * provided, it determines the cache key for storing the result based on the\n   * arguments provided to the memoized function. By default, the first argument\n   * provided to the memoized function is used as the map cache key. The `func`\n   * is invoked with the `this` binding of the memoized function.\n   *\n   * **Note:** The cache is exposed as the `cache` property on the memoized\n   * function. Its creation may be customized by replacing the `_.memoize.Cache`\n   * constructor with one whose instances implement the\n   * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n   * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Function\n   * @param {Function} func The function to have its output memoized.\n   * @param {Function} [resolver] The function to resolve the cache key.\n   * @returns {Function} Returns the new memoized function.\n   * @example\n   *\n   * var object = { 'a': 1, 'b': 2 };\n   * var other = { 'c': 3, 'd': 4 };\n   *\n   * var values = _.memoize(_.values);\n   * values(object);\n   * // => [1, 2]\n   *\n   * values(other);\n   * // => [3, 4]\n   *\n   * object.a = 2;\n   * values(object);\n   * // => [1, 2]\n   *\n   * // Modify the result cache.\n   * values.cache.set(object, ['a', 'b']);\n   * values(object);\n   * // => ['a', 'b']\n   *\n   * // Replace `_.memoize.Cache`.\n   * _.memoize.Cache = WeakMap;\n   */\n\n\n  function memoize(func, resolver) {\n    if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {\n      throw new TypeError(FUNC_ERROR_TEXT);\n    }\n\n    var memoized = function () {\n      var args = arguments,\n          key = resolver ? resolver.apply(this, args) : args[0],\n          cache = memoized.cache;\n\n      if (cache.has(key)) {\n        return cache.get(key);\n      }\n\n      var result = func.apply(this, args);\n      memoized.cache = cache.set(key, result) || cache;\n      return result;\n    };\n\n    memoized.cache = new (memoize.Cache || MapCache)();\n    return memoized;\n  } // Expose `MapCache`.\n\n\n  memoize.Cache = MapCache;\n  /**\n   * Performs a\n   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n   * comparison between two values to determine if they are equivalent.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to compare.\n   * @param {*} other The other value to compare.\n   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n   * @example\n   *\n   * var object = { 'a': 1 };\n   * var other = { 'a': 1 };\n   *\n   * _.eq(object, object);\n   * // => true\n   *\n   * _.eq(object, other);\n   * // => false\n   *\n   * _.eq('a', 'a');\n   * // => true\n   *\n   * _.eq('a', Object('a'));\n   * // => false\n   *\n   * _.eq(NaN, NaN);\n   * // => true\n   */\n\n  function eq(value, other) {\n    return value === other || value !== value && other !== other;\n  }\n  /**\n   * Checks if `value` is likely an `arguments` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n   *  else `false`.\n   * @example\n   *\n   * _.isArguments(function() { return arguments; }());\n   * // => true\n   *\n   * _.isArguments([1, 2, 3]);\n   * // => false\n   */\n\n\n  var isArguments = baseIsArguments(function () {\n    return arguments;\n  }()) ? baseIsArguments : function (value) {\n    return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');\n  };\n  /**\n   * Checks if `value` is classified as an `Array` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n   * @example\n   *\n   * _.isArray([1, 2, 3]);\n   * // => true\n   *\n   * _.isArray(document.body.children);\n   * // => false\n   *\n   * _.isArray('abc');\n   * // => false\n   *\n   * _.isArray(_.noop);\n   * // => false\n   */\n\n  var isArray = Array.isArray;\n  /**\n   * Checks if `value` is array-like. A value is considered array-like if it's\n   * not a function and has a `value.length` that's an integer greater than or\n   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n   * @example\n   *\n   * _.isArrayLike([1, 2, 3]);\n   * // => true\n   *\n   * _.isArrayLike(document.body.children);\n   * // => true\n   *\n   * _.isArrayLike('abc');\n   * // => true\n   *\n   * _.isArrayLike(_.noop);\n   * // => false\n   */\n\n  function isArrayLike(value) {\n    return value != null && isLength(value.length) && !isFunction(value);\n  }\n  /**\n   * Checks if `value` is a buffer.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.3.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n   * @example\n   *\n   * _.isBuffer(new Buffer(2));\n   * // => true\n   *\n   * _.isBuffer(new Uint8Array(2));\n   * // => false\n   */\n\n\n  var isBuffer = nativeIsBuffer || stubFalse;\n  /**\n   * Checks if `value` is classified as a `Function` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n   * @example\n   *\n   * _.isFunction(_);\n   * // => true\n   *\n   * _.isFunction(/abc/);\n   * // => false\n   */\n\n  function isFunction(value) {\n    if (!isObject(value)) {\n      return false;\n    } // The use of `Object#toString` avoids issues with the `typeof` operator\n    // in Safari 9 which returns 'object' for typed arrays and other constructors.\n\n\n    var tag = baseGetTag(value);\n    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n  }\n  /**\n   * Checks if `value` is a valid array-like length.\n   *\n   * **Note:** This method is loosely based on\n   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n   * @example\n   *\n   * _.isLength(3);\n   * // => true\n   *\n   * _.isLength(Number.MIN_VALUE);\n   * // => false\n   *\n   * _.isLength(Infinity);\n   * // => false\n   *\n   * _.isLength('3');\n   * // => false\n   */\n\n\n  function isLength(value) {\n    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n  }\n  /**\n   * Checks if `value` is the\n   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n   * @example\n   *\n   * _.isObject({});\n   * // => true\n   *\n   * _.isObject([1, 2, 3]);\n   * // => true\n   *\n   * _.isObject(_.noop);\n   * // => true\n   *\n   * _.isObject(null);\n   * // => false\n   */\n\n\n  function isObject(value) {\n    var type = typeof value;\n    return value != null && (type == 'object' || type == 'function');\n  }\n  /**\n   * Checks if `value` is object-like. A value is object-like if it's not `null`\n   * and has a `typeof` result of \"object\".\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n   * @example\n   *\n   * _.isObjectLike({});\n   * // => true\n   *\n   * _.isObjectLike([1, 2, 3]);\n   * // => true\n   *\n   * _.isObjectLike(_.noop);\n   * // => false\n   *\n   * _.isObjectLike(null);\n   * // => false\n   */\n\n\n  function isObjectLike(value) {\n    return value != null && typeof value == 'object';\n  }\n  /**\n   * Checks if `value` is classified as a `Symbol` primitive or object.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n   * @example\n   *\n   * _.isSymbol(Symbol.iterator);\n   * // => true\n   *\n   * _.isSymbol('abc');\n   * // => false\n   */\n\n\n  function isSymbol(value) {\n    return typeof value == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;\n  }\n  /**\n   * Checks if `value` is classified as a typed array.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n   * @example\n   *\n   * _.isTypedArray(new Uint8Array);\n   * // => true\n   *\n   * _.isTypedArray([]);\n   * // => false\n   */\n\n\n  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n  /**\n   * Converts `value` to a finite number.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.12.0\n   * @category Lang\n   * @param {*} value The value to convert.\n   * @returns {number} Returns the converted number.\n   * @example\n   *\n   * _.toFinite(3.2);\n   * // => 3.2\n   *\n   * _.toFinite(Number.MIN_VALUE);\n   * // => 5e-324\n   *\n   * _.toFinite(Infinity);\n   * // => 1.7976931348623157e+308\n   *\n   * _.toFinite('3.2');\n   * // => 3.2\n   */\n\n  function toFinite(value) {\n    if (!value) {\n      return value === 0 ? value : 0;\n    }\n\n    value = toNumber(value);\n\n    if (value === INFINITY || value === -INFINITY) {\n      var sign = value < 0 ? -1 : 1;\n      return sign * MAX_INTEGER;\n    }\n\n    return value === value ? value : 0;\n  }\n  /**\n   * Converts `value` to an integer.\n   *\n   * **Note:** This method is loosely based on\n   * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to convert.\n   * @returns {number} Returns the converted integer.\n   * @example\n   *\n   * _.toInteger(3.2);\n   * // => 3\n   *\n   * _.toInteger(Number.MIN_VALUE);\n   * // => 0\n   *\n   * _.toInteger(Infinity);\n   * // => 1.7976931348623157e+308\n   *\n   * _.toInteger('3.2');\n   * // => 3\n   */\n\n\n  function toInteger(value) {\n    var result = toFinite(value),\n        remainder = result % 1;\n    return result === result ? remainder ? result - remainder : result : 0;\n  }\n  /**\n   * Converts `value` to a number.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to process.\n   * @returns {number} Returns the number.\n   * @example\n   *\n   * _.toNumber(3.2);\n   * // => 3.2\n   *\n   * _.toNumber(Number.MIN_VALUE);\n   * // => 5e-324\n   *\n   * _.toNumber(Infinity);\n   * // => Infinity\n   *\n   * _.toNumber('3.2');\n   * // => 3.2\n   */\n\n\n  function toNumber(value) {\n    if (typeof value == 'number') {\n      return value;\n    }\n\n    if (isSymbol(value)) {\n      return NAN;\n    }\n\n    if (isObject(value)) {\n      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n      value = isObject(other) ? other + '' : other;\n    }\n\n    if (typeof value != 'string') {\n      return value === 0 ? value : +value;\n    }\n\n    value = value.replace(reTrim, '');\n    var isBinary = reIsBinary.test(value);\n    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;\n  }\n  /**\n   * Converts `value` to a string. An empty string is returned for `null`\n   * and `undefined` values. The sign of `-0` is preserved.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to convert.\n   * @returns {string} Returns the converted string.\n   * @example\n   *\n   * _.toString(null);\n   * // => ''\n   *\n   * _.toString(-0);\n   * // => '-0'\n   *\n   * _.toString([1, 2, 3]);\n   * // => '1,2,3'\n   */\n\n\n  function toString(value) {\n    return value == null ? '' : baseToString(value);\n  }\n  /**\n   * Gets the value at `path` of `object`. If the resolved value is\n   * `undefined`, the `defaultValue` is returned in its place.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.7.0\n   * @category Object\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path of the property to get.\n   * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n   * @returns {*} Returns the resolved value.\n   * @example\n   *\n   * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n   *\n   * _.get(object, 'a[0].b.c');\n   * // => 3\n   *\n   * _.get(object, ['a', '0', 'b', 'c']);\n   * // => 3\n   *\n   * _.get(object, 'a.b.c', 'default');\n   * // => 'default'\n   */\n\n\n  function get(object, path, defaultValue) {\n    var result = object == null ? undefined : baseGet(object, path);\n    return result === undefined ? defaultValue : result;\n  }\n  /**\n   * Checks if `path` is a direct or inherited property of `object`.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Object\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path to check.\n   * @returns {boolean} Returns `true` if `path` exists, else `false`.\n   * @example\n   *\n   * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n   *\n   * _.hasIn(object, 'a');\n   * // => true\n   *\n   * _.hasIn(object, 'a.b');\n   * // => true\n   *\n   * _.hasIn(object, ['a', 'b']);\n   * // => true\n   *\n   * _.hasIn(object, 'b');\n   * // => false\n   */\n\n\n  function hasIn(object, path) {\n    return object != null && hasPath(object, path, baseHasIn);\n  }\n  /**\n   * Creates an array of the own enumerable property names of `object`.\n   *\n   * **Note:** Non-object values are coerced to objects. See the\n   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n   * for more details.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Object\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names.\n   * @example\n   *\n   * function Foo() {\n   *   this.a = 1;\n   *   this.b = 2;\n   * }\n   *\n   * Foo.prototype.c = 3;\n   *\n   * _.keys(new Foo);\n   * // => ['a', 'b'] (iteration order is not guaranteed)\n   *\n   * _.keys('hi');\n   * // => ['0', '1']\n   */\n\n\n  function keys(object) {\n    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n  }\n  /**\n   * This method returns the first argument it receives.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Util\n   * @param {*} value Any value.\n   * @returns {*} Returns `value`.\n   * @example\n   *\n   * var object = { 'a': 1 };\n   *\n   * console.log(_.identity(object) === object);\n   * // => true\n   */\n\n\n  function identity(value) {\n    return value;\n  }\n  /**\n   * Creates a function that returns the value at `path` of a given object.\n   *\n   * @static\n   * @memberOf _\n   * @since 2.4.0\n   * @category Util\n   * @param {Array|string} path The path of the property to get.\n   * @returns {Function} Returns the new accessor function.\n   * @example\n   *\n   * var objects = [\n   *   { 'a': { 'b': 2 } },\n   *   { 'a': { 'b': 1 } }\n   * ];\n   *\n   * _.map(objects, _.property('a.b'));\n   * // => [2, 1]\n   *\n   * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n   * // => [1, 2]\n   */\n\n\n  function property(path) {\n    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n  }\n  /**\n   * This method returns a new empty array.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.13.0\n   * @category Util\n   * @returns {Array} Returns the new empty array.\n   * @example\n   *\n   * var arrays = _.times(2, _.stubArray);\n   *\n   * console.log(arrays);\n   * // => [[], []]\n   *\n   * console.log(arrays[0] === arrays[1]);\n   * // => false\n   */\n\n\n  function stubArray() {\n    return [];\n  }\n  /**\n   * This method returns `false`.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.13.0\n   * @category Util\n   * @returns {boolean} Returns `false`.\n   * @example\n   *\n   * _.times(2, _.stubFalse);\n   * // => [false, false]\n   */\n\n\n  function stubFalse() {\n    return false;\n  }\n\n  module.exports = findIndex;\n  });\n\n  var Collection =\n  /*#__PURE__*/\n  function () {\n    function Collection() {\n      var initialArray = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      _classCallCheck(this, Collection);\n\n      this.realArray = [];\n\n      if (initialArray != null) {\n        this.realArray = initialArray;\n      }\n    }\n\n    _createClass(Collection, [{\n      key: \"_hasOwnProperty\",\n      value: function _hasOwnProperty(key) {\n        return Object.prototype.hasOwnProperty.call(this.realArray, key);\n      }\n    }, {\n      key: \"_get\",\n      value: function _get(key) {\n        return this.realArray[key];\n      }\n    }, {\n      key: \"_set\",\n      value: function _set(key, value) {\n        this.realArray[key] = value;\n      }\n    }, {\n      key: \"_keys\",\n      value: function _keys() {\n        return Object.keys(this.realArray);\n      }\n    }, {\n      key: \"_delete\",\n      value: function _delete(key) {\n        return delete this.realArray[key];\n      }\n      /**\n       * exports a Collection object\n       */\n\n    }, {\n      key: \"_export\",\n      value: function _export() {\n        return this.realArray;\n      }\n    }]);\n\n    return Collection;\n  }();\n\n  /*\n  lane:\n       * [\n       *      {\n       *          id: the id of the Incident\n       *          millisecond: the millisecond of the channel this Animation (that affects the selector/attribute pair) runs\n       *      }\n       *  ]\n  */\n  function updateFinalValues(affectedIncident, initialValues, originalFinalValues, finalValues) {\n    // console.log(initialValues, originalFinalValues);\n    var change = false;\n\n    for (var key in initialValues) {\n      if (!Object.prototype.hasOwnProperty.call(originalFinalValues, key)) {\n        change = true;\n        finalValues[key] = initialValues[key];\n      }\n    }\n\n    affectedIncident.animatedAttributeValue = finalValues;\n    return change;\n  }\n  /**\n   * This function takes as input the index of the affected incident on the lane,\n   * the lane and it re-calculates the\n   * initial and final values of all the following incidents in the lane.\n   * The function is used only in cases of combo attributes\n   *\n   * @param {boolean} store - if set to true the first Incident to be edited stores the\n   *      initial values as its pureInitialValues\n   * */\n\n\n  function setInitialValue(lane, incidentsById, newInitialValues, affectedIndex) {\n    var store = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    var affectedItem = lane[affectedIndex];\n\n    var affectedIncident = incidentsById._get(affectedItem.id);\n\n    affectedIncident.setInitialValue(newInitialValues, store);\n    var change = updateFinalValues(affectedIncident, affectedIncident.initialValue, affectedIncident.originalAnimatedAttributeValue, JSON.parse(JSON.stringify(affectedIncident.animatedAttributeValue))); // / if the final values have changed according to the new initial values and there is\n    // a following incident on the lane\n\n    if (change) {\n      affectedIncident.lastWish();\n      affectedIncident.onGetContext();\n    }\n\n    if (change && affectedIndex < lane.length - 1) {\n      setInitialValue(lane, incidentsById, affectedIncident.animatedAttributeValue, affectedIndex + 1, false);\n    }\n  }\n\n  /**\n   * The goal of this class is to get an original array, provide all the functionality\n   * of the Collection class but by keeping the originalArray clean as it was provided.\n   */\n  var SandboxCollection =\n  /*#__PURE__*/\n  function () {\n    function SandboxCollection(originalArray) {\n      _classCallCheck(this, SandboxCollection);\n\n      this.originalArray = originalArray;\n      this.extraArray = {};\n      this.addedKeys = [];\n      this.removedKeys = [];\n    }\n\n    _createClass(SandboxCollection, [{\n      key: \"_hasOwnProperty\",\n      value: function _hasOwnProperty(key) {\n        return Object.prototype.hasOwnProperty.call(this.originalArray, key) || Object.prototype.hasOwnProperty.call(this.extraArray, key);\n      }\n    }, {\n      key: \"_get\",\n      value: function _get(key) {\n        if (Object.prototype.hasOwnProperty.call(this.extraArray, key)) {\n          return this.extraArray[key];\n        }\n\n        if (!Object.prototype.hasOwnProperty.call(this.originalArray, key)) {\n          return undefined;\n        }\n\n        this.extraArray[key] = _objectSpread2({}, this.originalArray[key]);\n        return this.extraArray[key];\n      }\n    }, {\n      key: \"_set\",\n      value: function _set(key, value) {\n        this.extraArray[key] = value;\n\n        if (!Object.prototype.hasOwnProperty.call(this.originalArray, key)) {\n          this.addedKeys.push(key);\n        }\n\n        var indexOnRemovedKeys = this.removedKeys.indexOf(key);\n\n        if (indexOnRemovedKeys > -1) {\n          this.removedKeys.splice(indexOnRemovedKeys, 1);\n        }\n      }\n    }, {\n      key: \"_keys\",\n      value: function _keys() {\n        var allKeys = Object.keys(this.originalArray).concat(this.addedKeys);\n\n        for (var i = 0; i < this.removedKeys.length; i++) {\n          var indexOnArray = this.removedKeys.indexOf(this.removedKeys[i]);\n          allKeys.splice(indexOnArray, 1);\n        }\n\n        return allKeys;\n      }\n    }, {\n      key: \"_delete\",\n      value: function _delete(key) {\n        var indexOnAddedKeys = this.addedKeys.indexOf(key);\n\n        if (indexOnAddedKeys > -1) {\n          this.addedKeys.splice(indexOnAddedKeys);\n          return delete this.extraArray[key];\n        }\n\n        return this.removedKeys.push(key);\n      }\n    }, {\n      key: \"_export\",\n      value: function _export() {\n        for (var key in this.extraArray) {\n          this.originalArray[key] = this.extraArray[key];\n        }\n\n        for (var i = 0; i < this.removedKeys.length; i++) {\n          delete this.originalArray[this.removedKeys[i]];\n        }\n\n        return this.originalArray;\n      }\n    }]);\n\n    return SandboxCollection;\n  }();\n\n  var SandboxIncidentsById =\n  /*#__PURE__*/\n  function (_SandboxCollection) {\n    _inherits(SandboxIncidentsById, _SandboxCollection);\n\n    function SandboxIncidentsById() {\n      _classCallCheck(this, SandboxIncidentsById);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(SandboxIncidentsById).apply(this, arguments));\n    }\n\n    _createClass(SandboxIncidentsById, [{\n      key: \"_get\",\n      value: function _get(key) {\n        if (Object.prototype.hasOwnProperty.call(this.extraArray, key)) {\n          return this.extraArray[key];\n        }\n\n        if (!Object.prototype.hasOwnProperty.call(this.originalArray, key)) {\n          return undefined;\n        }\n\n        return this.originalArray[key];\n      }\n    }]);\n\n    return SandboxIncidentsById;\n  }(SandboxCollection);\n\n  var SandboxLanes =\n  /*#__PURE__*/\n  function (_SandboxCollection) {\n    _inherits(SandboxLanes, _SandboxCollection);\n\n    function SandboxLanes() {\n      _classCallCheck(this, SandboxLanes);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(SandboxLanes).apply(this, arguments));\n    }\n\n    _createClass(SandboxLanes, [{\n      key: \"_get\",\n      value: function _get(key) {\n        if (Object.prototype.hasOwnProperty.call(this.extraArray, key)) {\n          return this.extraArray[key];\n        }\n\n        if (!Object.prototype.hasOwnProperty.call(this.originalArray, key)) {\n          return undefined;\n        }\n\n        this.extraArray[key] = [];\n\n        for (var i = 0; i < this.originalArray[key].length; i++) {\n          this.extraArray[key].push({\n            id: this.originalArray[key][i].id,\n            // incident: this.originalArray[key][i].incident,\n            millisecond: this.originalArray[key][i].millisecond * 1\n          });\n        }\n\n        return this.extraArray[key];\n      }\n    }]);\n\n    return SandboxLanes;\n  }(SandboxCollection);\n\n  var LanesHandler =\n  /*#__PURE__*/\n  function () {\n    function LanesHandler() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      _classCallCheck(this, LanesHandler);\n\n      /*\n           * Keeps the lanes of the Channel in the form:\n           * {\n           *  <motorcortex-id>_<attribute>: [\n           *      {\n           *          id: the id of the Incident\n           *          millisecond: the millisecond of the channel this Animation (that affects the selector/attribute pair) runs\n           *      }\n           *  ]\n           * }\n           /** @type {{}}\n           */\n      this.lanes = new Collection({});\n\n      if (props.lanes) {\n        this.lanes = props.lanes;\n      }\n\n      this.comboAttributes = {};\n\n      if (props.comboAttributes != null) {\n        this.comboAttributes = props.comboAttributes;\n      }\n\n      this.runTimeInfo = props.runTimeInfo;\n      /*\n          Keeps an indexing of the lanes each Animation belongs to. The form is the following:\n          belongingLaneKeysByAnimationId: {\n              <animation_id>: [laneKey1, laneKey2, ...],\n              <animation_id>: [laneKey2, laneKey3, ...],\n              ...\n          }\n           */\n\n      this.belongingLaneKeysByAnimationId = new Collection({});\n\n      if (props.belongingLaneKeysByAnimationId) {\n        this.belongingLaneKeysByAnimationId = props.belongingLaneKeysByAnimationId;\n      }\n      /*\n          keeps all Incidents (that appear on the lanes) mapped on a key - value pair\n          object on which the keys are the ids and the values the corresponding Incidents.\n          The Incidents of this object are ContextAwareIncidents\n          */\n\n\n      this.incidentsById = new Collection({});\n\n      if (props.incidentsById) {\n        this.incidentsById = props.incidentsById;\n      }\n    }\n    /**\n     * This method resizes all the lanes of the Lanes Handler by the durationFraction provided.\n     * No checks are performed.\n     * This method is been invoked in cases where a full Clip gets resized, so no conflict checks need to\n     * run.\n     * @param {float} durationFration: the fraction between the new duration and the current\n     */\n\n\n    _createClass(LanesHandler, [{\n      key: \"_resize\",\n      value: function _resize(durationFraction) {\n        var keys = this.lanes._keys();\n\n        for (var i = 0; i < keys.length; i++) {\n          var key = keys[i];\n\n          var theLane = this.lanes._get(key);\n\n          for (var j = 0; j < theLane.length; j++) {\n            theLane[j].millisecond = theLane[j].millisecond * durationFraction;\n          }\n        }\n      }\n      /**\n       * it creates a new LanesHandler that acts as a sanbox for testing changes\n       */\n\n    }, {\n      key: \"createTestLanesSanbox\",\n      value: function createTestLanesSanbox() {\n        var props = {\n          lanes: new SandboxLanes(this.lanes._export()),\n          belongingLaneKeysByAnimationId: new SandboxCollection(this.belongingLaneKeysByAnimationId._export()),\n          incidentsById: new SandboxIncidentsById(this.incidentsById._export())\n        };\n\n        if (this.comboAttributes) {\n          props.comboAttributes = this.comboAttributes;\n        }\n\n        return new LanesHandler(props);\n      }\n    }, {\n      key: \"getLanesCopy\",\n      value: function getLanesCopy(lane) {\n        var laneToReturn = [];\n\n        for (var i = 0; i < lane.length; i++) {\n          laneToReturn.push({\n            id: lane[i].id,\n            millisecond: lane[i].millisecond * 1\n          });\n        }\n\n        return laneToReturn;\n      }\n    }, {\n      key: \"getLaneElementsClone\",\n      value: function getLaneElementsClone(laneElement) {\n        return {\n          id: laneElement.id,\n          millisecond: laneElement.millisecond * 1\n        };\n      }\n    }, {\n      key: \"applySandboxChanges\",\n      value: function applySandboxChanges(SanboxObject) {\n        this.lanes = new Collection(SanboxObject.lanes._export());\n        this.belongingLaneKeysByAnimationId = new Collection(SanboxObject.belongingLaneKeysByAnimationId._export());\n        this.incidentsById = new Collection(SanboxObject.incidentsById._export());\n      }\n    }, {\n      key: \"getLane\",\n      value: function getLane(mcid, attr) {\n        return this.lanes._get(getLaneKey(mcid, attr));\n      }\n      /**\n       * return true if lane exists or false otherwise\n       * @param {String} mcid\n       * @param {String} attr\n       * @param {boolean} ifNotCreateIt - if is set to true and the lane doesn't exist it creates it but still returning false\n       */\n\n    }, {\n      key: \"laneExists\",\n      value: function laneExists(mcid, attr) {\n        var ifNotCreateIt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        var laneKey = getLaneKey(mcid, attr);\n\n        if (!this.lanes._hasOwnProperty(laneKey)) {\n          if (ifNotCreateIt) {\n            this.lanes._set(laneKey, []);\n          }\n\n          return false;\n        }\n\n        return true;\n      }\n      /**\n       * @param {Object} newAnim - an object of the form of a lane item (with keys \"millisecond\" and \"incident\"\n       * @param {string} mcid\n       * @param {String} attr\n       * @param {array} excludeIdsFromCheck - optional. If exists it excludes all the ids of this array from check. This\n       *  parameter has been added for the edit checks where an animation might overlap another animation that participates on\n       *  the move, something that should not happen as the edited animations pre-existed without conflicts and the move of all\n       *  of them together guarantees that there is going to be no conflict between them even after the edit\n       * @param {int} testDuration - optional. This parameter is used when the channel needs to addcheck overlaps after duration\n       *  edits, so the testDuration is passed (we don't want to polute the original animation object as it refers to the real one)\n       * @retuns {array} - a list of all overlapping animations of the lane\n       */\n\n    }, {\n      key: \"getOverlappingAnims\",\n      value: function getOverlappingAnims(newAnim, mcid, attr) {\n        var excludeIdsFromCheck = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n        var testDuration = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n        var that = this;\n\n        var overlappingAnims = lodash_filter(this.lanes._get(getLaneKey(mcid, attr)), function (existingAnim) {\n          var durationToUseOnChecks = newAnim.incident.duration;\n\n          if (testDuration != null) {\n            durationToUseOnChecks = testDuration;\n          }\n\n          return existingAnim.id !== newAnim.incident.id && excludeIdsFromCheck.indexOf(existingAnim.id) < 0 && ( // existing anim starts within the new anim's extend\n          existingAnim.millisecond >= newAnim.millisecond && existingAnim.millisecond < durationToUseOnChecks + newAnim.millisecond || // or ends within the new anim's extend\n          existingAnim.millisecond + that.incidentsById._get(existingAnim.id).duration > newAnim.millisecond && existingAnim.millisecond + that.incidentsById._get(existingAnim.id).duration <= durationToUseOnChecks + newAnim.millisecond || // or it starts before and ends after the new anim's extend\n          existingAnim.millisecond < newAnim.millisecond && existingAnim.millisecond + that.incidentsById._get(existingAnim.id).duration > durationToUseOnChecks + newAnim.millisecond);\n        });\n\n        return overlappingAnims;\n      }\n      /**\n       * it justs adds the lane item to the lane and adjusts the initial values of the Anims in sequence\n       * No checks are performed, just execution.\n       * @param {String} mcid\n       * @param {String} attr\n       * @param {int} millisecond\n       * @param {Object} incident\n       */\n\n    }, {\n      key: \"addElementToLane\",\n      value: function addElementToLane(mcid, attr, millisecond, incident) {\n        var laneKey = getLaneKey(mcid, attr);\n\n        this.incidentsById._set(incident.id, incident);\n\n        var laneElement = {\n          millisecond: millisecond,\n          id: incident.id\n        };\n        this.laneExists(mcid, attr, true);\n\n        var theLane = this.lanes._get(laneKey);\n\n        theLane.push(laneElement);\n        theLane = lodash_sortby(theLane, ['millisecond']);\n\n        this.lanes._set(laneKey, theLane); // indexing stuff\n\n\n        if (!this.belongingLaneKeysByAnimationId._hasOwnProperty(incident.id)) {\n          this.belongingLaneKeysByAnimationId._set(incident.id, []);\n        }\n\n        this.belongingLaneKeysByAnimationId._get(incident.id).push(laneKey); // indexing\n\n\n        var newAnimsIndex = lodash_findindex(theLane, function (item) {\n          return item.id === incident.id;\n        }); // helper.log(newAnimsIndex);\n        // step 1: set the intial values of the new Animation\n\n\n        if (newAnimsIndex === 0) {\n          // if the newly entered animation is the first of the lane\n          if (theLane.length > 1) {\n            // and it has other animations too\n            incident.setInitialValue(this.incidentsById._get(theLane[1].id).pureInitialValues);\n          } else {\n            incident.setInitialValue();\n          }\n        } else {\n          incident.setInitialValue(this.incidentsById._get(theLane[newAnimsIndex - 1].id).animatedAttributeValue);\n        }\n        /* if the attribute of the lane is a compo attribute */\n\n\n        if (Object.prototype.hasOwnProperty.call(this.comboAttributes, attr)) {\n          var incidentInitialValues = incident.initialValue;\n          setInitialValue(theLane, this.incidentsById, incidentInitialValues, newAnimsIndex);\n        } // step 2: set the inital values of the following Animation (if any).\n\n\n        if (newAnimsIndex + 1 < theLane.length) {\n          this.incidentsById._get(theLane[newAnimsIndex + 1].id).setInitialValue(incident.animatedAttributeValue);\n\n          if (this.incidentsById._get(theLane[newAnimsIndex + 1].id).gotContext) {\n            this.incidentsById._get(theLane[newAnimsIndex + 1].id).lastWish();\n\n            this.incidentsById._get(theLane[newAnimsIndex + 1].id).onGetContext();\n          }\n        }\n      }\n      /**\n       * it justs updates the lane\n       * No checks are performed, just execution\n       * @param {array} affectedAnimationsIds\n       * @param {int} millisecondDelta\n       */\n\n    }, {\n      key: \"updateLane\",\n      value: function updateLane(affectedAnimationsIds, millisecondsDelta) {\n        var _this = this;\n\n        // first we group the affected animations by lanes\n        var affectedLanes = {};\n        var that = this;\n\n        for (var i = 0; i < affectedAnimationsIds.length; i++) {\n          var belongingLanes = this.belongingLaneKeysByAnimationId._get(affectedAnimationsIds[i]);\n\n          for (var j = 0; j < belongingLanes.length; j++) {\n            var laneKey = belongingLanes[j];\n\n            if (!Object.prototype.hasOwnProperty.call(affectedLanes, laneKey)) {\n              affectedLanes[laneKey] = {\n                animations: [],\n                lane: that.lanes._get(laneKey),\n                laneData: getMCIDandAttrOutOfLaneKey(belongingLanes[j])\n              };\n            }\n\n            affectedLanes[laneKey].animations.push(affectedAnimationsIds[i]);\n          }\n        } // for each of the affected lanes\n\n\n        for (var _laneKey in affectedLanes) {\n          var affectedLane = affectedLanes[_laneKey];\n          var lane = affectedLane.lane;\n          var laneData = affectedLane.laneData;\n\n          var laneBeforeEdit = lodash_sortby(this.getLanesCopy(lane), ['millisecond']);\n\n          var isComboAttr = Object.prototype.hasOwnProperty.call(this.comboAttributes, laneData.attribute); // edit lane items millisecond\n\n          for (var k = 0; k < lane.length; k++) {\n            if (affectedLane.animations.indexOf(lane[k].id) >= 0) {\n              lane[k].millisecond += millisecondsDelta;\n            }\n          } // end for searching for the animations within the lane\n\n\n          var sortedLane = lodash_sortby(lane, ['millisecond']);\n\n          this.lanes._set(_laneKey, sortedLane);\n\n          lane = sortedLane;\n\n          var _loop = function _loop(_i) {\n            var animationToCheck = affectedLane.animations[_i];\n\n            var animationIndexBeforeEdit = lodash_findindex(laneBeforeEdit, function (item) {\n              return item.id === animationToCheck;\n            });\n\n            var animationIndexAfterEdit = lodash_findindex(lane, function (item) {\n              return item.id === animationToCheck;\n            });\n\n            var animation = _this.incidentsById._get(lane[animationIndexAfterEdit].id);\n\n            if (animationIndexBeforeEdit !== animationIndexAfterEdit || animationIndexAfterEdit > 1) {\n              if (animationIndexBeforeEdit + 1 < lane.length) {\n                // if the animation was not the last animation on the lane before the edit\n                // we should take care of the initial values of the animation's previous successor\n                if (animationIndexBeforeEdit === 0) {\n                  // if the edited animation was the first one before the edit\n                  // pass its initial values to its previous successor as its new initial values\n                  if (isComboAttr) {\n                    setInitialValue(lane, _this.incidentsById, animation.pureInitialValues, 0, true);\n                  } else {\n                    _this.incidentsById._get(laneBeforeEdit[1].id).setInitialValue(animation.pureInitialValues);\n\n                    _this.incidentsById._get(laneBeforeEdit[1].id).onGetContext();\n                  }\n                } else {\n                  // else if the edited animation was not the first one before the edit\n                  // meaning its previous successor is not the first one on the lane after the edit\n                  // just grab the target value of the new previous animation of the animation's previous successor and set it as initial value\n                  if (isComboAttr) {\n                    var indexToAffect = animationIndexAfterEdit > animationIndexBeforeEdit ? animationIndexBeforeEdit : animationIndexAfterEdit;\n                    setInitialValue(lane, _this.incidentsById, _this.incidentsById._get(laneBeforeEdit[animationIndexBeforeEdit - 1].id).animatedAttributeValue, indexToAffect, true);\n                  } else {\n                    _this.incidentsById._get(laneBeforeEdit[animationIndexBeforeEdit + 1].id).setInitialValue(_this.incidentsById._get(laneBeforeEdit[animationIndexBeforeEdit - 1].id).animatedAttributeValue);\n\n                    _this.incidentsById._get(laneBeforeEdit[animationIndexBeforeEdit + 1].id).onGetContext();\n                  }\n                }\n              } // for the edited animation itself now:\n\n\n              if (animationIndexAfterEdit === 0) {\n                // is it the first one (after edit)?\n                // get the initial values of the previously 0 indexed animation of the lane\n                if (isComboAttr) {\n                  setInitialValue(lane, _this.incidentsById, _this.incidentsById._get(laneBeforeEdit[0].id).pureInitialValues, animationIndexAfterEdit, true);\n                } else {\n                  animation.setInitialValue(_this.incidentsById._get(laneBeforeEdit[0].id).pureInitialValues);\n                  animation.onGetContext();\n                }\n              } else {\n                // else if it is not the first one after editd\n                // just grab the target value of the previous animation on the updated lane and set it as its initial value\n                if (isComboAttr) {\n                  setInitialValue(lane, _this.incidentsById, _this.incidentsById._get(lane[animationIndexAfterEdit - 1].id).animatedAttributeValue, animationIndexAfterEdit, true);\n                } else {\n                  animation.setInitialValue(_this.incidentsById._get(lane[animationIndexAfterEdit - 1].id).animatedAttributeValue);\n                  animation.onGetContext();\n                }\n              } // for its new next animation (if it has one)\n\n\n              if (animationIndexAfterEdit + 1 < lane.length) {\n                // set its initial value to equal the target value of the edited animation\n                if (isComboAttr) {\n                  setInitialValue(lane, _this.incidentsById, animation.animatedAttributeValue, animationIndexAfterEdit + 1, true);\n                } else {\n                  _this.incidentsById._get(lane[animationIndexAfterEdit + 1].id).setInitialValue(animation.animatedAttributeValue);\n\n                  _this.incidentsById._get(lane[animationIndexAfterEdit + 1].id).onGetContext();\n                }\n              }\n            }\n          };\n\n          for (var _i = 0; _i < affectedLane.animations.length; _i++) {\n            _loop(_i);\n          }\n        } // end for each of the belonging lanes of the animation\n\n      }\n      /**\n       * removes the list of animations as provided\n       * @param {array} removedAnimations - an array with the removed animations' ids\n       */\n\n    }, {\n      key: \"deleteAnimations\",\n      value: function deleteAnimations(removedAnimations) {\n        var affectedLanes = {};\n\n        for (var i = 0; i < removedAnimations.length; i++) {\n          var id = removedAnimations[i]; // for each lane the affected Animation appears in\n\n          var belongingLanes = this.belongingLaneKeysByAnimationId._get(id);\n\n          for (var j = 0; j < belongingLanes.length; j++) {\n            var lane = this.lanes._get(belongingLanes[j]);\n\n            var animationIndexBeforeEdit = -1;\n\n            for (var k = 0; k < lane.length; k++) {\n              if (lane[k].id === id) {\n                animationIndexBeforeEdit = k;\n                break;\n              }\n            } // helper.log(animationIndexBeforeEdit);\n\n\n            var animationToDelete = _objectSpread2({}, lane[animationIndexBeforeEdit]);\n\n            var animationObjectToDelete = this.incidentsById._get(animationToDelete.id);\n\n            var laneData = getMCIDandAttrOutOfLaneKey(belongingLanes[j]); // gets the lane without the removed animation\n\n            var newLane = [];\n\n            for (var _k = 0; _k < lane.length; _k++) {\n              if (lane[_k].id !== id) {\n                newLane.push(lane[_k]);\n              }\n            }\n\n            this.lanes._set(belongingLanes[j], newLane);\n\n            lane = this.lanes._get(belongingLanes[j]);\n\n            if (lane.length === 0) {\n              // in case there are no more animations on the lane any more we reset\n              // the lane by running the progress(0,0), so that the affected elements\n              // will get back to their original attribute value\n              animationObjectToDelete.onProgress(0, 0);\n\n              this.lanes._delete(belongingLanes[j]);\n\n              if (Object.prototype.hasOwnProperty.call(affectedLanes, belongingLanes[j])) {\n                delete affectedLanes[belongingLanes[j]];\n              }\n            } else {\n              affectedLanes[belongingLanes[j]] = getMCIDandAttrOutOfLaneKey(belongingLanes[j]);\n\n              if (animationIndexBeforeEdit < lane.length && this.incidentsById._get(animationToDelete.id).pureInitialValues !== false) {\n                if (Object.prototype.hasOwnProperty.call(this.comboAttributes, laneData.attribute)) {\n                  setInitialValue(lane, this.incidentsById, this.incidentsById._get(animationToDelete.id).pureInitialValues, animationIndexBeforeEdit, true);\n                } else {\n                  this.incidentsById._get(lane[animationIndexBeforeEdit].id).setInitialValue(this.incidentsById._get(animationToDelete.id).pureInitialValues);\n\n                  this.incidentsById._get(lane[animationIndexBeforeEdit].id).onGetContext();\n                }\n              }\n            }\n          }\n\n          this.belongingLaneKeysByAnimationId._delete(removedAnimations[i]);\n        }\n\n        return affectedLanes;\n      }\n      /**\n       * This method is responsible for recalculating the scratch values of the first\n       * Incident of each of the lanes of the LanesHandler according to the provided\n       * context id\n       * */\n\n    }, {\n      key: \"recalcScratchValues\",\n      value: function recalcScratchValues(contextId) {\n        var keys = this.lanes._keys();\n\n        for (var i = 0; i < keys.length; i++) {\n          var key = keys[i];\n\n          var theLane = this.lanes._get(key);\n\n          if (theLane.length > 0) {\n            var firstIncident = this.incidentsById._get(theLane[0].id);\n\n            var newScratchValue = firstIncident.getScratchValue(contextId);\n            var laneData = getMCIDandAttrOutOfLaneKey(key);\n\n            if (Object.prototype.hasOwnProperty.call(this.comboAttributes, laneData.attribute)) {\n              // if it is a combo\n              setInitialValue(theLane, this.incidentsById, newScratchValue, 0, true);\n            } else {\n              // else if it's not a combo attribute\n              firstIncident.setInitialValue(newScratchValue);\n            }\n\n            firstIncident.lastWish();\n            firstIncident.onGetContext();\n          }\n        }\n      }\n    }]);\n\n    return LanesHandler;\n  }();\n\n  var AttributeChannel =\n  /*#__PURE__*/\n  function (_Channel) {\n    _inherits(AttributeChannel, _Channel);\n\n    function AttributeChannel(props) {\n      var _this;\n\n      _classCallCheck(this, AttributeChannel);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(AttributeChannel).call(this, props));\n      /*\n          comboAttributes are attributes of type object, holding a number of other attributes.\n          E.g. CSS \"transform\" attribute is a combo that holds a number of other attributes such as:\n          translateX, translateY, etc. The lanes handler keeps just one lane for the combo attrs\n          in an object format keeping the value of each attribute at any given point.\n          Combo attributes are passed on the constructor of the Channel in the format:\n          props.comboAttributes: {\n              transition: ['translateX', 'translateY', ...],\n              <something_else>: ['<attrName1>', '<attrName2>', ...]\n          }\n          */\n\n      _this.comboAttributes = {};\n      /**\n       * For incidents that do not have animatedAttrs there should be only one lane per element.\n       * The attributes Channel will use a default (fake), fixed attribute for this cases so it always ends\n       * up with just one lane per element: <element_id>_<this.fixedAttributeName>\n       */\n\n      _this.fixedAttributeName = '_';\n\n      if (props.comboAttributes != null) {\n        _this.comboAttributes = props.comboAttributes;\n      }\n\n      _this.LanesHandler = new LanesHandler({\n        comboAttributes: _this.comboAttributes,\n        runTimeInfo: _this.runTimeInfo\n      }); // this.type = \"attributes\";\n\n      return _this;\n    }\n\n    _createClass(AttributeChannel, [{\n      key: \"setComboAttributes\",\n      value: function setComboAttributes(comboAttributes) {\n        this.comboAttributes = comboAttributes;\n        this.LanesHandler = new LanesHandler({\n          comboAttributes: this.comboAttributes\n        });\n      }\n    }, {\n      key: \"_resize\",\n      value: function _resize(durationFraction) {\n        this.LanesHandler._resize(durationFraction);\n      }\n      /* *******************************************************\n         DECISION METHODS\n         ******************************************************* */\n\n      /**\n       * All of the incidents coming to this method are element-attribute incidents meaning that they only\n       * target just one element and also they include just a single attribute on the incident.attrs.animatedAttrs\n       * object\n       *\n       * @param {array} incidents - A collection of Incidents in the form:\n       * {\n       *  millisecond\n       *  incident\n       *  id\n       * }\n       * @param {string} type - can be either \"all-or-nothing\" (default) or \"keep-passing\". If type = \"all-or-nothing\"\n       *  the addition passes only if all incidents pass. If type = \"keep-passing\" the method will still return true\n       *  but will also include an errors array on its return and also will only include the success callbacks on\n       *  the execute key of its return\n       * @returns either:\n       *   {\n       *       result:true,\n       *       execute: // an array of functions that when executed it will add the Incidents on the Channels\n       *   }\n       *   or\n       *   {\n       *       result: false,\n       *       errors\n       *   }\n       */\n\n    }, {\n      key: \"checkAddition\",\n      value: function checkAddition(incidents) {\n        var _this2 = this;\n\n        var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'all-or-nothing';\n        var LanesHandlerSandbox = this.LanesHandler.createTestLanesSanbox();\n        // the permanent and pre-existing objects it handles, such as changes on the initial values of existing animations.\n        // Because of the fact the LanesSandboxHandler is only there for testing we don't want to execute these changes\n        // during checks but still we need to know them on success. For this, the onSuccessActions array holds all executable\n        // functions retured by various LanesHandlerSanbox functions so it can execute them on success.\n\n        var onSuccessActions = [];\n        var conflicts = [];\n\n        var _loop = function _loop(i) {\n          var incidentConflicts = false; // a boolean that keeps the information whether the incident conflicts or not\n\n          var laneItem = incidents[i];\n          var incident = laneItem.incident;\n          var mcid = incident.mcid;\n          var attribute = incident.attribute || _this2.fixedAttributeName;\n          LanesHandlerSandbox.laneExists(mcid, attribute); // create the lane if it doesn't exist already\n\n          var overlappingAnims = LanesHandlerSandbox.getOverlappingAnims(laneItem, mcid, attribute); // helper.log(overlappingAnim)\n\n          if (overlappingAnims.length > 0) {\n            incidentConflicts = true;\n            conflicts.push({\n              type: 'unauthorised, overlapping incidents on the same element',\n              meta: {\n                element_mcid: mcid,\n                attribute: attribute,\n                incident: laneItem,\n                overlappingAnims: overlappingAnims\n              }\n            });\n          }\n\n          if (!incidentConflicts) {\n            onSuccessActions.push(function () {\n              LanesHandlerSandbox.addElementToLane(mcid, attribute, laneItem.millisecond, incident);\n\n              incident._onGetContextOnce();\n            });\n          }\n        };\n\n        for (var i = 0; i < incidents.length; i++) {\n          _loop(i);\n        } // end for each incident\n        // if we have conflicts and the type = \"all-or-nothing\"\n\n\n        if (conflicts.length > 0 && type === 'all-or-nothing') {\n          return {\n            result: false,\n            errors: conflicts\n          };\n        } // as soon as we want all passing additions to get applied the Lanes Handler will create a callback that will be passed to the result.\n        // This callback will apply all passing additions.\n        // success message\n\n\n        var that = this;\n\n        var exec = function execFunct() {\n          for (var _i = 0; _i < onSuccessActions.length; _i++) {\n            onSuccessActions[_i]();\n          }\n\n          that.LanesHandler.applySandboxChanges(LanesHandlerSandbox);\n        };\n\n        return {\n          result: true,\n          errors: conflicts,\n          execute: exec\n        };\n      }\n      /**\n         * It initially checks if the edit is allowed and if it is it retuns an array of executable functions\n         * that apply the change\n         * @param {array} incidents - the list of the lane items to edit in an array format [object, object, ...]\n         * @param {int} millisecondsDelta - the milliseconds delta to apply to the incidents\n         * @returns {object} -\n         * either:\n         {\n            result: true,\n            execute: // array of functions to be executed in order to apply the edit\n         }\n         or\n         {\n             result: false,\n             errors: // an array including all the errors / conflicts found on edit\n         }\n        */\n\n    }, {\n      key: \"checkEdit\",\n      value: function checkEdit(incidents, millisecondsDelta) {\n        // console.log(incidents);\n        var affectedIncidentIds = [];\n\n        for (var i = 0; i < incidents.length; i++) {\n          affectedIncidentIds.push(incidents[i].id);\n        }\n\n        var LanesHandlerSandbox = this.LanesHandler.createTestLanesSanbox();\n        var conflicts = [];\n\n        for (var _i2 = 0; _i2 < incidents.length; _i2++) {\n          var incident = incidents[_i2].incident;\n          var incidentId = incident.id;\n          var mcid = incidents[_i2].incident.mcid;\n          var attribute = incidents[_i2].incident.attribute || this.fixedAttributeName;\n          var lane = LanesHandlerSandbox.getLane(mcid, attribute);\n\n          for (var k = 0; k < lane.length; k++) {\n            if (lane[k].id === incidentId) {\n              var affectedAnim = lane[k];\n              var testLaneElement = LanesHandlerSandbox.getLaneElementsClone(affectedAnim);\n              testLaneElement.millisecond += millisecondsDelta;\n              testLaneElement.incident = LanesHandlerSandbox.incidentsById._get(testLaneElement.id);\n              var overlappingAnims = LanesHandlerSandbox.getOverlappingAnims(testLaneElement, mcid, attribute, affectedIncidentIds);\n\n              if (overlappingAnims.length > 0) {\n                conflicts.push({\n                  type: 'anauthorised, overlapping animations on the same element',\n                  meta: {\n                    element_mcid: mcid,\n                    attribute: attribute,\n                    newAnimation: testLaneElement,\n                    overlappingAnims: overlappingAnims\n                  }\n                });\n              }\n\n              break;\n            } // end of if we found the specific animation on the lane's sequence\n\n          } // end of each lane's item\n\n        } // end for each affected animation's id\n\n\n        if (conflicts.length > 0) {\n          return {\n            result: false,\n            errors: conflicts\n          };\n        }\n\n        var that = this;\n\n        var exec = function execFunct() {\n          that.LanesHandler.updateLane(affectedIncidentIds, millisecondsDelta);\n        };\n\n        return {\n          result: true,\n          execute: exec\n        };\n      }\n      /**\n       * @param {array} incidents - [{id, start, end, startDelta}]\n       * @param {boolean} fullChannelResize - if set to true then the full html channel is resizing. This is a special case as in\n       *  that case no checks should be actually perfomed nor the projected candidate should be applied directly\n       * */\n\n    }, {\n      key: \"checkResizedIncidents\",\n      value: function checkResizedIncidents(incidents) {\n        var fullChannelResize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        var excludeIdsFromCheck = [];\n\n        for (var i = 0; i < incidents.length; i++) {\n          excludeIdsFromCheck.push(incidents[i].id);\n        }\n\n        var LanesHandlerSandbox = this.LanesHandler.createTestLanesSanbox();\n        var conflicts = [];\n\n        for (var _i3 = 0; _i3 < incidents.length; _i3++) {\n          // get the ContextAwareIncident\n          var incident = this.LanesHandler.incidentsById._get(incidents[_i3].id);\n\n          var mcid = incident.mcid;\n          var attribute = incident.attribute || this.fixedAttributeName;\n          var lane = LanesHandlerSandbox.getLane(mcid, attribute);\n          var laneAttrs = {\n            mcid: mcid,\n            attribute: attribute\n          };\n          var testDuration = incidents[_i3].end - incidents[_i3].start; // check for conflicts and edit lane items millisecond\n\n          for (var k = 0; k < lane.length; k++) {\n            if (lane[k].id === incidents[_i3].id) {\n\n              if (fullChannelResize === false) {\n                var affectedAnim = lane[k];\n                var testLaneElement = LanesHandlerSandbox.getLaneElementsClone(affectedAnim);\n                testLaneElement.millisecond += incidents[_i3].startDelta;\n                testLaneElement.incident = LanesHandlerSandbox.incidentsById._get(testLaneElement.id);\n                var overlappingAnims = LanesHandlerSandbox.getOverlappingAnims(testLaneElement, laneAttrs.mcid, laneAttrs.attribute, excludeIdsFromCheck, testDuration);\n\n                if (overlappingAnims.length > 0) {\n                  conflicts.push({\n                    type: 'anauthorised overlapping animations on the same element',\n                    meta: {\n                      element_mcid: laneAttrs.mcid,\n                      attribute: laneAttrs.attribute,\n                      newAnimation: testLaneElement,\n                      overlappingAnims: overlappingAnims\n                    }\n                  });\n                }\n              }\n\n              break;\n            } // end of if we found the specific animation on the lane's sequence\n\n          } // end of each lane's item\n\n        } // end for each affected animation's id\n\n\n        if (conflicts.length > 0) {\n          return {\n            result: false,\n            errors: conflicts\n          };\n        }\n\n        var that = this;\n\n        var exec = function execFunct() {\n          // updateLanes (only this time animation by animation as the milliseconds delta is not standard for all)\n          // as soon as there are no conflicts the Lanes Handler applies the changes before sending over the\n          // success message\n          for (var _i4 = 0; _i4 < incidents.length; _i4++) {\n            that.LanesHandler.updateLane([incidents[_i4].id], incidents[_i4].startDelta);\n          }\n        };\n\n        return {\n          execute: exec,\n          result: true\n        };\n      }\n      /**\n       *\n       */\n\n    }, {\n      key: \"checkDelete\",\n      value: function checkDelete(removedAnimations) {\n        // eslint-disable-line no-unused-vars\n        var removedAnimationIds = [];\n\n        for (var i = 0; i < removedAnimations.length; i++) {\n          removedAnimationIds.push(removedAnimations[i].id);\n        }\n\n        var that = this;\n\n        var exec = function execFunct() {\n          that.LanesHandler.deleteAnimations(removedAnimationIds);\n        };\n\n        return {\n          result: true,\n          execute: exec\n        };\n      }\n      /**\n       * This method is responsible for recalculating the scratch values of the first\n       * Incident of each of the lanes of the LanesHandler according to the provided\n       * context id\n       * */\n\n    }, {\n      key: \"recalcScratchValues\",\n      value: function recalcScratchValues(contextId) {\n        this.LanesHandler.recalcScratchValues(contextId);\n      }\n      /**\n       * Slips to just one lane forwards\n       * @param {array} lane - the lane to slip into\n       * @param {object} laneData - an object with keys: attribute & mcid\n       * @param {int} currentMillisecond - the millisecond the slip starts from\n       * @param {int} millisecond - the target millisecond of the slip\n       * @param {string} contextId - the contextId of the Incidents to slip\n       */\n\n    }, {\n      key: \"slipIntoLaneForwards\",\n      value: function slipIntoLaneForwards(lane, laneData, currentMillisecond, millisecond, contextId) {\n        var forceReset = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n        // console.log(lane, currentMillisecond, millisecond);\n        var that = this;\n\n        var participatingAnims = lodash_filter(lane, function (laneItem) {\n          return (// it ends after currentMillisecond and before target millisecond\n            // or it ends after the target millisecond but also starts before it\n            laneItem.millisecond + that.incidentsById._get(laneItem.id).duration >= currentMillisecond && laneItem.millisecond + that.incidentsById._get(laneItem.id).duration <= millisecond || that.incidentsById._get(laneItem.id).duration + laneItem.millisecond >= millisecond && laneItem.millisecond <= millisecond\n          );\n        });\n\n        if (participatingAnims.length === 0) {\n          // there are two cases forceReset can be used: a) when we are flashing the Clip\n          // going from 0 to millisecond via flash method of ExtendableClip or when\n          // we want to seek the Clip without executing it (like it was in transitional state)\n          // we diferentiate the two by the currentMillisecond value which in case (a) is always 0\n          if (forceReset === true && currentMillisecond === 0) {\n            var firstIncident = this.incidentsById._get(lane[0].id);\n\n            firstIncident.onProgress(0, 0, contextId);\n          }\n\n          return true;\n        }\n\n        participatingAnims = lodash_sortby(participatingAnims, [function (laneItem) {\n          return laneItem.millisecond;\n        }]); // We only care about the last (in chronological order) Incident, as this\n        // will define the final value\n\n        var lastIndex = participatingAnims.length - 1;\n\n        var participatingAnim = this.incidentsById._get(participatingAnims[lastIndex].id);\n\n        var startMillisecond = participatingAnims[lastIndex].millisecond; // if the animation ends before the target millisecond\n\n        if (participatingAnim.duration + startMillisecond <= millisecond) {\n          // and it's the last one on the row\n          participatingAnim.onProgress(1, participatingAnim.duration, contextId);\n        } else {\n          // slip for the specific element and the specific attribute. Set the Animation as paused or playing a\n          // and store this info somewhere\n          var percentageComplete = (millisecond - startMillisecond) / participatingAnim.duration;\n          participatingAnim.onProgress(percentageComplete, millisecond - startMillisecond, contextId);\n        }\n      }\n      /**\n       * Slips to just one lane backwards\n       * @param {array} lane - the lane to slip into\n       * @param {object} laneData - an object with keys: attribute & mcid\n       * @param {int} currentMillisecond - the millisecond the slip starts from\n       * @param {int} millisecond - the target millisecond of the slip\n       * @param {string} contextId - the contextId of the Incidents to slip\n       */\n\n    }, {\n      key: \"slipToLaneBackwards\",\n      value: function slipToLaneBackwards(lane, laneData, currentMillisecond, millisecond, contextId) {\n        // eslint-disable-line no-unused-vars\n        // we take all Animations that are either currently running or\n        // they end after the destination point\n        // helper.log('<------');\n        var that = this;\n\n        var participatingAnims = lodash_filter(lane, function (laneItem) {\n          var laneItemEnd = that.incidentsById._get(laneItem.id).duration + laneItem.millisecond;\n          return laneItemEnd <= millisecond && laneItemEnd >= currentMillisecond || // they end in the hot area\n          laneItem.millisecond >= currentMillisecond && laneItem.millisecond <= millisecond || // they start in the hot area\n          laneItem.millisecond < currentMillisecond && laneItemEnd > millisecond; // they overlap the hot area\n        });\n\n        if (participatingAnims.length === 0) {\n          return true;\n        }\n\n        participatingAnims = lodash_sortby(participatingAnims, [function (laneItem) {\n          return laneItem.millisecond;\n        }]); // We only care about the first (in chronological order) Incident, as this\n        // will define the final value of the backwards move\n\n        var lastIndex = 0;\n\n        var participatingAnim = this.incidentsById._get(participatingAnims[lastIndex].id);\n\n        var startMillisecond = participatingAnims[lastIndex].millisecond; // if the animation starts after the target millisecond\n\n        if (startMillisecond >= millisecond) {\n          participatingAnim.onProgress(0, 0, contextId);\n        } else {\n          // slip for the specific element and the specific attribute. Set the Animation as paused or playing a\n          // and store this info somewhere\n          var percentageComplete = (millisecond - startMillisecond) / participatingAnim.duration;\n          participatingAnim.onProgress(percentageComplete, millisecond - startMillisecond, contextId);\n        }\n      }\n      /**\n         @param {int} from - the millisecond to start from\n         @param {int} to - the millisecond to go to\n         @param {sring} contextId - the context id to \"move\"\n         @param {boolean} forceReset - set to true if status recalc is needed after edit\n         */\n\n    }, {\n      key: \"moveTo\",\n      value: function moveTo(from, to, contextId) {\n        var forceReset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n        // step 1: iterate through all lanes\n        var laneKeys = this.lanes._keys();\n\n        for (var i = 0; i < laneKeys.length; i++) {\n          var laneid = laneKeys[i];\n\n          var lane = this.lanes._get(laneid);\n\n          var laneData = getMCIDandAttrOutOfLaneKey(laneid);\n\n          if (from <= to) {\n            this.slipIntoLaneForwards(lane, laneData, from, to, contextId, forceReset);\n          } else if (from > to) {\n            this.slipToLaneBackwards(lane, laneData, from, to, contextId, forceReset);\n          }\n        }\n      }\n    }, {\n      key: \"lanes\",\n      get: function get() {\n        return this.LanesHandler.lanes;\n      }\n    }, {\n      key: \"incidentsById\",\n      get: function get() {\n        return this.LanesHandler.incidentsById;\n      }\n    }], [{\n      key: \"type\",\n      get: function get() {\n        return 'attributes';\n      }\n    }]);\n\n    return AttributeChannel;\n  }(Channel);\n\n  var ContextHandler =\n  /*#__PURE__*/\n  function () {\n    function ContextHandler() {\n      _classCallCheck(this, ContextHandler);\n\n      this.customEntities = {};\n    }\n\n    _createClass(ContextHandler, [{\n      key: \"getElementByMCID\",\n      value: function getElementByMCID(mcid) {\n        if (Object.prototype.hasOwnProperty.call(this.customEntities, mcid)) {\n          return this.customEntities[mcid];\n        }\n\n        if (Object.prototype.hasOwnProperty.call(this.elementsByMCID, mcid)) {\n          return this.elementsByMCID[mcid];\n        }\n\n        var element = this.context.rootElement.querySelector(this.getElementSelectorByMCID(mcid));\n        this.elementsByMCID[mcid] = element;\n        return element;\n      }\n    }, {\n      key: \"getElements\",\n      value: function getElements(selector) {\n        if (selector.charAt(0) === '!') {\n          selector = selector.substr(1);\n\n          if (selector.charAt(0) === '#') {\n            return [this.customEntities[selector.substr(1)]];\n          }\n\n          if (selector.charAt(0) === '.') {\n            var toReturn = [];\n\n            for (var key in this.customEntities) {\n              var entity = this.customEntities[key];\n\n              if (entity.classes.indexOf(selector.substr(1)) > -1) {\n                toReturn.push(entity);\n              }\n            }\n\n            return toReturn;\n          }\n        }\n\n        return Array.from(this.context.rootElement.querySelectorAll(selector));\n      }\n    }, {\n      key: \"getMCID\",\n      value: function getMCID(element) {\n        if (element.customEntity === true) {\n          return element.id;\n        }\n\n        return element.getAttribute(elements_data_attribute_name);\n      }\n    }, {\n      key: \"setMCID\",\n      value: function setMCID(element, mcid) {\n        element.setAttribute(elements_data_attribute_name, mcid);\n      }\n    }, {\n      key: \"getElementSelectorByMCID\",\n      value: function getElementSelectorByMCID(mcid) {\n        if (Object.prototype.hasOwnProperty.call(this.customEntities, mcid)) {\n          return \"!#\".concat(mcid);\n        }\n\n        return \"[\".concat(elements_data_attribute_name, \"=\\\"\").concat(mcid, \"\\\"]\");\n      }\n    }, {\n      key: \"setCustomEntity\",\n      value: function setCustomEntity(id, entity) {\n        var classes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n        if (Object.prototype.hasOwnProperty.call(this.customEntities, id)) {\n          helper.error(\"Clip \".concat(this.id, \" already has custom Entity with id: \").concat(id));\n          return false;\n        }\n\n        this.customEntities[id] = {\n          id: id,\n          entity: entity,\n          classes: classes,\n          customEntity: true\n        };\n        return true;\n      }\n    }]);\n\n    return ContextHandler;\n  }();\n\n  var IframeContextHandler =\n  /*#__PURE__*/\n  function (_ContextHandler) {\n    _inherits(IframeContextHandler, _ContextHandler);\n\n    /**\n     * @param {object} props - an object that should contain all of the following keys:\n     * - html (the html template to render)\n     * - css (the css template of the isolated tree)\n     * - initParams (optional / the initialisation parameteres that will be passed both on the css and the html templates in order to render)\n     * - host (an Element object that will host the isolated tree)\n     * - containerParams (an object that holds parameters to affect the container of the isolated tree, e.g. width, height etc)\n     */\n    function IframeContextHandler() {\n      var _this;\n\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      _classCallCheck(this, IframeContextHandler);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(IframeContextHandler).call(this));\n\n      if (!isObject(props)) {\n        helper.error(\"ContextHandler expects an object on its constructor. \".concat(_typeof(props), \" passed\"));\n        return _possibleConstructorReturn(_this, false);\n      }\n\n      if (!Object.prototype.hasOwnProperty.call(props, 'html')) {\n        helper.error('ContextHandler expects the html key on its constructor properties which is missing');\n        return _possibleConstructorReturn(_this, false);\n      }\n\n      if (!Object.prototype.hasOwnProperty.call(props, 'css')) {\n        helper.error('ContextHandler expects the css key on its constructor properties which is missing');\n        return _possibleConstructorReturn(_this, false);\n      }\n\n      if (!Object.prototype.hasOwnProperty.call(props, 'initParams')) {\n        helper.info('ContextHandler got null initParams');\n      }\n\n      if (!Object.prototype.hasOwnProperty.call(props, 'host')) {\n        helper.error('ContextHandler expects the host key on its constructor properties which is missing');\n        return _possibleConstructorReturn(_this, false);\n      }\n\n      _this.isDOM = true;\n      var ownerDocument = props.host.ownerDocument;\n\n      if (!ownerDocument.getElementById('@kissmybutton/motorcortex/iframeContextHandler/css')) {\n        var seamlessCSS = \"\\n            iframe[seamless]{\\n                background-color: transparent;\\n                border: 0px none transparent;\\n                padding: 0px;\\n                overflow: hidden;\\n            }\\n            \";\n        var iframesCSS = ownerDocument.createElement('style');\n        iframesCSS.id = '@kissmybutton/motorcortex/iframeContextHandler/css';\n        iframesCSS.type = 'text/css';\n        var Head = ownerDocument.head || ownerDocument.getElementsByTagName('head')[0];\n\n        if (iframesCSS.styleSheet) {\n          iframesCSS.styleSheet.cssText = seamlessCSS;\n        } else {\n          iframesCSS.appendChild(ownerDocument.createTextNode(seamlessCSS));\n        }\n\n        Head.appendChild(iframesCSS);\n      } // Create an iframe:\n\n\n      var iframe = ownerDocument.createElement('iframe');\n      props.host.appendChild(iframe);\n      iframe.setAttribute('seamless', 'seamless');\n\n      if (Object.prototype.hasOwnProperty.call(props, 'containerParams')) {\n        if (Object.prototype.hasOwnProperty.call(props.containerParams, 'width')) {\n          iframe.setAttribute('width', props.containerParams.width);\n        }\n\n        if (Object.prototype.hasOwnProperty.call(props.containerParams, 'height')) {\n          iframe.setAttribute('height', props.containerParams.height);\n        }\n      } // Initialise the iframe\n\n\n      iframe.src = ''; // Put it in the document (but hidden):\n\n      var iframeDocument = iframe.contentWindow || iframe.contentDocument;\n\n      if (iframeDocument.document) {\n        iframeDocument = iframeDocument.document;\n      }\n\n      iframeDocument.write(renderTemplate(props.html, {\n        params: props.initParams\n      }));\n      var bodyFixCSS = \"\\n        body{\\n            padding:0;\\n            margin:0;\\n        }\\n        \";\n      var styleTag = iframeDocument.createElement('style');\n      styleTag.type = 'text/css';\n\n      if (styleTag.styleSheet) {\n        styleTag.styleSheet.cssText = renderTemplate(props.css, {\n          params: props.initParams\n        }) + bodyFixCSS;\n      } else {\n        styleTag.appendChild(ownerDocument.createTextNode(props.css + bodyFixCSS));\n      }\n\n      var head = iframeDocument.head || iframeDocument.getElementsByTagName('head')[0];\n      head.appendChild(styleTag);\n\n      if (Object.prototype.hasOwnProperty.call(props, 'fonts')) {\n        for (var i = 0; i < props.fonts.length; i++) {\n          var theFont = props.fonts[i];\n\n          if (theFont.type === 'google-font') {\n            var fontTag = iframeDocument.createElement('link');\n            fontTag.setAttribute('rel', 'stylesheet');\n            fontTag.setAttribute('href', theFont.src);\n            head.appendChild(fontTag);\n          }\n        }\n      }\n\n      _this.rootElement = iframe;\n      iframeDocument.close();\n      _this.context = {\n        document: iframeDocument,\n        window: iframe.contentWindow || iframe,\n        clipContainer: iframe,\n        rootElement: iframeDocument.body,\n        unmount: function unmount() {\n          props.host.removeChild(iframe);\n        },\n        getElements: _this.getElements.bind(_assertThisInitialized(_this)),\n        getMCID: _this.getMCID.bind(_assertThisInitialized(_this)),\n        setMCID: _this.setMCID.bind(_assertThisInitialized(_this)),\n        getElementSelectorByMCID: _this.getElementSelectorByMCID.bind(_assertThisInitialized(_this)),\n        getElementByMCID: _this.getElementByMCID.bind(_assertThisInitialized(_this)),\n        setCustomEntity: _this.setCustomEntity.bind(_assertThisInitialized(_this))\n      };\n      _this.elementsByMCID = {};\n      return _this;\n    }\n\n    return IframeContextHandler;\n  }(ContextHandler);\n\n  var WebComponentContextHandler =\n  /*#__PURE__*/\n  function (_ContextHandler) {\n    _inherits(WebComponentContextHandler, _ContextHandler);\n\n    /**\n     * @param {object} props - an object that should contain all of the following keys:\n     * - html (the html template to render)\n     * - css (the css template of the isolated tree)\n     * - initParams (optional / the initialisation parameteres that will be passed both on the css and the html templates in order to render)\n     * - host (an Element object that will host the isolated tree)\n     * - containerParams (an object that holds parameters to affect the container of the isolated tree, e.g. width, height etc)\n     */\n    function WebComponentContextHandler() {\n      var _this;\n\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      _classCallCheck(this, WebComponentContextHandler);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(WebComponentContextHandler).call(this));\n\n      if (!isObject(props)) {\n        helper.error(\"ContextHandler expects an object on its constructor. \".concat(_typeof(props), \" passed\"));\n        return _possibleConstructorReturn(_this, false);\n      }\n\n      if (!Object.prototype.hasOwnProperty.call(props, 'html')) {\n        helper.error('ContextHandler expects the html key on its constructor properties which is missing');\n        return _possibleConstructorReturn(_this, false);\n      }\n\n      if (!Object.prototype.hasOwnProperty.call(props, 'css')) {\n        helper.error('ContextHandler expects the css key on its constructor properties which is missing');\n        return _possibleConstructorReturn(_this, false);\n      }\n\n      if (!Object.prototype.hasOwnProperty.call(props, 'host')) {\n        helper.error('ContextHandler expects the host key on its constructor properties which is missing');\n        return _possibleConstructorReturn(_this, false);\n      }\n\n      _this.isDOM = true;\n      var shadow = props.host.attachShadow({\n        mode: 'closed'\n      });\n      var wrapper = document.createElement('div');\n\n      if (Object.prototype.hasOwnProperty.call(props, 'containerParams')) {\n        if (Object.prototype.hasOwnProperty.call(props.containerParams, 'width')) {\n          wrapper.style.width = props.containerParams.width;\n        }\n\n        if (Object.prototype.hasOwnProperty.call(props.containerParams, 'height')) {\n          wrapper.style.height = props.containerParams.height;\n        }\n      }\n\n      wrapper.innerHTML = renderTemplate(\"\".concat(props.html, \"<slot></slot>\"), {\n        params: props.initParams\n      });\n      shadow.appendChild(wrapper);\n      var styleTag = document.createElement('style');\n      styleTag.type = 'text/css';\n\n      if (styleTag.styleSheet) {\n        styleTag.styleSheet.cssText = renderTemplate(props.css, {\n          params: props.initParams\n        });\n      } else {\n        styleTag.appendChild(document.createTextNode(props.css));\n      }\n\n      shadow.appendChild(styleTag);\n      _this.fontTags = [];\n\n      if (Object.prototype.hasOwnProperty.call(props, 'fonts')) {\n        for (var i = 0; i < props.fonts.length; i++) {\n          var theFont = props.fonts[i];\n\n          if (theFont.type === 'google-font') {\n            var fontTag = document.createElement('link');\n            fontTag.setAttribute('rel', 'stylesheet');\n            fontTag.setAttribute('href', theFont.src);\n            document.getElementsByTagName('head')[0].appendChild(fontTag);\n\n            _this.fontTags.push(fontTag);\n          }\n        }\n      }\n\n      wrapper.style.overflow = 'hidden';\n      _this.rootElement = wrapper;\n      _this.context = {\n        document: document,\n        window: window,\n        clipContainer: _this.rootElement,\n        rootElement: wrapper,\n        unmount: function unmount() {\n          try {\n            props.host.removeChild(shadow);\n\n            for (var _i = 0; _i < this.fontTags.length; _i++) {\n              document.getElementsByTagName('head')[0].removeChild(this.fontTags[_i]);\n            }\n          } catch (er) {\n            helper.warning('The element of the Clip to be removed seems not to exist any more');\n          }\n        },\n        getElements: _this.getElements.bind(_assertThisInitialized(_this)),\n        getMCID: _this.getMCID.bind(_assertThisInitialized(_this)),\n        setMCID: _this.setMCID.bind(_assertThisInitialized(_this)),\n        getElementSelectorByMCID: _this.getElementSelectorByMCID.bind(_assertThisInitialized(_this)),\n        getElementByMCID: _this.getElementByMCID.bind(_assertThisInitialized(_this)),\n        setCustomEntity: _this.setCustomEntity.bind(_assertThisInitialized(_this))\n      };\n      _this.elementsByMCID = {};\n      return _this;\n    }\n\n    return WebComponentContextHandler;\n  }(ContextHandler);\n\n  var Clip$1 =\n  /*#__PURE__*/\n  function (_ExtendableClip) {\n    _inherits(Clip, _ExtendableClip);\n\n    /**\n     * @param {object} props - an object that should contain all of the following keys:\n     * - html (the html template to render)\n     * - css (the css template of the isolated tree)\n     * - initParams (optional / the initialisation parameteres that will be passed both on the css and the html templates in order to render)\n     * - host (an Element object that will host the isolated tree)\n     * - containerParams (an object that holds parameters to affect the container of the isolated tree, e.g. width, height etc)\n     */\n    function Clip() {\n      var _this;\n\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var oldProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      _classCallCheck(this, Clip);\n\n      var attrsToPass;\n      var propsToUse;\n      /*\n          backwards compatibility. If the user doesn't pass a second argument on the constructor then this is\n          the new way of initialising a Group (only props).\n          */\n\n      if (oldProps === null) {\n        attrsToPass = {};\n        propsToUse = props;\n      } else {\n        // else, in case the user has passed two arguments then both should be used\n        attrsToPass = props;\n        propsToUse = oldProps;\n      }\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(Clip).call(this, attrsToPass, propsToUse));\n      propsToUse = _objectSpread2({}, propsToUse, {\n        html: _this.html !== '' ? _this.html : propsToUse.html,\n        css: _this.css !== '' ? _this.css : propsToUse.css,\n        fonts: _this.fonts.length > 0 ? _this.fonts : propsToUse.fonts\n      }); // that means the Clip is hosted or, in other words a host has been\n      // provided on the props (and not a selector)\n      // this.isHostedClip = true;\n\n      var clipType = selfContainedContextHandler;\n      _this.clipType = clipType;\n      var ContextHanlder = null;\n\n      if (document.head.createShadowRoot || document.head.attachShadow) {\n        ContextHanlder = WebComponentContextHandler;\n      } else {\n        ContextHanlder = IframeContextHandler;\n      } // console.log(`this.id: ${this.id}, Class: ${this.constructor.name}, this.html: ${this.html}`)\n\n\n      var contextHanlder = new ContextHanlder(propsToUse);\n      _this.ownContext = _objectSpread2({}, contextHanlder.context, {\n        isHostedClip: _this.isHostedClip\n      });\n      _this.iframe = contextHanlder.iframeElement;\n      _this.forceExportIncidents = true;\n\n      _this.onAfterRender();\n\n      return _this;\n    }\n\n    _createClass(Clip, [{\n      key: \"onAfterRender\",\n      value: function onAfterRender() {// implement here\n      }\n    }, {\n      key: \"exportConstructionArguments\",\n      value: function exportConstructionArguments() {\n        // TODO also export CSS and fonts taking in account the potential existance\n        // of them on the get methods\n        return {\n          attrs: this.attrs,\n          props: _objectSpread2({}, this.props, {\n            host: undefined,\n            html: this.ownContext.rootElement.innerHTML\n          })\n        };\n      }\n    }, {\n      key: \"setCustomEntity\",\n      value: function setCustomEntity(id, entity) {\n        var classes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n        return this.context.setCustomEntity(id, entity, classes);\n      }\n    }, {\n      key: \"html\",\n      get: function get() {\n        return '';\n      }\n    }, {\n      key: \"css\",\n      get: function get() {\n        return '';\n      }\n    }, {\n      key: \"fonts\",\n      get: function get() {\n        return [];\n      }\n    }, {\n      key: \"rootElement\",\n      get: function get() {\n        return this.ownContext.clipContainer;\n      }\n    }]);\n\n    return Clip;\n  }(ExtendableClip);\n\n  var HTMLFragmentContextHandler =\n  /*#__PURE__*/\n  function (_ContextHandler) {\n    _inherits(HTMLFragmentContextHandler, _ContextHandler);\n\n    /**\n     * @param {object} props - an object that should contain all of the following keys:\n     * - html (the html template to render)\n     * - css (the css template of the isolated tree)\n     * - initParams (optional / the initialisation parameteres that will be passed both on the css and the html templates in order to render)\n     * - host (an Element object that will host the isolated tree)\n     * - containerParams (an object that holds parameters to affect the container of the isolated tree, e.g. width, height etc)\n     */\n    function HTMLFragmentContextHandler() {\n      var _this;\n\n      var originalProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      _classCallCheck(this, HTMLFragmentContextHandler);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(HTMLFragmentContextHandler).call(this));\n\n      var props = _objectSpread2({}, originalProps);\n\n      if (!isObject(props)) {\n        helper.error(\"HTMLFragmentContextHandler expects an object on its constructor. \".concat(_typeof(props), \" passed\"));\n        return _possibleConstructorReturn(_this, false);\n      }\n\n      if (!Object.prototype.hasOwnProperty.call(props, 'html')) {\n        props.html = '';\n      }\n\n      _this.isDOM = true;\n      var fragment = document.createDocumentFragment();\n      var wrapper = document.createElement('div');\n\n      if (Object.prototype.hasOwnProperty.call(props, 'containerParams')) {\n        if (Object.prototype.hasOwnProperty.call(props, 'width')) {\n          wrapper.style.width = props.containerParams.width;\n        }\n\n        if (Object.prototype.hasOwnProperty.call(props, 'height')) {\n          wrapper.style.height = props.containerParams.height;\n        }\n      }\n\n      wrapper.innerHTML = renderTemplate(props.html, {\n        params: props.initParams\n      });\n      fragment.appendChild(wrapper);\n      wrapper.style.overflow = 'hidden';\n      _this.rootElement = wrapper;\n      /* TODO make the context definition more generic so always the setCustomEntity gets set\n          along with the rest of the required methods, so it can be used on the afterRender method\n          of the DOMClip.\n          The Clip will expose a method \"setCustomEntity\" that will set custom entities.\n          TEST\n          */\n\n      _this.context = {\n        document: document,\n        window: window,\n        clipContainer: _this.rootElement,\n        rootElement: wrapper,\n        unmount: function unmount() {\n          props.host.removeChild(fragment);\n        },\n        getElements: _this.getElements.bind(_assertThisInitialized(_this)),\n        getMCID: _this.getMCID.bind(_assertThisInitialized(_this)),\n        setMCID: _this.setMCID.bind(_assertThisInitialized(_this)),\n        getElementSelectorByMCID: _this.getElementSelectorByMCID.bind(_assertThisInitialized(_this)),\n        getElementByMCID: _this.getElementByMCID.bind(_assertThisInitialized(_this)),\n        setCustomEntity: _this.setCustomEntity.bind(_assertThisInitialized(_this)),\n        fragment: true\n      };\n      _this.elementsByMCID = {};\n      return _this;\n    }\n\n    return HTMLFragmentContextHandler;\n  }(ContextHandler);\n\n  var FragmentedClip =\n  /*#__PURE__*/\n  function (_ExtendableClip) {\n    _inherits(FragmentedClip, _ExtendableClip);\n\n    function FragmentedClip() {\n      var _this;\n\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var oldProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      _classCallCheck(this, FragmentedClip);\n\n      var attrsToPass;\n      var propsToUse;\n      /*\n          backwards compatibility. If the user doesn't pass a second argument on the constructor then this is\n          the new way of initialising a Group (only props).\n          */\n\n      if (oldProps === null) {\n        attrsToPass = {};\n        propsToUse = props;\n      } else {\n        // else, in case the user has passed two arguments then both should be used\n        attrsToPass = props;\n        propsToUse = oldProps;\n      }\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(FragmentedClip).call(this, attrsToPass, propsToUse));\n      var contextHanlder = new HTMLFragmentContextHandler(_objectSpread2({}, propsToUse, {\n        html: Object.prototype.hasOwnProperty.call(propsToUse, 'html') ? propsToUse.html : _this.html,\n        css: Object.prototype.hasOwnProperty.call(propsToUse, 'css') ? propsToUse.css : _this.css,\n        fonts: Object.prototype.hasOwnProperty.call(propsToUse, 'fonts') ? propsToUse.fonts : _this.fonts\n      }));\n      _this.ownContext = _objectSpread2({}, contextHanlder.context, {\n        isHostedClip: false\n      });\n      _this.iframe = contextHanlder.iframeElement;\n      _this.forceExportIncidents = true;\n\n      _this.onDOMCLipInitialise(); // as soon as a Fragmented Clip is been intialised that means the Descriptive\n      // Clip has a selector and not a host. Thus is not a hosted clip\n      // this.isHostedClip = false;\n\n\n      return _this;\n    }\n\n    _createClass(FragmentedClip, [{\n      key: \"exportConstructionArguments\",\n      value: function exportConstructionArguments() {\n        // TODO also export CSS and fonts taking in account the potential existance\n        // of them on the get methods\n        // console.log(this.ownContext.rootElement.innerHTML);\n        return {\n          attrs: this.attrs,\n          props: _objectSpread2({}, this.props, {\n            html: this.ownContext.rootElement.innerHTML\n          })\n        };\n      }\n    }, {\n      key: \"onDOMCLipInitialise\",\n      value: function onDOMCLipInitialise() {// implement here\n      }\n    }, {\n      key: \"rootElement\",\n      get: function get() {\n        return this.ownContext.clipContainer;\n      }\n    }]);\n\n    return FragmentedClip;\n  }(ExtendableClip);\n\n  var NullClip =\n  /*#__PURE__*/\n  function () {\n    function NullClip() {\n      _classCallCheck(this, NullClip);\n    }\n\n    _createClass(NullClip, [{\n      key: \"addIncident\",\n      value: function addIncident() {\n        return {\n          result: true,\n          execute: function execute() {}\n        };\n      }\n    }, {\n      key: \"moveIncident\",\n      value: function moveIncident() {\n        return {\n          result: true,\n          execute: function execute() {}\n        };\n      }\n    }, {\n      key: \"removeIncident\",\n      value: function removeIncident() {\n        return {\n          result: true,\n          execute: function execute() {}\n        };\n      }\n    }, {\n      key: \"resizeIncident\",\n      value: function resizeIncident() {\n        return {\n          result: true,\n          execute: function execute() {}\n        };\n      }\n    }, {\n      key: \"getIncidentsByChannel\",\n      value: function getIncidentsByChannel() {\n        return {};\n      }\n    }, {\n      key: \"flash\",\n      value: function flash() {}\n    }, {\n      key: \"_resize\",\n      value: function _resize() {}\n    }, {\n      key: \"onProgress\",\n      value: function onProgress() {}\n    }, {\n      key: \"duration\",\n      get: function get() {\n        return 0;\n      }\n    }]);\n\n    return NullClip;\n  }();\n\n  var easingRule = [{\n    type: 'string',\n    optional: true,\n    default: 'linear',\n    enum: ['linear', 'easeInQuad', 'easeOutQuad', 'easeInOutQuad', 'easeInCubic', 'easeOutCubic', 'easeInOutCubic', 'easeInQuart', 'easeOutQuart', 'easeInOutQuart', 'easeInQuint', 'easeOutQuint', 'easeInOutQuint', 'easeInSine', 'easeOutSine', 'easeInOutSine', 'easeInExpo', 'easeOutExpo', 'easeInOutExpo', 'easeInCirc', 'easeOutCirc', 'easeInOutCirc', 'easeInElastic', 'easeOutElastic', 'easeInOutElastic', 'easeInBack', 'easeOutBack', 'easeInOutBack', 'easeInBounce', 'easeOutBounce', 'easeInOutBounce']\n  }, {\n    type: 'array',\n    optional: true,\n    length: 4,\n    items: {\n      type: 'number'\n    }\n  }];\n  var idRule = {\n    type: 'string',\n    optional: true\n  };\n  var selectorRule = {\n    type: 'string',\n    optional: false\n  };\n  var hostRule = {\n    type: 'any',\n    optional: false\n  };\n  var durationRule = {\n    type: 'number',\n    optional: false,\n    integer: true,\n    positive: true\n  };\n  var optionalStringRule = {\n    type: 'string',\n    optional: true\n  };\n  var fontsRule = {\n    type: 'array',\n    optional: true,\n    itams: {\n      type: 'object',\n      props: {\n        type: 'string',\n        url: 'string'\n      }\n    }\n  };\n  var audioSourcesRule = {\n    type: 'array',\n    items: {\n      type: 'object',\n      strict: true,\n      props: {\n        src: 'string',\n        id: 'string',\n        mcid: {\n          type: 'string',\n          optional: true\n        },\n        classes: {\n          type: 'array',\n          optional: true,\n          items: 'string'\n        },\n        base64: {\n          type: 'boolean',\n          optional: true\n        }\n      }\n    },\n    optional: true\n  };\n  var incidentPropsRule = {\n    props: {\n      type: 'object',\n      props: {\n        id: idRule,\n        selector: _objectSpread2({}, selectorRule, {\n          optional: true\n        }),\n        // can have no selector as it might inherit it from Group\n        easing: easingRule,\n        duration: durationRule,\n        startFrom: {\n          type: 'number',\n          integer: true,\n          min: 0,\n          optional: true\n        },\n        repeats: {\n          type: 'number',\n          integer: true,\n          min: 1,\n          optional: true\n        },\n        hiatus: {\n          type: 'number',\n          integer: true,\n          min: 0,\n          optional: true\n        },\n        delay: {\n          type: 'number',\n          integer: true,\n          min: 0,\n          optional: true\n        }\n      }\n    }\n  };\n  var containerParamsRule = {\n    type: 'object',\n    optional: true,\n    props: {\n      width: {\n        type: 'string',\n        optional: true\n      },\n      height: {\n        type: 'string',\n        optional: true\n      }\n    }\n  };\n  var audioOnClipsRule = {\n    type: 'string',\n    enum: ['on', 'off'],\n    optional: true\n  };\n  var clipPropsRule = {\n    props: [{\n      type: 'object',\n      strict: true,\n      props: {\n        id: idRule,\n        selector: _objectSpread2({}, selectorRule, {\n          optional: true\n        }),\n        easing: easingRule,\n        html: optionalStringRule,\n        css: optionalStringRule,\n        audioSources: audioSourcesRule,\n        audio: audioOnClipsRule,\n        containerParams: containerParamsRule,\n        fonts: fontsRule\n      }\n    }, {\n      type: 'object',\n      strict: true,\n      props: {\n        id: idRule,\n        host: hostRule,\n        html: optionalStringRule,\n        css: optionalStringRule,\n        audioSources: audioSourcesRule,\n        audio: audioOnClipsRule,\n        containerParams: containerParamsRule,\n        fonts: fontsRule\n      }\n    }, {\n      type: 'object',\n      strict: true,\n      props: {\n        root: {\n          type: 'boolean',\n          optional: true\n        },\n        id: idRule,\n        audioSources: audioSourcesRule,\n        audio: _objectSpread2({}, audioOnClipsRule, {\n          enum: ['on']\n        })\n      }\n    }]\n  };\n  var groupPropsRule = {\n    selector: _objectSpread2({}, selectorRule, {\n      optional: true,\n      strict: true\n    })\n  };\n\n  var _TARGETTYPES = {\n    _DECISIONAUTHORITY: 'mc.descriptive.decisionAuthority'\n  };\n\n  function editAttributes(payload) {\n    payload.descriptor.value = function editAttributesFunct(newAttrs) {\n      var checkIfBelongsToClip = this.putMessageOnPipe('checkForClip', {}, _TARGETTYPES._DECISIONAUTHORITY, {\n        selfExecute: true,\n        direction: _DIRECTIONS._UP\n      });\n\n      if (checkIfBelongsToClip.response === true) {\n        // if the Group belongs on a Clip\n        return this.manageEditAttrProps(newAttrs, 'attrs');\n      }\n\n      this.attrs = newAttrs;\n      return {\n        result: true\n      };\n    };\n  }\n\n  function editProperties(payload) {\n    payload.descriptor.value = function editPropertiesFunct(newProps) {\n      var valitation = helper.validateProps({\n        props: newProps\n      }, this.propsValidationRules, this.constructor);\n\n      if (!valitation.result) {\n        return valitation;\n      }\n\n      var checkIfBelongsToClip = this.putMessageOnPipe('checkForClip', {}, _TARGETTYPES._DECISIONAUTHORITY, {\n        selfExecute: true,\n        direction: _DIRECTIONS._UP\n      });\n\n      if (checkIfBelongsToClip.response === true) {\n        // if the Group belongs on a Clip\n        return this.manageEditAttrProps(newProps, 'props');\n      }\n\n      this.props = newProps;\n      return {\n        result: true\n      };\n    };\n  }\n\n  function getElements(payload) {\n    payload.descriptor.value = function getElementsFunct() {\n      if (this.props.host !== null && this.props.host !== undefined) {\n        return [this.props.host];\n      }\n\n      if (!this.hasParent) {\n        return [];\n      }\n\n      var checkIfBelongsToClip = this.putMessageOnPipe('checkForClip', {}, _TARGETTYPES._DECISIONAUTHORITY, {\n        selfExecute: true,\n        direction: _DIRECTIONS._UP\n      });\n\n      if (checkIfBelongsToClip.response === false) {\n        return [];\n      }\n\n      var elementsResponse = this.putMessageOnPipe('getElements', {\n        selector: this.selector()\n      }, _TARGETTYPES._DECISIONAUTHORITY, {\n        selfExecute: false,\n        direction: _DIRECTIONS._UP\n      });\n      return elementsResponse.response;\n    };\n  }\n\n  /**\n   * resize method resizes the Incident by maintaining proportions between delay, duraiton and hiatus.\n   * also, the new duration will be the full new duration of the Incident taking in considration\n   * all delay, duration and hiatus along with repeats\n   * */\n\n  function resize(payload) {\n    payload.descriptor.value = function resizeFunct(newSize) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        check: true\n      };\n\n      if (newSize === this.duration) {\n        return {\n          result: true,\n          meta: {\n            unprocessed: true\n          }\n        };\n      }\n\n      if (newSize <= 0) {\n        return {\n          result: false,\n          reason: 'Size must always be > 0'\n        };\n      }\n\n      if (options.check === true && this.hasParent) {\n        var mcCheck = this.putMessageOnPipe('checkResize', {\n          id: this.id,\n          newSize: newSize,\n          fraction: newSize / this.duration\n        }, _TARGETTYPES._DECISIONAUTHORITY, {\n          selfExecute: false,\n          direction: _DIRECTIONS._UP\n        });\n\n        if (mcCheck.response.result === false) {\n          return mcCheck.response;\n        }\n      }\n\n      this.setNewDuration(newSize);\n      return {\n        result: true\n      };\n    };\n  }\n\n  function selector(payload) {\n    payload.descriptor.value = function selectorFunct() {\n      if (this.inheritedSelector === null) {\n        // if the Incident has no parent selector inherited\n        if (!Object.prototype.hasOwnProperty.call(this.props, 'selector')) {\n          // and does not have a selector neither\n          return null; // then its selector is null\n        }\n\n        return this.props.selector; // else, if it has a selector that's its final selector\n      } // else if there is an inherited selector\n\n\n      if (!Object.prototype.hasOwnProperty.call(this.props, 'selector')) {\n        // and does not have a selector of its own\n        return this.inheritedSelector; // then its selector is equal to the inherited selector\n      } // else, if it both has an inherited and an own selector\n\n\n      if (this.props.selector.charAt(0) === '&') {\n        return this.inheritedSelector + this.props.selector.substring(1);\n      }\n\n      return \"\".concat(this.inheritedSelector, \" \").concat(this.props.selector);\n    };\n  }\n\n  var DescriptiveGroup = _decorate(null, function (_initialize, _Node) {\n    var DescriptiveGroup =\n    /*#__PURE__*/\n    function (_Node2) {\n      _inherits(DescriptiveGroup, _Node2);\n\n      function DescriptiveGroup() {\n        var _this;\n\n        var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n        _classCallCheck(this, DescriptiveGroup);\n\n        if (props === null) {\n          _this = _possibleConstructorReturn(this, _getPrototypeOf(DescriptiveGroup).call(this, attrs));\n\n          _initialize(_assertThisInitialized(_this));\n\n          _this.attrs = {};\n          _this.props = attrs;\n        } else {\n          _this = _possibleConstructorReturn(this, _getPrototypeOf(DescriptiveGroup).call(this, props));\n\n          _initialize(_assertThisInitialized(_this));\n\n          _this.attrs = attrs;\n          _this.props = props;\n        }\n\n        var propsValidation = helper.validateProps(_this.props, groupPropsRule, _this.constructor);\n\n        if (propsValidation.result === false) {\n          return _possibleConstructorReturn(_this, propsValidation);\n        }\n\n        _this.attrsValidationRules = {};\n        _this.propsValidationRules = groupPropsRule;\n        _this._inheritedSelector = null; // passiveAddition is a flag property indicating that any Incident to be\n        // added to the Clip will be passive. It initialises with value = false\n        // on DescriptiveGroup where it's originaly defined.\n        // Here we change its value just before the buildTree method execution\n        // so all Incidents added on it get the \"passive\" flag and don't get\n        // exported on the exportDefinition method. Once the buildTree method\n        // finishes we set it back to its original value (false)\n\n        _this.passiveAddition = true;\n\n        _this._buildTree();\n\n        _this.passiveAddition = false;\n        return _possibleConstructorReturn(_this);\n      }\n\n      return DescriptiveGroup;\n    }(_Node);\n\n    return {\n      F: DescriptiveGroup,\n      d: [{\n        kind: \"field\",\n        static: true,\n        key: \"Incident\",\n        value: function value() {\n          return Group;\n        }\n      }, {\n        kind: \"field\",\n        static: true,\n        key: \"plugin_npm_name\",\n        value: function value() {\n          return 'motor-cortex-js';\n        }\n      }, {\n        kind: \"field\",\n        static: true,\n        key: \"Channel\",\n        value: function value() {\n          return Channel;\n        }\n      }, {\n        kind: \"field\",\n        static: true,\n        key: \"ClassName\",\n        value: function value() {\n          return 'Group';\n        }\n      }, {\n        kind: \"field\",\n        static: true,\n        key: \"isGroup\",\n        value: function value() {\n          return true;\n        }\n      }, {\n        kind: \"method\",\n        decorators: [editAttributes],\n        key: \"editAttributes\",\n        value: function editAttributes() {}\n      }, {\n        kind: \"method\",\n        decorators: [editProperties],\n        key: \"editProperties\",\n        value: function editProperties() {}\n      }, {\n        kind: \"method\",\n        decorators: [resize],\n        key: \"resize\",\n        value: function resize() {}\n      }, {\n        kind: \"method\",\n        decorators: [selector],\n        key: \"selector\",\n        value: function selector() {}\n      }, {\n        kind: \"method\",\n        decorators: [getElements],\n        key: \"getElements\",\n        value: function getElements() {}\n      }, {\n        kind: \"method\",\n        key: \"_buildTree\",\n        value: function _buildTree() {\n          this.buildTree();\n        }\n      }, {\n        kind: \"method\",\n        key: \"_rebuildTree\",\n        value: function _rebuildTree() {\n          // remove all direct passive incidents as they might be dependent on the edited attrs/props\n          for (var id in this.children) {\n            var theChild = this.children[id];\n\n            if (theChild.leaf.passive === true) {\n              this.removeIncident(theChild.id);\n            }\n          } // run buildTree again\n\n\n          this.passiveAddition = true;\n          this.buildTree();\n          this.passiveAddition = false;\n        }\n      }, {\n        kind: \"method\",\n        key: \"buildTree\",\n        value: function buildTree() {}\n      }, {\n        kind: \"method\",\n        key: \"manageEditAttrProps\",\n        value: function manageEditAttrProps(newAttrs, type) {\n          // get a permanent reference to its parent node\n          var parentNode = this.parentNode; // get the position of the Incident within its parent\n\n          var position = parentNode.getLeafPosition(this.id); // keep a backup of the current attrs / props\n\n          var oldAttrs = JSON.parse(JSON.stringify(this[type]));\n          this[type] = newAttrs; // first detach the Incident from its parent\n\n          parentNode.removeIncident(this.id); // remove all direct passive incidents as they might be dependent on the edited attrs/props\n\n          this._rebuildTree(); // try to add the altered Group\n\n\n          var res = parentNode.addIncident(this, position);\n\n          if (res.result === false) {\n            this[type] = oldAttrs;\n\n            this._rebuildTree();\n\n            parentNode.addIncident(this, position);\n            return res;\n          }\n\n          return res;\n        }\n      }, {\n        kind: \"method\",\n        key: \"detachFromParent\",\n        value: function detachFromParent() {\n          _get(_getPrototypeOf(DescriptiveGroup.prototype), \"detachFromParent\", this).call(this);\n\n          this.inheritedSelector = null;\n        }\n      }, {\n        kind: \"get\",\n        key: \"inheritedSelector\",\n        value: function inheritedSelector() {\n          return this._inheritedSelector;\n        }\n      }, {\n        kind: \"set\",\n        key: \"inheritedSelector\",\n        value: function inheritedSelector(value) {\n          this._inheritedSelector = value;\n\n          for (var id in this.children) {\n            var theChild = this.children[id].leaf;\n            theChild.inheritedSelector = this.selector();\n          }\n        }\n      }, {\n        kind: \"get\",\n        key: \"selectorToPassToChildren\",\n        value: function selectorToPassToChildren() {\n          return this.selector();\n        }\n        /**\n         * The purpose of this method is to export a portable definition that can be\n         * later used in order to rebuild the Inicdent at any time\n         */\n\n      }, {\n        kind: \"method\",\n        key: \"exportDefinition\",\n        value: function exportDefinition() {\n          var toReturn = {\n            ClassName: this.constructor.ClassName,\n            plugin_npm_name: this.constructor.plugin_npm_name,\n            attrs: this.attrs,\n            props: this.props,\n            incidents: {},\n            duration: this.duration\n          };\n\n          for (var id in this.children) {\n            var theChild = this.children[id];\n\n            if (theChild.leaf.passive === true) {\n              continue;\n            }\n\n            toReturn.incidents[id] = {\n              id: theChild.id,\n              position: theChild.position,\n              leaf: theChild.leaf.exportDefinition()\n            };\n          }\n\n          return toReturn;\n        }\n        /**\n         * The purpose of this method is to export an object with \"live\" / real reference\n         * to the Class of the Incident so it can directly by used for Clip creation\n         * */\n\n      }, {\n        kind: \"method\",\n        key: \"exportLiveDefinition\",\n        value: function exportLiveDefinition() {\n          var toReturn = {\n            Class: this.constructor,\n            attrs: JSON.parse(JSON.stringify(this.attrs)),\n            props: JSON.parse(JSON.stringify(this.props)),\n            incidents: {}\n          };\n\n          for (var id in this.children) {\n            var theChild = this.children[id];\n\n            if (theChild.leaf.passive === true) {\n              continue;\n            }\n\n            toReturn.incidents[id] = {\n              id: theChild.id,\n              position: theChild.position,\n              leaf: theChild.leaf.exportLiveDefinition()\n            };\n          }\n\n          return toReturn;\n        }\n      }, {\n        kind: \"method\",\n        key: \"addIncident\",\n        value: function addIncident(descriptiveIncident, position) {\n          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n            check: true\n          };\n          descriptiveIncident.inheritedSelector = this.selectorToPassToChildren;\n\n          if (options.check === true) {\n            var initialCheck = _get(_getPrototypeOf(DescriptiveGroup.prototype), \"checkAddition\", this).call(this, descriptiveIncident, position);\n\n            if (initialCheck.result === false) {\n              descriptiveIncident.inheritedSelector = null;\n              return initialCheck;\n            }\n            /* Check for null or relative selector Incidents with no inherited selector */\n\n\n            var checkIfBelongsToClip = this.putMessageOnPipe('checkForClip', {}, _TARGETTYPES._DECISIONAUTHORITY, {\n              selfExecute: true,\n              direction: _DIRECTIONS._UP\n            });\n\n            if (checkIfBelongsToClip.response === true) {\n              // if the Group belongs on a Clip\n              var selectorsCheck = descriptiveIncident.putMessageOnPipe('checkForInvalidSelectors', {}, null, {\n                selfExecute: true,\n                direction: _DIRECTIONS._DOWN\n              });\n\n              if (selectorsCheck.length > 0) {\n                var errors = [];\n\n                for (var i = 0; i < selectorsCheck.length; i++) {\n                  errors.push(selectorsCheck[i].response);\n                }\n\n                return {\n                  result: false,\n                  errors: errors\n                };\n              }\n            } // sends the check request to its root, either a headless root or a Descriptive Clip\n\n\n            var mcCheck = this.putMessageOnPipe('checkAddition', {\n              incident: descriptiveIncident,\n              millisecond: position,\n              parentGroupId: this.id\n            }, _TARGETTYPES._DECISIONAUTHORITY, {\n              selfExecute: true,\n              direction: _DIRECTIONS._UP\n            });\n\n            if (mcCheck.response.result === false) {\n              descriptiveIncident.inheritedSelector = null;\n              return mcCheck.response;\n            }\n          } // if the passiveAddition flag is true we set the passive flag of the Incident\n          // to true before adding it to our Group\n\n\n          if (this.passiveAddition === true) {\n            descriptiveIncident.passive = true;\n          }\n\n          var res = this.addChild(descriptiveIncident, position);\n\n          if (res.result === false) {\n            descriptiveIncident.inheritedSelector = null;\n          }\n\n          return res;\n        }\n        /**\n         * @param input - can either be object or id\n         * */\n\n      }, {\n        kind: \"method\",\n        key: \"moveIncident\",\n        value: function moveIncident(input, position) {\n          var id = input;\n\n          if (_typeof(input) === 'object') {\n            id = input.id;\n          }\n\n          var initialCheck = _get(_getPrototypeOf(DescriptiveGroup.prototype), \"checkEditPosition\", this).call(this, id, position);\n\n          if (initialCheck.result === false) {\n            return initialCheck;\n          }\n\n          var originalPosition = this.getLeafPosition(id);\n          var positionDelta = position - originalPosition;\n\n          if (positionDelta === 0) {\n            return {\n              result: true\n            };\n          }\n\n          var mcCheck = this.putMessageOnPipe('checkMove', {\n            id: id,\n            millisecond: position,\n            positionDelta: positionDelta,\n            parentGroupId: this.id\n          }, _TARGETTYPES._DECISIONAUTHORITY, {\n            selfExecute: true,\n            direction: _DIRECTIONS._UP\n          });\n\n          if (mcCheck.response.result === false) {\n            return mcCheck.response;\n          }\n\n          var res = this.editPosition(id, position);\n          return res;\n        }\n      }, {\n        kind: \"method\",\n        key: \"removeIncident\",\n        value: function removeIncident(input) {\n          var id = input;\n\n          if (_typeof(input) === 'object') {\n            id = input.id;\n          }\n\n          var initialCheck = _get(_getPrototypeOf(DescriptiveGroup.prototype), \"checkRemoveChild\", this).call(this, id);\n\n          if (initialCheck.result === false) {\n            return initialCheck;\n          }\n\n          var mcCheck = this.putMessageOnPipe('checkDeletion', {\n            id: id,\n            parentGroupId: this.id\n          }, _TARGETTYPES._DECISIONAUTHORITY, {\n            selfExecute: true,\n            direction: _DIRECTIONS._UP\n          });\n\n          if (mcCheck.response.result === false) {\n            return mcCheck.response;\n          }\n\n          var res = this.removeChild(id);\n          return res;\n        }\n        /** ************************* HANDLING METHODS ****************************** */\n        // eslint-disable-next-line no-unused-vars\n\n      }, {\n        kind: \"method\",\n        key: \"handleCheckForClip\",\n        value: function handleCheckForClip(target, payload) {\n          if (this.hasParent) {\n            return this.bypass();\n          }\n\n          return false;\n        } // eslint-disable-next-line no-unused-vars\n\n      }, {\n        kind: \"method\",\n        key: \"handleCheckAddition\",\n        value: function handleCheckAddition(target, payload) {\n          /*\n              The DescriptiveGroup handles the checkAddition command which has the UP\n              direction. If the DG has a parent it forwards the command to it. If not\n              it just returns true, as it is a deadless tree\n              */\n          if (this.hasParent) {\n            return this.bypass();\n          }\n\n          return {\n            result: true\n          };\n        } // eslint-disable-next-line no-unused-vars\n\n      }, {\n        kind: \"method\",\n        key: \"handleCheckMove\",\n        value: function handleCheckMove(target, payload) {\n          if (this.hasParent) {\n            return this.bypass();\n          }\n\n          return {\n            result: true\n          };\n        } // eslint-disable-next-line no-unused-vars\n\n      }, {\n        kind: \"method\",\n        key: \"handleCheckDeletion\",\n        value: function handleCheckDeletion(target, payload) {\n          if (this.hasParent) {\n            return this.bypass();\n          }\n\n          return {\n            result: true\n          };\n        } // eslint-disable-next-line no-unused-vars\n\n      }, {\n        kind: \"method\",\n        key: \"handleCheckResize\",\n        value: function handleCheckResize(target, payload) {\n          if (this.hasParent) {\n            return this.bypass();\n          }\n\n          return {\n            result: true\n          };\n        }\n      }]\n    };\n  }, Node);\n\n  var Playable =\n  /*#__PURE__*/\n  function (_DescriptiveGroup) {\n    _inherits(Playable, _DescriptiveGroup);\n\n    function Playable(attrs, props) {\n      var _this;\n\n      _classCallCheck(this, Playable);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(Playable).call(this, attrs, props));\n      _this.runTimeInfo = {\n        currentMillisecond: 0,\n        state: 'idle' // supported states: idle, playing, paused, blocked, armed\n\n      };\n      /**\n            @member {object} - listeners are functions to be executed on time change of the Clip.\n            It has the following format:\n           listeners: {\n              listener_id: {\n                       funct : the function to be executed\n                       threshold : the threshold of delta\n                       roundTo : round millisecond\n                   },\n                   listener_id: {\n                       funct : the function to be executed\n                       threshold : the threshold of delta\n                       roundTo : round millisecond\n                   },\n                   ...\n             }\n             */\n\n      _this.listeners = {}; // previousTimeStamp is a property holding the last timestamp that the\n      // requestAnimationFrame ran\n\n      _this.previousTimeStamp = -1;\n      _this.speed = 1;\n      return _this;\n    }\n    /** ********************* execution methods  *********************\n     *************************************************************** */\n\n\n    _createClass(Playable, [{\n      key: \"_setState\",\n      value: function _setState(newState) {\n        if (newState !== this.runTimeInfo.state) {\n          this.runTimeInfo.state = newState; // the only timer and the only responsible for Clip execution is the Clip\n          // All Incidents contained on a Clip are been executed by the Clip itself via its channels.\n          // Thus, the only Incidents that need to know about the state of the root Clip\n          // at any time are only the Clips\n\n          this.putMessageOnPipe('setState', newState, 'Clips', {\n            selfExecute: false,\n            direction: _DIRECTIONS._DOWN\n          });\n\n          for (var key in this.listeners) {\n            var listner = this.listeners[key];\n            listner.funct(this.runTimeInfo.currentMillisecond, newState);\n          }\n        }\n      }\n    }, {\n      key: \"handleSetState\",\n      value: function handleSetState(target, payload) {\n        this._setState(payload);\n      } // execution methods\n\n    }, {\n      key: \"play\",\n      value: function play() {\n        var _this2 = this;\n\n        var debug = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n        if (this.runTimeInfo.state === 'idle' || this.runTimeInfo.state === 'paused' || this.runTimeInfo.state === 'armed' || this.runTimeInfo.state === 'transitional' || this.runTimeInfo.state === 'blocked') {\n          if (this.runTimeInfo.state === 'paused') {\n            var delta = new Date().getTime() - this.pauseMoment;\n            this.previousTimeStamp += delta;\n          }\n\n          this._setState('playing');\n\n          this.onPlay();\n\n          if (debug === false) {\n            window.requestAnimationFrame(function (timestamp) {\n              _this2.step(timestamp);\n            });\n          }\n        }\n      }\n    }, {\n      key: \"pause\",\n      value: function pause() {\n        if (this.runTimeInfo.state === 'playing') {\n          this._setState('paused');\n\n          this.pauseMoment = new Date().getTime();\n          this.onWait();\n        }\n      }\n      /* armed state means the Clip is on paused state after transition */\n\n    }, {\n      key: \"arm\",\n      value: function arm() {\n        if (this.runTimeInfo.state === 'transitional') {\n          this._setState('armed');\n        }\n      }\n    }, {\n      key: \"complete\",\n      value: function complete() {\n        this._setState('idle');\n\n        this.previousTimeStamp = -1;\n      }\n      /* in order to start a journey via the TimeCapsule the Playable needs first to stop */\n\n    }, {\n      key: \"stop\",\n      value: function stop() {\n        this._setState('transitional');\n\n        this.previousTimeStamp = -1;\n      }\n    }, {\n      key: \"block\",\n      value: function block() {\n        this._setState('blocked');\n\n        this.previousTimeStamp = -1;\n      }\n    }, {\n      key: \"onPlay\",\n      value: function onPlay() {}\n    }, {\n      key: \"onWait\",\n      value: function onWait() {}\n    }, {\n      key: \"playableProgress\",\n      value: function playableProgress(fraction, millisecond) {\n        if (this.isTheRootClip) {\n          for (var key in this.listeners) {\n            var listner = this.listeners[key]; // if the listener is only for state change continue\n\n            if (listner.onlyOnStateChange === true) {\n              continue;\n            } // console.log(`Math.abs(${milliseconds} + ${listner.cavaDelta} - ${this.runTimeInfo.currentMillisecond}) > ${listner.threshold}`);\n\n\n            if (Math.abs(millisecond + listner.cavaDelta - this.runTimeInfo.currentMillisecond) > listner.threshold) {\n              listner.funct(roundNumberTo(millisecond, listner.roundTo), this.runTimeInfo.state);\n              listner.cavaDelta = 0;\n            } else {\n              listner.cavaDelta += Math.abs(millisecond - this.runTimeInfo.currentMillisecond);\n            }\n          }\n\n          this.onProgress(fraction, millisecond);\n          this.runTimeInfo.currentMillisecond = millisecond;\n          return true;\n        }\n\n        return false;\n      }\n    }, {\n      key: \"step\",\n      // *******************************************************\n      // STEP FUNCTION\n      value: function step(timestamp) {\n        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n        if (this.runTimeInfo.state !== 'playing') {\n          return;\n        }\n\n        var that = this;\n\n        if (this.previousTimeStamp === -1) {\n          this.previousTimeStamp = timestamp;\n        } // progressStep is the progress made from previousTimeStamp both in milliseconds and in fraction [0 to 1]\n\n\n        var progress = {\n          milliseconds: Math.round(this.runTimeInfo.currentMillisecond + (timestamp - this.previousTimeStamp) * this.speed),\n          fraction: (this.runTimeInfo.currentMillisecond + (timestamp - this.previousTimeStamp) * this.speed) / this.duration\n        };\n\n        if (progress.fraction >= 1) {\n          this.playableProgress(1, this.duration);\n          this.complete();\n          return;\n        }\n\n        if (progress.fraction < 0) {\n          this.playableProgress(0, 0);\n          this.complete(); // this.broadcastEvent('state-change', { oldState: \"playing\", newState: \"idle\" });\n\n          return;\n        }\n\n        this.playableProgress(progress.fraction, progress.milliseconds);\n        this.previousTimeStamp = timestamp;\n\n        if (debug === false) {\n          window.requestAnimationFrame(that.step.bind(that));\n        }\n      } // ************ PUB SUB ********************\n      // *****************************************\n\n      /**\n          By subscribing a module can get notified about changes on the Clip's time\n          subscribe method subscribes a function to the time change dispatcher. As Clip uses requestAnimationFrame for its timing\n          each cyrcle / step gets the current time and subtracts the previous time so it know how many milliseconds has elapsed\n          since last step. Subscribers can set to get informed about time changes only if the delta is greater than a given\n          number (e.g. greater than 300ms). That property is passed as the second argument \"threshold\".\n          Finally if any of the subscribers want the Scene to provide back a rounded number of the milliseconds. Options:\n            - 1 (round it on its actual units\n           - 10 (round it on tenths)\n           - 100 (round it on hundreds)\n           - 1000 (round it on thousands)\n          the first argument provides an id to the listener for future reference (deletion etc)\n          the second argument is a function that takes two arguments: millisecond, state (current millisecond of the Scene\n          and the state of it  */\n\n    }, {\n      key: \"subscribe\",\n      value: function subscribe(id, funct, threshold, roundTo) {\n        var onlyOnStateChange = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n        if (!threshold) {\n          threshold = 0;\n        }\n\n        if (!roundTo) {\n          roundTo = 1; // round second to its units, meaning leave it as it is\n        }\n\n        this.listeners[id] = {\n          funct: funct,\n          threshold: threshold,\n          roundTo: roundTo,\n          cavaDelta: 0,\n          onlyOnStateChange: onlyOnStateChange\n        };\n      }\n    }, {\n      key: \"unsubscribe\",\n      value: function unsubscribe(id) {\n        if (Object.prototype.hasOwnProperty.call(this.listeners, id)) {\n          delete this.listeners[id];\n        }\n      }\n    }, {\n      key: \"subscribeToDurationChange\",\n      value: function subscribeToDurationChange(funct) {\n        if (this.isTheRootClip) {\n          this.realClip.subscribeToDurationChange(funct);\n          return true;\n        }\n\n        return false;\n      }\n    }, {\n      key: \"executionSpeed\",\n      set: function set(speed) {\n        if (!this.isTheRootClip) {\n          return false;\n        }\n\n        this.speed = parseFloat(speed);\n      }\n    }]);\n\n    return Playable;\n  }(DescriptiveGroup);\n\n  /*\n  dna: {\n      host\n      descriptiveIncident\n  }\n  */\n\n  var ClipClone =\n  /*#__PURE__*/\n  function () {\n    function ClipClone(dna) {\n      _classCallCheck(this, ClipClone);\n\n      this.runTimeInfo = {\n        currentMillisecond: 0,\n        state: 'transitional'\n      };\n      this.id = getAnId();\n      this.realClip = dna.descriptiveIncident.realClip; // In order to render itself on the given element first it needs the props (including html and css)\n      // from the real Clip it copies\n\n      var constructionArgs = dna.descriptiveIncident.realClip.exportConstructionArguments(); // it properly sets its own host on the props to use to initialise its own clip\n\n      var hostedProps = _objectSpread2({}, constructionArgs.props, {\n        selector: undefined,\n        host: dna.host,\n        id: this.id\n      }); // we create a clip because Clips on creation render and thus have their own context\n\n\n      this.ownClip = new dna.descriptiveIncident.constructor.Incident(constructionArgs.attrs, hostedProps); // flushes the realClip with its ownClip's context\n\n      dna.descriptiveIncident.realClip.addContext({\n        clipId: this.id,\n        context: this.ownClip.ownContext,\n        synchronize: dna.synchronize,\n        runTimeInfo: this.runTimeInfo\n      }, true);\n    } // eslint-disable-next-line no-unused-vars\n\n\n    _createClass(ClipClone, [{\n      key: \"onProgress\",\n      value: function onProgress(fraction, milliseconds) {\n\n        for (var key in this.realClip.instantiatedChannels) {\n          var channel = this.realClip.instantiatedChannels[key];\n          channel.moveTo(this.runTimeInfo.currentMillisecond, milliseconds, this.id, true);\n        }\n\n        this.runTimeInfo.currentMillisecond = milliseconds;\n      }\n    }]);\n\n    return ClipClone;\n  }();\n\n  /**\n   * Along with the expected props for the Clip on the props support the audio key.\n   * The audio can take one of the 3 following values:\n   * - \"on\": The Clip has audio enabled\n   * - \"off\": The Clip has audio disabled\n   * - \"only\": The Clip is only audio\n   *\n   * Also, in the case audio is on or only the user should pass the \"audioSources\"\n   * key containing all the audio sources they want to pass on the Audio Context\n   * of their clip. Please check AudioClip for details on the expected format\n   * */\n\n  var DescriptiveClip =\n  /*#__PURE__*/\n  function (_Playable) {\n    _inherits(DescriptiveClip, _Playable);\n\n    function DescriptiveClip(attrs) {\n      var _this;\n\n      var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      _classCallCheck(this, DescriptiveClip);\n\n      var attrsToPass;\n      var propsToUse;\n\n      if (props === null) {\n        attrsToPass = {};\n        propsToUse = attrs;\n      } else {\n        // else, in case the user has passed two arguments then both should be used\n        attrsToPass = attrs;\n        propsToUse = props;\n      }\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(DescriptiveClip).call(this, attrsToPass, propsToUse));\n\n      var propsValidation = _this._validateProps();\n\n      if (propsValidation.result === false) {\n        return _possibleConstructorReturn(_this, propsValidation);\n      }\n\n      _this.attrsValidationRules = {};\n      _this.propsValidationRules = clipPropsRule; // isTheRootClip defines whether the Clip is the root or not. It depends on\n      // the host or selector parameter passed on props (if host is present then\n      // the Clip is the root Clip while if the Clip gets initialised by a selector\n      // is not)\n\n      _this.isTheRootClip = false; // check if\n\n      var ingredients = {\n        id: _this.id,\n        attrs: attrsToPass,\n        props: _objectSpread2({}, propsToUse, {\n          html: Object.prototype.hasOwnProperty.call(propsToUse, 'html') ? propsToUse.html : _this.html,\n          css: Object.prototype.hasOwnProperty.call(propsToUse, 'css') ? propsToUse.css : _this.css,\n          fonts: Object.prototype.hasOwnProperty.call(propsToUse, 'fonts') ? propsToUse.fonts : _this.fonts,\n          runTimeInfo: _this.runTimeInfo,\n          subscribe: _this.subscribe.bind(_assertThisInitialized(_this))\n        }),\n        plugin_npm_name: _this.constructor.plugin_npm_name,\n        Channel: _this.constructor.Channel,\n        DescriptiveIncident: _assertThisInitialized(_this)\n      }; // Decide what kind of audio (or non-audio) Clip we are dealing with\n\n      _this.audio = 'on';\n\n      if (Object.prototype.hasOwnProperty.call(_this.constructor, 'audio')) {\n        _this.audio = _this.constructor.audio;\n      }\n\n      if (Object.prototype.hasOwnProperty.call(propsToUse, 'audio')) {\n        _this.audio = propsToUse.audio;\n      } // decide if this is the root clip\n\n\n      if (Object.prototype.hasOwnProperty.call(propsToUse, 'selector') && propsToUse.selector !== undefined && _this.constructor.customClip !== true) {\n        ingredients.Incident = FragmentedClip; // TODO it doesn't take in account the get html and get css of the Descriptive Clip\n      } else if (Object.prototype.hasOwnProperty.call(propsToUse, 'selector') && propsToUse.selector !== undefined && _this.constructor.customClip === true) {\n        delete ingredients.props.selector;\n        var FragmentWrapper = new FragmentedClip({\n          html: '<div id=\"clip-container\"></div>'\n        });\n        ingredients.props.host = FragmentWrapper.rootElement;\n        ingredients.Incident = _this.constructor.Incident;\n      } else if (_this.audio === 'only' && _this.props.root !== true) {\n        // audioClips can never be the root\n        _this.isTheRootClip = false;\n      } else {\n        _this.isTheRootClip = true;\n        /*\n              blockingWaitings are been triggered by Incidents when there is the\n              need to halt the Clip's execution and wait. As an example a blocking\n              waiting can be set by an Audio Playback Incident when the audio has\n              not been loaded yet.\n              Each blocking waiting has an id and via the same id the waiting can be\n              unblocked.\n              The blockingWaitings property of the root Clip is a collection with\n              keys the blocking waitings ids and values the description of each waiting\n              which consists of:\n              {\n                  id\n                  description\n                  incidentId\n              }\n              The blocking waitings are triggered by real Incidents living on the real\n              Clips of the Descriptive Clip (either the audioClip or the realClip).\n              The root that a waiting set or unset follows is from any real incident\n              up to its ContextAware Incident and from there\n              up to the real Clip and from thre to its DescriptiveTree and from there\n              all the way up to the root Descriptive Clip.\n              Blocking waitings must always be triggered on the \"onProgress\" or on\n              the \"play\" methods of Incidents. Setting a blocking waiting from anywhere\n              else is an error\n              */\n\n        _this.blockingWaitings = {};\n        ingredients.Incident = _this.constructor.Incident;\n      } // we initialise real and audio clips of the Clip by checking the static audio\n      // property\n      // the property this.audio helps incidentFromDescription identify if the Incident\n      // participates or not on the audioClip. By default is \"on\" but if the props.audio is set to off\n      // it turns to \"off\" so the DC gets totally ignored on the addition process on audio clip\n\n      /* The audio value is set in the following manner\n              - first we check if the Class has a static audio parameter and if yes we keep it\n              - then we check if this.props has the audio key and if yes we keep this one\n              - otherwise we use the default (\"on\")\n          */\n\n\n      if (_this.audio === 'on' || _this.audio === 'off') {\n        _this.realClip = incidentFromIngredients(ingredients);\n      } else {\n        _this.realClip = new NullClip();\n      }\n\n      if (_this.audio === 'on' || _this.audio === 'only') {\n        var audioIngredients = {\n          id: _this.id,\n          attrs: {},\n          props: {\n            audioSources: Object.prototype.hasOwnProperty.call(propsToUse, 'audioSources') ? propsToUse.audioSources : _this.audioSources,\n            runTimeInfo: _this.runTimeInfo,\n            subscribe: _this.subscribe.bind(_assertThisInitialized(_this))\n          },\n          plugin_npm_name: _this.constructor.plugin_npm_name,\n          Channel: _this.constructor.Channel,\n          Incident: AudioClip,\n          DescriptiveIncident: _assertThisInitialized(_this)\n        };\n        _this.audioClip = incidentFromIngredients(audioIngredients);\n      } else {\n        _this.audio = 'off';\n        _this.audioClip = new NullClip();\n      } // passiveAddition is a flag property indicating that any Incident to be\n      // added to the Clip will be passive. It initialises with value = false\n      // on DescriptiveGroup where it's originaly defined.\n      // Here we change its value just before the buildTree method execution\n      // so all Incidents added on it get the \"passive\" flag and don't get\n      // exported on the exportDefinition method. Once the buildTree method\n      // finishes we set it back to its original value (false)\n\n\n      _this.passiveAddition = true;\n\n      _this._buildTree();\n\n      _this.passiveAddition = false;\n      return _this;\n    }\n\n    _createClass(DescriptiveClip, [{\n      key: \"_validateProps\",\n      value: function _validateProps() {\n        return helper.validateProps({\n          props: this.props\n        }, clipPropsRule, this.constructor);\n      }\n    }, {\n      key: \"_buildTree\",\n\n      /*\n        the _buildTree method acts as a proxy to the buildTree method defined by the\n        developers. The reason for this is that the actual buildTree method should\n        be executed in different order on Groups and on Clips (that extend Groups).\n        Calling the super on constructor fires the _buildTree execution on the\n        Group's constructor but this breaks on Clip as the realClip has not been\n        initialised yet.\n        */\n      value: function _buildTree() {\n        if (this.realClip === undefined) {\n          return;\n        }\n\n        this.buildTree();\n      }\n      /**\n       * When the resize command is given directly to a DescriptiveClip no checks\n       * need to be performed.\n       * DescriptiveClip directly invokes the _resize method of ExtendableClip which\n       * resizes the full clip\n       */\n\n    }, {\n      key: \"resize\",\n      value: function resize(newSize) {\n        this.realClip._resize(newSize / this.duration);\n\n        this.audioClip._resize(newSize / this.duration);\n\n        this.duration = newSize;\n        this.putMessageOnPipe('recalcDuration', {}, 'Groups', {\n          selfExecute: false,\n          direction: _DIRECTIONS._UP\n        });\n        this.putMessageOnPipe('flash', {}, 'RootClip', {\n          selfExecute: true,\n          direction: _DIRECTIONS._UP\n        });\n        return {\n          result: true\n        };\n      }\n      /** ************************* HANDLING METHODS ****************************** */\n      // eslint-disable-next-line no-unused-vars\n\n    }, {\n      key: \"handleCheckForClip\",\n      value: function handleCheckForClip(target, payload) {\n        return true;\n      }\n    }, {\n      key: \"handleGetElements\",\n      value: function handleGetElements(target, payload) {\n        return this.realClip.getElements(payload.selector);\n      }\n    }, {\n      key: \"handleCheckAddition\",\n      value: function handleCheckAddition(target, payload) {\n        /* Is the responsibility of the DescriptiveClip to pass the addition request\n            to its real clip and expect for a response. */\n        var res = this.realClip.addIncident(payload);\n        var audioRes = this.audioClip.addIncident(payload);\n\n        if (res.result === true && audioRes.result === true) {\n          res.execute();\n          audioRes.execute();\n          this.putMessageOnPipe('flash', {}, 'RootClip', {\n            selfExecute: true,\n            direction: _DIRECTIONS._UP\n          });\n          return {\n            result: true\n          };\n        }\n\n        return res;\n      }\n    }, {\n      key: \"handleCheckMove\",\n      value: function handleCheckMove(target, payload) {\n        var res = this.realClip.moveIncident(payload);\n        var audioRes = this.audioClip.moveIncident(payload);\n\n        if (res.result === true && audioRes.result === true) {\n          res.execute();\n          audioRes.execute();\n          this.putMessageOnPipe('flash', {}, 'RootClip', {\n            selfExecute: true,\n            direction: _DIRECTIONS._UP\n          });\n          return {\n            result: true\n          };\n        }\n\n        return res;\n      }\n    }, {\n      key: \"handleCheckDeletion\",\n      value: function handleCheckDeletion(target, payload) {\n        var res = this.realClip.removeIncident(payload);\n        var audioRes = this.audioClip.removeIncident(payload);\n\n        if (res.result === true && audioRes.result === true) {\n          res.execute();\n          audioRes.execute();\n          this.putMessageOnPipe('flash', {}, 'RootClip', {\n            selfExecute: true,\n            direction: _DIRECTIONS._UP\n          });\n          return {\n            result: true\n          };\n        }\n\n        return res;\n      }\n    }, {\n      key: \"handleCheckResize\",\n      value: function handleCheckResize(target, payload) {\n        var res = this.realClip.resizeIncident(payload);\n        var audioRes = this.audioClip.resizeIncident(payload);\n\n        if (res.result === true && audioRes.result === true) {\n          res.execute();\n          audioRes.execute();\n          this.putMessageOnPipe('flash', {}, 'RootClip', {\n            selfExecute: true,\n            direction: _DIRECTIONS._UP\n          });\n          return {\n            result: true\n          };\n        }\n\n        return res;\n      } // eslint-disable-next-line no-unused-vars\n\n    }, {\n      key: \"handleFlash\",\n      value: function handleFlash(target, payload) {\n        if (this.isTheRootClip) {\n          this.flash();\n        } else {\n          return this.bypass();\n        }\n      }\n      /** **************** BLOCKING WAITINGS HANDLING ************************* */\n\n      /** ******************************************************************** */\n\n    }, {\n      key: \"handleSetBlock\",\n      value: function handleSetBlock(target, payload) {\n        // only accepts blocks if is the root clip and if it's playing\n        if (this.isTheRootClip) {\n          if (this.runTimeInfo.state === 'transitional') {\n            return;\n          }\n\n          if (this.runTimeInfo.state !== 'blocked') {\n            this.statusBeforeBlock = this.runTimeInfo.state;\n          }\n\n          this.blockingWaitings[payload.id] = payload;\n          this.block();\n        } else {\n          return this.bypass();\n        }\n      }\n    }, {\n      key: \"handleUnBlock\",\n      value: function handleUnBlock(target, payload) {\n        if (this.isTheRootClip) {\n          if (Object.prototype.hasOwnProperty.call(this.blockingWaitings, payload.id)) {\n            delete this.blockingWaitings[payload.id];\n\n            if (Object.keys(this.blockingWaitings).length === 0) {\n              if (this.statusBeforeBlock === 'playing') {\n                this.previousTimeStamp = -1;\n                this.play();\n              } else {\n                this.arm();\n              }\n            }\n          }\n        } else {\n          return this.bypass();\n        }\n      }\n      /* empty blocking waitings on transition start */\n\n    }, {\n      key: \"stop\",\n      value: function stop() {\n        _get(_getPrototypeOf(DescriptiveClip.prototype), \"stop\", this).call(this);\n\n        this.blockingWaitings = {};\n      }\n      /** ******************************************************************** */\n\n      /** ******************************************************************** */\n\n    }, {\n      key: \"onProgress\",\n      value: function onProgress(fraction, millisecond) {\n        this.realClip.onProgress(fraction, millisecond);\n        this.audioClip.onProgress(fraction, millisecond);\n      }\n      /** ********************************************************** */\n\n    }, {\n      key: \"paste\",\n      value: function paste(host) {\n        if (this.isTheRootClip) {\n          var clipClone = new ClipClone({\n            host: host,\n            descriptiveIncident: this\n          });\n          return clipClone;\n        }\n\n        return null;\n      }\n    }, {\n      key: \"flash\",\n      value: function flash() {\n        this.realClip.flash();\n      }\n    }, {\n      key: \"setVolume\",\n      value: function setVolume(vol) {\n        if (vol < 0 || vol > 1) {\n          return {\n            result: false,\n            errors: [{\n              type: 'invalid volume number'\n            }]\n          };\n        }\n\n        if (this.audio === 'off') {\n          return {\n            result: false,\n            errors: [{\n              type: 'can not set volume of Clip with audio off'\n            }]\n          };\n        }\n\n        this.audioClip.setVolume(vol);\n        return {\n          result: true\n        };\n      }\n    }, {\n      key: \"selectorToPassToChildren\",\n      get: function get() {\n        return null; // the Clip (any Clip) resets the selection cascading\n      }\n    }, {\n      key: \"inheritedSelector\",\n      get: function get() {\n        return this._inheritedSelector;\n      },\n      set: function set(value) {\n        this._inheritedSelector = value;\n      }\n    }, {\n      key: \"html\",\n      get: function get() {\n        return '';\n      }\n    }, {\n      key: \"css\",\n      get: function get() {\n        return '';\n      }\n    }, {\n      key: \"fonts\",\n      get: function get() {\n        return [];\n      }\n    }, {\n      key: \"audioSources\",\n      get: function get() {\n        return [];\n      }\n    }]);\n\n    return DescriptiveClip;\n  }(Playable);\n\n  _defineProperty(DescriptiveClip, \"isClip\", true);\n\n  _defineProperty(DescriptiveClip, \"Incident\", Clip$1);\n\n  _defineProperty(DescriptiveClip, \"plugin_npm_name\", '@kissmybutton/self-contained-incidents');\n\n  _defineProperty(DescriptiveClip, \"Channel\", ClipChannel);\n\n  _defineProperty(DescriptiveClip, \"ClassName\", 'Clip');\n\n  var DescriptiveAudioClip =\n  /*#__PURE__*/\n  function (_DescriptiveClip) {\n    _inherits(DescriptiveAudioClip, _DescriptiveClip);\n\n    function DescriptiveAudioClip(audioSources) {\n      var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      _classCallCheck(this, DescriptiveAudioClip);\n\n      var propsToPass = {\n        audio: 'only',\n        audioSources: audioSources\n      };\n\n      if (id !== null) {\n        propsToPass.id = id;\n      }\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(DescriptiveAudioClip).call(this, propsToPass));\n    }\n\n    return DescriptiveAudioClip;\n  }(DescriptiveClip);\n\n  var DescriptiveIncident = _decorate(null, function (_initialize, _Leaf) {\n    var DescriptiveIncident =\n    /*#__PURE__*/\n    function (_Leaf2) {\n      _inherits(DescriptiveIncident, _Leaf2);\n\n      function DescriptiveIncident(attrs, props) {\n        var _this;\n\n        _classCallCheck(this, DescriptiveIncident);\n\n        if (props === undefined) {\n          props = attrs;\n          attrs = {};\n        }\n\n        _this = _possibleConstructorReturn(this, _getPrototypeOf(DescriptiveIncident).call(this, props));\n\n        _initialize(_assertThisInitialized(_this));\n\n        var propsValidation = helper.validateProps({\n          props: props\n        }, incidentPropsRule, _this.constructor);\n\n        if (propsValidation.result === false) {\n          return _possibleConstructorReturn(_this, propsValidation);\n        }\n\n        _this.inheritedSelector = null;\n        _this.attrs = attrs;\n\n        if (!Object.prototype.hasOwnProperty.call(props, 'duration')) {\n          props.duration = 0;\n        }\n\n        _this.props = props;\n        _this.attrsValidationRules = {};\n        _this.propsValidationRules = incidentPropsRule; // the passive flag (when true) indicates that the Descriptive Group has been created\n        // and passively added to a Clip or a Combo via buildTree method.\n        // Defaults to false\n\n        _this.passive = false;\n        return _this;\n      }\n\n      return DescriptiveIncident;\n    }(_Leaf);\n\n    return {\n      F: DescriptiveIncident,\n      d: [{\n        kind: \"field\",\n        static: true,\n        key: \"Incident\",\n        value: function value() {\n          return MonoIncident;\n        }\n      }, {\n        kind: \"field\",\n        static: true,\n        key: \"plugin_npm_name\",\n        value: function value() {\n          return 'motor-cortex-js-attribute';\n        }\n      }, {\n        kind: \"field\",\n        static: true,\n        key: \"Channel\",\n        value: function value() {\n          return AttributeChannel;\n        }\n      }, {\n        kind: \"field\",\n        static: true,\n        key: \"ClassName\",\n        value: function value() {\n          return 'Incident';\n        }\n      }, {\n        kind: \"method\",\n        decorators: [editAttributes],\n        key: \"editAttributes\",\n        value: function editAttributes() {}\n      }, {\n        kind: \"method\",\n        decorators: [editProperties],\n        key: \"editProperties\",\n        value: function editProperties() {}\n      }, {\n        kind: \"method\",\n        decorators: [resize],\n        key: \"resize\",\n        value: function resize() {}\n      }, {\n        kind: \"method\",\n        decorators: [selector],\n        key: \"selector\",\n        value: function selector() {}\n      }, {\n        kind: \"method\",\n        decorators: [getElements],\n        key: \"getElements\",\n        value: function getElements() {}\n      }, {\n        kind: \"method\",\n        key: \"manageEditAttrProps\",\n        value: function manageEditAttrProps(newAttrs, type) {\n          // get a permanent reference to its parent node\n          var parentNode = this.parentNode; // get the position of the Incident within its parent\n\n          var position = parentNode.getLeafPosition(this.id); // first detach the Incident from its parent\n\n          parentNode.removeIncident(this.id); // keep a backup of the current attrs/props\n\n          var oldAttrs = JSON.parse(JSON.stringify(this[type]));\n          this[type] = newAttrs;\n          var res = parentNode.addIncident(this, position);\n\n          if (res.result === false) {\n            parentNode.removeIncident(this.id);\n            this[type] = oldAttrs;\n            parentNode.addIncident(this, position);\n            return res;\n          }\n\n          return res;\n        }\n      }, {\n        kind: \"method\",\n        key: \"detachFromParent\",\n        value: function detachFromParent() {\n          _get(_getPrototypeOf(DescriptiveIncident.prototype), \"detachFromParent\", this).call(this);\n\n          this.inheritedSelector = null;\n        }\n      }, {\n        kind: \"method\",\n        key: \"handleCheckForInvalidSelectors\",\n        value: function handleCheckForInvalidSelectors() {\n          var selector = this.selector();\n\n          if (selector === null) {\n            return {\n              id: this.id,\n              ClassName: this.constructor.ClassName,\n              plugin_npm_name: this.constructor.plugin_npm_name,\n              error: 'null selector'\n            };\n          }\n\n          if (selector.charAt(0) === '&') {\n            return {\n              id: this.id,\n              ClassName: this.constructor.ClassName,\n              plugin_npm_name: this.constructor.plugin_npm_name,\n              error: 'relative selector with no inherited selector',\n              selector: selector\n            };\n          }\n\n          return this.bypass();\n        }\n        /**\n         * The purpose of this method is to export a portable definition that can be\n         * later used in order to rebuild the Inicdent at any time\n         */\n\n      }, {\n        kind: \"method\",\n        key: \"exportDefinition\",\n        value: function exportDefinition() {\n          return {\n            ClassName: this.constructor.ClassName,\n            plugin_npm_name: this.constructor.plugin_npm_name,\n            attrs: this.attrs,\n            props: this.props\n          };\n        }\n        /**\n         * The purpose of this method is to export an object with \"live\" / real reference\n         * to the Class of the Incident so it can directly by used for Clip creation\n         * */\n\n      }, {\n        kind: \"method\",\n        key: \"exportLiveDefinition\",\n        value: function exportLiveDefinition() {\n          return {\n            Class: this.constructor,\n            attrs: JSON.parse(JSON.stringify(this.attrs)),\n            props: JSON.parse(JSON.stringify(this.props))\n          };\n        }\n      }]\n    };\n  }, Leaf);\n\n  /*\n  definition: {\n      Class: <The Class>,\n      attrs: <attrs>,\n      props: <props>,\n      incidents: { // this exists only in the case of a Group or a Clip\n          id: <id>,\n          position> <position>,\n          leaf: <definition>\n      }\n  }\n  */\n  function constructIncident(definition) {\n    var TheIncident = new definition.Class(definition.attrs, definition.props);\n\n    if (Object.prototype.hasOwnProperty.call(definition, 'incidents')) {\n      for (var key in definition.incidents) {\n        var incidentDefinition = definition.incidents[key];\n        var incident = constructIncident(incidentDefinition.leaf);\n        TheIncident.addIncident(incident, incidentDefinition.position);\n      }\n    }\n\n    return TheIncident;\n  }\n\n  var colorRegexp = new RegExp(/^#([\\da-f]{3}){1,2}$|^#([\\da-f]{4}){1,2}$|(rgb|hsl)a?\\((\\s*-?\\d+%?\\s*,){2}(\\s*-?\\d+%?\\s*,?\\s*\\)?)(,\\s*(0?\\.\\d+)?|1)?\\)/, 'gi');\n  var intRegexp = new RegExp(/^[-+]?\\d+$/);\n  var createValidator = function createValidator() {\n    var v = new index_min({\n      messages: {\n        color: \"The '{field}' field must be an a valid color! Actual: {actual}\",\n        measurement: \"The '{field}' must be a measurement with specs that are not met. Please check schema definition. Actual: {actual}\"\n      }\n    }); // eslint-disable-next-line no-unused-vars\n\n    v.add('measurement', function (_ref, path, context) {\n      var schema = _ref.schema,\n          messages = _ref.messages;\n      var measurementRegexp = new RegExp('^[+-]?([0-9]+([.][0-9]*)?|[.][0-9]+)(' + schema.units.join('|') + ')$', 'gi');\n      var numberPartRegexp = new RegExp('^[+-]?([0-9]+([.][0-9]*)?|[.][0-9]+)', 'gi');\n      var unitsFlattened = schema.units.join(', ');\n      return {\n        source: \"\\n        if(typeof value !== 'string' && !(value instanceof String)){\\n          \".concat(this.makeError({\n          type: 'measurement',\n          actual: 'value',\n          units: unitsFlattened,\n          messages: messages\n        }), \"\\n          return ;\\n        }\\n        if(!value.match(\").concat(measurementRegexp, \")){\\n          \").concat(this.makeError({\n          type: 'measurement',\n          actual: 'value',\n          units: unitsFlattened,\n          messages: messages\n        }), \"\\n        } else {\\n          var numberPart = value.match(\").concat(numberPartRegexp, \")[0];\\n          if(\").concat(Object.prototype.hasOwnProperty.call(schema, 'min'), \"){\\n            if(\").concat(schema.min, \" > numberPart){\\n              \").concat(this.makeError({\n          type: 'measurement',\n          actual: 'value',\n          units: unitsFlattened,\n          messages: messages\n        }), \"\\n            }\\n          }\\n          if(\").concat(Object.prototype.hasOwnProperty.call(schema, 'max'), \"){\\n            if(\").concat(schema.max, \" < numberPart){\\n              \").concat(this.makeError({\n          type: 'measurement',\n          actual: 'value',\n          units: unitsFlattened,\n          messages: messages\n        }), \"\\n            }\\n          }\\n           if(\").concat(Object.prototype.hasOwnProperty.call(schema, 'integer'), \"){\\n            if(!numberPart.match(\").concat(intRegexp, \")){\\n              \").concat(this.makeError({\n          type: 'measurement',\n          actual: 'value',\n          units: unitsFlattened,\n          messages: messages\n        }), \"\\n            }\\n          }\\n        }\\n        return value;\\n      \")\n      };\n    }); // eslint-disable-next-line no-unused-vars\n\n    v.add('color', function (_ref2, path, context) {\n      var schema = _ref2.schema,\n          messages = _ref2.messages;\n      return {\n        source: \"\\n        if(typeof value !== 'string' && !(value instanceof String)){\\n          \".concat(this.makeError({\n          type: 'measurement',\n          actual: 'value',\n          messages: messages\n        }), \"\\n          return ;\\n        }\\n        if(!value.match(\").concat(colorRegexp, \") && [\\n            \\\"aliceblue\\\",\\n            \\\"antiquewhite\\\",\\n            \\\"aqua\\\",\\n            \\\"aquamarine\\\",\\n            \\\"azure\\\",\\n            \\\"beige\\\",\\n            \\\"bisque\\\",\\n            \\\"black\\\",\\n            \\\"blanchedalmond\\\",\\n            \\\"blue\\\",\\n            \\\"blueviolet\\\",\\n            \\\"brown\\\",\\n            \\\"burlywood\\\",\\n            \\\"cadetblue\\\",\\n            \\\"chartreuse\\\",\\n            \\\"chocolate\\\",\\n            \\\"coral\\\",\\n            \\\"cornflowerblue\\\",\\n            \\\"cornsilk\\\",\\n            \\\"crimson\\\",\\n            \\\"cyan\\\",\\n            \\\"darkblue\\\",\\n            \\\"darkcyan\\\",\\n            \\\"darkgoldenrod\\\",\\n            \\\"darkgray\\\",\\n            \\\"darkgrey\\\",\\n            \\\"darkgreen\\\",\\n            \\\"darkkhaki\\\",\\n            \\\"darkmagenta\\\",\\n            \\\"darkolivegreen\\\",\\n            \\\"darkorange\\\",\\n            \\\"darkorchid\\\",\\n            \\\"darkred\\\",\\n            \\\"darksalmon\\\",\\n            \\\"darkseagreen\\\",\\n            \\\"darkslateblue\\\",\\n            \\\"darkslategray\\\",\\n            \\\"darkslategrey\\\",\\n            \\\"darkturquoise\\\",\\n            \\\"darkviolet\\\",\\n            \\\"deeppink\\\",\\n            \\\"deepskyblue\\\",\\n            \\\"dimgray\\\",\\n            \\\"dimgrey\\\",\\n            \\\"dodgerblue\\\",\\n            \\\"firebrick\\\",\\n            \\\"floralwhite\\\",\\n            \\\"forestgreen\\\",\\n            \\\"fuchsia\\\",\\n            \\\"gainsboro\\\",\\n            \\\"ghostwhite\\\",\\n            \\\"gold\\\",\\n            \\\"goldenrod\\\",\\n            \\\"gray\\\",\\n            \\\"grey\\\",\\n            \\\"green\\\",\\n            \\\"greenyellow\\\",\\n            \\\"honeydew\\\",\\n            \\\"hotpink\\\",\\n            \\\"indianred\\\",\\n            \\\"indigo\\\",\\n            \\\"ivory\\\",\\n            \\\"khaki\\\",\\n            \\\"lavender\\\",\\n            \\\"lavenderblush\\\",\\n            \\\"lawngreen\\\",\\n            \\\"lemonchiffon\\\",\\n            \\\"lightblue\\\",\\n            \\\"lightcoral\\\",\\n            \\\"lightcyan\\\",\\n            \\\"lightgoldenrodyellow\\\",\\n            \\\"lightgray\\\",\\n            \\\"lightgrey\\\",\\n            \\\"lightgreen\\\",\\n            \\\"lightpink\\\",\\n            \\\"lightsalmon\\\",\\n            \\\"lightseagreen\\\",\\n            \\\"lightskyblue\\\",\\n            \\\"lightslategray\\\",\\n            \\\"lightslategrey\\\",\\n            \\\"lightsteelblue\\\",\\n            \\\"lightyellow\\\",\\n            \\\"lime\\\",\\n            \\\"limegreen\\\",\\n            \\\"linen\\\",\\n            \\\"magenta\\\",\\n            \\\"maroon\\\",\\n            \\\"mediumaquamarine\\\",\\n            \\\"mediumblue\\\",\\n            \\\"mediumorchid\\\",\\n            \\\"mediumpurple\\\",\\n            \\\"mediumseagreen\\\",\\n            \\\"mediumslateblue\\\",\\n            \\\"mediumspringgreen\\\",\\n            \\\"mediumturquoise\\\",\\n            \\\"mediumvioletred\\\",\\n            \\\"midnightblue\\\",\\n            \\\"mintcream\\\",\\n            \\\"mistyrose\\\",\\n            \\\"moccasin\\\",\\n            \\\"navajowhite\\\",\\n            \\\"navy\\\",\\n            \\\"oldlace\\\",\\n            \\\"olive\\\",\\n            \\\"olivedrab\\\",\\n            \\\"orange\\\",\\n            \\\"orangered\\\",\\n            \\\"orchid\\\",\\n            \\\"palegoldenrod\\\",\\n            \\\"palegreen\\\",\\n            \\\"paleturquoise\\\",\\n            \\\"palevioletred\\\",\\n            \\\"papayawhip\\\",\\n            \\\"peachpuff\\\",\\n            \\\"peru\\\",\\n            \\\"pink\\\",\\n            \\\"plum\\\",\\n            \\\"powderblue\\\",\\n            \\\"purple\\\",\\n            \\\"rebeccapurple\\\",\\n            \\\"red\\\",\\n            \\\"rosybrown\\\",\\n            \\\"royalblue\\\",\\n            \\\"saddlebrown\\\",\\n            \\\"salmon\\\",\\n            \\\"sandybrown\\\",\\n            \\\"seagreen\\\",\\n            \\\"seashell\\\",\\n            \\\"sienna\\\",\\n            \\\"silver\\\",\\n            \\\"skyblue\\\",\\n            \\\"slateblue\\\",\\n            \\\"slategray\\\",\\n            \\\"slategrey\\\",\\n            \\\"snow\\\",\\n            \\\"springgreen\\\",\\n            \\\"steelblue\\\",\\n            \\\"tan\\\",\\n            \\\"teal\\\",\\n            \\\"thistle\\\",\\n            \\\"tomato\\\",\\n            \\\"turquoise\\\",\\n            \\\"violet\\\",\\n            \\\"wheat\\\",\\n            \\\"white\\\",\\n            \\\"whitesmoke\\\",\\n            \\\"yellow\\\",\\n            \\\"yellowgreen\\\",\\n          ].indexOf(value.toLowerCase()) < 0){\\n          \").concat(this.makeError({\n          type: 'color',\n          actual: 'value',\n          messages: messages\n        }), \"\\n        }\\n        return value;\\n      \")\n      };\n    });\n    return v;\n  };\n\n  var Journey =\n  /*#__PURE__*/\n  function () {\n    function Journey(props) {\n      _classCallCheck(this, Journey);\n\n      if (!Object.prototype.hasOwnProperty.call(props, 'incident')) {\n        helper.error('Journey constructor expects an Incident on its properties on the key \"incident\"');\n        return false;\n      }\n\n      this.memory = props.calpuleMemory;\n      this.stations = [];\n      this.incident = props.incident;\n      this.startMillisecond = this.incident.runTimeInfo.currentMillisecond * 1;\n      this.startState = \"\".concat(this.incident.runTimeInfo.state);\n      this.incident.stop();\n    }\n\n    _createClass(Journey, [{\n      key: \"station\",\n      value: function station(millisecond) {\n        var props = {};\n\n        if (this.stations.length > 0) {\n          props.previousStop = this.stations[this.stations.length - 1];\n        }\n\n        this.stations.push(millisecond); // helper.log(`CAPSULE passes as previousStop: ${props.previousStop}`);\n        // helper.log(this.stations);\n\n        this.incident.playableProgress(millisecond / this.incident.duration, millisecond);\n      }\n    }, {\n      key: \"destination\",\n      value: function destination() {\n        var millisecond = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n        if (millisecond != null) {\n          this.station(millisecond);\n        } else {\n          millisecond = this.stations[this.stations.length - 1];\n        }\n\n        this.incident.playableProgress(millisecond / this.incident.duration, millisecond); // if the clip was playing start it again\n\n        if (this.startState === 'playing' || this.startState === 'blocked' && this.incident.statusBeforeBlock === 'playing') {\n          this.incident.play();\n        } else if (millisecond >= this.incident.duration) {\n          this.incident.complete();\n        } else {\n          this.incident.arm();\n        }\n\n        this.memory.push(this.exportJourneyLog);\n      }\n    }, {\n      key: \"exportJourneyLog\",\n      value: function exportJourneyLog() {\n        return {\n          startMillisecond: this.startMillisecond,\n          startState: this.startState,\n          stations: this.stations\n        };\n      }\n    }]);\n\n    return Journey;\n  }();\n\n  var TimeCapsule =\n  /*#__PURE__*/\n  function () {\n    function TimeCapsule() {\n      _classCallCheck(this, TimeCapsule);\n\n      this.memory = [];\n    }\n\n    _createClass(TimeCapsule, [{\n      key: \"startJourney\",\n      value: function startJourney(incident) {\n        if (!incident) {\n          helper.error('startJourney expects an Incident as an argument');\n          return false;\n        }\n\n        return new Journey({\n          incident: incident,\n          calpuleMemory: this.memory\n        });\n      }\n    }]);\n\n    return TimeCapsule;\n  }();\n\n  var v = createValidator();\n  var helper$1 = new Helper({\n    logLevel: 0\n  });\n\n  function checkPlugin(main) {\n    if (Object.prototype.hasOwnProperty.call(main, 'default')) {\n      main = main.default;\n    }\n\n    var plugin_name = main.npm_name;\n    var check = true;\n\n    if (!Object.prototype.hasOwnProperty.call(main, 'name')) {\n      helper$1.error(\"Warning on plugin \".concat(plugin_name, \". A plugin is always good to have its name on\\n        its main.js file, under the key \\\"name\\\". It's missing from this plugin\"));\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(main, 'incidents') && !Object.prototype.hasOwnProperty.call(main, 'Clip')) {\n      helper$1.error(\"Error on plugin \".concat(plugin_name, \". A plugin must expose at least one Incident or a Clip.\\n        Exposed plugin Incidents should be defined on the \\\"incidents\\\" key of the main.js file while Clips on the \\\"Clip\\\".\"));\n      check = false;\n    }\n\n    if (Object.prototype.hasOwnProperty.call(main, 'incidents') && !Array.isArray(main.incidents)) {\n      helper$1.error(\"Error on plugin \".concat(plugin_name, \". thePlugin exposed Incidents are defined on the \\\"incidents\\\" key of the main.js file in array format.\\n        Please refer to the documentation\"));\n      check = false;\n    } else if (Object.prototype.hasOwnProperty.call(main, 'incidents')) {\n      for (var i = 0; i < main.incidents.length; i++) {\n        var exposedIncidentDefinition = main.incidents[i];\n\n        if (_typeof(exposedIncidentDefinition.exportable) === 'object') {\n          if (Object.prototype.hasOwnProperty.call(exposedIncidentDefinition.exportable, 'default')) {\n            exposedIncidentDefinition.exportable = exposedIncidentDefinition.exportable.default;\n          }\n        }\n\n        if (!(exposedIncidentDefinition.exportable.prototype instanceof DescriptiveGroup) && !(exposedIncidentDefinition.exportable.prototype instanceof DescriptiveClip) && !(exposedIncidentDefinition.exportable.prototype instanceof MonoIncident) && !(exposedIncidentDefinition.exportable.prototype instanceof MediaPlay)) {\n          helper$1.error(\"Error on plugin \".concat(plugin_name, \". Exportable Incidents by any plugin must extend one of the base classes provided by MotorCortex.\\n                \").concat(exposedIncidentDefinition.exportable.constructor.name, \" doesn't.\\n                Please refer to documentation\"));\n          check = false;\n        }\n\n        if (!Object.prototype.hasOwnProperty.call(exposedIncidentDefinition, 'name')) {\n          helper$1.error(\"Error on plugin \".concat(plugin_name, \". Exportable Incidents by any plugin must have the \\\"name\\\" key which defines the name of the exported Incident.\\n                Please refer to documentation\"));\n          check = false;\n        }\n\n        if (!Object.prototype.hasOwnProperty.call(exposedIncidentDefinition, 'propTypes')) {\n          helper$1.log(\"Warning on plugin \".concat(plugin_name, \".\\n                It's always good for plugins to define the supported propTypes of their exposed Incidents' supported properties.\\n                \").concat(exposedIncidentDefinition.exportable.constructor.name, \" doesn't.\\n                Please refer to documentation\"), 'warning');\n        }\n      }\n    }\n\n    return check;\n  } // plugin_name is the unique name of the plugin\n\n\n  function loadPlugin(plugin) {\n    if (Object.prototype.hasOwnProperty.call(plugin, 'default')) {\n      plugin = plugin.default;\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(plugin, 'npm_name')) {\n      plugin.npm_name = \"plugin_\".concat(new Date().getTime());\n    }\n\n    if (!checkPlugin(plugin)) {\n      return false;\n    } // thePlugin is the plugin object which will hold on its keys\n    // the names of the exposed Incidents of its. The keys of this object\n    // are going to be identical with the names of the classes exposed\n\n\n    var thePlugin = {};\n\n    if (Object.prototype.hasOwnProperty.call(plugin, 'Clip')) {\n      var _class, _temp;\n\n      var DynamicDescriptiveClip = (_temp = _class =\n      /*#__PURE__*/\n      function (_DescriptiveClip) {\n        _inherits(DynamicDescriptiveClip, _DescriptiveClip);\n\n        function DynamicDescriptiveClip() {\n          _classCallCheck(this, DynamicDescriptiveClip);\n\n          return _possibleConstructorReturn(this, _getPrototypeOf(DynamicDescriptiveClip).apply(this, arguments));\n        }\n\n        return DynamicDescriptiveClip;\n      }(DescriptiveClip), _defineProperty(_class, \"Incident\", plugin.Clip), _defineProperty(_class, \"audio\", plugin.audio ? plugin.audio : 'off'), _defineProperty(_class, \"customClip\", true), _temp);\n      thePlugin.Clip = DynamicDescriptiveClip;\n    } // if the plugin definition has compositeAttributes then we dynamically\n    // create a new Channel class extending AttributeChannel setting the\n    // composite Attributes on the fly. We can then use this Channel class\n    // for all Incidents exposed by the plugin\n\n\n    var AttributeChannelToUse = AttributeChannel;\n\n    if (Object.prototype.hasOwnProperty.call(plugin, 'compositeAttributes')) {\n      AttributeChannelToUse =\n      /*#__PURE__*/\n      function (_AttributeChannel) {\n        _inherits(AttributeChannelToUse, _AttributeChannel);\n\n        function AttributeChannelToUse(props) {\n          _classCallCheck(this, AttributeChannelToUse);\n\n          props.comboAttributes = plugin.compositeAttributes;\n          return _possibleConstructorReturn(this, _getPrototypeOf(AttributeChannelToUse).call(this, props));\n        }\n\n        return AttributeChannelToUse;\n      }(AttributeChannel);\n    } // for each of the exposed Incidents\n\n\n    if (Object.prototype.hasOwnProperty.call(plugin, 'incidents')) {\n      var _loop = function _loop(i) {\n        var incidentClass = plugin.incidents[i].exportable;\n        var DynamicDescriptiveIncident = void 0; // the exportable Incident can be either a Clip, a Compo or an Incident\n        // if it is an Incident\n\n        if (incidentClass.prototype instanceof MonoIncident) {\n          var _class2, _temp2;\n\n          DynamicDescriptiveIncident = (_temp2 = _class2 =\n          /*#__PURE__*/\n          function (_DescriptiveIncident) {\n            _inherits(DynamicDescriptiveIncident, _DescriptiveIncident);\n\n            function DynamicDescriptiveIncident() {\n              _classCallCheck(this, DynamicDescriptiveIncident);\n\n              return _possibleConstructorReturn(this, _getPrototypeOf(DynamicDescriptiveIncident).apply(this, arguments));\n            }\n\n            return DynamicDescriptiveIncident;\n          }(DescriptiveIncident), _defineProperty(_class2, \"Incident\", incidentClass), _defineProperty(_class2, \"plugin_npm_name\", plugin.npm_name), _defineProperty(_class2, \"plugin\", plugin.name), _defineProperty(_class2, \"ClassName\", plugin.incidents[i].name), _defineProperty(_class2, \"Channel\", AttributeChannelToUse), _defineProperty(_class2, \"audio\", plugin.audio ? plugin.audio : 'off'), _temp2);\n        } else if (incidentClass.prototype instanceof MediaPlay) {\n          var _class3, _temp3;\n\n          DynamicDescriptiveIncident = (_temp3 = _class3 =\n          /*#__PURE__*/\n          function (_DescriptiveIncident2) {\n            _inherits(DynamicDescriptiveIncident, _DescriptiveIncident2);\n\n            function DynamicDescriptiveIncident() {\n              _classCallCheck(this, DynamicDescriptiveIncident);\n\n              return _possibleConstructorReturn(this, _getPrototypeOf(DynamicDescriptiveIncident).apply(this, arguments));\n            }\n\n            return DynamicDescriptiveIncident;\n          }(DescriptiveIncident), _defineProperty(_class3, \"Incident\", incidentClass), _defineProperty(_class3, \"plugin_npm_name\", '@kissmybutton/media-playback'), _defineProperty(_class3, \"plugin\", plugin.name), _defineProperty(_class3, \"ClassName\", plugin.incidents[i].name), _defineProperty(_class3, \"Channel\", AudioPlaybackChannel), _defineProperty(_class3, \"audio\", plugin.audio ? plugin.audio : 'off'), _temp3);\n        } else if (incidentClass.prototype instanceof DescriptiveClip) {\n          var _class4, _temp4;\n\n          DynamicDescriptiveIncident = (_temp4 = _class4 =\n          /*#__PURE__*/\n          function (_incidentClass) {\n            _inherits(DynamicDescriptiveIncident, _incidentClass);\n\n            function DynamicDescriptiveIncident() {\n              _classCallCheck(this, DynamicDescriptiveIncident);\n\n              return _possibleConstructorReturn(this, _getPrototypeOf(DynamicDescriptiveIncident).apply(this, arguments));\n            }\n\n            return DynamicDescriptiveIncident;\n          }(incidentClass), _defineProperty(_class4, \"plugin\", plugin.name), _defineProperty(_class4, \"ClassName\", plugin.incidents[i].name), _defineProperty(_class4, \"audio\", plugin.audio ? plugin.audio : 'on'), _temp4);\n        } else if (incidentClass.prototype instanceof DescriptiveGroup) {\n          var _class5, _temp5;\n\n          DynamicDescriptiveIncident = (_temp5 = _class5 =\n          /*#__PURE__*/\n          function (_incidentClass2) {\n            _inherits(DynamicDescriptiveIncident, _incidentClass2);\n\n            function DynamicDescriptiveIncident() {\n              _classCallCheck(this, DynamicDescriptiveIncident);\n\n              return _possibleConstructorReturn(this, _getPrototypeOf(DynamicDescriptiveIncident).apply(this, arguments));\n            }\n\n            return DynamicDescriptiveIncident;\n          }(incidentClass), _defineProperty(_class5, \"plugin\", plugin.name), _defineProperty(_class5, \"ClassName\", plugin.incidents[i].name), _temp5);\n        }\n\n        Object.defineProperty(thePlugin, plugin.incidents[i].name, {\n          get: function get() {\n            // the getter will construct a wrapper class which on the constructor will instantiate an object of the\n            // exposed class, set to it the plugin name and channel class parameters and return\n            // it from the constructor\n            var WrapperClass = function WrapperClass(attrs, props) {\n              _classCallCheck(this, WrapperClass);\n\n              var instantiatedIncident = new DynamicDescriptiveIncident(attrs, props);\n\n              if (Object.prototype.hasOwnProperty.call(plugin.incidents[i], 'attributesValidationRules')) {\n                var validationResult = v.validate(attrs, plugin.incidents[i].attributesValidationRules);\n\n                if (validationResult.length > 0) {\n                  var errorMessage = \"Error on plugin's \\\"\".concat(plugin.npm_name, \"\\\" \\\"\").concat(plugin.incidents[i].name, \"\\\" instantiation. Errors:\");\n\n                  for (var j = 0; j < validationResult.length; j++) {\n                    errorMessage += \"\\n - \".concat(validationResult[j].message, \". \").concat(validationResult[j].actual, \" provided\");\n                  }\n\n                  console.error(errorMessage); // eslint-disable-line no-console\n\n                  return {\n                    result: false,\n                    errors: validationResult\n                  };\n                } else {\n                  instantiatedIncident.attrsValidationRules = plugin.incidents[i].attributesValidationRules;\n                }\n              } else {\n                helper$1.warning(\"It's always good to provide attributesValidationRules to the exported incidents. \".concat(plugin.npm_name, \".\").concat(instantiatedIncident.constructor.name, \" doesn't provide it\"));\n              }\n\n              return instantiatedIncident;\n            };\n\n            return WrapperClass;\n          }\n        });\n      };\n\n      for (var i = 0; i < plugin.incidents.length; i++) {\n        _loop(i);\n      }\n    }\n\n    return thePlugin;\n  }\n  var AudioPlugin = loadPlugin(audioPluginMain);\n  var Clip$2 = DescriptiveClip;\n  var Group$1 = DescriptiveGroup;\n  var AudioClip$1 = AudioPlugin.Clip;\n  var AudioPlayback$1 = AudioPlugin.AudioPlayback;\n  var API = {\n    MonoIncident: MonoIncident,\n    Group: Group$1,\n    Clip: Clip$2,\n    AudioClip: DescriptiveAudioClip,\n    MediaPlayback: MediaPlay,\n    ExtendableClip: ExtendableClip,\n    DOMClip: Clip$1,\n    easings: easing,\n    clipFromDefinition: constructIncident\n  };\n  var main = {\n    API: API,\n    Group: Group$1,\n    Clip: Clip$2,\n    loadPlugin: loadPlugin,\n    AudioClip: AudioClip$1,\n    AudioPlayback: AudioPlayback$1,\n    AudioEffect: AudioPlugin.AudioEffect,\n    TimeCapsule: TimeCapsule\n  };\n\n  exports.API = API;\n  exports.AudioClip = AudioClip$1;\n  exports.AudioPlayback = AudioPlayback$1;\n  exports.Clip = Clip$2;\n  exports.Group = Group$1;\n  exports.TimeCapsule = TimeCapsule;\n  exports.default = main;\n  exports.loadPlugin = loadPlugin;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"../node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9tb3RvcmNvcnRleC51bWQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9tb3RvcmNvcnRleC51bWQuanM/OWEwNiJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuTW90b3JDb3J0ZXggPSB7fSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3R5cGVvZihvYmopO1xuICB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICAgIGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgICB9KTtcbiAgICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2V5cztcbiAgfVxuXG4gIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcblxuICAgICAgaWYgKGkgJSAyKSB7XG4gICAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cblxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG4gIH1cblxuICBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICByZXR1cm4gbztcbiAgICB9O1xuXG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgIHJldHVybiBjYWxsO1xuICAgIH1cblxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xuICB9XG5cbiAgZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgICBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgICAgIGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cblxuICBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7XG4gICAgICBfZ2V0ID0gUmVmbGVjdC5nZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICAgIHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7XG5cbiAgICAgICAgaWYgKCFiYXNlKSByZXR1cm47XG4gICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG5cbiAgICAgICAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3Quc2V0KSB7XG4gICAgICBzZXQgPSBSZWZsZWN0LnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0ID0gZnVuY3Rpb24gc2V0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCByZWNlaXZlcikge1xuICAgICAgICB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuXG4gICAgICAgIHZhciBkZXNjO1xuXG4gICAgICAgIGlmIChiYXNlKSB7XG4gICAgICAgICAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuXG4gICAgICAgICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICAgICAgICBkZXNjLnNldC5jYWxsKHJlY2VpdmVyLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFkZXNjLndyaXRhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocmVjZWl2ZXIsIHByb3BlcnR5KTtcblxuICAgICAgICBpZiAoZGVzYykge1xuICAgICAgICAgIGlmICghZGVzYy53cml0YWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlc2MudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVjZWl2ZXIsIHByb3BlcnR5LCBkZXNjKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfZGVmaW5lUHJvcGVydHkocmVjZWl2ZXIsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHNldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gX3NldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIsIGlzU3RyaWN0KSB7XG4gICAgdmFyIHMgPSBzZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyIHx8IHRhcmdldCk7XG5cbiAgICBpZiAoIXMgJiYgaXNTdHJpY3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZmFpbGVkIHRvIHNldCBwcm9wZXJ0eScpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF90b0FycmF5KGFycikge1xuICAgIHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICAgIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG4gIH1cblxuICBmdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgICAgIHJldHVybiBhcnIyO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xuICB9XG5cbiAgZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gICAgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZXIpID09PSBcIltvYmplY3QgQXJndW1lbnRzXVwiKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG4gIH1cblxuICBmdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0O1xuICAgIHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcblxuICAgIGlmIChwcmltICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpO1xuICAgICAgaWYgKHR5cGVvZiByZXMgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7XG4gIH1cblxuICBmdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHtcbiAgICB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7XG5cbiAgICByZXR1cm4gdHlwZW9mIGtleSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2RlY29yYXRlKGRlY29yYXRvcnMsIGZhY3RvcnksIHN1cGVyQ2xhc3MsIG1peGlucykge1xuICAgIHZhciBhcGkgPSBfZ2V0RGVjb3JhdG9yc0FwaSgpO1xuXG4gICAgaWYgKG1peGlucykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaXhpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXBpID0gbWl4aW5zW2ldKGFwaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHIgPSBmYWN0b3J5KGZ1bmN0aW9uIGluaXRpYWxpemUoTykge1xuICAgICAgYXBpLmluaXRpYWxpemVJbnN0YW5jZUVsZW1lbnRzKE8sIGRlY29yYXRlZC5lbGVtZW50cyk7XG4gICAgfSwgc3VwZXJDbGFzcyk7XG4gICAgdmFyIGRlY29yYXRlZCA9IGFwaS5kZWNvcmF0ZUNsYXNzKF9jb2FsZXNjZUNsYXNzRWxlbWVudHMoci5kLm1hcChfY3JlYXRlRWxlbWVudERlc2NyaXB0b3IpKSwgZGVjb3JhdG9ycyk7XG4gICAgYXBpLmluaXRpYWxpemVDbGFzc0VsZW1lbnRzKHIuRiwgZGVjb3JhdGVkLmVsZW1lbnRzKTtcbiAgICByZXR1cm4gYXBpLnJ1bkNsYXNzRmluaXNoZXJzKHIuRiwgZGVjb3JhdGVkLmZpbmlzaGVycyk7XG4gIH1cblxuICBmdW5jdGlvbiBfZ2V0RGVjb3JhdG9yc0FwaSgpIHtcbiAgICBfZ2V0RGVjb3JhdG9yc0FwaSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcGk7XG4gICAgfTtcblxuICAgIHZhciBhcGkgPSB7XG4gICAgICBlbGVtZW50c0RlZmluaXRpb25PcmRlcjogW1tcIm1ldGhvZFwiXSwgW1wiZmllbGRcIl1dLFxuICAgICAgaW5pdGlhbGl6ZUluc3RhbmNlRWxlbWVudHM6IGZ1bmN0aW9uIChPLCBlbGVtZW50cykge1xuICAgICAgICBbXCJtZXRob2RcIiwgXCJmaWVsZFwiXS5mb3JFYWNoKGZ1bmN0aW9uIChraW5kKSB7XG4gICAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQua2luZCA9PT0ga2luZCAmJiBlbGVtZW50LnBsYWNlbWVudCA9PT0gXCJvd25cIikge1xuICAgICAgICAgICAgICB0aGlzLmRlZmluZUNsYXNzRWxlbWVudChPLCBlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9LFxuICAgICAgaW5pdGlhbGl6ZUNsYXNzRWxlbWVudHM6IGZ1bmN0aW9uIChGLCBlbGVtZW50cykge1xuICAgICAgICB2YXIgcHJvdG8gPSBGLnByb3RvdHlwZTtcbiAgICAgICAgW1wibWV0aG9kXCIsIFwiZmllbGRcIl0uZm9yRWFjaChmdW5jdGlvbiAoa2luZCkge1xuICAgICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBwbGFjZW1lbnQgPSBlbGVtZW50LnBsYWNlbWVudDtcblxuICAgICAgICAgICAgaWYgKGVsZW1lbnQua2luZCA9PT0ga2luZCAmJiAocGxhY2VtZW50ID09PSBcInN0YXRpY1wiIHx8IHBsYWNlbWVudCA9PT0gXCJwcm90b3R5cGVcIikpIHtcbiAgICAgICAgICAgICAgdmFyIHJlY2VpdmVyID0gcGxhY2VtZW50ID09PSBcInN0YXRpY1wiID8gRiA6IHByb3RvO1xuICAgICAgICAgICAgICB0aGlzLmRlZmluZUNsYXNzRWxlbWVudChyZWNlaXZlciwgZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfSxcbiAgICAgIGRlZmluZUNsYXNzRWxlbWVudDogZnVuY3Rpb24gKHJlY2VpdmVyLCBlbGVtZW50KSB7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gZWxlbWVudC5kZXNjcmlwdG9yO1xuXG4gICAgICAgIGlmIChlbGVtZW50LmtpbmQgPT09IFwiZmllbGRcIikge1xuICAgICAgICAgIHZhciBpbml0aWFsaXplciA9IGVsZW1lbnQuaW5pdGlhbGl6ZXI7XG4gICAgICAgICAgZGVzY3JpcHRvciA9IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGRlc2NyaXB0b3IuZW51bWVyYWJsZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiBkZXNjcmlwdG9yLndyaXRhYmxlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSxcbiAgICAgICAgICAgIHZhbHVlOiBpbml0aWFsaXplciA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5pdGlhbGl6ZXIuY2FsbChyZWNlaXZlcilcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlY2VpdmVyLCBlbGVtZW50LmtleSwgZGVzY3JpcHRvcik7XG4gICAgICB9LFxuICAgICAgZGVjb3JhdGVDbGFzczogZnVuY3Rpb24gKGVsZW1lbnRzLCBkZWNvcmF0b3JzKSB7XG4gICAgICAgIHZhciBuZXdFbGVtZW50cyA9IFtdO1xuICAgICAgICB2YXIgZmluaXNoZXJzID0gW107XG4gICAgICAgIHZhciBwbGFjZW1lbnRzID0ge1xuICAgICAgICAgIHN0YXRpYzogW10sXG4gICAgICAgICAgcHJvdG90eXBlOiBbXSxcbiAgICAgICAgICBvd246IFtdXG4gICAgICAgIH07XG4gICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICB0aGlzLmFkZEVsZW1lbnRQbGFjZW1lbnQoZWxlbWVudCwgcGxhY2VtZW50cyk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgaWYgKCFfaGFzRGVjb3JhdG9ycyhlbGVtZW50KSkgcmV0dXJuIG5ld0VsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgdmFyIGVsZW1lbnRGaW5pc2hlcnNFeHRyYXMgPSB0aGlzLmRlY29yYXRlRWxlbWVudChlbGVtZW50LCBwbGFjZW1lbnRzKTtcbiAgICAgICAgICBuZXdFbGVtZW50cy5wdXNoKGVsZW1lbnRGaW5pc2hlcnNFeHRyYXMuZWxlbWVudCk7XG4gICAgICAgICAgbmV3RWxlbWVudHMucHVzaC5hcHBseShuZXdFbGVtZW50cywgZWxlbWVudEZpbmlzaGVyc0V4dHJhcy5leHRyYXMpO1xuICAgICAgICAgIGZpbmlzaGVycy5wdXNoLmFwcGx5KGZpbmlzaGVycywgZWxlbWVudEZpbmlzaGVyc0V4dHJhcy5maW5pc2hlcnMpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICBpZiAoIWRlY29yYXRvcnMpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZWxlbWVudHM6IG5ld0VsZW1lbnRzLFxuICAgICAgICAgICAgZmluaXNoZXJzOiBmaW5pc2hlcnNcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuZGVjb3JhdGVDb25zdHJ1Y3RvcihuZXdFbGVtZW50cywgZGVjb3JhdG9ycyk7XG4gICAgICAgIGZpbmlzaGVycy5wdXNoLmFwcGx5KGZpbmlzaGVycywgcmVzdWx0LmZpbmlzaGVycyk7XG4gICAgICAgIHJlc3VsdC5maW5pc2hlcnMgPSBmaW5pc2hlcnM7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuICAgICAgYWRkRWxlbWVudFBsYWNlbWVudDogZnVuY3Rpb24gKGVsZW1lbnQsIHBsYWNlbWVudHMsIHNpbGVudCkge1xuICAgICAgICB2YXIga2V5cyA9IHBsYWNlbWVudHNbZWxlbWVudC5wbGFjZW1lbnRdO1xuXG4gICAgICAgIGlmICghc2lsZW50ICYmIGtleXMuaW5kZXhPZihlbGVtZW50LmtleSkgIT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkR1cGxpY2F0ZWQgZWxlbWVudCAoXCIgKyBlbGVtZW50LmtleSArIFwiKVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGtleXMucHVzaChlbGVtZW50LmtleSk7XG4gICAgICB9LFxuICAgICAgZGVjb3JhdGVFbGVtZW50OiBmdW5jdGlvbiAoZWxlbWVudCwgcGxhY2VtZW50cykge1xuICAgICAgICB2YXIgZXh0cmFzID0gW107XG4gICAgICAgIHZhciBmaW5pc2hlcnMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBkZWNvcmF0b3JzID0gZWxlbWVudC5kZWNvcmF0b3JzLCBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHZhciBrZXlzID0gcGxhY2VtZW50c1tlbGVtZW50LnBsYWNlbWVudF07XG4gICAgICAgICAga2V5cy5zcGxpY2Uoa2V5cy5pbmRleE9mKGVsZW1lbnQua2V5KSwgMSk7XG4gICAgICAgICAgdmFyIGVsZW1lbnRPYmplY3QgPSB0aGlzLmZyb21FbGVtZW50RGVzY3JpcHRvcihlbGVtZW50KTtcbiAgICAgICAgICB2YXIgZWxlbWVudEZpbmlzaGVyRXh0cmFzID0gdGhpcy50b0VsZW1lbnRGaW5pc2hlckV4dHJhcygoMCwgZGVjb3JhdG9yc1tpXSkoZWxlbWVudE9iamVjdCkgfHwgZWxlbWVudE9iamVjdCk7XG4gICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnRGaW5pc2hlckV4dHJhcy5lbGVtZW50O1xuICAgICAgICAgIHRoaXMuYWRkRWxlbWVudFBsYWNlbWVudChlbGVtZW50LCBwbGFjZW1lbnRzKTtcblxuICAgICAgICAgIGlmIChlbGVtZW50RmluaXNoZXJFeHRyYXMuZmluaXNoZXIpIHtcbiAgICAgICAgICAgIGZpbmlzaGVycy5wdXNoKGVsZW1lbnRGaW5pc2hlckV4dHJhcy5maW5pc2hlcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG5ld0V4dHJhcyA9IGVsZW1lbnRGaW5pc2hlckV4dHJhcy5leHRyYXM7XG5cbiAgICAgICAgICBpZiAobmV3RXh0cmFzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5ld0V4dHJhcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICB0aGlzLmFkZEVsZW1lbnRQbGFjZW1lbnQobmV3RXh0cmFzW2pdLCBwbGFjZW1lbnRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXh0cmFzLnB1c2guYXBwbHkoZXh0cmFzLCBuZXdFeHRyYXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICBmaW5pc2hlcnM6IGZpbmlzaGVycyxcbiAgICAgICAgICBleHRyYXM6IGV4dHJhc1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGRlY29yYXRlQ29uc3RydWN0b3I6IGZ1bmN0aW9uIChlbGVtZW50cywgZGVjb3JhdG9ycykge1xuICAgICAgICB2YXIgZmluaXNoZXJzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB2YXIgb2JqID0gdGhpcy5mcm9tQ2xhc3NEZXNjcmlwdG9yKGVsZW1lbnRzKTtcbiAgICAgICAgICB2YXIgZWxlbWVudHNBbmRGaW5pc2hlciA9IHRoaXMudG9DbGFzc0Rlc2NyaXB0b3IoKDAsIGRlY29yYXRvcnNbaV0pKG9iaikgfHwgb2JqKTtcblxuICAgICAgICAgIGlmIChlbGVtZW50c0FuZEZpbmlzaGVyLmZpbmlzaGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZpbmlzaGVycy5wdXNoKGVsZW1lbnRzQW5kRmluaXNoZXIuZmluaXNoZXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChlbGVtZW50c0FuZEZpbmlzaGVyLmVsZW1lbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVsZW1lbnRzID0gZWxlbWVudHNBbmRGaW5pc2hlci5lbGVtZW50cztcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBlbGVtZW50cy5sZW5ndGggLSAxOyBqKyspIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgayA9IGogKyAxOyBrIDwgZWxlbWVudHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudHNbal0ua2V5ID09PSBlbGVtZW50c1trXS5rZXkgJiYgZWxlbWVudHNbal0ucGxhY2VtZW50ID09PSBlbGVtZW50c1trXS5wbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEdXBsaWNhdGVkIGVsZW1lbnQgKFwiICsgZWxlbWVudHNbal0ua2V5ICsgXCIpXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzLFxuICAgICAgICAgIGZpbmlzaGVyczogZmluaXNoZXJzXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgZnJvbUVsZW1lbnREZXNjcmlwdG9yOiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB2YXIgb2JqID0ge1xuICAgICAgICAgIGtpbmQ6IGVsZW1lbnQua2luZCxcbiAgICAgICAgICBrZXk6IGVsZW1lbnQua2V5LFxuICAgICAgICAgIHBsYWNlbWVudDogZWxlbWVudC5wbGFjZW1lbnQsXG4gICAgICAgICAgZGVzY3JpcHRvcjogZWxlbWVudC5kZXNjcmlwdG9yXG4gICAgICAgIH07XG4gICAgICAgIHZhciBkZXNjID0ge1xuICAgICAgICAgIHZhbHVlOiBcIkRlc2NyaXB0b3JcIixcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgU3ltYm9sLnRvU3RyaW5nVGFnLCBkZXNjKTtcbiAgICAgICAgaWYgKGVsZW1lbnQua2luZCA9PT0gXCJmaWVsZFwiKSBvYmouaW5pdGlhbGl6ZXIgPSBlbGVtZW50LmluaXRpYWxpemVyO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfSxcbiAgICAgIHRvRWxlbWVudERlc2NyaXB0b3JzOiBmdW5jdGlvbiAoZWxlbWVudE9iamVjdHMpIHtcbiAgICAgICAgaWYgKGVsZW1lbnRPYmplY3RzID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICAgICAgcmV0dXJuIF90b0FycmF5KGVsZW1lbnRPYmplY3RzKS5tYXAoZnVuY3Rpb24gKGVsZW1lbnRPYmplY3QpIHtcbiAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMudG9FbGVtZW50RGVzY3JpcHRvcihlbGVtZW50T2JqZWN0KTtcbiAgICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkoZWxlbWVudE9iamVjdCwgXCJmaW5pc2hlclwiLCBcIkFuIGVsZW1lbnQgZGVzY3JpcHRvclwiKTtcbiAgICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkoZWxlbWVudE9iamVjdCwgXCJleHRyYXNcIiwgXCJBbiBlbGVtZW50IGRlc2NyaXB0b3JcIik7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHRvRWxlbWVudERlc2NyaXB0b3I6IGZ1bmN0aW9uIChlbGVtZW50T2JqZWN0KSB7XG4gICAgICAgIHZhciBraW5kID0gU3RyaW5nKGVsZW1lbnRPYmplY3Qua2luZCk7XG5cbiAgICAgICAgaWYgKGtpbmQgIT09IFwibWV0aG9kXCIgJiYga2luZCAhPT0gXCJmaWVsZFwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQW4gZWxlbWVudCBkZXNjcmlwdG9yXFwncyAua2luZCBwcm9wZXJ0eSBtdXN0IGJlIGVpdGhlciBcIm1ldGhvZFwiIG9yJyArICcgXCJmaWVsZFwiLCBidXQgYSBkZWNvcmF0b3IgY3JlYXRlZCBhbiBlbGVtZW50IGRlc2NyaXB0b3Igd2l0aCcgKyAnIC5raW5kIFwiJyArIGtpbmQgKyAnXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBrZXkgPSBfdG9Qcm9wZXJ0eUtleShlbGVtZW50T2JqZWN0LmtleSk7XG5cbiAgICAgICAgdmFyIHBsYWNlbWVudCA9IFN0cmluZyhlbGVtZW50T2JqZWN0LnBsYWNlbWVudCk7XG5cbiAgICAgICAgaWYgKHBsYWNlbWVudCAhPT0gXCJzdGF0aWNcIiAmJiBwbGFjZW1lbnQgIT09IFwicHJvdG90eXBlXCIgJiYgcGxhY2VtZW50ICE9PSBcIm93blwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQW4gZWxlbWVudCBkZXNjcmlwdG9yXFwncyAucGxhY2VtZW50IHByb3BlcnR5IG11c3QgYmUgb25lIG9mIFwic3RhdGljXCIsJyArICcgXCJwcm90b3R5cGVcIiBvciBcIm93blwiLCBidXQgYSBkZWNvcmF0b3IgY3JlYXRlZCBhbiBlbGVtZW50IGRlc2NyaXB0b3InICsgJyB3aXRoIC5wbGFjZW1lbnQgXCInICsgcGxhY2VtZW50ICsgJ1wiJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IGVsZW1lbnRPYmplY3QuZGVzY3JpcHRvcjtcbiAgICAgICAgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KGVsZW1lbnRPYmplY3QsIFwiZWxlbWVudHNcIiwgXCJBbiBlbGVtZW50IGRlc2NyaXB0b3JcIik7XG4gICAgICAgIHZhciBlbGVtZW50ID0ge1xuICAgICAgICAgIGtpbmQ6IGtpbmQsXG4gICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICAgICAgZGVzY3JpcHRvcjogT2JqZWN0LmFzc2lnbih7fSwgZGVzY3JpcHRvcilcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoa2luZCAhPT0gXCJmaWVsZFwiKSB7XG4gICAgICAgICAgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KGVsZW1lbnRPYmplY3QsIFwiaW5pdGlhbGl6ZXJcIiwgXCJBIG1ldGhvZCBkZXNjcmlwdG9yXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShkZXNjcmlwdG9yLCBcImdldFwiLCBcIlRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIG9mIGEgZmllbGQgZGVzY3JpcHRvclwiKTtcbiAgICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkoZGVzY3JpcHRvciwgXCJzZXRcIiwgXCJUaGUgcHJvcGVydHkgZGVzY3JpcHRvciBvZiBhIGZpZWxkIGRlc2NyaXB0b3JcIik7XG4gICAgICAgICAgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KGRlc2NyaXB0b3IsIFwidmFsdWVcIiwgXCJUaGUgcHJvcGVydHkgZGVzY3JpcHRvciBvZiBhIGZpZWxkIGRlc2NyaXB0b3JcIik7XG4gICAgICAgICAgZWxlbWVudC5pbml0aWFsaXplciA9IGVsZW1lbnRPYmplY3QuaW5pdGlhbGl6ZXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgIH0sXG4gICAgICB0b0VsZW1lbnRGaW5pc2hlckV4dHJhczogZnVuY3Rpb24gKGVsZW1lbnRPYmplY3QpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnRvRWxlbWVudERlc2NyaXB0b3IoZWxlbWVudE9iamVjdCk7XG5cbiAgICAgICAgdmFyIGZpbmlzaGVyID0gX29wdGlvbmFsQ2FsbGFibGVQcm9wZXJ0eShlbGVtZW50T2JqZWN0LCBcImZpbmlzaGVyXCIpO1xuXG4gICAgICAgIHZhciBleHRyYXMgPSB0aGlzLnRvRWxlbWVudERlc2NyaXB0b3JzKGVsZW1lbnRPYmplY3QuZXh0cmFzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICAgIGZpbmlzaGVyOiBmaW5pc2hlcixcbiAgICAgICAgICBleHRyYXM6IGV4dHJhc1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGZyb21DbGFzc0Rlc2NyaXB0b3I6IGZ1bmN0aW9uIChlbGVtZW50cykge1xuICAgICAgICB2YXIgb2JqID0ge1xuICAgICAgICAgIGtpbmQ6IFwiY2xhc3NcIixcbiAgICAgICAgICBlbGVtZW50czogZWxlbWVudHMubWFwKHRoaXMuZnJvbUVsZW1lbnREZXNjcmlwdG9yLCB0aGlzKVxuICAgICAgICB9O1xuICAgICAgICB2YXIgZGVzYyA9IHtcbiAgICAgICAgICB2YWx1ZTogXCJEZXNjcmlwdG9yXCIsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIFN5bWJvbC50b1N0cmluZ1RhZywgZGVzYyk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9LFxuICAgICAgdG9DbGFzc0Rlc2NyaXB0b3I6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgdmFyIGtpbmQgPSBTdHJpbmcob2JqLmtpbmQpO1xuXG4gICAgICAgIGlmIChraW5kICE9PSBcImNsYXNzXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIGNsYXNzIGRlc2NyaXB0b3JcXCdzIC5raW5kIHByb3BlcnR5IG11c3QgYmUgXCJjbGFzc1wiLCBidXQgYSBkZWNvcmF0b3InICsgJyBjcmVhdGVkIGEgY2xhc3MgZGVzY3JpcHRvciB3aXRoIC5raW5kIFwiJyArIGtpbmQgKyAnXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGlzYWxsb3dQcm9wZXJ0eShvYmosIFwia2V5XCIsIFwiQSBjbGFzcyBkZXNjcmlwdG9yXCIpO1xuICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkob2JqLCBcInBsYWNlbWVudFwiLCBcIkEgY2xhc3MgZGVzY3JpcHRvclwiKTtcbiAgICAgICAgdGhpcy5kaXNhbGxvd1Byb3BlcnR5KG9iaiwgXCJkZXNjcmlwdG9yXCIsIFwiQSBjbGFzcyBkZXNjcmlwdG9yXCIpO1xuICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkob2JqLCBcImluaXRpYWxpemVyXCIsIFwiQSBjbGFzcyBkZXNjcmlwdG9yXCIpO1xuICAgICAgICB0aGlzLmRpc2FsbG93UHJvcGVydHkob2JqLCBcImV4dHJhc1wiLCBcIkEgY2xhc3MgZGVzY3JpcHRvclwiKTtcblxuICAgICAgICB2YXIgZmluaXNoZXIgPSBfb3B0aW9uYWxDYWxsYWJsZVByb3BlcnR5KG9iaiwgXCJmaW5pc2hlclwiKTtcblxuICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLnRvRWxlbWVudERlc2NyaXB0b3JzKG9iai5lbGVtZW50cyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzLFxuICAgICAgICAgIGZpbmlzaGVyOiBmaW5pc2hlclxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHJ1bkNsYXNzRmluaXNoZXJzOiBmdW5jdGlvbiAoY29uc3RydWN0b3IsIGZpbmlzaGVycykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbmlzaGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBuZXdDb25zdHJ1Y3RvciA9ICgwLCBmaW5pc2hlcnNbaV0pKGNvbnN0cnVjdG9yKTtcblxuICAgICAgICAgIGlmIChuZXdDb25zdHJ1Y3RvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5ld0NvbnN0cnVjdG9yICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpbmlzaGVycyBtdXN0IHJldHVybiBhIGNvbnN0cnVjdG9yLlwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3RydWN0b3IgPSBuZXdDb25zdHJ1Y3RvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uc3RydWN0b3I7XG4gICAgICB9LFxuICAgICAgZGlzYWxsb3dQcm9wZXJ0eTogZnVuY3Rpb24gKG9iaiwgbmFtZSwgb2JqZWN0VHlwZSkge1xuICAgICAgICBpZiAob2JqW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKG9iamVjdFR5cGUgKyBcIiBjYW4ndCBoYXZlIGEgLlwiICsgbmFtZSArIFwiIHByb3BlcnR5LlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGFwaTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50RGVzY3JpcHRvcihkZWYpIHtcbiAgICB2YXIga2V5ID0gX3RvUHJvcGVydHlLZXkoZGVmLmtleSk7XG5cbiAgICB2YXIgZGVzY3JpcHRvcjtcblxuICAgIGlmIChkZWYua2luZCA9PT0gXCJtZXRob2RcIikge1xuICAgICAgZGVzY3JpcHRvciA9IHtcbiAgICAgICAgdmFsdWU6IGRlZi52YWx1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChkZWYua2luZCA9PT0gXCJnZXRcIikge1xuICAgICAgZGVzY3JpcHRvciA9IHtcbiAgICAgICAgZ2V0OiBkZWYudmFsdWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChkZWYua2luZCA9PT0gXCJzZXRcIikge1xuICAgICAgZGVzY3JpcHRvciA9IHtcbiAgICAgICAgc2V0OiBkZWYudmFsdWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChkZWYua2luZCA9PT0gXCJmaWVsZFwiKSB7XG4gICAgICBkZXNjcmlwdG9yID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50ID0ge1xuICAgICAga2luZDogZGVmLmtpbmQgPT09IFwiZmllbGRcIiA/IFwiZmllbGRcIiA6IFwibWV0aG9kXCIsXG4gICAgICBrZXk6IGtleSxcbiAgICAgIHBsYWNlbWVudDogZGVmLnN0YXRpYyA/IFwic3RhdGljXCIgOiBkZWYua2luZCA9PT0gXCJmaWVsZFwiID8gXCJvd25cIiA6IFwicHJvdG90eXBlXCIsXG4gICAgICBkZXNjcmlwdG9yOiBkZXNjcmlwdG9yXG4gICAgfTtcbiAgICBpZiAoZGVmLmRlY29yYXRvcnMpIGVsZW1lbnQuZGVjb3JhdG9ycyA9IGRlZi5kZWNvcmF0b3JzO1xuICAgIGlmIChkZWYua2luZCA9PT0gXCJmaWVsZFwiKSBlbGVtZW50LmluaXRpYWxpemVyID0gZGVmLnZhbHVlO1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gX2NvYWxlc2NlR2V0dGVyU2V0dGVyKGVsZW1lbnQsIG90aGVyKSB7XG4gICAgaWYgKGVsZW1lbnQuZGVzY3JpcHRvci5nZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgb3RoZXIuZGVzY3JpcHRvci5nZXQgPSBlbGVtZW50LmRlc2NyaXB0b3IuZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICBvdGhlci5kZXNjcmlwdG9yLnNldCA9IGVsZW1lbnQuZGVzY3JpcHRvci5zZXQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2NvYWxlc2NlQ2xhc3NFbGVtZW50cyhlbGVtZW50cykge1xuICAgIHZhciBuZXdFbGVtZW50cyA9IFtdO1xuXG4gICAgdmFyIGlzU2FtZUVsZW1lbnQgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgIHJldHVybiBvdGhlci5raW5kID09PSBcIm1ldGhvZFwiICYmIG90aGVyLmtleSA9PT0gZWxlbWVudC5rZXkgJiYgb3RoZXIucGxhY2VtZW50ID09PSBlbGVtZW50LnBsYWNlbWVudDtcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgIHZhciBvdGhlcjtcblxuICAgICAgaWYgKGVsZW1lbnQua2luZCA9PT0gXCJtZXRob2RcIiAmJiAob3RoZXIgPSBuZXdFbGVtZW50cy5maW5kKGlzU2FtZUVsZW1lbnQpKSkge1xuICAgICAgICBpZiAoX2lzRGF0YURlc2NyaXB0b3IoZWxlbWVudC5kZXNjcmlwdG9yKSB8fCBfaXNEYXRhRGVzY3JpcHRvcihvdGhlci5kZXNjcmlwdG9yKSkge1xuICAgICAgICAgIGlmIChfaGFzRGVjb3JhdG9ycyhlbGVtZW50KSB8fCBfaGFzRGVjb3JhdG9ycyhvdGhlcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcIkR1cGxpY2F0ZWQgbWV0aG9kcyAoXCIgKyBlbGVtZW50LmtleSArIFwiKSBjYW4ndCBiZSBkZWNvcmF0ZWQuXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG90aGVyLmRlc2NyaXB0b3IgPSBlbGVtZW50LmRlc2NyaXB0b3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKF9oYXNEZWNvcmF0b3JzKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICBpZiAoX2hhc0RlY29yYXRvcnMob3RoZXIpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcIkRlY29yYXRvcnMgY2FuJ3QgYmUgcGxhY2VkIG9uIGRpZmZlcmVudCBhY2Nlc3NvcnMgd2l0aCBmb3IgXCIgKyBcInRoZSBzYW1lIHByb3BlcnR5IChcIiArIGVsZW1lbnQua2V5ICsgXCIpLlwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3RoZXIuZGVjb3JhdG9ycyA9IGVsZW1lbnQuZGVjb3JhdG9ycztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfY29hbGVzY2VHZXR0ZXJTZXR0ZXIoZWxlbWVudCwgb3RoZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdFbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXdFbGVtZW50cztcbiAgfVxuXG4gIGZ1bmN0aW9uIF9oYXNEZWNvcmF0b3JzKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudC5kZWNvcmF0b3JzICYmIGVsZW1lbnQuZGVjb3JhdG9ycy5sZW5ndGg7XG4gIH1cblxuICBmdW5jdGlvbiBfaXNEYXRhRGVzY3JpcHRvcihkZXNjKSB7XG4gICAgcmV0dXJuIGRlc2MgIT09IHVuZGVmaW5lZCAmJiAhKGRlc2MudmFsdWUgPT09IHVuZGVmaW5lZCAmJiBkZXNjLndyaXRhYmxlID09PSB1bmRlZmluZWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gX29wdGlvbmFsQ2FsbGFibGVQcm9wZXJ0eShvYmosIG5hbWUpIHtcbiAgICB2YXIgdmFsdWUgPSBvYmpbbmFtZV07XG5cbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkICdcIiArIG5hbWUgKyBcIicgdG8gYmUgYSBmdW5jdGlvblwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICB2YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxuICBmdW5jdGlvbiBjcmVhdGVDb21tb25qc01vZHVsZShmbiwgbW9kdWxlKSB7XG4gIFx0cmV0dXJuIG1vZHVsZSA9IHsgZXhwb3J0czoge30gfSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xuICB9XG5cbiAgdmFyIGluZGV4X21pbiA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuICBmdW5jdGlvbiB1KCkge1xuICAgIGZ1bmN0aW9uIHQodCkge1xuICAgICAgdGhpcy5vcHRzID0ge1xuICAgICAgICBtZXNzYWdlczogeCh7fSwgdylcbiAgICAgIH0sIHQgJiYgeCh0aGlzLm9wdHMsIHQpLCB0aGlzLm1lc3NhZ2VzID0gdGhpcy5vcHRzLm1lc3NhZ2VzLCB0aGlzLnJ1bGVzID0ge1xuICAgICAgICBhbnk6IGIsXG4gICAgICAgIGFycmF5OiB5LFxuICAgICAgICBib29sZWFuOiBnLFxuICAgICAgICBjdXN0b206IHYsXG4gICAgICAgIGRhdGU6IGQsXG4gICAgICAgIGVtYWlsOiBtLFxuICAgICAgICBlbnVtOiBoLFxuICAgICAgICBlcXVhbDogcCxcbiAgICAgICAgZm9yYmlkZGVuOiBjLFxuICAgICAgICBmdW5jdGlvbjogZixcbiAgICAgICAgbXVsdGk6IG8sXG4gICAgICAgIG51bWJlcjogbCxcbiAgICAgICAgb2JqZWN0OiB1LFxuICAgICAgICBzdHJpbmc6IHMsXG4gICAgICAgIHVybDogaSxcbiAgICAgICAgdXVpZDogYSxcbiAgICAgICAgbWFjOiByLFxuICAgICAgICBsdWhuOiBuXG4gICAgICB9LCB0aGlzLmNhY2hlID0gbmV3IE1hcCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGUodCkge1xuICAgICAgcmV0dXJuIGsgfHwgKGsgPSBTKCksIE8gPSB7XG4gICAgICAgIHBhcnNlcjogXCJiYWJlbFwiLFxuICAgICAgICB1c2VUYWJzOiAhMSxcbiAgICAgICAgcHJpbnRXaWR0aDogMTIwLFxuICAgICAgICB0cmFpbGluZ0NvbW1hOiBcIm5vbmVcIixcbiAgICAgICAgdGFiV2lkdGg6IDQsXG4gICAgICAgIHNpbmdsZVF1b3RlOiAhMSxcbiAgICAgICAgc2VtaTogITAsXG4gICAgICAgIGJyYWNrZXRTcGFjaW5nOiAhMFxuICAgICAgfSwgaiA9IFMoKSwgXyA9IHtcbiAgICAgICAgbGFuZ3VhZ2U6IFwianNcIixcbiAgICAgICAgdGhlbWU6IGouZnJvbUpzb24oe1xuICAgICAgICAgIGtleXdvcmQ6IFtcIndoaXRlXCIsIFwiYm9sZFwiXSxcbiAgICAgICAgICBidWlsdF9pbjogXCJtYWdlbnRhXCIsXG4gICAgICAgICAgbGl0ZXJhbDogXCJjeWFuXCIsXG4gICAgICAgICAgbnVtYmVyOiBcIm1hZ2VudGFcIixcbiAgICAgICAgICByZWdleHA6IFwicmVkXCIsXG4gICAgICAgICAgc3RyaW5nOiBbXCJ5ZWxsb3dcIiwgXCJib2xkXCJdLFxuICAgICAgICAgIHN5bWJvbDogXCJwbGFpblwiLFxuICAgICAgICAgIGNsYXNzOiBcImJsdWVcIixcbiAgICAgICAgICBhdHRyOiBcInBsYWluXCIsXG4gICAgICAgICAgZnVuY3Rpb246IFtcIndoaXRlXCIsIFwiYm9sZFwiXSxcbiAgICAgICAgICB0aXRsZTogXCJwbGFpblwiLFxuICAgICAgICAgIHBhcmFtczogXCJncmVlblwiLFxuICAgICAgICAgIGNvbW1lbnQ6IFwiZ3JleVwiXG4gICAgICAgIH0pXG4gICAgICB9KSwgdCA9IGsuZm9ybWF0KHQsIE8pLCBqLmhpZ2hsaWdodCh0LCBfKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBuKHQpIHtcbiAgICAgIHJldHVybiB0ID0gdC5tZXNzYWdlcywge1xuICAgICAgICBzb3VyY2U6ICdcXG5cXHRcXHRcXHRpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XFxuXFx0XFx0XFx0XFx0JyArIHRoaXMubWFrZUVycm9yKHtcbiAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgIGFjdHVhbDogXCJ2YWx1ZVwiLFxuICAgICAgICAgIG1lc3NhZ2VzOiB0XG4gICAgICAgIH0pICsgJ1xcblxcdFxcdFxcdFxcdHJldHVybiB2YWx1ZTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIilcXG5cXHRcXHRcXHRcXHR2YWx1ZSA9IFN0cmluZyh2YWx1ZSk7XFxuXFxuXFx0XFx0XFx0dmFsID0gdmFsdWUucmVwbGFjZSgvXFxcXEQrL2csIFwiXCIpO1xcblxcblxcdFxcdFxcdHZhciBhcnJheSA9IFswLCAyLCA0LCA2LCA4LCAxLCAzLCA1LCA3LCA5XTtcXG5cXHRcXHRcXHR2YXIgbGVuID0gdmFsID8gdmFsLmxlbmd0aCA6IDAsXFxuXFx0XFx0XFx0XFx0Yml0ID0gMSxcXG5cXHRcXHRcXHRcXHRzdW0gPSAwO1xcblxcdFxcdFxcdHdoaWxlIChsZW4tLSkge1xcblxcdFxcdFxcdFxcdHN1bSArPSAhKGJpdCBePSAxKSA/IHBhcnNlSW50KHZhbFtsZW5dLCAxMCkgOiBhcnJheVt2YWxbbGVuXV07XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICghKHN1bSAlIDEwID09PSAwICYmIHN1bSA+IDApKSB7XFxuXFx0XFx0XFx0XFx0JyArIHRoaXMubWFrZUVycm9yKHtcbiAgICAgICAgICB0eXBlOiBcImx1aG5cIixcbiAgICAgICAgICBhY3R1YWw6IFwidmFsdWVcIixcbiAgICAgICAgICBtZXNzYWdlczogdFxuICAgICAgICB9KSArIFwiXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB2YWx1ZTtcXG5cXHRcXHRcIlxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByKHQpIHtcbiAgICAgIHJldHVybiB0ID0gdC5tZXNzYWdlcywge1xuICAgICAgICBzb3VyY2U6ICdcXG5cXHRcXHRcXHRpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XFxuXFx0XFx0XFx0XFx0JyArIHRoaXMubWFrZUVycm9yKHtcbiAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgIGFjdHVhbDogXCJ2YWx1ZVwiLFxuICAgICAgICAgIG1lc3NhZ2VzOiB0XG4gICAgICAgIH0pICsgXCJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdmFsdWU7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciB2ID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcXG5cXHRcXHRcXHRpZiAoIVwiICsgUC50b1N0cmluZygpICsgXCIudGVzdCh2KSkge1xcblxcdFxcdFxcdFxcdFwiICsgdGhpcy5tYWtlRXJyb3Ioe1xuICAgICAgICAgIHR5cGU6IFwibWFjXCIsXG4gICAgICAgICAgYWN0dWFsOiBcInZhbHVlXCIsXG4gICAgICAgICAgbWVzc2FnZXM6IHRcbiAgICAgICAgfSkgKyBcIlxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdmFsdWU7XFxuXFx0XFx0XCJcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYSh0KSB7XG4gICAgICB2YXIgZSA9IHQuc2NoZW1hO1xuICAgICAgdCA9IHQubWVzc2FnZXM7XG4gICAgICB2YXIgbiA9IFtdO1xuICAgICAgcmV0dXJuIG4ucHVzaCgnXFxuXFx0XFx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xcblxcdFxcdFxcdCcgKyB0aGlzLm1ha2VFcnJvcih7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGFjdHVhbDogXCJ2YWx1ZVwiLFxuICAgICAgICBtZXNzYWdlczogdFxuICAgICAgfSkgKyBcIlxcblxcdFxcdFxcdHJldHVybiB2YWx1ZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dmFyIHZhbCA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XFxuXFx0XFx0aWYgKCFcIiArIEkudG9TdHJpbmcoKSArIFwiLnRlc3QodmFsKSkge1xcblxcdFxcdFxcdFwiICsgdGhpcy5tYWtlRXJyb3Ioe1xuICAgICAgICB0eXBlOiBcInV1aWRcIixcbiAgICAgICAgYWN0dWFsOiBcInZhbHVlXCIsXG4gICAgICAgIG1lc3NhZ2VzOiB0XG4gICAgICB9KSArIFwiXFxuXFx0XFx0XFx0cmV0dXJuIHZhbHVlO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRjb25zdCB2ZXJzaW9uID0gdmFsLmNoYXJBdCgxNCkgfCAwO1xcblxcdFwiKSwgZS52ZXJzaW9uICYmIG4ucHVzaChcIlxcblxcdFxcdFxcdGlmIChcIiArIGUudmVyc2lvbiArIFwiICE9PSB2ZXJzaW9uKSB7XFxuXFx0XFx0XFx0XFx0XCIgKyB0aGlzLm1ha2VFcnJvcih7XG4gICAgICAgIHR5cGU6IFwidXVpZFZlcnNpb25cIixcbiAgICAgICAgZXhwZWN0ZWQ6IGUudmVyc2lvbixcbiAgICAgICAgYWN0dWFsOiBcInZlcnNpb25cIixcbiAgICAgICAgbWVzc2FnZXM6IHRcbiAgICAgIH0pICsgXCJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdmFsdWU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFwiKSwgbi5wdXNoKCdcXG5cXHRcXHRzd2l0Y2ggKHZlcnNpb24pIHtcXG5cXHRcXHRjYXNlIDE6XFxuXFx0XFx0Y2FzZSAyOlxcblxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdGNhc2UgMzpcXG5cXHRcXHRjYXNlIDQ6XFxuXFx0XFx0Y2FzZSA1OlxcblxcdFxcdFxcdGlmIChbXCI4XCIsIFwiOVwiLCBcImFcIiwgXCJiXCJdLmluZGV4T2YodmFsdWUuY2hhckF0KDE5KSkgPT09IC0xKSB7XFxuXFx0XFx0XFx0XFx0JyArIHRoaXMubWFrZUVycm9yKHtcbiAgICAgICAgdHlwZTogXCJ1dWlkXCIsXG4gICAgICAgIGFjdHVhbDogXCJ2YWx1ZVwiLFxuICAgICAgICBtZXNzYWdlczogdFxuICAgICAgfSkgKyBcIlxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHZhbHVlO1xcblxcdFwiKSwge1xuICAgICAgICBzb3VyY2U6IG4uam9pbihcIlxcblwiKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpKHQpIHtcbiAgICAgIHQgPSB0Lm1lc3NhZ2VzO1xuICAgICAgdmFyIGUgPSBbXTtcbiAgICAgIHJldHVybiBlLnB1c2goJ1xcblxcdFxcdGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcXG5cXHRcXHRcXHQnICsgdGhpcy5tYWtlRXJyb3Ioe1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBhY3R1YWw6IFwidmFsdWVcIixcbiAgICAgICAgbWVzc2FnZXM6IHRcbiAgICAgIH0pICsgXCJcXG5cXHRcXHRcXHRyZXR1cm4gdmFsdWU7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICghXCIgKyBSLnRvU3RyaW5nKCkgKyBcIi50ZXN0KHZhbHVlKSkge1xcblxcdFxcdFxcdFwiICsgdGhpcy5tYWtlRXJyb3Ioe1xuICAgICAgICB0eXBlOiBcInVybFwiLFxuICAgICAgICBhY3R1YWw6IFwidmFsdWVcIixcbiAgICAgICAgbWVzc2FnZXM6IHRcbiAgICAgIH0pICsgXCJcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHZhbHVlO1xcblxcdFwiKSwge1xuICAgICAgICBzb3VyY2U6IGUuam9pbihcIlxcblwiKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzKHQpIHtcbiAgICAgIHZhciBlID0gdC5zY2hlbWE7XG4gICAgICB0ID0gdC5tZXNzYWdlcztcbiAgICAgIHZhciBuID0gW10sXG4gICAgICAgICAgciA9ICExO1xuXG4gICAgICBpZiAoITAgPT09IGUuY29udmVydCAmJiAociA9ICEwLCBuLnB1c2goJ1xcblxcdFxcdFxcdGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcXG5cXHRcXHRcXHRcXHR2YWx1ZSA9IFN0cmluZyh2YWx1ZSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdCcpKSwgbi5wdXNoKCdcXG5cXHRcXHRpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XFxuXFx0XFx0XFx0JyArIHRoaXMubWFrZUVycm9yKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgYWN0dWFsOiBcInZhbHVlXCIsXG4gICAgICAgIG1lc3NhZ2VzOiB0XG4gICAgICB9KSArIFwiXFxuXFx0XFx0XFx0cmV0dXJuIHZhbHVlO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR2YXIgb3JpZ1ZhbHVlID0gdmFsdWU7XFxuXFx0XCIpLCBlLnRyaW0gJiYgKHIgPSAhMCwgbi5wdXNoKFwiXFxuXFx0XFx0XFx0dmFsdWUgPSB2YWx1ZS50cmltKCk7XFxuXFx0XFx0XCIpKSwgZS50cmltTGVmdCAmJiAociA9ICEwLCBuLnB1c2goXCJcXG5cXHRcXHRcXHR2YWx1ZSA9IHZhbHVlLnRyaW1MZWZ0KCk7XFxuXFx0XFx0XCIpKSwgZS50cmltUmlnaHQgJiYgKHIgPSAhMCwgbi5wdXNoKFwiXFxuXFx0XFx0XFx0dmFsdWUgPSB2YWx1ZS50cmltUmlnaHQoKTtcXG5cXHRcXHRcIikpLCBlLnBhZFN0YXJ0ICYmIChyID0gITAsIG4ucHVzaChcIlxcblxcdFxcdFxcdHZhbHVlID0gdmFsdWUucGFkU3RhcnQoXCIgKyBlLnBhZFN0YXJ0ICsgXCIsIFwiICsgSlNPTi5zdHJpbmdpZnkobnVsbCAhPSBlLnBhZENoYXIgPyBlLnBhZENoYXIgOiBcIiBcIikgKyBcIik7XFxuXFx0XFx0XCIpKSwgZS5wYWRFbmQgJiYgKHIgPSAhMCwgbi5wdXNoKFwiXFxuXFx0XFx0XFx0dmFsdWUgPSB2YWx1ZS5wYWRFbmQoXCIgKyBlLnBhZEVuZCArIFwiLCBcIiArIEpTT04uc3RyaW5naWZ5KG51bGwgIT0gZS5wYWRDaGFyID8gZS5wYWRDaGFyIDogXCIgXCIpICsgXCIpO1xcblxcdFxcdFwiKSksIGUubG93ZXJjYXNlICYmIChyID0gITAsIG4ucHVzaChcIlxcblxcdFxcdFxcdHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcXG5cXHRcXHRcIikpLCBlLnVwcGVyY2FzZSAmJiAociA9ICEwLCBuLnB1c2goXCJcXG5cXHRcXHRcXHR2YWx1ZSA9IHZhbHVlLnRvVXBwZXJDYXNlKCk7XFxuXFx0XFx0XCIpKSwgZS5sb2NhbGVMb3dlcmNhc2UgJiYgKHIgPSAhMCwgbi5wdXNoKFwiXFxuXFx0XFx0XFx0dmFsdWUgPSB2YWx1ZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xcblxcdFxcdFwiKSksIGUubG9jYWxlVXBwZXJjYXNlICYmIChyID0gITAsIG4ucHVzaChcIlxcblxcdFxcdFxcdHZhbHVlID0gdmFsdWUudG9Mb2NhbGVVcHBlckNhc2UoKTtcXG5cXHRcXHRcIikpLCBuLnB1c2goXCJcXG5cXHRcXHRcXHR2YXIgbGVuID0gdmFsdWUubGVuZ3RoO1xcblxcdFwiKSwgITEgPT09IGUuZW1wdHkgJiYgbi5wdXNoKFwiXFxuXFx0XFx0XFx0aWYgKGxlbiA9PT0gMCkge1xcblxcdFxcdFxcdFxcdFwiICsgdGhpcy5tYWtlRXJyb3Ioe1xuICAgICAgICB0eXBlOiBcInN0cmluZ0VtcHR5XCIsXG4gICAgICAgIGFjdHVhbDogXCJ2YWx1ZVwiLFxuICAgICAgICBtZXNzYWdlczogdFxuICAgICAgfSkgKyBcIlxcblxcdFxcdFxcdH1cXG5cXHRcXHRcIiksIG51bGwgIT0gZS5taW4gJiYgbi5wdXNoKFwiXFxuXFx0XFx0XFx0aWYgKGxlbiA8IFwiICsgZS5taW4gKyBcIikge1xcblxcdFxcdFxcdFxcdFwiICsgdGhpcy5tYWtlRXJyb3Ioe1xuICAgICAgICB0eXBlOiBcInN0cmluZ01pblwiLFxuICAgICAgICBleHBlY3RlZDogZS5taW4sXG4gICAgICAgIGFjdHVhbDogXCJsZW5cIixcbiAgICAgICAgbWVzc2FnZXM6IHRcbiAgICAgIH0pICsgXCJcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XCIpLCBudWxsICE9IGUubWF4ICYmIG4ucHVzaChcIlxcblxcdFxcdFxcdGlmIChsZW4gPiBcIiArIGUubWF4ICsgXCIpIHtcXG5cXHRcXHRcXHRcXHRcIiArIHRoaXMubWFrZUVycm9yKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdNYXhcIixcbiAgICAgICAgZXhwZWN0ZWQ6IGUubWF4LFxuICAgICAgICBhY3R1YWw6IFwibGVuXCIsXG4gICAgICAgIG1lc3NhZ2VzOiB0XG4gICAgICB9KSArIFwiXFxuXFx0XFx0XFx0fVxcblxcdFxcdFwiKSwgbnVsbCAhPSBlLmxlbmd0aCAmJiBuLnB1c2goXCJcXG5cXHRcXHRcXHRpZiAobGVuICE9PSBcIiArIGUubGVuZ3RoICsgXCIpIHtcXG5cXHRcXHRcXHRcXHRcIiArIHRoaXMubWFrZUVycm9yKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdMZW5ndGhcIixcbiAgICAgICAgZXhwZWN0ZWQ6IGUubGVuZ3RoLFxuICAgICAgICBhY3R1YWw6IFwibGVuXCIsXG4gICAgICAgIG1lc3NhZ2VzOiB0XG4gICAgICB9KSArIFwiXFxuXFx0XFx0XFx0fVxcblxcdFxcdFwiKSwgbnVsbCAhPSBlLnBhdHRlcm4pIHtcbiAgICAgICAgdmFyIGEgPSBlLnBhdHRlcm47XG4gICAgICAgIFwic3RyaW5nXCIgPT0gdHlwZW9mIGUucGF0dGVybiAmJiAoYSA9IG5ldyBSZWdFeHAoZS5wYXR0ZXJuLCBlLnBhdHRlcm5GbGFncykpLCBuLnB1c2goXCJcXG5cXHRcXHRcXHRpZiAoIVwiICsgYS50b1N0cmluZygpICsgXCIudGVzdCh2YWx1ZSkpXFxuXFx0XFx0XFx0XFx0XCIgKyB0aGlzLm1ha2VFcnJvcih7XG4gICAgICAgICAgdHlwZTogXCJzdHJpbmdQYXR0ZXJuXCIsXG4gICAgICAgICAgZXhwZWN0ZWQ6ICdcIicgKyBhLnRvU3RyaW5nKCkucmVwbGFjZSgnXCInLCAnXFxcXFwiJykgKyAnXCInLFxuICAgICAgICAgIGFjdHVhbDogXCJvcmlnVmFsdWVcIixcbiAgICAgICAgICBtZXNzYWdlczogdFxuICAgICAgICB9KSArIFwiXFxuXFx0XFx0XCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbCAhPSBlLmNvbnRhaW5zICYmIG4ucHVzaCgnXFxuXFx0XFx0XFx0aWYgKHZhbHVlLmluZGV4T2YoXCInICsgZS5jb250YWlucyArICdcIikgPT09IC0xKSB7XFxuXFx0XFx0XFx0XFx0JyArIHRoaXMubWFrZUVycm9yKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdDb250YWluc1wiLFxuICAgICAgICBleHBlY3RlZDogJ1wiJyArIGUuY29udGFpbnMgKyAnXCInLFxuICAgICAgICBhY3R1YWw6IFwib3JpZ1ZhbHVlXCIsXG4gICAgICAgIG1lc3NhZ2VzOiB0XG4gICAgICB9KSArIFwiXFxuXFx0XFx0XFx0fVxcblxcdFxcdFwiKSwgbnVsbCAhPSBlLmVudW0gJiYgKGEgPSBKU09OLnN0cmluZ2lmeShlLmVudW0pLCBuLnB1c2goXCJcXG5cXHRcXHRcXHRpZiAoXCIgKyBhICsgXCIuaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XFxuXFx0XFx0XFx0XFx0XCIgKyB0aGlzLm1ha2VFcnJvcih7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nRW51bVwiLFxuICAgICAgICBleHBlY3RlZDogJ1wiJyArIGUuZW51bS5qb2luKFwiLCBcIikgKyAnXCInLFxuICAgICAgICBhY3R1YWw6IFwib3JpZ1ZhbHVlXCIsXG4gICAgICAgIG1lc3NhZ2VzOiB0XG4gICAgICB9KSArIFwiXFxuXFx0XFx0XFx0fVxcblxcdFxcdFwiKSksICEwID09PSBlLm51bWVyaWMgJiYgbi5wdXNoKFwiXFxuXFx0XFx0XFx0aWYgKCFcIiArIFYudG9TdHJpbmcoKSArIFwiLnRlc3QodmFsdWUpICkge1xcblxcdFxcdFxcdFxcdFwiICsgdGhpcy5tYWtlRXJyb3Ioe1xuICAgICAgICB0eXBlOiBcInN0cmluZ051bWVyaWNcIixcbiAgICAgICAgYWN0dWFsOiBcIm9yaWdWYWx1ZVwiLFxuICAgICAgICBtZXNzYWdlczogdFxuICAgICAgfSkgKyBcIlxcblxcdFxcdFxcdH1cXG5cXHRcXHRcIiksICEwID09PSBlLmFscGhhICYmIG4ucHVzaChcIlxcblxcdFxcdFxcdGlmKCFcIiArIE0udG9TdHJpbmcoKSArIFwiLnRlc3QodmFsdWUpKSB7XFxuXFx0XFx0XFx0XFx0XCIgKyB0aGlzLm1ha2VFcnJvcih7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nQWxwaGFcIixcbiAgICAgICAgYWN0dWFsOiBcIm9yaWdWYWx1ZVwiLFxuICAgICAgICBtZXNzYWdlczogdFxuICAgICAgfSkgKyBcIlxcblxcdFxcdFxcdH1cXG5cXHRcXHRcIiksICEwID09PSBlLmFscGhhbnVtICYmIG4ucHVzaChcIlxcblxcdFxcdFxcdGlmKCFcIiArIHEudG9TdHJpbmcoKSArIFwiLnRlc3QodmFsdWUpKSB7XFxuXFx0XFx0XFx0XFx0XCIgKyB0aGlzLm1ha2VFcnJvcih7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nQWxwaGFudW1cIixcbiAgICAgICAgYWN0dWFsOiBcIm9yaWdWYWx1ZVwiLFxuICAgICAgICBtZXNzYWdlczogdFxuICAgICAgfSkgKyBcIlxcblxcdFxcdFxcdH1cXG5cXHRcXHRcIiksICEwID09PSBlLmFscGhhZGFzaCAmJiBuLnB1c2goXCJcXG5cXHRcXHRcXHRpZighXCIgKyBGLnRvU3RyaW5nKCkgKyBcIi50ZXN0KHZhbHVlKSkge1xcblxcdFxcdFxcdFxcdFwiICsgdGhpcy5tYWtlRXJyb3Ioe1xuICAgICAgICB0eXBlOiBcInN0cmluZ0FscGhhZGFzaFwiLFxuICAgICAgICBhY3R1YWw6IFwib3JpZ1ZhbHVlXCIsXG4gICAgICAgIG1lc3NhZ2VzOiB0XG4gICAgICB9KSArIFwiXFxuXFx0XFx0XFx0fVxcblxcdFxcdFwiKSwgbi5wdXNoKFwiXFxuXFx0XFx0cmV0dXJuIHZhbHVlO1xcblxcdFwiKSwge1xuICAgICAgICBzYW5pdGl6ZWQ6IHIsXG4gICAgICAgIHNvdXJjZTogbi5qb2luKFwiXFxuXCIpXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHUodCwgZSwgbikge1xuICAgICAgdmFyIHIgPSB0LnNjaGVtYTtcbiAgICAgIHQgPSB0Lm1lc3NhZ2VzO1xuICAgICAgdmFyIGEgPSBbXTtcbiAgICAgIGEucHVzaCgnXFxuXFx0XFx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSA9PT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xcblxcdFxcdFxcdCcgKyB0aGlzLm1ha2VFcnJvcih7XG4gICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgIGFjdHVhbDogXCJ2YWx1ZVwiLFxuICAgICAgICBtZXNzYWdlczogdFxuICAgICAgfSkgKyBcIlxcblxcdFxcdFxcdHJldHVybiB2YWx1ZTtcXG5cXHRcXHR9XFxuXFx0XCIpO1xuICAgICAgdmFyIGkgPSByLnByb3BlcnRpZXMgfHwgci5wcm9wcztcblxuICAgICAgaWYgKGkpIHtcbiAgICAgICAgYS5wdXNoKFwidmFyIHBhcmVudE9iaiA9IHZhbHVlO1wiKSwgYS5wdXNoKFwidmFyIHBhcmVudEZpZWxkID0gZmllbGQ7XCIpO1xuXG4gICAgICAgIGZvciAodmFyIHMgPSBPYmplY3Qua2V5cyhpKSwgdSA9IDA7IHUgPCBzLmxlbmd0aDsgdSsrKSB7XG4gICAgICAgICAgdmFyIGwgPSBzW3VdLFxuICAgICAgICAgICAgICBvID0gRShsKSxcbiAgICAgICAgICAgICAgZiA9IEEudGVzdChvKSA/IFwiLlwiICsgbyA6IFwiWydcIiArIG8gKyBcIiddXCIsXG4gICAgICAgICAgICAgIGMgPSBcInBhcmVudE9ialwiICsgZixcbiAgICAgICAgICAgICAgcCA9IChlID8gZSArIFwiLlwiIDogXCJcIikgKyBsO1xuICAgICAgICAgIGEucHVzaChcIlxcbi8vIEZpZWxkOiBcIiArIEUocCkpLCBhLnB1c2goJ2ZpZWxkID0gcGFyZW50RmllbGQgPyBwYXJlbnRGaWVsZCArIFwiJyArIGYgKyAnXCIgOiBcIicgKyBvICsgJ1wiOycpLCBhLnB1c2goXCJ2YWx1ZSA9IFwiICsgYyArIFwiO1wiKSwgbCA9IHRoaXMuZ2V0UnVsZUZyb21TY2hlbWEoaVtsXSksIGEucHVzaCh0aGlzLmNvbXBpbGVSdWxlKGwsIG4sIHAsIGMgKyBcIiA9IGNvbnRleHQuZm5bJSVJTkRFWCUlXSh2YWx1ZSwgZmllbGQsIHBhcmVudE9iaiwgZXJyb3JzLCBjb250ZXh0KTtcIiwgYykpO1xuICAgICAgICB9XG5cbiAgICAgICAgci5zdHJpY3QgJiYgKGUgPSBPYmplY3Qua2V5cyhpKSwgYS5wdXNoKFwiXFxuXFx0XFx0XFx0XFx0ZmllbGQgPSBwYXJlbnRGaWVsZDtcXG5cXHRcXHRcXHRcXHR2YXIgaW52YWxpZFByb3BzID0gW107XFxuXFx0XFx0XFx0XFx0dmFyIHByb3BzID0gT2JqZWN0LmtleXMocGFyZW50T2JqKTtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKFwiICsgSlNPTi5zdHJpbmdpZnkoZSkgKyBcIi5pbmRleE9mKHByb3BzW2ldKSA9PT0gLTEpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpbnZhbGlkUHJvcHMucHVzaChwcm9wc1tpXSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpZiAoaW52YWxpZFByb3BzLmxlbmd0aCkge1xcblxcdFxcdFxcdFwiKSwgXCJyZW1vdmVcIiA9PSByLnN0cmljdCA/IGEucHVzaChcIlxcblxcdFxcdFxcdFxcdFxcdGludmFsaWRQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGVsZXRlIHBhcmVudE9ialtmaWVsZF07XFxuXFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0XCIpIDogYS5wdXNoKFwiXFxuXFx0XFx0XFx0XFx0XFx0XCIgKyB0aGlzLm1ha2VFcnJvcih7XG4gICAgICAgICAgdHlwZTogXCJvYmplY3RTdHJpY3RcIixcbiAgICAgICAgICBleHBlY3RlZDogJ1wiJyArIGUuam9pbihcIiwgXCIpICsgJ1wiJyxcbiAgICAgICAgICBhY3R1YWw6IFwiaW52YWxpZFByb3BzLmpvaW4oJywgJylcIixcbiAgICAgICAgICBtZXNzYWdlczogdFxuICAgICAgICB9KSArIFwiXFxuXFx0XFx0XFx0XFx0XCIpLCBhLnB1c2goXCJcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XCIpKSwgYS5wdXNoKFwiXFxuXFx0XFx0XFx0cmV0dXJuIHBhcmVudE9iajtcXG5cXHRcXHRcIik7XG4gICAgICB9IGVsc2UgYS5wdXNoKFwiXFxuXFx0XFx0XFx0cmV0dXJuIHZhbHVlO1xcblxcdFxcdFwiKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlOiBhLmpvaW4oXCJcXG5cIilcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbCh0KSB7XG4gICAgICB2YXIgZSA9IHQuc2NoZW1hO1xuICAgICAgdCA9IHQubWVzc2FnZXM7XG4gICAgICB2YXIgbiA9IFtdO1xuICAgICAgbi5wdXNoKFwiXFxuXFx0XFx0dmFyIG9yaWdWYWx1ZSA9IHZhbHVlO1xcblxcdFwiKTtcbiAgICAgIHZhciByID0gITE7XG4gICAgICByZXR1cm4gITAgPT09IGUuY29udmVydCAmJiAociA9ICEwLCBuLnB1c2goJ1xcblxcdFxcdFxcdGlmICh0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIpIHtcXG5cXHRcXHRcXHRcXHR2YWx1ZSA9IE51bWJlcih2YWx1ZSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdCcpKSwgbi5wdXNoKCdcXG5cXHRcXHRpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiIHx8IGlzTmFOKHZhbHVlKSB8fCAhaXNGaW5pdGUodmFsdWUpKSB7XFxuXFx0XFx0XFx0JyArIHRoaXMubWFrZUVycm9yKHtcbiAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgYWN0dWFsOiBcIm9yaWdWYWx1ZVwiLFxuICAgICAgICBtZXNzYWdlczogdFxuICAgICAgfSkgKyBcIlxcblxcdFxcdFxcdHJldHVybiB2YWx1ZTtcXG5cXHRcXHR9XFxuXFx0XCIpLCBudWxsICE9IGUubWluICYmIG4ucHVzaChcIlxcblxcdFxcdFxcdGlmICh2YWx1ZSA8IFwiICsgZS5taW4gKyBcIikge1xcblxcdFxcdFxcdFxcdFwiICsgdGhpcy5tYWtlRXJyb3Ioe1xuICAgICAgICB0eXBlOiBcIm51bWJlck1pblwiLFxuICAgICAgICBleHBlY3RlZDogZS5taW4sXG4gICAgICAgIGFjdHVhbDogXCJvcmlnVmFsdWVcIixcbiAgICAgICAgbWVzc2FnZXM6IHRcbiAgICAgIH0pICsgXCJcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XCIpLCBudWxsICE9IGUubWF4ICYmIG4ucHVzaChcIlxcblxcdFxcdFxcdGlmICh2YWx1ZSA+IFwiICsgZS5tYXggKyBcIikge1xcblxcdFxcdFxcdFxcdFwiICsgdGhpcy5tYWtlRXJyb3Ioe1xuICAgICAgICB0eXBlOiBcIm51bWJlck1heFwiLFxuICAgICAgICBleHBlY3RlZDogZS5tYXgsXG4gICAgICAgIGFjdHVhbDogXCJvcmlnVmFsdWVcIixcbiAgICAgICAgbWVzc2FnZXM6IHRcbiAgICAgIH0pICsgXCJcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XCIpLCBudWxsICE9IGUuZXF1YWwgJiYgbi5wdXNoKFwiXFxuXFx0XFx0XFx0aWYgKHZhbHVlICE9PSBcIiArIGUuZXF1YWwgKyBcIikge1xcblxcdFxcdFxcdFxcdFwiICsgdGhpcy5tYWtlRXJyb3Ioe1xuICAgICAgICB0eXBlOiBcIm51bWJlckVxdWFsXCIsXG4gICAgICAgIGV4cGVjdGVkOiBlLmVxdWFsLFxuICAgICAgICBhY3R1YWw6IFwib3JpZ1ZhbHVlXCIsXG4gICAgICAgIG1lc3NhZ2VzOiB0XG4gICAgICB9KSArIFwiXFxuXFx0XFx0XFx0fVxcblxcdFxcdFwiKSwgbnVsbCAhPSBlLm5vdEVxdWFsICYmIG4ucHVzaChcIlxcblxcdFxcdFxcdGlmICh2YWx1ZSA9PT0gXCIgKyBlLm5vdEVxdWFsICsgXCIpIHtcXG5cXHRcXHRcXHRcXHRcIiArIHRoaXMubWFrZUVycm9yKHtcbiAgICAgICAgdHlwZTogXCJudW1iZXJOb3RFcXVhbFwiLFxuICAgICAgICBleHBlY3RlZDogZS5ub3RFcXVhbCxcbiAgICAgICAgYWN0dWFsOiBcIm9yaWdWYWx1ZVwiLFxuICAgICAgICBtZXNzYWdlczogdFxuICAgICAgfSkgKyBcIlxcblxcdFxcdFxcdH1cXG5cXHRcXHRcIiksICEwID09PSBlLmludGVnZXIgJiYgbi5wdXNoKFwiXFxuXFx0XFx0XFx0aWYgKHZhbHVlICUgMSAhPT0gMCkge1xcblxcdFxcdFxcdFxcdFwiICsgdGhpcy5tYWtlRXJyb3Ioe1xuICAgICAgICB0eXBlOiBcIm51bWJlckludGVnZXJcIixcbiAgICAgICAgYWN0dWFsOiBcIm9yaWdWYWx1ZVwiLFxuICAgICAgICBtZXNzYWdlczogdFxuICAgICAgfSkgKyBcIlxcblxcdFxcdFxcdH1cXG5cXHRcXHRcIiksICEwID09PSBlLnBvc2l0aXZlICYmIG4ucHVzaChcIlxcblxcdFxcdFxcdGlmICh2YWx1ZSA8PSAwKSB7XFxuXFx0XFx0XFx0XFx0XCIgKyB0aGlzLm1ha2VFcnJvcih7XG4gICAgICAgIHR5cGU6IFwibnVtYmVyUG9zaXRpdmVcIixcbiAgICAgICAgYWN0dWFsOiBcIm9yaWdWYWx1ZVwiLFxuICAgICAgICBtZXNzYWdlczogdFxuICAgICAgfSkgKyBcIlxcblxcdFxcdFxcdH1cXG5cXHRcXHRcIiksICEwID09PSBlLm5lZ2F0aXZlICYmIG4ucHVzaChcIlxcblxcdFxcdFxcdGlmICh2YWx1ZSA+PSAwKSB7XFxuXFx0XFx0XFx0XFx0XCIgKyB0aGlzLm1ha2VFcnJvcih7XG4gICAgICAgIHR5cGU6IFwibnVtYmVyTmVnYXRpdmVcIixcbiAgICAgICAgYWN0dWFsOiBcIm9yaWdWYWx1ZVwiLFxuICAgICAgICBtZXNzYWdlczogdFxuICAgICAgfSkgKyBcIlxcblxcdFxcdFxcdH1cXG5cXHRcXHRcIiksIG4ucHVzaChcIlxcblxcdFxcdHJldHVybiB2YWx1ZTtcXG5cXHRcIiksIHtcbiAgICAgICAgc2FuaXRpemVkOiByLFxuICAgICAgICBzb3VyY2U6IG4uam9pbihcIlxcblwiKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvKHQsIGUsIG4pIHtcbiAgICAgIHQgPSB0LnNjaGVtYTtcbiAgICAgIHZhciByID0gW107XG4gICAgICByLnB1c2goXCJcXG5cXHRcXHR2YXIgcHJldkVyckxlbiA9IGVycm9ycy5sZW5ndGg7XFxuXFx0XFx0dmFyIGVyckJlZm9yZTtcXG5cXHRcXHR2YXIgaGFzVmFsaWQgPSBmYWxzZTtcXG5cXHRcXHR2YXIgbmV3VmFsID0gdmFsdWU7XFxuXFx0XCIpO1xuXG4gICAgICBmb3IgKHZhciBhID0gMDsgYSA8IHQucnVsZXMubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgci5wdXNoKFwiXFxuXFx0XFx0XFx0aWYgKCFoYXNWYWxpZCkge1xcblxcdFxcdFxcdFxcdGVyckJlZm9yZSA9IGVycm9ycy5sZW5ndGg7XFxuXFx0XFx0XCIpO1xuICAgICAgICB2YXIgaSA9IHRoaXMuZ2V0UnVsZUZyb21TY2hlbWEodC5ydWxlc1thXSk7XG4gICAgICAgIHIucHVzaCh0aGlzLmNvbXBpbGVSdWxlKGksIG4sIGUsIFwidmFyIHRtcFZhbCA9IGNvbnRleHQuZm5bJSVJTkRFWCUlXSh2YWx1ZSwgZmllbGQsIHBhcmVudCwgZXJyb3JzLCBjb250ZXh0KTtcIiwgXCJ0bXBWYWxcIikpLCByLnB1c2goXCJcXG5cXHRcXHRcXHRcXHRpZiAoZXJyb3JzLmxlbmd0aCA9PSBlcnJCZWZvcmUpIHtcXG5cXHRcXHRcXHRcXHRcXHRoYXNWYWxpZCA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0bmV3VmFsID0gdG1wVmFsO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gci5wdXNoKFwiXFxuXFx0XFx0aWYgKGhhc1ZhbGlkKSB7XFxuXFx0XFx0XFx0ZXJyb3JzLmxlbmd0aCA9IHByZXZFcnJMZW47XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBuZXdWYWw7XFxuXFx0XCIpLCB7XG4gICAgICAgIHNvdXJjZTogci5qb2luKFwiXFxuXCIpXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGYodCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlOiAnXFxuXFx0XFx0XFx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKVxcblxcdFxcdFxcdFxcdCcgKyB0aGlzLm1ha2VFcnJvcih7XG4gICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgIGFjdHVhbDogXCJ2YWx1ZVwiLFxuICAgICAgICAgIG1lc3NhZ2VzOiB0Lm1lc3NhZ2VzXG4gICAgICAgIH0pICsgXCJcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdmFsdWU7XFxuXFx0XFx0XCJcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYyh0KSB7XG4gICAgICB2YXIgZSA9IHQuc2NoZW1hO1xuICAgICAgdCA9IHQubWVzc2FnZXM7XG4gICAgICB2YXIgbiA9IFtdO1xuICAgICAgcmV0dXJuIG4ucHVzaChcIlxcblxcdFxcdGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XFxuXFx0XCIpLCBlLnJlbW92ZSA/IG4ucHVzaChcIlxcblxcdFxcdFxcdHJldHVybiB1bmRlZmluZWQ7XFxuXFx0XFx0XCIpIDogbi5wdXNoKFwiXFxuXFx0XFx0XFx0XCIgKyB0aGlzLm1ha2VFcnJvcih7XG4gICAgICAgIHR5cGU6IFwiZm9yYmlkZGVuXCIsXG4gICAgICAgIGFjdHVhbDogXCJ2YWx1ZVwiLFxuICAgICAgICBtZXNzYWdlczogdFxuICAgICAgfSkgKyBcIlxcblxcdFxcdFwiKSwgbi5wdXNoKFwiXFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiB2YWx1ZTtcXG5cXHRcIiksIHtcbiAgICAgICAgc291cmNlOiBuLmpvaW4oXCJcXG5cIilcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcCh0KSB7XG4gICAgICB2YXIgZSA9IHQuc2NoZW1hO1xuICAgICAgdCA9IHQubWVzc2FnZXM7XG4gICAgICB2YXIgbiA9IFtdO1xuICAgICAgcmV0dXJuIGUuZmllbGQgPyAoZS5zdHJpY3QgPyBuLnB1c2goJ1xcblxcdFxcdFxcdFxcdGlmICh2YWx1ZSAhPT0gcGFyZW50W1wiJyArIGUuZmllbGQgKyAnXCJdKVxcblxcdFxcdFxcdCcpIDogbi5wdXNoKCdcXG5cXHRcXHRcXHRcXHRpZiAodmFsdWUgIT0gcGFyZW50W1wiJyArIGUuZmllbGQgKyAnXCJdKVxcblxcdFxcdFxcdCcpLCBuLnB1c2goXCJcXG5cXHRcXHRcXHRcXHRcIiArIHRoaXMubWFrZUVycm9yKHtcbiAgICAgICAgdHlwZTogXCJlcXVhbEZpZWxkXCIsXG4gICAgICAgIGFjdHVhbDogXCJ2YWx1ZVwiLFxuICAgICAgICBleHBlY3RlZDogSlNPTi5zdHJpbmdpZnkoZS5maWVsZCksXG4gICAgICAgIG1lc3NhZ2VzOiB0XG4gICAgICB9KSArIFwiXFxuXFx0XFx0XCIpKSA6IChlLnN0cmljdCA/IG4ucHVzaChcIlxcblxcdFxcdFxcdFxcdGlmICh2YWx1ZSAhPT0gXCIgKyBKU09OLnN0cmluZ2lmeShlLnZhbHVlKSArIFwiKVxcblxcdFxcdFxcdFwiKSA6IG4ucHVzaChcIlxcblxcdFxcdFxcdFxcdGlmICh2YWx1ZSAhPSBcIiArIEpTT04uc3RyaW5naWZ5KGUudmFsdWUpICsgXCIpXFxuXFx0XFx0XFx0XCIpLCBuLnB1c2goXCJcXG5cXHRcXHRcXHRcXHRcIiArIHRoaXMubWFrZUVycm9yKHtcbiAgICAgICAgdHlwZTogXCJlcXVhbFZhbHVlXCIsXG4gICAgICAgIGFjdHVhbDogXCJ2YWx1ZVwiLFxuICAgICAgICBleHBlY3RlZDogSlNPTi5zdHJpbmdpZnkoZS52YWx1ZSksXG4gICAgICAgIG1lc3NhZ2VzOiB0XG4gICAgICB9KSArIFwiXFxuXFx0XFx0XCIpKSwgbi5wdXNoKFwiXFxuXFx0XFx0cmV0dXJuIHZhbHVlO1xcblxcdFwiKSwge1xuICAgICAgICBzb3VyY2U6IG4uam9pbihcIlxcblwiKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoKHQpIHtcbiAgICAgIHZhciBlID0gdC5zY2hlbWE7XG4gICAgICByZXR1cm4gdCA9IHQubWVzc2FnZXMsIHtcbiAgICAgICAgc291cmNlOiBcIlxcblxcdFxcdFxcdGlmIChcIiArIEpTT04uc3RyaW5naWZ5KGUudmFsdWVzIHx8IFtdKSArIFwiLmluZGV4T2YodmFsdWUpID09PSAtMSlcXG5cXHRcXHRcXHRcXHRcIiArIHRoaXMubWFrZUVycm9yKHtcbiAgICAgICAgICB0eXBlOiBcImVudW1WYWx1ZVwiLFxuICAgICAgICAgIGV4cGVjdGVkOiAnXCInICsgZS52YWx1ZXMuam9pbihcIiwgXCIpICsgJ1wiJyxcbiAgICAgICAgICBhY3R1YWw6IFwidmFsdWVcIixcbiAgICAgICAgICBtZXNzYWdlczogdFxuICAgICAgICB9KSArIFwiXFxuXFxuXFx0XFx0XFx0cmV0dXJuIHZhbHVlO1xcblxcdFxcdFwiXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG0odCkge1xuICAgICAgdmFyIGUgPSB0LnNjaGVtYTtcbiAgICAgIHQgPSB0Lm1lc3NhZ2VzO1xuICAgICAgdmFyIG4gPSBbXSxcbiAgICAgICAgICByID0gXCJwcmVjaXNlXCIgPT0gZS5tb2RlID8gTiA6IFQsXG4gICAgICAgICAgYSA9ICExO1xuICAgICAgcmV0dXJuIG4ucHVzaCgnXFxuXFx0XFx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xcblxcdFxcdFxcdCcgKyB0aGlzLm1ha2VFcnJvcih7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGFjdHVhbDogXCJ2YWx1ZVwiLFxuICAgICAgICBtZXNzYWdlczogdFxuICAgICAgfSkgKyBcIlxcblxcdFxcdFxcdHJldHVybiB2YWx1ZTtcXG5cXHRcXHR9XFxuXFx0XCIpLCBlLm5vcm1hbGl6ZSAmJiAoYSA9ICEwLCBuLnB1c2goXCJcXG5cXHRcXHRcXHR2YWx1ZSA9IHZhbHVlLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xcblxcdFxcdFwiKSksIG4ucHVzaChcIlxcblxcdFxcdGlmICghXCIgKyByLnRvU3RyaW5nKCkgKyBcIi50ZXN0KHZhbHVlKSlcXG5cXHRcXHRcXHRcIiArIHRoaXMubWFrZUVycm9yKHtcbiAgICAgICAgdHlwZTogXCJlbWFpbFwiLFxuICAgICAgICBhY3R1YWw6IFwidmFsdWVcIixcbiAgICAgICAgbWVzc2FnZXM6IHRcbiAgICAgIH0pICsgXCJcXG5cXG5cXHRcXHRyZXR1cm4gdmFsdWU7XFxuXFx0XCIpLCB7XG4gICAgICAgIHNhbml0aXplZDogYSxcbiAgICAgICAgc291cmNlOiBuLmpvaW4oXCJcXG5cIilcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZCh0KSB7XG4gICAgICB2YXIgZSA9IHQuc2NoZW1hO1xuICAgICAgdCA9IHQubWVzc2FnZXM7XG4gICAgICB2YXIgbiA9IFtdLFxuICAgICAgICAgIHIgPSAhMTtcbiAgICAgIHJldHVybiBuLnB1c2goXCJcXG5cXHRcXHR2YXIgb3JpZ1ZhbHVlID0gdmFsdWU7XFxuXFx0XCIpLCAhMCA9PT0gZS5jb252ZXJ0ICYmIChyID0gITAsIG4ucHVzaChcIlxcblxcdFxcdFxcdGlmICghKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkpIHtcXG5cXHRcXHRcXHRcXHR2YWx1ZSA9IG5ldyBEYXRlKHZhbHVlKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XCIpKSwgbi5wdXNoKFwiXFxuXFx0XFx0aWYgKCEodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB8fCBpc05hTih2YWx1ZS5nZXRUaW1lKCkpKVxcblxcdFxcdFxcdFwiICsgdGhpcy5tYWtlRXJyb3Ioe1xuICAgICAgICB0eXBlOiBcImRhdGVcIixcbiAgICAgICAgYWN0dWFsOiBcIm9yaWdWYWx1ZVwiLFxuICAgICAgICBtZXNzYWdlczogdFxuICAgICAgfSkgKyBcIlxcblxcblxcdFxcdHJldHVybiB2YWx1ZTtcXG5cXHRcIiksIHtcbiAgICAgICAgc2FuaXRpemVkOiByLFxuICAgICAgICBzb3VyY2U6IG4uam9pbihcIlxcblwiKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2KHQsIGUsIG4pIHtcbiAgICAgIHZhciByID0gdC5zY2hlbWE7XG4gICAgICB0ID0gdC5tZXNzYWdlcztcbiAgICAgIHZhciBhID0gW107XG4gICAgICByZXR1cm4gXCJmdW5jdGlvblwiID09IHR5cGVvZiByLmNoZWNrICYmIChuLmN1c3RvbXNbZV0gPSB7XG4gICAgICAgIHNjaGVtYTogcixcbiAgICAgICAgbWVzc2FnZXM6IHRcbiAgICAgIH0sIGEucHVzaCgnXFxuXFx0XFx0XFx0Y29uc3QgcnVsZSA9IGNvbnRleHQuY3VzdG9tc1tcIicgKyBlICsgJ1wiXTtcXG5cXHRcXHRcXHRjb25zdCByZXMgPSBydWxlLnNjaGVtYS5jaGVjay5jYWxsKHRoaXMsIHZhbHVlLCBydWxlLnNjaGVtYSwgXCInICsgZSArICdcIiwgcGFyZW50LCBjb250ZXh0KTtcXG5cXHRcXHRcXHRpZiAoQXJyYXkuaXNBcnJheShyZXMpKSB7XFxuXFx0XFx0XFx0XFx0cmVzLmZvckVhY2goZXJyID0+IGVycm9ycy5wdXNoKE9iamVjdC5hc3NpZ24oeyBtZXNzYWdlOiBydWxlLm1lc3NhZ2VzW2Vyci50eXBlXSwgZmllbGQgfSwgZXJyKSkpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdmFsdWU7XFxuXFx0XFx0JykpLCB7XG4gICAgICAgIHNvdXJjZTogYS5qb2luKFwiXFxuXCIpXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGcodCkge1xuICAgICAgdmFyIGUgPSB0LnNjaGVtYTtcbiAgICAgIHQgPSB0Lm1lc3NhZ2VzO1xuICAgICAgdmFyIG4gPSBbXSxcbiAgICAgICAgICByID0gITE7XG4gICAgICByZXR1cm4gbi5wdXNoKFwiXFxuXFx0XFx0dmFyIG9yaWdWYWx1ZSA9IHZhbHVlO1xcblxcdFwiKSwgITAgPT09IGUuY29udmVydCAmJiAociA9ICEwLCBuLnB1c2goJ1xcblxcdFxcdFxcdGlmICh0eXBlb2YgdmFsdWUgIT09IFwiYm9vbGVhblwiKSB7XFxuXFx0XFx0XFx0XFx0aWYgKFxcblxcdFxcdFxcdFxcdHZhbHVlID09PSAxXFxuXFx0XFx0XFx0XFx0fHwgdmFsdWUgPT09IFwidHJ1ZVwiXFxuXFx0XFx0XFx0XFx0fHwgdmFsdWUgPT09IFwiMVwiXFxuXFx0XFx0XFx0XFx0fHwgdmFsdWUgPT09IFwib25cIlxcblxcdFxcdFxcdFxcdCkge1xcblxcdFxcdFxcdFxcdFxcdHZhbHVlID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKFxcblxcdFxcdFxcdFxcdHZhbHVlID09PSAwXFxuXFx0XFx0XFx0XFx0fHwgdmFsdWUgPT09IFwiZmFsc2VcIlxcblxcdFxcdFxcdFxcdHx8IHZhbHVlID09PSBcIjBcIlxcblxcdFxcdFxcdFxcdHx8IHZhbHVlID09PSBcIm9mZlwiXFxuXFx0XFx0XFx0XFx0KSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFsdWUgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdCcpKSwgbi5wdXNoKCdcXG5cXHRcXHRpZiAodHlwZW9mIHZhbHVlICE9PSBcImJvb2xlYW5cIilcXG5cXHRcXHRcXHQnICsgdGhpcy5tYWtlRXJyb3Ioe1xuICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgYWN0dWFsOiBcIm9yaWdWYWx1ZVwiLFxuICAgICAgICBtZXNzYWdlczogdFxuICAgICAgfSkgKyBcIlxcblxcblxcdFxcdHJldHVybiB2YWx1ZTtcXG5cXHRcIiksIHtcbiAgICAgICAgc2FuaXRpemVkOiByLFxuICAgICAgICBzb3VyY2U6IG4uam9pbihcIlxcblwiKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB5KHQsIGUsIG4pIHtcbiAgICAgIHZhciByID0gdC5zY2hlbWEsXG4gICAgICAgICAgYSA9IHQubWVzc2FnZXM7XG5cbiAgICAgIGlmICgodCA9IFtdKS5wdXNoKFwiXFxuXFx0XFx0aWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xcblxcdFxcdFxcdFwiICsgdGhpcy5tYWtlRXJyb3Ioe1xuICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgIGFjdHVhbDogXCJ2YWx1ZVwiLFxuICAgICAgICBtZXNzYWdlczogYVxuICAgICAgfSkgKyBcIlxcblxcdFxcdFxcdHJldHVybiB2YWx1ZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dmFyIGxlbiA9IHZhbHVlLmxlbmd0aDtcXG5cXHRcIiksICExID09PSByLmVtcHR5ICYmIHQucHVzaChcIlxcblxcdFxcdFxcdGlmIChsZW4gPT09IDApIHtcXG5cXHRcXHRcXHRcXHRcIiArIHRoaXMubWFrZUVycm9yKHtcbiAgICAgICAgdHlwZTogXCJhcnJheUVtcHR5XCIsXG4gICAgICAgIGFjdHVhbDogXCJ2YWx1ZVwiLFxuICAgICAgICBtZXNzYWdlczogYVxuICAgICAgfSkgKyBcIlxcblxcdFxcdFxcdH1cXG5cXHRcXHRcIiksIG51bGwgIT0gci5taW4gJiYgdC5wdXNoKFwiXFxuXFx0XFx0XFx0aWYgKGxlbiA8IFwiICsgci5taW4gKyBcIikge1xcblxcdFxcdFxcdFxcdFwiICsgdGhpcy5tYWtlRXJyb3Ioe1xuICAgICAgICB0eXBlOiBcImFycmF5TWluXCIsXG4gICAgICAgIGV4cGVjdGVkOiByLm1pbixcbiAgICAgICAgYWN0dWFsOiBcImxlblwiLFxuICAgICAgICBtZXNzYWdlczogYVxuICAgICAgfSkgKyBcIlxcblxcdFxcdFxcdH1cXG5cXHRcXHRcIiksIG51bGwgIT0gci5tYXggJiYgdC5wdXNoKFwiXFxuXFx0XFx0XFx0aWYgKGxlbiA+IFwiICsgci5tYXggKyBcIikge1xcblxcdFxcdFxcdFxcdFwiICsgdGhpcy5tYWtlRXJyb3Ioe1xuICAgICAgICB0eXBlOiBcImFycmF5TWF4XCIsXG4gICAgICAgIGV4cGVjdGVkOiByLm1heCxcbiAgICAgICAgYWN0dWFsOiBcImxlblwiLFxuICAgICAgICBtZXNzYWdlczogYVxuICAgICAgfSkgKyBcIlxcblxcdFxcdFxcdH1cXG5cXHRcXHRcIiksIG51bGwgIT0gci5sZW5ndGggJiYgdC5wdXNoKFwiXFxuXFx0XFx0XFx0aWYgKGxlbiAhPT0gXCIgKyByLmxlbmd0aCArIFwiKSB7XFxuXFx0XFx0XFx0XFx0XCIgKyB0aGlzLm1ha2VFcnJvcih7XG4gICAgICAgIHR5cGU6IFwiYXJyYXlMZW5ndGhcIixcbiAgICAgICAgZXhwZWN0ZWQ6IHIubGVuZ3RoLFxuICAgICAgICBhY3R1YWw6IFwibGVuXCIsXG4gICAgICAgIG1lc3NhZ2VzOiBhXG4gICAgICB9KSArIFwiXFxuXFx0XFx0XFx0fVxcblxcdFxcdFwiKSwgbnVsbCAhPSByLmNvbnRhaW5zICYmIHQucHVzaChcIlxcblxcdFxcdFxcdGlmICh2YWx1ZS5pbmRleE9mKFwiICsgSlNPTi5zdHJpbmdpZnkoci5jb250YWlucykgKyBcIikgPT09IC0xKSB7XFxuXFx0XFx0XFx0XFx0XCIgKyB0aGlzLm1ha2VFcnJvcih7XG4gICAgICAgIHR5cGU6IFwiYXJyYXlDb250YWluc1wiLFxuICAgICAgICBleHBlY3RlZDogSlNPTi5zdHJpbmdpZnkoci5jb250YWlucyksXG4gICAgICAgIGFjdHVhbDogXCJ2YWx1ZVwiLFxuICAgICAgICBtZXNzYWdlczogYVxuICAgICAgfSkgKyBcIlxcblxcdFxcdFxcdH1cXG5cXHRcXHRcIiksICEwID09PSByLnVuaXF1ZSAmJiB0LnB1c2goXCJcXG5cXHRcXHRcXHRpZihsZW4gPiAobmV3IFNldCh2YWx1ZSkpLnNpemUpIHtcXG5cXHRcXHRcXHRcXHRcIiArIHRoaXMubWFrZUVycm9yKHtcbiAgICAgICAgdHlwZTogXCJhcnJheVVuaXF1ZVwiLFxuICAgICAgICBleHBlY3RlZDogXCJBcnJheS5mcm9tKG5ldyBTZXQodmFsdWUuZmlsdGVyKChpdGVtLCBpbmRleCkgPT4gdmFsdWUuaW5kZXhPZihpdGVtKSAhPT0gaW5kZXgpKSlcIixcbiAgICAgICAgYWN0dWFsOiBcInZhbHVlXCIsXG4gICAgICAgIG1lc3NhZ2VzOiBhXG4gICAgICB9KSArIFwiXFxuXFx0XFx0XFx0fVxcblxcdFxcdFwiKSwgbnVsbCAhPSByLmVudW0pIHtcbiAgICAgICAgdmFyIGkgPSBKU09OLnN0cmluZ2lmeShyLmVudW0pO1xuICAgICAgICB0LnB1c2goXCJcXG5cXHRcXHRcXHRmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0aWYgKFwiICsgaSArIFwiLmluZGV4T2YodmFsdWVbaV0pID09PSAtMSkge1xcblxcdFxcdFxcdFxcdFxcdFwiICsgdGhpcy5tYWtlRXJyb3Ioe1xuICAgICAgICAgIHR5cGU6IFwiYXJyYXlFbnVtXCIsXG4gICAgICAgICAgZXhwZWN0ZWQ6ICdcIicgKyByLmVudW0uam9pbihcIiwgXCIpICsgJ1wiJyxcbiAgICAgICAgICBhY3R1YWw6IFwidmFsdWVbaV1cIixcbiAgICAgICAgICBtZXNzYWdlczogYVxuICAgICAgICB9KSArIFwiXFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsICE9IHIuaXRlbXMgJiYgKHQucHVzaChcIlxcblxcdFxcdFxcdHZhciBhcnIgPSB2YWx1ZTtcXG5cXHRcXHRcXHR2YXIgcGFyZW50RmllbGQgPSBmaWVsZDtcXG5cXHRcXHRcXHRmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xcblxcdFxcdFwiKSwgciA9IHRoaXMuZ2V0UnVsZUZyb21TY2hlbWEoci5pdGVtcyksIHQucHVzaCh0aGlzLmNvbXBpbGVSdWxlKHIsIG4sIGUsICdhcnJbaV0gPSBjb250ZXh0LmZuWyUlSU5ERVglJV0oYXJyW2ldLCAocGFyZW50RmllbGQgPyBwYXJlbnRGaWVsZCA6IFwiXCIpICsgXCJbXCIgKyBpICsgXCJdXCIsIHBhcmVudCwgZXJyb3JzLCBjb250ZXh0KTsnLCBcImFycltpXVwiKSksIHQucHVzaChcIlxcblxcdFxcdFxcdH1cXG5cXHRcXHRcIikpLCB0LnB1c2goXCJcXG5cXHRcXHRyZXR1cm4gdmFsdWU7XFxuXFx0XCIpLCB7XG4gICAgICAgIHNvdXJjZTogdC5qb2luKFwiXFxuXCIpXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGIoKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgZnVuY3Rpb24geCh0LCBlKSB7XG4gICAgICBmb3IgKHZhciBuIGluIGUpIFwib2JqZWN0XCIgPT0gdHlwZW9mIGVbbl0gJiYgbnVsbCAhPT0gZVtuXSA/ICh0W25dID0gdFtuXSB8fCB7fSwgeCh0W25dLCBlW25dKSkgOiB0W25dID0gZVtuXTtcblxuICAgICAgcmV0dXJuIHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRSh0KSB7XG4gICAgICByZXR1cm4gdC5yZXBsYWNlKEMsIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHN3aXRjaCAodCkge1xuICAgICAgICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgICBjYXNlIFwiJ1wiOlxuICAgICAgICAgIGNhc2UgXCJcXFxcXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJcXFxcXCIgKyB0O1xuXG4gICAgICAgICAgY2FzZSBcIlxcblwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiXFxcXG5cIjtcblxuICAgICAgICAgIGNhc2UgXCJcXHJcIjpcbiAgICAgICAgICAgIHJldHVybiBcIlxcXFxyXCI7XG5cbiAgICAgICAgICBjYXNlIFwiXFx1MjAyOFwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiXFxcXHUyMDI4XCI7XG5cbiAgICAgICAgICBjYXNlIFwiXFx1MjAyOVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiXFxcXHUyMDI5XCI7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFMoKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkR5bmFtaWMgcmVxdWlyZXMgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGJ5IHJvbGx1cC1wbHVnaW4tY29tbW9uanNcIik7XG4gICAgfVxuXG4gICAgdmFyIGssXG4gICAgICAgIE8sXG4gICAgICAgIGosXG4gICAgICAgIF8sXG4gICAgICAgIHcgPSB7XG4gICAgICByZXF1aXJlZDogXCJUaGUgJ3tmaWVsZH0nIGZpZWxkIGlzIHJlcXVpcmVkLlwiLFxuICAgICAgc3RyaW5nOiBcIlRoZSAne2ZpZWxkfScgZmllbGQgbXVzdCBiZSBhIHN0cmluZy5cIixcbiAgICAgIHN0cmluZ0VtcHR5OiBcIlRoZSAne2ZpZWxkfScgZmllbGQgbXVzdCBub3QgYmUgZW1wdHkuXCIsXG4gICAgICBzdHJpbmdNaW46IFwiVGhlICd7ZmllbGR9JyBmaWVsZCBsZW5ndGggbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8ge2V4cGVjdGVkfSBjaGFyYWN0ZXJzIGxvbmcuXCIsXG4gICAgICBzdHJpbmdNYXg6IFwiVGhlICd7ZmllbGR9JyBmaWVsZCBsZW5ndGggbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8ge2V4cGVjdGVkfSBjaGFyYWN0ZXJzIGxvbmcuXCIsXG4gICAgICBzdHJpbmdMZW5ndGg6IFwiVGhlICd7ZmllbGR9JyBmaWVsZCBsZW5ndGggbXVzdCBiZSB7ZXhwZWN0ZWR9IGNoYXJhY3RlcnMgbG9uZy5cIixcbiAgICAgIHN0cmluZ1BhdHRlcm46IFwiVGhlICd7ZmllbGR9JyBmaWVsZCBmYWlscyB0byBtYXRjaCB0aGUgcmVxdWlyZWQgcGF0dGVybi5cIixcbiAgICAgIHN0cmluZ0NvbnRhaW5zOiBcIlRoZSAne2ZpZWxkfScgZmllbGQgbXVzdCBjb250YWluIHRoZSAne2V4cGVjdGVkfScgdGV4dC5cIixcbiAgICAgIHN0cmluZ0VudW06IFwiVGhlICd7ZmllbGR9JyBmaWVsZCBkb2VzIG5vdCBtYXRjaCBhbnkgb2YgdGhlIGFsbG93ZWQgdmFsdWVzLlwiLFxuICAgICAgc3RyaW5nTnVtZXJpYzogXCJUaGUgJ3tmaWVsZH0nIGZpZWxkIG11c3QgYmUgYSBudW1lcmljIHN0cmluZy5cIixcbiAgICAgIHN0cmluZ0FscGhhOiBcIlRoZSAne2ZpZWxkfScgZmllbGQgbXVzdCBiZSBhbiBhbHBoYWJldGljIHN0cmluZy5cIixcbiAgICAgIHN0cmluZ0FscGhhbnVtOiBcIlRoZSAne2ZpZWxkfScgZmllbGQgbXVzdCBiZSBhbiBhbHBoYW51bWVyaWMgc3RyaW5nLlwiLFxuICAgICAgc3RyaW5nQWxwaGFkYXNoOiBcIlRoZSAne2ZpZWxkfScgZmllbGQgbXVzdCBiZSBhbiBhbHBoYWRhc2ggc3RyaW5nLlwiLFxuICAgICAgbnVtYmVyOiBcIlRoZSAne2ZpZWxkfScgZmllbGQgbXVzdCBiZSBhIG51bWJlci5cIixcbiAgICAgIG51bWJlck1pbjogXCJUaGUgJ3tmaWVsZH0nIGZpZWxkIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHtleHBlY3RlZH0uXCIsXG4gICAgICBudW1iZXJNYXg6IFwiVGhlICd7ZmllbGR9JyBmaWVsZCBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB7ZXhwZWN0ZWR9LlwiLFxuICAgICAgbnVtYmVyRXF1YWw6IFwiVGhlICd7ZmllbGR9JyBmaWVsZCBtdXN0IGJlIGVxdWFsIHRvIHtleHBlY3RlZH0uXCIsXG4gICAgICBudW1iZXJOb3RFcXVhbDogXCJUaGUgJ3tmaWVsZH0nIGZpZWxkIGNhbid0IGJlIGVxdWFsIHRvIHtleHBlY3RlZH0uXCIsXG4gICAgICBudW1iZXJJbnRlZ2VyOiBcIlRoZSAne2ZpZWxkfScgZmllbGQgbXVzdCBiZSBhbiBpbnRlZ2VyLlwiLFxuICAgICAgbnVtYmVyUG9zaXRpdmU6IFwiVGhlICd7ZmllbGR9JyBmaWVsZCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyLlwiLFxuICAgICAgbnVtYmVyTmVnYXRpdmU6IFwiVGhlICd7ZmllbGR9JyBmaWVsZCBtdXN0IGJlIGEgbmVnYXRpdmUgbnVtYmVyLlwiLFxuICAgICAgYXJyYXk6IFwiVGhlICd7ZmllbGR9JyBmaWVsZCBtdXN0IGJlIGFuIGFycmF5LlwiLFxuICAgICAgYXJyYXlFbXB0eTogXCJUaGUgJ3tmaWVsZH0nIGZpZWxkIG11c3Qgbm90IGJlIGFuIGVtcHR5IGFycmF5LlwiLFxuICAgICAgYXJyYXlNaW46IFwiVGhlICd7ZmllbGR9JyBmaWVsZCBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qge2V4cGVjdGVkfSBpdGVtcy5cIixcbiAgICAgIGFycmF5TWF4OiBcIlRoZSAne2ZpZWxkfScgZmllbGQgbXVzdCBjb250YWluIGxlc3MgdGhhbiBvciBlcXVhbCB0byB7ZXhwZWN0ZWR9IGl0ZW1zLlwiLFxuICAgICAgYXJyYXlMZW5ndGg6IFwiVGhlICd7ZmllbGR9JyBmaWVsZCBtdXN0IGNvbnRhaW4ge2V4cGVjdGVkfSBpdGVtcy5cIixcbiAgICAgIGFycmF5Q29udGFpbnM6IFwiVGhlICd7ZmllbGR9JyBmaWVsZCBtdXN0IGNvbnRhaW4gdGhlICd7ZXhwZWN0ZWR9JyBpdGVtLlwiLFxuICAgICAgYXJyYXlVbmlxdWU6IFwiVGhlICd7YWN0dWFsfScgdmFsdWUgaW4gJ3tmaWVsZH0nIGZpZWxkIGRvZXMgbm90IHVuaXF1ZSB0aGUgJ3tleHBlY3RlZH0nIHZhbHVlcy5cIixcbiAgICAgIGFycmF5RW51bTogXCJUaGUgJ3thY3R1YWx9JyB2YWx1ZSBpbiAne2ZpZWxkfScgZmllbGQgZG9lcyBub3QgbWF0Y2ggYW55IG9mIHRoZSAne2V4cGVjdGVkfScgdmFsdWVzLlwiLFxuICAgICAgYm9vbGVhbjogXCJUaGUgJ3tmaWVsZH0nIGZpZWxkIG11c3QgYmUgYSBib29sZWFuLlwiLFxuICAgICAgZGF0ZTogXCJUaGUgJ3tmaWVsZH0nIGZpZWxkIG11c3QgYmUgYSBEYXRlLlwiLFxuICAgICAgZGF0ZU1pbjogXCJUaGUgJ3tmaWVsZH0nIGZpZWxkIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHtleHBlY3RlZH0uXCIsXG4gICAgICBkYXRlTWF4OiBcIlRoZSAne2ZpZWxkfScgZmllbGQgbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8ge2V4cGVjdGVkfS5cIixcbiAgICAgIGVudW1WYWx1ZTogXCJUaGUgJ3tmaWVsZH0nIGZpZWxkIHZhbHVlICd7ZXhwZWN0ZWR9JyBkb2VzIG5vdCBtYXRjaCBhbnkgb2YgdGhlIGFsbG93ZWQgdmFsdWVzLlwiLFxuICAgICAgZXF1YWxWYWx1ZTogXCJUaGUgJ3tmaWVsZH0nIGZpZWxkIHZhbHVlIG11c3QgYmUgZXF1YWwgdG8gJ3tleHBlY3RlZH0nLlwiLFxuICAgICAgZXF1YWxGaWVsZDogXCJUaGUgJ3tmaWVsZH0nIGZpZWxkIHZhbHVlIG11c3QgYmUgZXF1YWwgdG8gJ3tleHBlY3RlZH0nIGZpZWxkIHZhbHVlLlwiLFxuICAgICAgZm9yYmlkZGVuOiBcIlRoZSAne2ZpZWxkfScgZmllbGQgaXMgZm9yYmlkZGVuLlwiLFxuICAgICAgZnVuY3Rpb246IFwiVGhlICd7ZmllbGR9JyBmaWVsZCBtdXN0IGJlIGEgZnVuY3Rpb24uXCIsXG4gICAgICBlbWFpbDogXCJUaGUgJ3tmaWVsZH0nIGZpZWxkIG11c3QgYmUgYSB2YWxpZCBlLW1haWwuXCIsXG4gICAgICBsdWhuOiBcIlRoZSAne2ZpZWxkfScgZmllbGQgbXVzdCBiZSBhIHZhbGlkIGNoZWNrc3VtIGx1aG4uXCIsXG4gICAgICBtYWM6IFwiVGhlICd7ZmllbGR9JyBmaWVsZCBtdXN0IGJlIGEgdmFsaWQgTUFDIGFkZHJlc3MuXCIsXG4gICAgICBvYmplY3Q6IFwiVGhlICd7ZmllbGR9JyBtdXN0IGJlIGFuIE9iamVjdC5cIixcbiAgICAgIG9iamVjdFN0cmljdDogXCJUaGUgb2JqZWN0ICd7ZmllbGR9JyBjb250YWlucyBmb3JiaWRkZW4ga2V5czogJ3thY3R1YWx9Jy5cIixcbiAgICAgIHVybDogXCJUaGUgJ3tmaWVsZH0nIGZpZWxkIG11c3QgYmUgYSB2YWxpZCBVUkwuXCIsXG4gICAgICB1dWlkOiBcIlRoZSAne2ZpZWxkfScgZmllbGQgbXVzdCBiZSBhIHZhbGlkIFVVSUQuXCIsXG4gICAgICB1dWlkVmVyc2lvbjogXCJUaGUgJ3tmaWVsZH0nIGZpZWxkIG11c3QgYmUgYSB2YWxpZCBVVUlEIHZlcnNpb24gcHJvdmlkZWQuXCJcbiAgICB9LFxuICAgICAgICBOID0gL14oKFtePD4oKVtcXF1cXFxcLiw7Olxcc0BcIl0rKFxcLltePD4oKVtcXF1cXFxcLiw7Olxcc0BcIl0rKSopfChcIi4rXCIpKUAoKFxcW1swLTldezEsM31cXC5bMC05XXsxLDN9XFwuWzAtOV17MSwzfVxcLlswLTldezEsM31cXF0pfCgoW2EtekEtWlxcLTAtOV0rXFwuKStbYS16QS1aXXsyLH0pKSQvLFxuICAgICAgICBUID0gL15cXFMrQFxcUytcXC5cXFMrJC8sXG4gICAgICAgIEEgPSAvXltfJGEtekEtWl1bXyRhLXpBLVowLTldKiQvLFxuICAgICAgICBDID0gL1tcIidcXFxcXFxuXFxyXFx1MjAyOFxcdTIwMjldL2csXG4gICAgICAgIFYgPSAvXi0/WzAtOV1cXGQqKFxcLlxcZCspPyQvLFxuICAgICAgICBNID0gL15bYS16QS1aXSskLyxcbiAgICAgICAgcSA9IC9eW2EtekEtWjAtOV0rJC8sXG4gICAgICAgIEYgPSAvXlthLXpBLVowLTlfLV0rJC8sXG4gICAgICAgIFIgPSAvXmh0dHBzPzpcXC9cXC9cXFMrLyxcbiAgICAgICAgSSA9IC9eWzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzEtNV1bMC05YS1mXXszfS1bMC05YS1mXXs0fS1bMC05YS1mXXsxMn0kL2ksXG4gICAgICAgIFAgPSAvXigoKFthLWYwLTldW2EtZjAtOV0rWy1dKXs1fXwoW2EtZjAtOV1bYS1mMC05XStbOl0pezV9KShbYS1mMC05XVthLWYwLTldKSQpfCheKFthLWYwLTldW2EtZjAtOV1bYS1mMC05XVthLWYwLTldK1suXSl7Mn0oW2EtZjAtOV1bYS1mMC05XVthLWYwLTldW2EtZjAtOV0pKSQvaTtcblxuICAgIHJldHVybiB0LnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21waWxlKGUpKHQpO1xuICAgIH0sIHQucHJvdG90eXBlLndyYXBSZXF1aXJlZENoZWNrU291cmNlQ29kZSA9IGZ1bmN0aW9uICh0LCBlLCBuKSB7XG4gICAgICB2YXIgciA9IFtdLFxuICAgICAgICAgIGEgPSBudWxsICE9IHQuc2NoZW1hLmRlZmF1bHQgPyBKU09OLnN0cmluZ2lmeSh0LnNjaGVtYS5kZWZhdWx0KSA6IG51bGw7XG4gICAgICByZXR1cm4gci5wdXNoKFwiXFxuXFx0XFx0XFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcXG5cXHRcXHRcIiksICEwID09PSB0LnNjaGVtYS5vcHRpb25hbCB8fCBcImZvcmJpZGRlblwiID09IHQuc2NoZW1hLnR5cGUgPyBudWxsICE9IGEgJiYgbiA/IHIucHVzaChuICsgXCIgPSBcIiArIGEgKyBcIjtcIikgOiByLnB1c2goXCIvLyBEbyBub3RoaW5nLCBpdCdzIGFuIG9wdGlvbmFsIGZpZWxkXCIpIDogbnVsbCAhPSBhICYmIG4gPyByLnB1c2gobiArIFwiID0gXCIgKyBhICsgXCI7XCIpIDogci5wdXNoKHRoaXMubWFrZUVycm9yKHtcbiAgICAgICAgdHlwZTogXCJyZXF1aXJlZFwiLFxuICAgICAgICBhY3R1YWw6IFwidmFsdWVcIixcbiAgICAgICAgbWVzc2FnZXM6IHQubWVzc2FnZXNcbiAgICAgIH0pKSwgci5wdXNoKFwifSBlbHNlIHtcIiksIGUgJiYgci5wdXNoKGUpLCByLnB1c2goXCJcXHRcXHR9XCIpLCByLmpvaW4oXCJcXG5cIik7XG4gICAgfSwgdC5wcm90b3R5cGUuY29tcGlsZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBpZiAobnVsbCA9PT0gdCB8fCBcIm9iamVjdFwiICE9IHR5cGVvZiB0KSB0aHJvdyBFcnJvcihcIkludmFsaWQgc2NoZW1hLlwiKTtcbiAgICAgIHZhciBuID0gdGhpcyxcbiAgICAgICAgICByID0ge1xuICAgICAgICBpbmRleDogMCxcbiAgICAgICAgcnVsZXM6IFtdLFxuICAgICAgICBmbjogW10sXG4gICAgICAgIGN1c3RvbXM6IHt9XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuY2FjaGUuY2xlYXIoKSwgITAgIT09IHQuJCRyb290KSBpZiAoQXJyYXkuaXNBcnJheSh0KSkgdCA9IHRoaXMuZ2V0UnVsZUZyb21TY2hlbWEodCkuc2NoZW1hO2Vsc2Uge1xuICAgICAgICB2YXIgYSA9IE9iamVjdC5hc3NpZ24oe30sIHQpO1xuICAgICAgICB0ID0ge1xuICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgc3RyaWN0OiBhLiQkc3RyaWN0LFxuICAgICAgICAgIHByb3BlcnRpZXM6IGFcbiAgICAgICAgfSwgZGVsZXRlIGEuJCRzdHJpY3Q7XG4gICAgICB9XG4gICAgICBhID0gW1widmFyIGVycm9ycyA9IFtdO1wiLCBcInZhciBmaWVsZDtcIl0sIHQgPSB0aGlzLmdldFJ1bGVGcm9tU2NoZW1hKHQpLCBhLnB1c2godGhpcy5jb21waWxlUnVsZSh0LCByLCBudWxsLCBcImNvbnRleHQuZm5bJSVJTkRFWCUlXSh2YWx1ZSwgZmllbGQsIG51bGwsIGVycm9ycywgY29udGV4dCk7XCIsIFwidmFsdWVcIikpLCBhLnB1c2goXCJpZiAoZXJyb3JzLmxlbmd0aCkge1wiKSwgYS5wdXNoKCdcXG5cXHRcXHRcXHRyZXR1cm4gZXJyb3JzLm1hcChlcnIgPT4ge1xcblxcdFxcdFxcdFxcdGlmIChlcnIubWVzc2FnZSlcXG5cXHRcXHRcXHRcXHRcXHRlcnIubWVzc2FnZSA9IGVyci5tZXNzYWdlXFxuXFx0XFx0XFx0XFx0XFx0XFx0LnJlcGxhY2UoL1xcXFx7ZmllbGRcXFxcfS9nLCBlcnIuZmllbGQgfHwgXCJcIilcXG5cXHRcXHRcXHRcXHRcXHRcXHQucmVwbGFjZSgvXFxcXHtleHBlY3RlZFxcXFx9L2csIGVyci5leHBlY3RlZCAhPSBudWxsID8gZXJyLmV4cGVjdGVkIDogXCJcIilcXG5cXHRcXHRcXHRcXHRcXHRcXHQucmVwbGFjZSgvXFxcXHthY3R1YWxcXFxcfS9nLCBlcnIuYWN0dWFsICE9IG51bGwgPyBlcnIuYWN0dWFsIDogXCJcIik7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGVycjtcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHQnKSwgYS5wdXNoKFwifVwiKSwgYS5wdXNoKFwicmV0dXJuIHRydWU7XCIpLCB0ID0gYS5qb2luKFwiXFxuXCIpO1xuICAgICAgdmFyIGkgPSBuZXcgRnVuY3Rpb24oXCJ2YWx1ZVwiLCBcImNvbnRleHRcIiwgdCk7XG5cbiAgICAgIGlmICh0aGlzLm9wdHMuZGVidWcpIHtcbiAgICAgICAgdmFyIHMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICB9O1xuXG4gICAgICAgIFwidW5kZWZpbmVkXCIgPT0gdHlwZW9mIHdpbmRvdyAmJiAocyA9IGUpLCByLmZuLmZvckVhY2goZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICByZXR1cm4gY29uc29sZS5sb2cocyhcIi8vIENvbnRleHQuZm5bXCIgKyBlICsgXCJdXFxuXCIgKyB0LnRvU3RyaW5nKCkpKTtcbiAgICAgICAgfSksIGNvbnNvbGUubG9nKHMoXCIvLyBNYWluIGNoZWNrIGZ1bmN0aW9uXFxuXCIgKyBpLnRvU3RyaW5nKCkpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuY2xlYXIoKSwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHIuZGF0YSA9IHQsIGkuY2FsbChuLCB0LCByKTtcbiAgICAgIH07XG4gICAgfSwgdC5wcm90b3R5cGUuY29tcGlsZVJ1bGUgPSBmdW5jdGlvbiAodCwgZSwgbiwgciwgYSkge1xuICAgICAgdmFyIGkgPSBbXSxcbiAgICAgICAgICBzID0gdGhpcy5jYWNoZS5nZXQodC5zY2hlbWEpO1xuICAgICAgcmV0dXJuIHMgPyAodCA9IHMsIHQuY3ljbGUgPSAhMCwgdC5jeWNsZVN0YWNrID0gW10sIGkucHVzaCh0aGlzLndyYXBSZXF1aXJlZENoZWNrU291cmNlQ29kZSh0LCBcIlxcblxcdFxcdFxcdFxcdHZhciBydWxlID0gY29udGV4dC5ydWxlc1tcIiArIHQuaW5kZXggKyBcIl07XFxuXFx0XFx0XFx0XFx0aWYgKHJ1bGUuY3ljbGVTdGFjay5pbmRleE9mKHZhbHVlKSA9PT0gLTEpIHtcXG5cXHRcXHRcXHRcXHRcXHRydWxlLmN5Y2xlU3RhY2sucHVzaCh2YWx1ZSk7XFxuXFx0XFx0XFx0XFx0XFx0XCIgKyByLnJlcGxhY2UoXCIlJUlOREVYJSVcIiwgdC5pbmRleCkgKyBcIlxcblxcdFxcdFxcdFxcdFxcdHJ1bGUuY3ljbGVTdGFjay5wb3AodmFsdWUpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcIiwgYSkpKSA6ICh0aGlzLmNhY2hlLnNldCh0LnNjaGVtYSwgdCksIHQuaW5kZXggPSBlLmluZGV4LCBlLnJ1bGVzW2UuaW5kZXhdID0gdCwgZS5pbmRleCsrLCBuID0gdC5ydWxlRnVuY3Rpb24uY2FsbCh0aGlzLCB0LCBuLCBlKSwgbi5zb3VyY2UgPyAobiA9IG5ldyBGdW5jdGlvbihcInZhbHVlXCIsIFwiZmllbGRcIiwgXCJwYXJlbnRcIiwgXCJlcnJvcnNcIiwgXCJjb250ZXh0XCIsIG4uc291cmNlKSwgZS5mblt0LmluZGV4XSA9IG4sIGkucHVzaCh0aGlzLndyYXBSZXF1aXJlZENoZWNrU291cmNlQ29kZSh0LCByLnJlcGxhY2UoXCIlJUlOREVYJSVcIiwgdC5pbmRleCksIGEpKSkgOiBpLnB1c2godGhpcy53cmFwUmVxdWlyZWRDaGVja1NvdXJjZUNvZGUodCkpKSwgaS5qb2luKFwiXFxuXCIpO1xuICAgIH0sIHQucHJvdG90eXBlLmdldFJ1bGVGcm9tU2NoZW1hID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcztcblxuICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHQpIHtcbiAgICAgICAgdmFyIG4gPSB0LnNwbGl0KFwifFwiKS5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdC50cmltKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0ID0ge1xuICAgICAgICAgIHR5cGU6IG5bMF1cbiAgICAgICAgfSwgbi5zbGljZSgxKS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB2YXIgbiA9IGUuaW5kZXhPZihcIjpcIik7XG5cbiAgICAgICAgICBpZiAoLTEgIT09IG4pIHtcbiAgICAgICAgICAgIHZhciByID0gZS5zdWJzdHIoMCwgbikudHJpbSgpO1xuICAgICAgICAgICAgXCJ0cnVlXCIgPT09IChlID0gZS5zdWJzdHIobiArIDEpLnRyaW0oKSkgfHwgXCJmYWxzZVwiID09PSBlID8gZSA9IFwidHJ1ZVwiID09PSBlIDogTnVtYmVyLmlzTmFOKE51bWJlcihlKSkgfHwgKGUgPSBOdW1iZXIoZSkpLCB0W3JdID0gZTtcbiAgICAgICAgICB9IGVsc2UgZS5zdGFydHNXaXRoKFwibm8tXCIpID8gdFtlLnNsaWNlKDMpXSA9ICExIDogdFtlXSA9ICEwO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0KSkge1xuICAgICAgICBpZiAoMCA9PSB0Lmxlbmd0aCkgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIHNjaGVtYS5cIik7XG4gICAgICAgICh0ID0ge1xuICAgICAgICAgIHR5cGU6IFwibXVsdGlcIixcbiAgICAgICAgICBydWxlczogdFxuICAgICAgICB9KS5ydWxlcy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gZS5nZXRSdWxlRnJvbVNjaGVtYSh0KTtcbiAgICAgICAgfSkuZXZlcnkoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gMSA9PSB0LnNjaGVtYS5vcHRpb25hbDtcbiAgICAgICAgfSkgJiYgKHQub3B0aW9uYWwgPSAhMCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghKG4gPSB0aGlzLnJ1bGVzW3QudHlwZV0pKSB0aHJvdyBFcnJvcihcIkludmFsaWQgJ1wiICsgdC50eXBlICsgXCInIHR5cGUgaW4gdmFsaWRhdG9yIHNjaGVtYS5cIik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtZXNzYWdlczogT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5tZXNzYWdlcywgdC5tZXNzYWdlcyksXG4gICAgICAgIHNjaGVtYTogdCxcbiAgICAgICAgcnVsZUZ1bmN0aW9uOiBuXG4gICAgICB9O1xuICAgIH0sIHQucHJvdG90eXBlLm1ha2VFcnJvciA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IHQudHlwZSxcbiAgICAgICAgICBuID0gdC5maWVsZCxcbiAgICAgICAgICByID0gdC5leHBlY3RlZCxcbiAgICAgICAgICBhID0gdC5hY3R1YWwsXG4gICAgICAgICAgaSA9IHtcbiAgICAgICAgdHlwZTogJ1wiJyArIGUgKyAnXCInLFxuICAgICAgICBtZXNzYWdlOiAnXCInICsgdC5tZXNzYWdlc1tlXSArICdcIidcbiAgICAgIH07XG4gICAgICByZXR1cm4gaS5maWVsZCA9IG4gPyAnXCInICsgbiArICdcIicgOiBcImZpZWxkXCIsIHIgJiYgKGkuZXhwZWN0ZWQgPSByKSwgYSAmJiAoaS5hY3R1YWwgPSBhKSwgXCJlcnJvcnMucHVzaCh7IFwiICsgT2JqZWN0LmtleXMoaSkubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0ICsgXCI6IFwiICsgaVt0XTtcbiAgICAgIH0pLmpvaW4oXCIsIFwiKSArIFwiIH0pO1wiO1xuICAgIH0sIHQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB0aGlzLnJ1bGVzW3RdID0gZTtcbiAgICB9LCB0O1xuICB9XG5cbiAgdmFyIGYgPSBmIHx8IHt9O1xuICBmLnNjb3BlID0ge30sIGYuQVNTVU1FX0VTNSA9ICExLCBmLkFTU1VNRV9OT19OQVRJVkVfTUFQID0gITEsIGYuQVNTVU1FX05PX05BVElWRV9TRVQgPSAhMSwgZi5kZWZpbmVQcm9wZXJ0eSA9IGYuQVNTVU1FX0VTNSB8fCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gKHQsIGUsIG4pIHtcbiAgICB0ICE9IEFycmF5LnByb3RvdHlwZSAmJiB0ICE9IE9iamVjdC5wcm90b3R5cGUgJiYgKHRbZV0gPSBuLnZhbHVlKTtcbiAgfSwgZi5nZXRHbG9iYWwgPSBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiB3aW5kb3cgJiYgd2luZG93ID09PSB0ID8gdCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGNvbW1vbmpzR2xvYmFsICYmIG51bGwgIT0gY29tbW9uanNHbG9iYWwgPyBjb21tb25qc0dsb2JhbCA6IHQ7XG4gIH0sIGYuZ2xvYmFsID0gZi5nZXRHbG9iYWwoY29tbW9uanNHbG9iYWwpLCBmLlNZTUJPTF9QUkVGSVggPSBcImpzY29tcF9zeW1ib2xfXCIsIGYuaW5pdFN5bWJvbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmLmluaXRTeW1ib2wgPSBmdW5jdGlvbiAoKSB7fSwgZi5nbG9iYWwuU3ltYm9sIHx8IChmLmdsb2JhbC5TeW1ib2wgPSBmLlN5bWJvbCk7XG4gIH0sIGYuU3ltYm9sID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0ID0gMDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBmLlNZTUJPTF9QUkVGSVggKyAoZSB8fCBcIlwiKSArIHQrKztcbiAgICB9O1xuICB9KCksIGYuaW5pdFN5bWJvbEl0ZXJhdG9yID0gZnVuY3Rpb24gKCkge1xuICAgIGYuaW5pdFN5bWJvbCgpO1xuICAgIHZhciB0ID0gZi5nbG9iYWwuU3ltYm9sLml0ZXJhdG9yO1xuICAgIHQgfHwgKHQgPSBmLmdsb2JhbC5TeW1ib2wuaXRlcmF0b3IgPSBmLmdsb2JhbC5TeW1ib2woXCJpdGVyYXRvclwiKSksIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgQXJyYXkucHJvdG90eXBlW3RdICYmIGYuZGVmaW5lUHJvcGVydHkoQXJyYXkucHJvdG90eXBlLCB0LCB7XG4gICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGYuYXJyYXlJdGVyYXRvcih0aGlzKTtcbiAgICAgIH1cbiAgICB9KSwgZi5pbml0U3ltYm9sSXRlcmF0b3IgPSBmdW5jdGlvbiAoKSB7fTtcbiAgfSwgZi5hcnJheUl0ZXJhdG9yID0gZnVuY3Rpb24gKHQpIHtcbiAgICB2YXIgZSA9IDA7XG4gICAgcmV0dXJuIGYuaXRlcmF0b3JQcm90b3R5cGUoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGUgPCB0Lmxlbmd0aCA/IHtcbiAgICAgICAgZG9uZTogITEsXG4gICAgICAgIHZhbHVlOiB0W2UrK11cbiAgICAgIH0gOiB7XG4gICAgICAgIGRvbmU6ICEwXG4gICAgICB9O1xuICAgIH0pO1xuICB9LCBmLml0ZXJhdG9yUHJvdG90eXBlID0gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gZi5pbml0U3ltYm9sSXRlcmF0b3IoKSwgdCA9IHtcbiAgICAgIG5leHQ6IHRcbiAgICB9LCB0W2YuZ2xvYmFsLlN5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LCB0O1xuICB9LCBmLml0ZXJhdG9yRnJvbUFycmF5ID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICBmLmluaXRTeW1ib2xJdGVyYXRvcigpLCB0IGluc3RhbmNlb2YgU3RyaW5nICYmICh0ICs9IFwiXCIpO1xuICAgIHZhciBuID0gMCxcbiAgICAgICAgciA9IHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG4gPCB0Lmxlbmd0aCkge1xuICAgICAgICAgIHZhciBhID0gbisrO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogZShhLCB0W2FdKSxcbiAgICAgICAgICAgIGRvbmU6ICExXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6ICEwLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICAgIH07XG4gICAgICAgIH0sIHIubmV4dCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHJbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByO1xuICAgIH0sIHI7XG4gIH0sIGYucG9seWZpbGwgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgIGlmIChlKSB7XG4gICAgICB2YXIgbiA9IGYuZ2xvYmFsO1xuICAgICAgdCA9IHQuc3BsaXQoXCIuXCIpO1xuXG4gICAgICBmb3IgKHZhciByID0gMDsgciA8IHQubGVuZ3RoIC0gMTsgcisrKSB7XG4gICAgICAgIHZhciBhID0gdFtyXTtcbiAgICAgICAgYSBpbiBuIHx8IChuW2FdID0ge30pLCBuID0gblthXTtcbiAgICAgIH1cblxuICAgICAgKGUgPSBlKHIgPSBuW3QgPSB0W3QubGVuZ3RoIC0gMV1dKSkgIT0gciAmJiBudWxsICE9IGUgJiYgZi5kZWZpbmVQcm9wZXJ0eShuLCB0LCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgZi5wb2x5ZmlsbChcIkFycmF5LnByb3RvdHlwZS52YWx1ZXNcIiwgZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdCB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZi5pdGVyYXRvckZyb21BcnJheSh0aGlzLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0sIFwiZXM4XCIsIFwiZXMzXCIpLCBmLnBvbHlmaWxsKFwiQXJyYXkucHJvdG90eXBlLmtleXNcIiwgZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdCB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZi5pdGVyYXRvckZyb21BcnJheSh0aGlzLCBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdDtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0sIFwiZXM2XCIsIFwiZXMzXCIpLCBmLmNoZWNrRXM2Q29uZm9ybWFuY2VWaWFQcm94eSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIHQgPSB7fSxcbiAgICAgICAgICBlID0gT2JqZWN0LmNyZWF0ZShuZXcgZi5nbG9iYWwuUHJveHkodCwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIChuLCByLCBhKSB7XG4gICAgICAgICAgcmV0dXJuIG4gPT0gdCAmJiBcInFcIiA9PSByICYmIGEgPT0gZTtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgICAgcmV0dXJuICEwID09PSBlLnE7XG4gICAgfSBjYXRjaCAodCkge1xuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgfSwgZi5VU0VfUFJPWFlfRk9SX0VTNl9DT05GT1JNQU5DRV9DSEVDS1MgPSAhMSwgZi5FUzZfQ09ORk9STUFOQ0UgPSBmLlVTRV9QUk9YWV9GT1JfRVM2X0NPTkZPUk1BTkNFX0NIRUNLUyAmJiBmLmNoZWNrRXM2Q29uZm9ybWFuY2VWaWFQcm94eSgpLCBmLm1ha2VJdGVyYXRvciA9IGZ1bmN0aW9uICh0KSB7XG4gICAgZi5pbml0U3ltYm9sSXRlcmF0b3IoKTtcbiAgICB2YXIgZSA9IHRbU3ltYm9sLml0ZXJhdG9yXTtcbiAgICByZXR1cm4gZSA/IGUuY2FsbCh0KSA6IGYuYXJyYXlJdGVyYXRvcih0KTtcbiAgfSwgZi5vd25zID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsIGUpO1xuICB9LCBmLnBvbHlmaWxsKFwiV2Vha01hcFwiLCBmdW5jdGlvbiAodCkge1xuICAgIGZ1bmN0aW9uIGUodCkge1xuICAgICAgaWYgKHRoaXMuaWRfID0gKGkgKz0gTWF0aC5yYW5kb20oKSArIDEpLnRvU3RyaW5nKCksIHQpIHtcbiAgICAgICAgZi5pbml0U3ltYm9sKCksIGYuaW5pdFN5bWJvbEl0ZXJhdG9yKCksIHQgPSBmLm1ha2VJdGVyYXRvcih0KTtcblxuICAgICAgICBmb3IgKHZhciBlOyAhKGUgPSB0Lm5leHQoKSkuZG9uZTspIGUgPSBlLnZhbHVlLCB0aGlzLnNldChlWzBdLCBlWzFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBuKHQpIHtcbiAgICAgIGYub3ducyh0LCBhKSB8fCBmLmRlZmluZVByb3BlcnR5KHQsIGEsIHtcbiAgICAgICAgdmFsdWU6IHt9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByKHQpIHtcbiAgICAgIHZhciBlID0gT2JqZWN0W3RdO1xuICAgICAgZSAmJiAoT2JqZWN0W3RdID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIG4odCksIGUodCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoZi5VU0VfUFJPWFlfRk9SX0VTNl9DT05GT1JNQU5DRV9DSEVDS1MpIHtcbiAgICAgIGlmICh0ICYmIGYuRVM2X0NPTkZPUk1BTkNFKSByZXR1cm4gdDtcbiAgICB9IGVsc2UgaWYgKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdCB8fCAhT2JqZWN0LnNlYWwpIHJldHVybiAhMTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGUgPSBPYmplY3Quc2VhbCh7fSksXG4gICAgICAgICAgICBuID0gT2JqZWN0LnNlYWwoe30pLFxuICAgICAgICAgICAgciA9IG5ldyB0KFtbZSwgMl0sIFtuLCAzXV0pO1xuICAgICAgICByZXR1cm4gMiA9PSByLmdldChlKSAmJiAzID09IHIuZ2V0KG4pICYmIChyLmRlbGV0ZShlKSwgci5zZXQobiwgNCksICFyLmhhcyhlKSAmJiA0ID09IHIuZ2V0KG4pKTtcbiAgICAgIH0gY2F0Y2ggKHQpIHtcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICAgIH0oKSkgcmV0dXJuIHQ7XG5cbiAgICB2YXIgYSA9IFwiJGpzY29tcF9oaWRkZW5fXCIgKyBNYXRoLnJhbmRvbSgpO1xuICAgIHIoXCJmcmVlemVcIiksIHIoXCJwcmV2ZW50RXh0ZW5zaW9uc1wiKSwgcihcInNlYWxcIik7XG4gICAgdmFyIGkgPSAwO1xuICAgIHJldHVybiBlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgaWYgKG4odCksICFmLm93bnModCwgYSkpIHRocm93IEVycm9yKFwiV2Vha01hcCBrZXkgZmFpbDogXCIgKyB0KTtcbiAgICAgIHJldHVybiB0W2FdW3RoaXMuaWRfXSA9IGUsIHRoaXM7XG4gICAgfSwgZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiBmLm93bnModCwgYSkgPyB0W2FdW3RoaXMuaWRfXSA6IHZvaWQgMDtcbiAgICB9LCBlLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIGYub3ducyh0LCBhKSAmJiBmLm93bnModFthXSwgdGhpcy5pZF8pO1xuICAgIH0sIGUucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gISghZi5vd25zKHQsIGEpIHx8ICFmLm93bnModFthXSwgdGhpcy5pZF8pKSAmJiBkZWxldGUgdFthXVt0aGlzLmlkX107XG4gICAgfSwgZTtcbiAgfSwgXCJlczZcIiwgXCJlczNcIiksIGYuTWFwRW50cnkgPSBmdW5jdGlvbiAoKSB7fSwgZi5wb2x5ZmlsbChcIk1hcFwiLCBmdW5jdGlvbiAodCkge1xuICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICB2YXIgdCA9IHt9O1xuICAgICAgcmV0dXJuIHQucHJldmlvdXMgPSB0Lm5leHQgPSB0LmhlYWQgPSB0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG4odCwgZSkge1xuICAgICAgdmFyIG4gPSB0LmhlYWRfO1xuICAgICAgcmV0dXJuIGYuaXRlcmF0b3JQcm90b3R5cGUoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobikge1xuICAgICAgICAgIGZvciAoOyBuLmhlYWQgIT0gdC5oZWFkXzspIG4gPSBuLnByZXZpb3VzO1xuXG4gICAgICAgICAgZm9yICg7IG4ubmV4dCAhPSBuLmhlYWQ7KSByZXR1cm4gbiA9IG4ubmV4dCwge1xuICAgICAgICAgICAgZG9uZTogITEsXG4gICAgICAgICAgICB2YWx1ZTogZShuKVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBuID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZG9uZTogITAsXG4gICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcih0LCBlKSB7XG4gICAgICB2YXIgbiA9IGUgJiYgdHlwZW9mIGU7XG4gICAgICBcIm9iamVjdFwiID09IG4gfHwgXCJmdW5jdGlvblwiID09IG4gPyBpLmhhcyhlKSA/IG4gPSBpLmdldChlKSA6IChuID0gXCJcIiArICsrcywgaS5zZXQoZSwgbikpIDogbiA9IFwicF9cIiArIGU7XG4gICAgICB2YXIgciA9IHQuZGF0YV9bbl07XG4gICAgICBpZiAociAmJiBmLm93bnModC5kYXRhXywgbikpIGZvciAodCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgIHZhciBhID0gclt0XTtcbiAgICAgICAgaWYgKGUgIT09IGUgJiYgYS5rZXkgIT09IGEua2V5IHx8IGUgPT09IGEua2V5KSByZXR1cm4ge1xuICAgICAgICAgIGlkOiBuLFxuICAgICAgICAgIGxpc3Q6IHIsXG4gICAgICAgICAgaW5kZXg6IHQsXG4gICAgICAgICAgZW50cnk6IGFcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBuLFxuICAgICAgICBsaXN0OiByLFxuICAgICAgICBpbmRleDogLTEsXG4gICAgICAgIGVudHJ5OiB2b2lkIDBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYSh0KSB7XG4gICAgICBpZiAodGhpcy5kYXRhXyA9IHt9LCB0aGlzLmhlYWRfID0gZSgpLCB0aGlzLnNpemUgPSAwLCB0KSB7XG4gICAgICAgIHQgPSBmLm1ha2VJdGVyYXRvcih0KTtcblxuICAgICAgICBmb3IgKHZhciBuOyAhKG4gPSB0Lm5leHQoKSkuZG9uZTspIG4gPSBuLnZhbHVlLCB0aGlzLnNldChuWzBdLCBuWzFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZi5VU0VfUFJPWFlfRk9SX0VTNl9DT05GT1JNQU5DRV9DSEVDS1MpIHtcbiAgICAgIGlmICh0ICYmIGYuRVM2X0NPTkZPUk1BTkNFKSByZXR1cm4gdDtcbiAgICB9IGVsc2UgaWYgKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChmLkFTU1VNRV9OT19OQVRJVkVfTUFQIHx8ICF0IHx8IFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgdCB8fCAhdC5wcm90b3R5cGUuZW50cmllcyB8fCBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIE9iamVjdC5zZWFsKSByZXR1cm4gITE7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBlID0gT2JqZWN0LnNlYWwoe1xuICAgICAgICAgIHg6IDRcbiAgICAgICAgfSksXG4gICAgICAgICAgICBuID0gbmV3IHQoZi5tYWtlSXRlcmF0b3IoW1tlLCBcInNcIl1dKSk7XG4gICAgICAgIGlmIChcInNcIiAhPSBuLmdldChlKSB8fCAxICE9IG4uc2l6ZSB8fCBuLmdldCh7XG4gICAgICAgICAgeDogNFxuICAgICAgICB9KSB8fCBuLnNldCh7XG4gICAgICAgICAgeDogNFxuICAgICAgICB9LCBcInRcIikgIT0gbiB8fCAyICE9IG4uc2l6ZSkgcmV0dXJuICExO1xuICAgICAgICB2YXIgciA9IG4uZW50cmllcygpLFxuICAgICAgICAgICAgYSA9IHIubmV4dCgpO1xuICAgICAgICByZXR1cm4gIWEuZG9uZSAmJiBhLnZhbHVlWzBdID09IGUgJiYgXCJzXCIgPT0gYS52YWx1ZVsxXSAmJiAhKChhID0gci5uZXh0KCkpLmRvbmUgfHwgNCAhPSBhLnZhbHVlWzBdLnggfHwgXCJ0XCIgIT0gYS52YWx1ZVsxXSB8fCAhci5uZXh0KCkuZG9uZSk7XG4gICAgICB9IGNhdGNoICh0KSB7XG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICB9KCkpIHJldHVybiB0O1xuXG4gICAgZi5pbml0U3ltYm9sKCksIGYuaW5pdFN5bWJvbEl0ZXJhdG9yKCk7XG4gICAgdmFyIGkgPSBuZXcgV2Vha01hcCgpO1xuICAgIGEucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB2YXIgbiA9IHIodGhpcywgdCk7XG4gICAgICByZXR1cm4gbi5saXN0IHx8IChuLmxpc3QgPSB0aGlzLmRhdGFfW24uaWRdID0gW10pLCBuLmVudHJ5ID8gbi5lbnRyeS52YWx1ZSA9IGUgOiAobi5lbnRyeSA9IHtcbiAgICAgICAgbmV4dDogdGhpcy5oZWFkXyxcbiAgICAgICAgcHJldmlvdXM6IHRoaXMuaGVhZF8ucHJldmlvdXMsXG4gICAgICAgIGhlYWQ6IHRoaXMuaGVhZF8sXG4gICAgICAgIGtleTogdCxcbiAgICAgICAgdmFsdWU6IGVcbiAgICAgIH0sIG4ubGlzdC5wdXNoKG4uZW50cnkpLCB0aGlzLmhlYWRfLnByZXZpb3VzLm5leHQgPSBuLmVudHJ5LCB0aGlzLmhlYWRfLnByZXZpb3VzID0gbi5lbnRyeSwgdGhpcy5zaXplKyspLCB0aGlzO1xuICAgIH0sIGEucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gISghKHQgPSByKHRoaXMsIHQpKS5lbnRyeSB8fCAhdC5saXN0KSAmJiAodC5saXN0LnNwbGljZSh0LmluZGV4LCAxKSwgdC5saXN0Lmxlbmd0aCB8fCBkZWxldGUgdGhpcy5kYXRhX1t0LmlkXSwgdC5lbnRyeS5wcmV2aW91cy5uZXh0ID0gdC5lbnRyeS5uZXh0LCB0LmVudHJ5Lm5leHQucHJldmlvdXMgPSB0LmVudHJ5LnByZXZpb3VzLCB0LmVudHJ5LmhlYWQgPSBudWxsLCB0aGlzLnNpemUtLSwgITApO1xuICAgIH0sIGEucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5kYXRhXyA9IHt9LCB0aGlzLmhlYWRfID0gdGhpcy5oZWFkXy5wcmV2aW91cyA9IGUoKSwgdGhpcy5zaXplID0gMDtcbiAgICB9LCBhLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuICEhcih0aGlzLCB0KS5lbnRyeTtcbiAgICB9LCBhLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuICh0ID0gcih0aGlzLCB0KS5lbnRyeSkgJiYgdC52YWx1ZTtcbiAgICB9LCBhLnByb3RvdHlwZS5lbnRyaWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG4odGhpcywgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIFt0LmtleSwgdC52YWx1ZV07XG4gICAgICB9KTtcbiAgICB9LCBhLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG4odGhpcywgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQua2V5O1xuICAgICAgfSk7XG4gICAgfSwgYS5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG4odGhpcywgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQudmFsdWU7XG4gICAgICB9KTtcbiAgICB9LCBhLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGZvciAodmFyIG4sIHIgPSB0aGlzLmVudHJpZXMoKTsgIShuID0gci5uZXh0KCkpLmRvbmU7KSBuID0gbi52YWx1ZSwgdC5jYWxsKGUsIG5bMV0sIG5bMF0sIHRoaXMpO1xuICAgIH0sIGEucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBhLnByb3RvdHlwZS5lbnRyaWVzO1xuICAgIHZhciBzID0gMDtcbiAgICByZXR1cm4gYTtcbiAgfSwgXCJlczZcIiwgXCJlczNcIiksIGYuYXNzaWduID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgZm9yICh2YXIgbiA9IDE7IG4gPCBhcmd1bWVudHMubGVuZ3RoOyBuKyspIHtcbiAgICAgIHZhciByID0gYXJndW1lbnRzW25dO1xuICAgICAgaWYgKHIpIGZvciAodmFyIGEgaW4gcikgZi5vd25zKHIsIGEpICYmICh0W2FdID0gclthXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHQ7XG4gIH0sIGYucG9seWZpbGwoXCJPYmplY3QuYXNzaWduXCIsIGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHQgfHwgZi5hc3NpZ247XG4gIH0sIFwiZXM2XCIsIFwiZXMzXCIpLCBmLnBvbHlmaWxsKFwiTnVtYmVyLmlzTmFOXCIsIGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHQgfHwgZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiBcIm51bWJlclwiID09IHR5cGVvZiB0ICYmIGlzTmFOKHQpO1xuICAgIH07XG4gIH0sIFwiZXM2XCIsIFwiZXMzXCIpLCBmLmNoZWNrU3RyaW5nQXJncyA9IGZ1bmN0aW9uICh0LCBlLCBuKSB7XG4gICAgaWYgKG51bGwgPT0gdCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSAndGhpcycgdmFsdWUgZm9yIFN0cmluZy5wcm90b3R5cGUuXCIgKyBuICsgXCIgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWRcIik7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBSZWdFeHApIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaXJzdCBhcmd1bWVudCB0byBTdHJpbmcucHJvdG90eXBlLlwiICsgbiArIFwiIG11c3Qgbm90IGJlIGEgcmVndWxhciBleHByZXNzaW9uXCIpO1xuICAgIHJldHVybiB0ICsgXCJcIjtcbiAgfSwgZi5wb2x5ZmlsbChcIlN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aFwiLCBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0IHx8IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB2YXIgbiA9IGYuY2hlY2tTdHJpbmdBcmdzKHRoaXMsIHQsIFwic3RhcnRzV2l0aFwiKTtcbiAgICAgIHQgKz0gXCJcIjtcbiAgICAgIHZhciByID0gbi5sZW5ndGgsXG4gICAgICAgICAgYSA9IHQubGVuZ3RoO1xuICAgICAgZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDAgfCBlLCBuLmxlbmd0aCkpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEgJiYgZSA8IHI7KSBpZiAobltlKytdICE9IHRbaSsrXSkgcmV0dXJuICExO1xuXG4gICAgICByZXR1cm4gaSA+PSBhO1xuICAgIH07XG4gIH0sIFwiZXM2XCIsIFwiZXMzXCIpO1xuICAgbW9kdWxlLmV4cG9ydHMgPSB1KCkgO1xuICB9KTtcblxuICAvKlxuICBrbm93biBldmVudHM6XG4gIC0gc3RhdGUtY2hhbmdlIC8gbWV0YTogdGhlIG5hbWUgb2YgdGhlIG5ldyBzdGF0ZVxuICAtIGF0dHJpYnV0ZS1yZWplY3Rpb24gLyBtZXRhOiBhbmltYXRpb25JRCwgYXR0cmlidXRlc1xuICAtIGFuaW1hdGlvbi1yZWplY3Rpb24gLyBtZXRhOiBhbmltYXRpb25JRFxuICAtIGNvbmZsaWN0cy1vbi1lZGl0XG4gICovXG4gIHZhciBsb2dUeXBlcyA9IFt7XG4gICAga2V5OiAnaW5mbycsXG4gICAgc3R5bGU6ICdjb2xvcjogIzY2NjsnLFxuICAgIGxldmVsOiA1XG4gIH0sIHtcbiAgICBrZXk6ICdub3RpY2UnLFxuICAgIHN0eWxlOiAnYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjgpOyBjb2xvcjp3aGl0ZTsgcGFkZGluZzo4cHg7JyxcbiAgICBsZXZlbDogNFxuICB9LCB7XG4gICAga2V5OiAnd2FybmluZycsXG4gICAgc3R5bGU6ICdjb2xvcjogYmxhY2s7IGJhY2tncm91bmQ6IG9yYW5nZTsnLFxuICAgIGxldmVsOiAyXG4gIH0sIHtcbiAgICBrZXk6ICdlcnJvcicsXG4gICAgc3R5bGU6ICdjb2xvcjogYmxhY2s7IGJhY2tncm91bmQ6IHJlZDsnLFxuICAgIGxldmVsOiAxXG4gIH1dO1xuICB2YXIgbGFuZXNNQ0lEYXR0cnNTZXBlcmF0b3IgPSAnX19fJztcbiAgdmFyIGtleWZyYW1lX3NlY19rZXkgPSAnc2VjXyc7XG4gIHZhciBlbGVtZW50c19kYXRhX2F0dHJpYnV0ZV9uYW1lID0gJ2RhdGEtbW90b3Jjb3J0ZXgyLWlkJztcbiAgdmFyIHNlbGZDb250YWluZWRDb250ZXh0SGFuZGxlciA9ICdjbG9zZWQnO1xuICB2YXIgbG9nTGV2ZWwgPSAxO1xuICB2YXIgdGVzdE1vZGUgPSB0cnVlO1xuICB2YXIgY29uZiA9IHtcbiAgICBrZXlmcmFtZV9zZWNfa2V5OiBrZXlmcmFtZV9zZWNfa2V5LFxuICAgIGVsZW1lbnRzX2RhdGFfYXR0cmlidXRlX25hbWU6IGVsZW1lbnRzX2RhdGFfYXR0cmlidXRlX25hbWUsXG4gICAgc2VsZkNvbnRhaW5lZENvbnRleHRIYW5kbGVyOiBzZWxmQ29udGFpbmVkQ29udGV4dEhhbmRsZXIsXG4gICAgbG9nTGV2ZWw6IGxvZ0xldmVsLFxuICAgIHRlc3RNb2RlOiB0ZXN0TW9kZSxcbiAgICBsb2dUeXBlczogbG9nVHlwZXNcbiAgfTtcblxuICB3aW5kb3cuQXVkaW9Db250ZXh0ID0gd2luZG93LkF1ZGlvQ29udGV4dCB8fCB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0O1xuICB2YXIgYXVkaW9Db250ZXh0ID0gbmV3IHdpbmRvdy5BdWRpb0NvbnRleHQoKTtcbiAgZnVuY3Rpb24gaXNPYmplY3QodGVzdCkge1xuICAgIHJldHVybiBfdHlwZW9mKHRlc3QpID09PSAnb2JqZWN0JztcbiAgfVxuICBmdW5jdGlvbiBqc1VjZmlyc3Qoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKTtcbiAgfVxuICAvKipcbiAgIHN1YmRpdmlzaW9uIG1pZ2h0IGJlIHJvdW5kaW5nIHRoZSBudW1iZXIgdG8gaXRzOlxuICAgLSB1bml0cyAoc3ViZGl2aXNpb24gPSAxKVxuICAgLSB0ZW50aHMgKHN1YmRpdmlzaW9uID0gMTApXG4gICAtIGh1bmRyZWRzIChzdWJkaXZpc2lvbiA9IDEwMClcbiAgIC0gdGhvdXNhbmRzIChzdWJkaXZpc2lvbiA9IDEwMDApXG4gICBAcGFyYW0ge251bWJlcn0gbnVtYmVyXG4gICBAcGFyYW0ge251bWJlcn0gc3ViZGl2aXNpb25cbiAgIEByZXR1cm5zIHtudW1iZXJ9IHRoZSByb3VuZGVkIG51bWJlclxuICAgKi9cblxuICBmdW5jdGlvbiByb3VuZE51bWJlclRvKG51bWJlciwgc3ViZGl2aXNpb24pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChudW1iZXIgLyBzdWJkaXZpc2lvbikgKiBzdWJkaXZpc2lvbjtcbiAgfVxuICBmdW5jdGlvbiBnZXRNQ0lEYW5kQXR0ck91dE9mTGFuZUtleShsYW5lS2V5KSB7XG4gICAgdmFyIGxhbmVBcnJheSA9IGxhbmVLZXkuc3BsaXQobGFuZXNNQ0lEYXR0cnNTZXBlcmF0b3IpO1xuICAgIHJldHVybiB7XG4gICAgICBtY2lkOiBsYW5lQXJyYXlbMF0sXG4gICAgICBhdHRyaWJ1dGU6IGxhbmVBcnJheVsxXVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzNCgpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcigoMSArIE1hdGgucmFuZG9tKCkpICogMHgxMDAwMCkudG9TdHJpbmcoMTYpLnN1YnN0cmluZygxKTtcbiAgfVxuICAvKipcbiAgICogQHJldHVybnMge3N0cmluZ30gaW4gdGhlIGZvcm0gXCIxYmM0NWY3OC1hYjIzLWpsNTlcIlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldEFuSWQoKSB7XG4gICAgdmFyIHVuZGVyc2NvcmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgIHZhciBzcGVjaWFsQ2hhciA9IHVuZGVyc2NvcmUgPyAnXycgOiAnLSc7XG4gICAgcmV0dXJuIHM0KCkgKyBzNCgpICsgc3BlY2lhbENoYXIgKyBzNCgpICsgc3BlY2lhbENoYXIgKyBzNCgpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbmRlclRlbXBsYXRlKHRlbXBsYXRlU3RyaW5nLCB0ZW1wbGF0ZVZhcnMpIHtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwicmV0dXJuIGBcIi5jb25jYXQodGVtcGxhdGVTdHJpbmcsIFwiYDtcIikpLmNhbGwodGVtcGxhdGVWYXJzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctZnVuY1xuICB9XG4gIGZ1bmN0aW9uIGdldExhbmVLZXkobWNpZCwgYXR0cmlidXRlKSB7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KG1jaWQpLmNvbmNhdChsYW5lc01DSURhdHRyc1NlcGVyYXRvcikuY29uY2F0KGF0dHJpYnV0ZSk7XG4gIH1cbiAgLyoqIEBjbGFzc2Rlc2MgSGVscGVyIG1haW50YWlucyBhIG51bWJlciBvZiBoZWxwZnVsIGZ1bmN0aW9ucyBpbiBhIHNpbmdsZSBwb2ludCAgKi9cblxuICB2YXIgSGVscGVyID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSGVscGVyKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIZWxwZXIpO1xuXG4gICAgICB2YXIgbG9nTGV2ZWwgPSBjb25mLmxvZ0xldmVsO1xuXG4gICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZ3VyYXRpb24sICdsb2dMZXZlbCcpKSB7XG4gICAgICAgICAgbG9nTGV2ZWwgPSBjb25maWd1cmF0aW9uLmxvZ0xldmVsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9nVHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGxvZ1R5cGUgPSBsb2dUeXBlc1tpXTtcblxuICAgICAgICBpZiAobG9nTGV2ZWwgPj0gbG9nVHlwZS5sZXZlbCkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXNbbG9nVHlwZS5rZXldID0gd2luZG93LmNvbnNvbGUubG9nLmJpbmQod2luZG93LmNvbnNvbGUsIFwiTW90b3JDb3J0ZXggLSBcIi5jb25jYXQobG9nVHlwZS5rZXksIFwiOiBcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHRoaXNbbG9nVHlwZS5rZXldID0gZnVuY3Rpb24gZnVuY3QoKSB7fTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxvZ0xldmVsID49IDMpIHtcbiAgICAgICAgdGhpcy5sb2cgPSB3aW5kb3cuY29uc29sZS5sb2cuYmluZCh3aW5kb3cuY29uc29sZSwgJ01vdG9yQ29ydGV4IC0gJyk7XG4gICAgICB9IGVsc2UgdGhpcy5sb2cgPSBmdW5jdGlvbiBmdW5jdCgpIHt9O1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhIZWxwZXIsIFt7XG4gICAgICBrZXk6IFwidmFsaWRhdGVQcm9wc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRlUHJvcHMocHJvcHMsIHJ1bGVzLCBjb25zdHJ1Y3Rvcikge1xuICAgICAgICB2YXIgdiA9IG5ldyBpbmRleF9taW4oKTtcbiAgICAgICAgdmFyIHZhbGlkYXRpb25SZXN1bHQgPSB2LnZhbGlkYXRlKHByb3BzLCBydWxlcyk7XG5cbiAgICAgICAgaWYgKHZhbGlkYXRpb25SZXN1bHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSBcIkVycm9yIG9uIHBsdWdpbidzIFxcXCJcIi5jb25jYXQoY29uc3RydWN0b3IucGx1Z2luX25wbV9uYW1lLCBcIlxcXCIgXFxcIlwiKS5jb25jYXQoY29uc3RydWN0b3IuQ2xhc3NOYW1lLCBcIlxcXCIgaW5zdGFudGlhdGlvbi4gRXJyb3JzIChvcCBwcm9wcyk6XCIpO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWxpZGF0aW9uUmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gXCJcXG4gLSBcIi5jb25jYXQodmFsaWRhdGlvblJlc3VsdFtpXS5tZXNzYWdlLCBcIi4gXCIpLmNvbmNhdCh2YWxpZGF0aW9uUmVzdWx0W2ldLmFjdHVhbCwgXCIgcHJvdmlkZWRcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvck1lc3NhZ2UpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3JzOiB2YWxpZGF0aW9uUmVzdWx0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzdWx0OiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldEVsZW1lbnRCeU1DSURcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFbGVtZW50QnlNQ0lEKGNvbnRleHQsIG1jaWQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQucm9vdEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcIltcIi5jb25jYXQoZWxlbWVudHNfZGF0YV9hdHRyaWJ1dGVfbmFtZSwgXCI9XFxcIlwiKS5jb25jYXQobWNpZCwgXCJcXFwiXVwiKSlbMF07XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIHN5c3RvbGUgLyBkaWFzdG9sZSBvZiB0aGUgcHJvamVjdGlvbnNcbiAgICAgICAqIEByZXR1cm5zIHthcnJheX0gLSBjb2xsZWN0aW9uIG9mIG9iamVjdHMgd2l0aCBrZXlzOiB7aWQsIHN0YXJ0LCBlbmQsIHN0YXJ0RGVsdGF9XG4gICAgICAgKiAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInN5c3RvbGVEaWFzdG9sZVByb2plY3Rpb25zXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc3lzdG9sZURpYXN0b2xlUHJvamVjdGlvbnMocHJvamVjdGlvbnMsIGR1cmF0aW9uRnJhY3Rpb24sIGFuY2hvclBvaW50KSB7XG4gICAgICAgIHZhciBhbHRlcmVkUHJvamVjdGlvbnMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb2plY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHByb2plY3RlZEluY2lkZW50ID0gcHJvamVjdGlvbnNbaV07XG4gICAgICAgICAgdmFyIG1zSW5SZXNpemVkUG9ydGlvbiA9IHByb2plY3RlZEluY2lkZW50LnBhcmVudE1pbGxpc2Vjb25kIC0gYW5jaG9yUG9pbnQ7XG5cbiAgICAgICAgICBpZiAoZHVyYXRpb25GcmFjdGlvbiAhPT0gMSkge1xuICAgICAgICAgICAgYWx0ZXJlZFByb2plY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICBpZDogcHJvamVjdGVkSW5jaWRlbnQuaW5jaWRlbnQuaWQsXG4gICAgICAgICAgICAgIHN0YXJ0OiBtc0luUmVzaXplZFBvcnRpb24gKiBkdXJhdGlvbkZyYWN0aW9uICsgYW5jaG9yUG9pbnQsXG4gICAgICAgICAgICAgIGVuZDogbXNJblJlc2l6ZWRQb3J0aW9uICogZHVyYXRpb25GcmFjdGlvbiArIGFuY2hvclBvaW50ICsgcHJvamVjdGVkSW5jaWRlbnQuaW5jaWRlbnQuZHVyYXRpb24gKiBkdXJhdGlvbkZyYWN0aW9uLFxuICAgICAgICAgICAgICBzdGFydERlbHRhOiBtc0luUmVzaXplZFBvcnRpb24gKiBkdXJhdGlvbkZyYWN0aW9uICsgYW5jaG9yUG9pbnQgLSBwcm9qZWN0ZWRJbmNpZGVudC5taWxsaXNlY29uZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFsdGVyZWRQcm9qZWN0aW9ucztcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gSGVscGVyO1xuICB9KCk7XG4gIHZhciBoZWxwZXIgPSBuZXcgSGVscGVyKCk7XG5cbiAgdmFyIENoYW5uZWwgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDaGFubmVsKHByb3BzKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2hhbm5lbCk7XG5cbiAgICAgIHRoaXMucnVuVGltZUluZm8gPSBwcm9wcy5ydW5UaW1lSW5mbztcbiAgICAgIHRoaXMuY29udGV4dCA9IHByb3BzLmNvbnRleHQ7XG4gICAgICB0aGlzLm9uSW5pdGlhbGlzZSgpO1xuICAgICAgdGhpcy5nZXRJbmNpZGVudEJ5SWQgPSBwcm9wcy5nZXRJbmNpZGVudEJ5SWQ7IC8vIHRoaXMudHlwZSA9IFwicGxhaW5cIjtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoQ2hhbm5lbCwgW3tcbiAgICAgIGtleTogXCJvbkluaXRpYWxpc2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkluaXRpYWxpc2UoKSB7fVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfcmVzaXplXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc2l6ZSgpIHtcbiAgICAgICAgaGVscGVyLmxvZygnUGxlYXNlIG92ZXJ3aXRlIHRoZSBfcmVzaXplIG1ldGhvZCBvZiB0aGUgQ2hhbm5lbCcpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge2FycmF5fSBpbmNpZGVudHMgLSBBIGNvbGxlY3Rpb24gb2YgSW5jaWRlbnRzIGluIHRoZSBmb3JtOlxuICAgICAgICoge1xuICAgICAgICogIG1pbGxpc2Vjb25kXG4gICAgICAgKiAgaW5jaWRlbnRcbiAgICAgICAqICBpZFxuICAgICAgICogfVxuICAgICAgICogQHJldHVybnMgZWl0aGVyOlxuICAgICAgICogICB7XG4gICAgICAgKiAgICAgICByZXN1bHQ6dHJ1ZSxcbiAgICAgICAqICAgICAgIGV4ZWN1dGU6IC8vIGFuIGFycmF5IG9mIGZ1bmN0aW9ucyB0aGF0IHdoZW4gZXhlY3V0ZWQgaXQgd2lsbCBhZGQgdGhlIEluY2lkZW50cyBvbiB0aGUgQ2hhbm5lbHNcbiAgICAgICAqICAgfVxuICAgICAgICogICBvclxuICAgICAgICogICB7XG4gICAgICAgKiAgICAgICByZXN1bHQ6IGZhbHNlLFxuICAgICAgICogICAgICAgZXJyb3JzXG4gICAgICAgKiAgIH1cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImFkZEluY2lkZW50c1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEluY2lkZW50cyhpbmNpZGVudHMpIHtcbiAgICAgICAgLy8gZmlyc3QgY2hlY2sgdGhlIEluY2lkZW50cyBhZGRpdGlvbiBkaXJlY3RseSB1c2luZyB0aGUgY2hlY2tBZGRpdGlvbiBtZXRob2Qgb2YgdGhlIGNsYXNzXG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNoZWNrQWRkaXRpb24oaW5jaWRlbnRzKTtcblxuICAgICAgICBpZiAocmVzdWx0LnJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdWx0OiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yczogcmVzdWx0LmVycm9yc1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc3VsdDogdHJ1ZSxcbiAgICAgICAgICBleGVjdXRlOiByZXN1bHQuZXhlY3V0ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgICAqIEl0IGluaXRpYWxseSBjaGVja3MgaWYgdGhlIGVkaXQgaXMgYWxsb3dlZCBhbmQgaWYgaXQgaXMgaXQgcmV0dW5zIGFuIGFycmF5IG9mIGV4ZWN1dGFibGUgZnVuY3Rpb25zXG4gICAgICAgICAqIHRoYXQgYXBwbHkgdGhlIGNoYW5nZVxuICAgICAgICAgKiBAcGFyYW0ge2FycmF5fSBpbmNpZGVudHMgLSB0aGUgbGlzdCBvZiB0aGUgaW5jaWRlbnRzIHRvIGVkaXQgaW4gYW4gYXJyYXkgZm9ybWF0IFtvYmplY3QsIG9iamVjdCwgLi4uXVxuICAgICAgICAgKiBAcGFyYW0ge2ludH0gbWlsbGlzZWNvbmRzRGVsdGEgLSB0aGUgbWlsbGlzZWNvbmRzIGRlbHRhIHRvIGFwcGx5IHRvIHRoZSBpbmNpZGVudHNcbiAgICAgICAgICogQHJldHVybnMge29iamVjdH0gLVxuICAgICAgICAgKiBlaXRoZXI6XG4gICAgICAgICB7XG4gICAgICAgICAgICByZXN1bHQ6IHRydWUsXG4gICAgICAgICAgICBleGVjdXRlOiAvLyBhcnJheSBvZiBmdW5jdGlvbnMgdG8gYmUgZXhlY3V0ZWQgaW4gb3JkZXIgdG8gYXBwbHkgdGhlIGVkaXRcbiAgICAgICAgIH1cbiAgICAgICAgIG9yXG4gICAgICAgICB7XG4gICAgICAgICAgICAgcmVzdWx0OiBmYWxzZSxcbiAgICAgICAgICAgICBlcnJvcnM6IC8vIGFuIGFycmF5IGluY2x1ZGluZyBhbGwgdGhlIGVycm9ycyAvIGNvbmZsaWN0cyBmb3VuZCBvbiBlZGl0XG4gICAgICAgICB9XG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZWRpdEluY2lkZW50c1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVkaXRJbmNpZGVudHMoaW5jaWRlbnRzLCBtaWxsaXNlY29uZHNEZWx0YSkge1xuICAgICAgICAvLyBmaXJzdCBjaGVjayB0aGUgSW5jaWRlbnRzIGFkZGl0aW9uIGRpcmVjdGx5IHVzaW5nIHRoZSBjaGVja0FkZGl0aW9uIG1ldGhvZCBvZiB0aGUgY2xhc3NcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY2hlY2tFZGl0KGluY2lkZW50cywgbWlsbGlzZWNvbmRzRGVsdGEpO1xuXG4gICAgICAgIGlmIChyZXN1bHQucmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3JzOiByZXN1bHQuZXJyb3JzXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzdWx0OiB0cnVlLFxuICAgICAgICAgIGV4ZWN1dGU6IHJlc3VsdC5leGVjdXRlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIHRvIHJlbW92ZSBpbmNpZGVudHNcbiAgICAgICAgICogQHBhcmFtIHthcnJheX0gaW5jaWRlbnRzIC0gdGhlIGlkcyBvZiB0aGUgaW5jaWRlbnRzIHRvIHJlbW92ZSBpbiBhbiBhcnJheSBmb3JtYXRcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gICAgICAgICAqIEByZXR1bnMge29iamVjdH0gLVxuICAgICAgICAgKiBlaXRoZXI6XG4gICAgICAgICB7XG4gICAgICAgICAgICByZXN1bHQ6IHRydWUsXG4gICAgICAgICAgICBleGVjdXRlOiAvLyBhcnJheSBvZiBmdW5jdGlvbnMgdG8gYmUgZXhlY3V0ZWQgaW4gb3JkZXIgdG8gYXBwbHkgdGhlIGVkaXRcbiAgICAgICAgIH1cbiAgICAgICAgIG9yXG4gICAgICAgICB7XG4gICAgICAgICAgICAgcmVzdWx0OiBmYWxzZSxcbiAgICAgICAgICAgICBlcnJvcnM6IC8vIGFuIGFycmF5IGluY2x1ZGluZyBhbGwgdGhlIGVycm9ycyAvIGNvbmZsaWN0cyBmb3VuZCBvbiBlZGl0XG4gICAgICAgICB9XG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicmVtb3ZlSW5jaWRlbnRzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlSW5jaWRlbnRzKGluY2lkZW50cykge1xuICAgICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgICAvLyBmaXJzdCBjaGVjayB0aGUgSW5jaWRlbnRzIGFkZGl0aW9uIGRpcmVjdGx5IHVzaW5nIHRoZSBjaGVja0FkZGl0aW9uIG1ldGhvZCBvZiB0aGUgY2xhc3NcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY2hlY2tEZWxldGUoaW5jaWRlbnRzLCBwcm9wcyk7XG5cbiAgICAgICAgaWYgKHJlc3VsdC5yZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcnM6IHJlc3VsdC5lcnJvcnNcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXN1bHQ6IHRydWUsXG4gICAgICAgICAgZXhlY3V0ZTogcmVzdWx0LmV4ZWN1dGVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBtZXRob2QgaXMgaW52b2tlZCB3aGVuZXZlciBhIENBU0kgKHRoZSBvd25lciBvZiB0aGUgQ2hhbm5lbCkgZW50ZXJzXG4gICAgICAgKiB0aGUgdHJlZSBvZiBhbm90aGVyIGNsaXAsIHNvIHRoZSBzY3JhdGNoIHZhbHVlcyBvZiBhbGwgZmlyc3QgSW5jaWRlbnRzIG9mXG4gICAgICAgKiBlYWNoIGNoYW5uZWwgc2hvdWxkIGJlIHJlY2FsY3VsYXRlZCBiYXNlZCBvbiB0aGUgY29udGV4dC4gQWxsIENoYW5uZWxzXG4gICAgICAgKiB0aGF0IGV4dGVuZCBDaGFubmVsIGNhbiByZXdyaXRlIHRoaXMgbWV0aG9kIGFjY29yZGluZ2x5XG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGV4dElkIC0gVGhlIGlkIG9mIHRoZSBjb250ZXh0IG9mIHRoZSBDbGlwIENvcHkgYWNjb3JkaW5nIHRvIHdoaWNoXG4gICAgICAgKiAgICAgIHdlIGFyZSBnb2luZyB0byByZWNhbGMgdGhlIHNjcmF0Y2ggdmFsdWVzXG4gICAgICAgKiAqL1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicmVjYWxjU2NyYXRjaFZhbHVlc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlY2FsY1NjcmF0Y2hWYWx1ZXMoY29udGV4dElkKSB7fVxuICAgICAgLyoqXG4gICAgICAgICAqIE9uIHRoaXMgbWV0aG9kIHRoZSB1c2VyIGRlZmluZXMgdGhlIHNwZWNpZmljIHJ1bGVzIHRoYXQgYXBwbHkgb24gdGhlIHBsdWdpbiBpdHNlbGYgYW5kIG9uIHRoZSBJbmNpZGVudHMgb2YgdGhlIHBsdWdpbiBpdHNlbGZcbiAgICAgICAgICogVGhlIG1ldGhvZCBzaG91bGQgZWl0aGVyIHJldHVybiB7cmVzdWx0OiB0cnVlfSBvciB7cmVzdWx0OiBmYWxzZSwgZXJyb3JzOlt7ZXJyb3Itb2JqZWN0fV19LCB3aGVyZSBlcnJvci1vYmplY3QgaGFzIHRoZSBzdHJ1Y3R1cmU6XG4gICAgICAgICAqICB7XG4gICAgICAgICAgICAgICAgaW5jaWRlbnQ6IC8vIHJlZmVyZW5jZSB0byB0aGUgSW5jaWRlbnQgb2JqZWN0IHRoYXQgaGFzIGJlZSBkaXNjYXJkZWRcbiAgICAgICAgICAgICAgICBlcnJvcjogLy8gdGV4dFxuICAgICAgICAgICAgfVxuICAgICAgICAqIEBwYXJhbSB7YXJyYXl9IGluY2lkZW50cyAtIGEgY29sbGVjaXRvbiBvZiBhbGwgaW5jaWRlbnRzIHRvIGJlIGFkZGVkIG9uIHRoZSBmb3JtOlxuICAgICAgICAqXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWRcbiAgICAgICAgICAgICAgICBtaWxsaXNlY29uZFxuICAgICAgICAgICAgICAgIGluY2lkZW50XG4gICAgICAgICAgICB9XG4gICAgICAgICogQHJldHVybnMge29iamVjdH0gLVxuICAgICAgICAqIGVpdGhlcjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXN1bHQ6dHJ1ZSxcbiAgICAgICAgICAgICAgICBleGVjdXRlOiAvLyBhIGZ1bmN0aW9uIHRoYXQgd2hlbiBleGVjdXRlZCBpdCB3aWxsIGFkZCB0aGUgSW5jaWRlbnRzIG9uIHRoZSBDaGFubmVsc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3JcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXN1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yc1xuICAgICAgICAgICAgfVxuICAgICAgICAqL1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY2hlY2tBZGRpdGlvblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrQWRkaXRpb24oaW5jaWRlbnRzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzdWx0OiB0cnVlLFxuICAgICAgICAgIGV4ZWN1dGU6IGZ1bmN0aW9uIGV4ZWN1dGUoKSB7fVxuICAgICAgICB9O1xuICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjaGVja0VkaXRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0VkaXQoaW5jaWRlbnRzQXJyYXksIG1pbGxpc2Vjb25kc0RlbHRhKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzdWx0OiB0cnVlLFxuICAgICAgICAgIGV4ZWN1dGU6IGZ1bmN0aW9uIGV4ZWN1dGUoKSB7fVxuICAgICAgICB9O1xuICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjaGVja0RlbGV0ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrRGVsZXRlKGluY2lkZW50SWRzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzdWx0OiB0cnVlLFxuICAgICAgICAgIGV4ZWN1dGU6IGZ1bmN0aW9uIGV4ZWN1dGUoKSB7fVxuICAgICAgICB9O1xuICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjaGVja1Jlc2l6ZWRJbmNpZGVudHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja1Jlc2l6ZWRJbmNpZGVudHMoaW5jaWRlbnRzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzdWx0OiB0cnVlLFxuICAgICAgICAgIGV4ZWN1dGU6IGZ1bmN0aW9uIGV4ZWN1dGUoKSB7fVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJtb3ZlVG9cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlVG8oZnJvbSwgdG8sIGNvbnRleHRJZCkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gICAgfV0sIFt7XG4gICAgICBrZXk6IFwidHlwZVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiAncGxhaW4nO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBDaGFubmVsO1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIHRoaXMgbWV0aG9kIGFjdHMgYXMgYSBwcm94eSB0byBkdXJhdGlvbiBzZXR0ZXIgYnkgdGFraW5nIGEgZnJhY3Rpb24gYW5kIG5vdFxuICAgKiBhbiBhYnNvbHV0ZSBudW1iZXIgZm9yIHRoZSBvdmVyYWxsIGR1cmF0aW9uIG9mIHRoZSBMZWFmXG4gICAqICovXG4gIGZ1bmN0aW9uIHN5c3RvbGVEaWFzdG9sZShwYXlsb2FkKSB7XG4gICAgcGF5bG9hZC5kZXNjcmlwdG9yLnZhbHVlID0gZnVuY3Rpb24gc3lzdG9sZURpYXN0b2xlRnVuY3QoZHVyYXRpb25GcmFjdGlvbikge1xuICAgICAgdGhpcy5kdXJhdGlvbiA9IHRoaXMuZHVyYXRpb24gKiBkdXJhdGlvbkZyYWN0aW9uO1xuICAgIH07XG4gIH1cblxuICB2YXIgX0RJUkVDVElPTlMgPSB7XG4gICAgX1VQOiAndXAnLFxuICAgIF9ET1dOOiAnZG93bidcbiAgfTtcbiAgdmFyIF9CWVBBU1MgPSAnbmF0aXZlLnRyZWUuYnlwYXNzJztcblxuICB2YXIgTGVhZiA9IF9kZWNvcmF0ZShudWxsLCBmdW5jdGlvbiAoX2luaXRpYWxpemUpIHtcbiAgICB2YXIgTGVhZiA9IGZ1bmN0aW9uIExlYWYoKSB7XG4gICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGVhZik7XG5cbiAgICAgIF9pbml0aWFsaXplKHRoaXMpO1xuXG4gICAgICAvLyBwYXJlbnROb2RlIGlzIGEgcmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgTm9kZSB0aGUgTGVhZiBpcyBhdHRhY2hlZCB0byAoaWYgYW55KVxuICAgICAgdGhpcy5wYXJlbnROb2RlID0gbnVsbDtcbiAgICAgIHRoaXMuaXNOb2RlID0gZmFsc2U7XG5cbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvcHMsICdpZCcpKSB7XG4gICAgICAgIHRoaXMuaWQgPSBwcm9wcy5pZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaWQgPSBnZXRBbklkKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIEY6IExlYWYsXG4gICAgICBkOiBbe1xuICAgICAgICBraW5kOiBcImdldFwiLFxuICAgICAgICBrZXk6IFwiZGVsYXlcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGF5KCkge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5wcm9wcywgJ2RlbGF5JykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLmRlbGF5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwic2V0XCIsXG4gICAgICAgIGtleTogXCJkZWxheVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVsYXkodmFsKSB7XG4gICAgICAgICAgaWYgKHZhbCAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5kZWxheSA9IHZhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJnZXRcIixcbiAgICAgICAga2V5OiBcImhpYXR1c1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGlhdHVzKCkge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5wcm9wcywgJ2hpYXR1cycpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5oaWF0dXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJzZXRcIixcbiAgICAgICAga2V5OiBcImhpYXR1c1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGlhdHVzKHZhbCkge1xuICAgICAgICAgIGlmICh2YWwgIT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMuaGlhdHVzID0gdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBraW5kOiBcImdldFwiLFxuICAgICAgICBrZXk6IFwicmVwZWF0c1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVwZWF0cygpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMucHJvcHMsICdyZXBlYXRzJykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLnJlcGVhdHM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJzZXRcIixcbiAgICAgICAga2V5OiBcInJlcGVhdHNcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlcGVhdHModmFsKSB7XG4gICAgICAgICAgdGhpcy5wcm9wcy5yZXBlYXRzID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0aGUgZnVsbCBkdXJhdGlvbiBvZiB0aGUgTGVhZiB0YWtpbmcgaW4gY29uc2lkZXJhdGlvbiBhbGw6IGRlbGF5LCBkdXJhdGlvbiwgaGlhdHVzIGFuZFxuICAgICAgICAgKiByZXBlYXRzIGZhY3RvclxuICAgICAgICAgKiAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwiZ2V0XCIsXG4gICAgICAgIGtleTogXCJkdXJhdGlvblwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZHVyYXRpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVwZWF0cyAqICh0aGlzLmRlbGF5ICsgdGhpcy5wcm9wcy5kdXJhdGlvbiArIHRoaXMuaGlhdHVzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogdGhlIHNldHRlciBzZXRzIHRoZSBvdmVyYWxsIGR1cmF0aW9uIG9mIHRoZSBMZWFmIGJ5IGFsdGVyaW5nIGFsbFxuICAgICAgICAgKiBkZWxheSwgZHVyYXRpb24gYW5kIGhpYXR1cyBwcm9wZXJ0aWVzIG9mIGl0XG4gICAgICAgICAqICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJzZXRcIixcbiAgICAgICAga2V5OiBcImR1cmF0aW9uXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkdXJhdGlvbihtaWxsaXNlY29uZHMpIHtcbiAgICAgICAgICB2YXIgZnJhY3Rpb24gPSBtaWxsaXNlY29uZHMgLyB0aGlzLmR1cmF0aW9uO1xuICAgICAgICAgIHRoaXMucHJvcHMuZHVyYXRpb24gKj0gZnJhY3Rpb247XG4gICAgICAgICAgdGhpcy5oaWF0dXMgKj0gZnJhY3Rpb247XG4gICAgICAgICAgdGhpcy5kZWxheSAqPSBmcmFjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogc2V0TmV3RHVyYXRpb24gbWV0aG9kIHNldHMgdGhlIG5ldyBGVUxMIGR1cmF0aW9uIGFzIGl0IGRlcml2ZXMgZnJvbSB0aGVcbiAgICAgICAgICogZGVsYXksIGR1cmF0aW9uLCBoaWF0dXMgYW5kIHJlcGVhdHMgZmFjdG9yc1xuICAgICAgICAgKiAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICAgIGtleTogXCJzZXROZXdEdXJhdGlvblwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TmV3RHVyYXRpb24obmV3RHVyYXRpb24pIHtcbiAgICAgICAgICB0aGlzLmR1cmF0aW9uID0gbmV3RHVyYXRpb247XG4gICAgICAgICAgdGhpcy5wdXRNZXNzYWdlT25QaXBlKCdyZWNhbGNEdXJhdGlvbicsIHt9LCAnR3JvdXBzJywge1xuICAgICAgICAgICAgc2VsZkV4ZWN1dGU6IGZhbHNlLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBfRElSRUNUSU9OUy5fVVBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAgICBkZWNvcmF0b3JzOiBbc3lzdG9sZURpYXN0b2xlXSxcbiAgICAgICAga2V5OiBcInN5c3RvbGVEaWFzdG9sZVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc3lzdG9sZURpYXN0b2xlKCkge31cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJnZXRcIixcbiAgICAgICAga2V5OiBcImhhc1BhcmVudFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFzUGFyZW50KCkge1xuICAgICAgICAgIGlmICh0aGlzLnBhcmVudE5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAgICBrZXk6IFwiYXR0YWNoVG9Ob2RlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRhY2hUb05vZGUobm9kZSkge1xuICAgICAgICAgIHRoaXMucGFyZW50Tm9kZSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgICAga2V5OiBcImRldGFjaEZyb21QYXJlbnRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRldGFjaEZyb21QYXJlbnQoKSB7XG4gICAgICAgICAgdGhpcy5wYXJlbnROb2RlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgbWVzc2FnZVxuICAgICAgICBAcGFyYW0ge29iamVjdH0gcGF5bG9hZCAtIHRoZSBwYXlsb2FkIG9mIHRoZSBtZXNzYWdlXG4gICAgICAgIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgLSBzcGVjaWZpZXMgdGhlIHRhcmdldCBvZiB0aGUgbWVzc2FnZSBpbiBhIGtleS12YWx1ZSBwYWlycyBvYmplY3RcbiAgICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBpbiB0aGUgZm9ybTpcbiAgICAgICAge1xuICAgICAgICAgICAgZGlyZWN0aW9uIChlaXRoZXIgX1VQIG9yIF9ET1dOKVxuICAgICAgICAgICAgc2VsZkV4ZWN1dGUgKGVpdGhlciB0cnVlIHdoaWNoIG1lYW5zIHRoZSBMZWFmIHNob3VsZCB0cnkgdG8gaGFuZGxlIHRoZSBtZXNzYWdlIGl0c2VsZiBvclxuICAgICAgICAgICAgICAgIGZhbHNlIHdoaWNoIG1lYW5zIHRoZSBMZWFmIHNob3VsZCBkaXJlY3RseSBmb3J3YXJkIHRoZSBtZXNzYWdlIHRvIGl0cyBwYXJlbnQpXG4gICAgICAgIH1cbiAgICAgICAgQHJldHVybnMgVGhlIGV4cGVjdGVkIHJlc3VsdCBvZiB0aGlzIG1ldGhvZCBpcyBvbiB0aGUgZm9ybTpcbiAgICAgICAge1xuICAgICAgICAgICAgcmVzcG9uc2U6IGFuIG9iamVjdCB0aGUgc3RydWN0dXJlIG9mIHdoaWNoIGRlcGVuZHMgb24gdGhlIG5hbWUgb2YgdGhlIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICBhbmQgbWF5YmUgZXZlbiBvbiB0aGUgcGF5bG9hZFxuICAgICAgICAgICAgcmVzcG9uZGVyOiBhIGRpcmVjdCByZWZlcmVuY2UgdG8gdGhlIGxlYWQgdGhhdCBhY3R1YWxseSByZXNwb25kZWRcbiAgICAgICAgICAgIChvbmx5IHZhbGlkIGZvciBkaXJlYWN0aW9uIF9ET1dOKSBwb3NpdGlvbkRlbHRhOiB0aGUgcG9zaXRpb24gZGVsdGEgb2YgdGhlIHJlc3BvbmRlciBjb21wYXJlZCB0byB0aGUgcmVxdWVzdGVyXG4gICAgICAgIH1cbiAgICAgICAgKiAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICAgIGtleTogXCJwdXRNZXNzYWdlT25QaXBlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwdXRNZXNzYWdlT25QaXBlKG5hbWUsIHBheWxvYWQsIHRhcmdldCkge1xuICAgICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcblxuICAgICAgICAgIC8vIGRlZmF1bHQgZGlyZWN0aW9uOiBfRE9XTlxuICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICdkaXJlY3Rpb24nKSkge1xuICAgICAgICAgICAgb3B0aW9ucy5kaXJlY3Rpb24gPSBfRElSRUNUSU9OUy5fRE9XTjtcbiAgICAgICAgICB9IC8vIGRlZmF1bHQgcG9zaXRpb25EZWx0YSA9IDBcblxuXG4gICAgICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0aW9uID09PSBfRElSRUNUSU9OUy5fRE9XTiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICdwb3NpdGlvbkRlbHRhJykpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucG9zaXRpb25EZWx0YSA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG9wdGlvbnMuc2VsZkV4ZWN1dGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBMZWFmIGhhcyBhIFwiaGFuZGxlPG5hbWU+XCIgbWV0aG9kIHdpdGggdGhlIGZpcnN0IGxldHRlciBvZlxuICAgICAgICAgICAgLy8gbmFtZSBpbiBDYXBpdGFsIGl0IHJ1bnMgaXRcbiAgICAgICAgICAgIHZhciBoYW5kbGluZ01ldGhvZE5hbWUgPSBcImhhbmRsZVwiLmNvbmNhdChqc1VjZmlyc3QobmFtZSkpO1xuICAgICAgICAgICAgdmFyIGNhcGFibGUgPSB0eXBlb2YgdGhpc1toYW5kbGluZ01ldGhvZE5hbWVdID09PSAnZnVuY3Rpb24nO1xuXG4gICAgICAgICAgICBpZiAoY2FwYWJsZSkge1xuICAgICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSB0aGlzW2hhbmRsaW5nTWV0aG9kTmFtZV0odGFyZ2V0LCBwYXlsb2FkKTtcblxuICAgICAgICAgICAgICBpZiAocmVzcG9uc2UgIT09IF9CWVBBU1MpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgcmVzcG9uZGVyOiB0aGlzXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRpcmVjdGlvbiA9PT0gX0RJUkVDVElPTlMuX1VQKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBbX29iamVjdFNwcmVhZDIoe30sIHJlc3VsdCwge1xuICAgICAgICAgICAgICAgICAgcG9zaXRpb25EZWx0YTogb3B0aW9ucy5wb3NpdGlvbkRlbHRhXG4gICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0aW9uID09PSBfRElSRUNUSU9OUy5fVVApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc1BhcmVudCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnROb2RlLnB1dE1lc3NhZ2VPblBpcGUobmFtZSwgcGF5bG9hZCwgdGFyZ2V0LCB7XG4gICAgICAgICAgICAgICAgc2VsZkV4ZWN1dGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBfRElSRUNUSU9OUy5fVVBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IC8vIGlmIHRoZSBtZXNzYWdlIHJlYWNoZXMgdGhlIHRvcCBvZiB0aGUgdHJlZSB3aXRob3V0IGZpbmRpbmcgYW55IGxpYWJsZSB0YXJnZXRcblxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICByZXNwb25zZTogZmFsc2UsXG4gICAgICAgICAgICAgIHJlc3BvbmRlcjogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IC8vIF9DT05TVC5fRElSRUNUSU9OUy5fRE9XTlxuXG5cbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgICAga2V5OiBcImJ5cGFzc1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYnlwYXNzKCkge1xuICAgICAgICAgIHJldHVybiBfQllQQVNTO1xuICAgICAgICB9IC8vIFBvc3Rpb24gb24gUHlyYW1pZGlvblxuICAgICAgICAvLyBcIlB5cmFtaWRpb25cIiBpcyB0aGUgdXBwZXJtb3N0IHBpZWNlIG9yIGNhcHN0b25lIG9mIGFuIEVneXB0aWFuIHB5cmFtaWQuXG4gICAgICAgIC8vIFRvIHVzIFwiUHlyYW1pZGlvblwiIGlzIHRoZSB0b3AgTm9kZSBvZiB0aGUgVHJlZSB0byB3aGljaCB0aGlzIExlYWYgYmVsb25ncyB0b1xuICAgICAgICAvLyBhbmQgdGhlIGZvbGxvd2luZyBpbmZyYXN0cnVjdHVyZSBpbXBsZW1lbnRzIGl0XG5cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJnZXRcIixcbiAgICAgICAga2V5OiBcInBvc2l0aW9uT25QeXJhbWlkaW9uXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwb3NpdGlvbk9uUHlyYW1pZGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRQb3NpdGlvbk9uUHlyYW1pZGlvbigpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICAgIGtleTogXCJnZXRQb3NpdGlvbk9uUHlyYW1pZGlvblwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9zaXRpb25PblB5cmFtaWRpb24oKSB7XG4gICAgICAgICAgdmFyIGRlbHRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuXG4gICAgICAgICAgaWYgKCF0aGlzLmhhc1BhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlbHRhO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5wdXRNZXNzYWdlT25QaXBlKCdnZXRQb3NpdGlvbk9uUHlyYW1pZGlvbicsIHtcbiAgICAgICAgICAgICAgZGVsdGE6IGRlbHRhLFxuICAgICAgICAgICAgICBpZDogdGhpcy5pZFxuICAgICAgICAgICAgfSwgJ1BhcmVudCcsIHtcbiAgICAgICAgICAgICAgc2VsZkV4ZWN1dGU6IGZhbHNlLFxuICAgICAgICAgICAgICBkaXJlY3Rpb246IF9ESVJFQ1RJT05TLl9VUFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlc3BvbnNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfV1cbiAgICB9O1xuICB9KTtcblxuICB2YXIgX0xFQUZBTFJFQURZQVNTSUdORUQgPSAnTGVhZiBoYXMgYWxyZWFkeSBiZWVuIGF0dGFjaGVkIHRvIGFub3RoZXIgTm9kZSc7XG4gIHZhciBfTkVHQVRJVkVQT1NJVElPTk5PVEFMTE9XRUQgPSAnTmVnYXRpdmUgcG9zaXRpb25pbmcgb2YgY2hpbGRzIG9uIG5vZGVzIGlzIG5vdCBhbGxvd2VkJztcbiAgdmFyIF9MRUFGTk9URk9VTkQgPSBcIlRoZSBMZWFmIHdpdGggdGhlIHJlcXVlc3RlZCBpZCBjb3VsZG4ndCBiZSBmb3VuZCBvbiB0aGUgVHJlZVwiO1xuXG4gIHZhciBOb2RlID0gX2RlY29yYXRlKG51bGwsIGZ1bmN0aW9uIChfaW5pdGlhbGl6ZSwgX0xlYWYpIHtcbiAgICB2YXIgTm9kZSA9XG4gICAgLyojX19QVVJFX18qL1xuICAgIGZ1bmN0aW9uIChfTGVhZjIpIHtcbiAgICAgIF9pbmhlcml0cyhOb2RlLCBfTGVhZjIpO1xuXG4gICAgICBmdW5jdGlvbiBOb2RlKCkge1xuICAgICAgICB2YXIgX3RoaXM7XG5cbiAgICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9kZSk7XG5cbiAgICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoTm9kZSkuY2FsbCh0aGlzLCBwcm9wcykpO1xuXG4gICAgICAgIF9pbml0aWFsaXplKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgICAgICBfdGhpcy5pc05vZGUgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICAgICAgVGhlIG9iamVjdCBob2xkcyB0aGUgSW5jaWRlbnRzIG9mIHRoZSBTY2VuZSBvbiB0aGUgZm9ybWF0OlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICA8aWQ+OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZCAvLyB0aGUgaWQgb2YgdGhlIEluY2lkZW50IG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVhZiAvLyB0aGUgaW5jaWRlbnQgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiAvLyB0aGUgcG9zaXRpb24gb2YgdGhlIGluY2lkZW50XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgLi4uXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgX3RoaXMuY2hpbGRyZW4gPSB7fTtcbiAgICAgICAgX3RoaXMuY2FsY3VsYXRlZER1cmF0aW9uID0gMDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gTm9kZTtcbiAgICB9KF9MZWFmKTtcblxuICAgIHJldHVybiB7XG4gICAgICBGOiBOb2RlLFxuICAgICAgZDogW3tcbiAgICAgICAga2luZDogXCJnZXRcIixcbiAgICAgICAga2V5OiBcImR1cmF0aW9uXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkdXJhdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jYWxjdWxhdGVkRHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJzZXRcIixcbiAgICAgICAga2V5OiBcImR1cmF0aW9uXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkdXJhdGlvbihuZXdEdXJhdGlvbikge1xuICAgICAgICAgIHZhciBkdXJhdGlvbkZyYWN0aW9uID0gbmV3RHVyYXRpb24gLyB0aGlzLmR1cmF0aW9uO1xuXG4gICAgICAgICAgaWYgKHRoaXMucHJvcHMpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5wcm9wcywgJ2R1cmF0aW9uJykpIHtcbiAgICAgICAgICAgICAgdGhpcy5wcm9wcy5kdXJhdGlvbiA9IG5ld0R1cmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuY2FsY3VsYXRlZER1cmF0aW9uID0gbmV3RHVyYXRpb247XG5cbiAgICAgICAgICBmb3IgKHZhciBjaGlsZEtleSBpbiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2NoaWxkS2V5XTtcbiAgICAgICAgICAgIHRoaXMuZWRpdFBvc2l0aW9uKGNoaWxkLmlkLCBjaGlsZC5wb3NpdGlvbiAqIGR1cmF0aW9uRnJhY3Rpb24sIHRydWUpO1xuICAgICAgICAgICAgY2hpbGQubGVhZi5zeXN0b2xlRGlhc3RvbGUoZHVyYXRpb25GcmFjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICAgIGtleTogXCJzZXROZXdEdXJhdGlvblwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TmV3RHVyYXRpb24obmV3RHVyYXRpb24pIHtcbiAgICAgICAgICB0aGlzLmR1cmF0aW9uID0gbmV3RHVyYXRpb247XG4gICAgICAgICAgdGhpcy5wdXRNZXNzYWdlT25QaXBlKCdyZWNhbGNEdXJhdGlvbicsIHt9LCAnR3JvdXBzJywge1xuICAgICAgICAgICAgc2VsZkV4ZWN1dGU6IGZhbHNlLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBfRElSRUNUSU9OUy5fVVBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAgICBrZXk6IFwiX2NhbGN1bGF0ZUR1cmF0aW9uXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FsY3VsYXRlRHVyYXRpb24oKSB7XG4gICAgICAgICAgdmFyIGR1cmF0aW9uID0gMDtcblxuICAgICAgICAgIGZvciAodmFyIGNoaWxkS2V5IGluIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5bY2hpbGRLZXldO1xuXG4gICAgICAgICAgICBpZiAoY2hpbGQucG9zaXRpb24gKyBjaGlsZC5sZWFmLmR1cmF0aW9uID4gZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgZHVyYXRpb24gPSBjaGlsZC5wb3NpdGlvbiArIGNoaWxkLmxlYWYuZHVyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGR1cmF0aW9uID09PSB0aGlzLmNhbGN1bGF0ZWREdXJhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLnByb3BzKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMucHJvcHMsICdkdXJhdGlvbicpKSB7XG4gICAgICAgICAgICAgIHRoaXMucHJvcHMuZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmNhbGN1bGF0ZWREdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICAgIGRlY29yYXRvcnM6IFtzeXN0b2xlRGlhc3RvbGVdLFxuICAgICAgICBrZXk6IFwic3lzdG9sZURpYXN0b2xlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzeXN0b2xlRGlhc3RvbGUoKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAgICAgfSwge1xuICAgICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAgICBrZXk6IFwiaGFuZGxlUmVjYWxjRHVyYXRpb25cIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVJlY2FsY0R1cmF0aW9uKHRhcmdldCwgcGF5bG9hZCkge1xuICAgICAgICAgIGlmICh0aGlzLl9jYWxjdWxhdGVEdXJhdGlvbigpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXRNZXNzYWdlT25QaXBlKCdyZWNhbGNEdXJhdGlvbicsIHt9LCAnR3JvdXBzJywge1xuICAgICAgICAgICAgICBzZWxmRXhlY3V0ZTogZmFsc2UsXG4gICAgICAgICAgICAgIGRpcmVjdGlvbjogX0RJUkVDVElPTlMuX1VQXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAgICBrZXk6IFwiZ2V0TGVhZkJ5SWRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldExlYWZCeUlkKGlkKSB7XG4gICAgICAgICAgdmFyIG9ubHlEaXJlY3RDaGlsZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuY2hpbGRyZW4sIGlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5baWRdLmxlYWY7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG9ubHlEaXJlY3RDaGlsZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGNoaWxkIGluIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgdmFyIGNoaWxkTGVhZiA9IHRoaXMuY2hpbGRyZW5bY2hpbGRdLmxlYWY7XG5cbiAgICAgICAgICAgICAgaWYgKGNoaWxkTGVhZi5pc05vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVhZiA9IGNoaWxkTGVhZi5nZXRMZWFmQnlJZChpZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAobGVhZiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbGVhZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgICAga2V5OiBcImdldExlYWZQb3NpdGlvblwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGVhZlBvc2l0aW9uKGlkKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmNoaWxkcmVuLCBpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW2lkXS5wb3NpdGlvbjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmVzID0gdGhpcy5wdXRNZXNzYWdlT25QaXBlKCdnZXRMZWFmUG9zaXRpb24nLCB7XG4gICAgICAgICAgICBpZDogaWRcbiAgICAgICAgICB9LCAnR3JvdXBzJywge1xuICAgICAgICAgICAgc2VsZkV4ZWN1dGU6IGZhbHNlLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBfRElSRUNUSU9OUy5fRE9XTlxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHJlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzWzBdLnBvc2l0aW9uRGVsdGEgKyByZXNbMF0ucmVzcG9uc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICAgIGtleTogXCJoYW5kbGVHZXRMZWFmUG9zaXRpb25cIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUdldExlYWZQb3NpdGlvbih0YXJnZXQsIHBheWxvYWQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMZWFmUG9zaXRpb24ocGF5bG9hZC5pZCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgICAga2V5OiBcImNoZWNrQWRkaXRpb25cIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrQWRkaXRpb24obGVhZiwgcG9zaXRpb24pIHtcbiAgICAgICAgICBpZiAobGVhZi5oYXNQYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAgICAgIHJlYXNvbjogX0xFQUZBTFJFQURZQVNTSUdORURcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgcmVzdWx0OiBmYWxzZSxcbiAgICAgICAgICAgICAgcmVhc29uOiBfTkVHQVRJVkVQT1NJVElPTk5PVEFMTE9XRURcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3VsdDogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgICAga2V5OiBcImFkZENoaWxkXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRDaGlsZChsZWFmLCBwb3NpdGlvbikge1xuICAgICAgICAgIC8vIHRoaXMgaGFzUGFyZW50IGNoZWNrIG9jY3VycyBoZXJlIGFzIGFuIGV4dHJhIHNlY3VyaXR5IGNoZWNrIHNvIGl0XG4gICAgICAgICAgLy8gZ2V0cyBleGVjdXRlZCByZWdhcmRsZXNzIGlmIHRoZSB1c2VyIHdhbnRzIHRvIHBlcmZvcm0gY2hlY2tzIG9yIG5vdFxuICAgICAgICAgIGlmIChsZWFmLmhhc1BhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgcmVzdWx0OiBmYWxzZSxcbiAgICAgICAgICAgICAgcmVhc29uOiBfTEVBRkFMUkVBRFlBU1NJR05FRFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmNoaWxkcmVuW2xlYWYuaWRdID0ge1xuICAgICAgICAgICAgaWQ6IGxlYWYuaWQsXG4gICAgICAgICAgICBsZWFmOiBsZWFmLFxuICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uXG4gICAgICAgICAgfTtcbiAgICAgICAgICBsZWFmLmF0dGFjaFRvTm9kZSh0aGlzKTtcbiAgICAgICAgICB0aGlzLnB1dE1lc3NhZ2VPblBpcGUoJ3JlY2FsY0R1cmF0aW9uJywge30sICdHcm91cHMnLCB7XG4gICAgICAgICAgICBzZWxmRXhlY3V0ZTogdHJ1ZSxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogX0RJUkVDVElPTlMuX1VQXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3VsdDogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgICAga2V5OiBcImNoZWNrUmVtb3ZlQ2hpbGRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrUmVtb3ZlQ2hpbGQoaWQpIHtcbiAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmNoaWxkcmVuLCBpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAgICAgIHJlYXNvbjogX0xFQUZOT1RGT1VORFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdWx0OiB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAgICBrZXk6IFwicmVtb3ZlQ2hpbGRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUNoaWxkKGlkKSB7XG4gICAgICAgICAgdGhpcy5jaGlsZHJlbltpZF0ubGVhZi5kZXRhY2hGcm9tUGFyZW50KCk7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuY2hpbGRyZW5baWRdO1xuICAgICAgICAgIHRoaXMucHV0TWVzc2FnZU9uUGlwZSgncmVjYWxjRHVyYXRpb24nLCB7fSwgJ0dyb3VwcycsIHtcbiAgICAgICAgICAgIHNlbGZFeGVjdXRlOiB0cnVlLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBfRElSRUNUSU9OUy5fVVBcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdWx0OiB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAgICBrZXk6IFwiY2hlY2tFZGl0UG9zaXRpb25cIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrRWRpdFBvc2l0aW9uKGlkLCBwb3NpdGlvbikge1xuICAgICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAgICAgIHJlYXNvbjogX05FR0FUSVZFUE9TSVRJT05OT1RBTExPV0VEXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuY2hpbGRyZW4sIGlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgcmVzdWx0OiBmYWxzZSxcbiAgICAgICAgICAgICAgcmVhc29uOiBfTEVBRk5PVEZPVU5EXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN1bHQ6IHRydWVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICAgIGtleTogXCJlZGl0UG9zaXRpb25cIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVkaXRQb3NpdGlvbihpZCwgcG9zaXRpb24pIHtcbiAgICAgICAgICB2YXIgYnlwYXNzUmVjYWxjRHVyYXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmNoaWxkcmVuLCBpZCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baWRdLnBvc2l0aW9uID0gcG9zaXRpb247XG5cbiAgICAgICAgICAgIGlmIChieXBhc3NSZWNhbGNEdXJhdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgdGhpcy5wdXRNZXNzYWdlT25QaXBlKCdyZWNhbGNEdXJhdGlvbicsIHt9LCAnR3JvdXBzJywge1xuICAgICAgICAgICAgICAgIHNlbGZFeGVjdXRlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogX0RJUkVDVElPTlMuX1VQXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICByZXN1bHQ6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgIFRoZSBleHBlY3RlZCByZXN1bHQgb2YgdGhpcyBtZXRob2QgZGVwZW5kcyBvbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBtZXNzYWdlXG4gICAgICAgICAgVGhlIGRpcmVjdGlvbiBtaWdodCBlaXRoZXIgYmUgX1VQIG9yIF9ET1dOLlxuICAgICAgICAgIEluIHRoZSBjYXNlIG9mIF9VUCB0aGUgZXhwZWN0ZWQgcmVzdWx0IGlzIGlkZW50aWNhbCBhcyBvbiBMZWFmOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcmVzcG9uc2U6IGFuIG9iamVjdCB0aGUgc3RydWN0dXJlIG9mIHdoaWNoIGRlcGVuZHMgb24gdGhlIG5hbWUgb2YgdGhlIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgIGFuZCBtYXliZSBldmVuIG9uIHRoZSBwYXlsb2FkXG4gICAgICAgICAgICAgIHJlc3BvbmRlcjogYSBkaXJlY3QgcmVmZXJlbmNlIHRvIHRoZSBsZWFkIHRoYXQgYWN0dWFsbHkgcmVzcG9uZGVkXG4gICAgICAgICAgfVxuICAgICAgICAgIEluIHRoZSBjYXNlIG9mIF9ET1dOIHRob3VnaCwgd2hlcmUgbXVsdGlwbGUgTGVhZnMgbWlnaHQgYmUgZWxpZ2libGUgaW4gdGhlIHRyZWVcbiAgICAgICAgICBmb3IgaGFuZGxpbmcgdGhlIG1lc3NhZ2UgdGhlIHJlc3VsdCBpcyBvbiB0aGUgZm9ybTpcbiAgICAgICAgICBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiBhbiBvYmplY3QgdGhlIHN0cnVjdHVyZSBvZiB3aGljaCBkZXBlbmRzIG9uIHRoZSBuYW1lIG9mIHRoZSBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgYW5kIG1heWJlIGV2ZW4gb24gdGhlIHBheWxvYWRcbiAgICAgICAgICAgICAgICAgIHJlc3BvbmRlcjogYSBkaXJlY3QgcmVmZXJlbmNlIHRvIHRoZSBsZWFkIHRoYXQgYWN0dWFsbHkgcmVzcG9uZGVkXG4gICAgICAgICAgICAgICAgICBwb3NpdGlvbkRlbHRhOiB0aGUgcG9zaXRpb24gZGVsdGEgb2YgdGhlIHJlc3BvbmRlciBjb21wYXJlZCB0byB0aGUgcmVxdWVzdGVyXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICBdXG4gICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAgICBrZXk6IFwicHV0TWVzc2FnZU9uUGlwZVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcHV0TWVzc2FnZU9uUGlwZShuYW1lLCBwYXlsb2FkLCB0YXJnZXQpIHtcbiAgICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG5cbiAgICAgICAgICAvLyBkZWZhdWx0IGRpcmVjdGlvbjogX0RPV05cbiAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCAnZGlyZWN0aW9uJykpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZGlyZWN0aW9uID0gX0RJUkVDVElPTlMuX0RPV047XG4gICAgICAgICAgfSAvLyBkZWZhdWx0IHBvc2l0aW9uRGVsdGEgPSAwXG5cblxuICAgICAgICAgIGlmIChvcHRpb25zLmRpcmVjdGlvbiA9PT0gX0RJUkVDVElPTlMuX0RPV04gJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCAncG9zaXRpb25EZWx0YScpKSB7XG4gICAgICAgICAgICBvcHRpb25zLnBvc2l0aW9uRGVsdGEgPSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcHRpb25zLmRpcmVjdGlvbiA9PT0gX0RJUkVDVElPTlMuX1VQKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgZGlyZWN0aW9uIGlzIHVwXG4gICAgICAgICAgICByZXR1cm4gX2dldChfZ2V0UHJvdG90eXBlT2YoTm9kZS5wcm90b3R5cGUpLCBcInB1dE1lc3NhZ2VPblBpcGVcIiwgdGhpcykuY2FsbCh0aGlzLCBuYW1lLCBwYXlsb2FkLCB0YXJnZXQsIG9wdGlvbnMpOyAvLyBhY3QgZXhhY3RseSBhcyBhbnkgb3RoZXIgTGVhZlxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByZXN1bHQgPSBfZ2V0KF9nZXRQcm90b3R5cGVPZihOb2RlLnByb3RvdHlwZSksIFwicHV0TWVzc2FnZU9uUGlwZVwiLCB0aGlzKS5jYWxsKHRoaXMsIG5hbWUsIHBheWxvYWQsIHRhcmdldCwgb3B0aW9ucyk7XG5cbiAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgY2hpbGQgaW4gdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgdmFyIGxlYWYgPSB0aGlzLmNoaWxkcmVuW2NoaWxkXS5sZWFmO1xuXG4gICAgICAgICAgICB2YXIgbmV3T3B0aW9ucyA9IF9vYmplY3RTcHJlYWQyKHt9LCBvcHRpb25zLCB7XG4gICAgICAgICAgICAgIHNlbGZFeGVjdXRlOiB0cnVlLFxuICAgICAgICAgICAgICBwb3NpdGlvbkRlbHRhOiBvcHRpb25zLnBvc2l0aW9uRGVsdGEgKyB0aGlzLmNoaWxkcmVuW2NoaWxkXS5wb3NpdGlvblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQobGVhZi5wdXRNZXNzYWdlT25QaXBlKG5hbWUsIHBheWxvYWQsIHRhcmdldCwgbmV3T3B0aW9ucykpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgICAga2V5OiBcImhhbmRsZUdldFBvc2l0aW9uT25QeXJhbWlkaW9uXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVHZXRQb3NpdGlvbk9uUHlyYW1pZGlvbih0YXJnZXQsIHBheWxvYWQpIHtcbiAgICAgICAgICB2YXIgZGVsdGEgPSBwYXlsb2FkLmRlbHRhICsgdGhpcy5nZXRMZWFmUG9zaXRpb24ocGF5bG9hZC5pZCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UG9zaXRpb25PblB5cmFtaWRpb24oZGVsdGEpO1xuICAgICAgICB9XG4gICAgICB9XVxuICAgIH07XG4gIH0sIExlYWYpO1xuXG4gIGZ1bmN0aW9uIGJsb2NrKHBsZCkge1xuICAgIHBsZC5kZXNjcmlwdG9yLnZhbHVlID0gZnVuY3Rpb24gYmxvY2tmdW5jdChkZXNjcmlwdGlvbikge1xuICAgICAgaWYgKHRoaXMuYmxvY2tJRCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuYmxvY2tJRCA9IGdldEFuSWQoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5EZXNjcmlwdGl2ZUluY2lkZW50LnB1dE1lc3NhZ2VPblBpcGUoJ3NldEJsb2NrJywge1xuICAgICAgICBpZDogdGhpcy5ibG9ja0lELFxuICAgICAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24sXG4gICAgICAgIGluY2lkZW50SWQ6IHRoaXMuRGVzY3JpcHRpdmVJbmNpZGVudC5pZCxcbiAgICAgICAgcmVhbEluY2lkZW50SWQ6IHRoaXMuaWRcbiAgICAgIH0sICdyb290Q2xpcCcsIHtcbiAgICAgICAgc2VsZkV4ZWN1dGU6IHRydWUsXG4gICAgICAgIGRpcmVjdGlvbjogX0RJUkVDVElPTlMuX1VQXG4gICAgICB9KTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlUmVzaXplKHBsZCkge1xuICAgIHBsZC5kZXNjcmlwdG9yLnZhbHVlID0gZnVuY3Rpb24gaGFuZGxlUmVzaXplRnVuY3QodGFyZ2V0KSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICBpZiAodGhpcy5pZCA9PT0gdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ieXBhc3MoKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gdW5ibG9jayhwbGQpIHtcbiAgICBwbGQuZGVzY3JpcHRvci52YWx1ZSA9IGZ1bmN0aW9uIHVuYmxvY2tGdW5jdCgpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHRoaXMuRGVzY3JpcHRpdmVJbmNpZGVudC5wdXRNZXNzYWdlT25QaXBlKCd1bkJsb2NrJywge1xuICAgICAgICBpZDogdGhpcy5ibG9ja0lEXG4gICAgICB9LCAncm9vdENsaXAnLCB7XG4gICAgICAgIHNlbGZFeGVjdXRlOiB0cnVlLFxuICAgICAgICBkaXJlY3Rpb246IF9ESVJFQ1RJT05TLl9VUFxuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBHcm91cCA9IF9kZWNvcmF0ZShudWxsLCBmdW5jdGlvbiAoX2luaXRpYWxpemUsIF9Ob2RlKSB7XG4gICAgdmFyIEdyb3VwID1cbiAgICAvKiNfX1BVUkVfXyovXG4gICAgZnVuY3Rpb24gKF9Ob2RlMikge1xuICAgICAgX2luaGVyaXRzKEdyb3VwLCBfTm9kZTIpO1xuXG4gICAgICBmdW5jdGlvbiBHcm91cChhdHRycywgcHJvcHMpIHtcbiAgICAgICAgdmFyIF90aGlzO1xuXG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBHcm91cCk7XG5cbiAgICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoR3JvdXApLmNhbGwodGhpcywgcHJvcHMpKTtcblxuICAgICAgICBfaW5pdGlhbGl6ZShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICAgICAgX3RoaXMubWNfcGx1Z2luX25wbV9uYW1lID0gJ21vdG9yLWNvcnRleC1qcyc7XG4gICAgICAgIF90aGlzLnBsdWdpbl9jaGFubmVsX2NsYXNzID0gQ2hhbm5lbDtcbiAgICAgICAgX3RoaXMuaGFzSW5jaWRlbnRzID0gdHJ1ZTtcblxuICAgICAgICBfdGhpcy5vbkdyb3VwSW5pdGlhbGlzZSgpO1xuXG4gICAgICAgIF90aGlzLmNhbGN1bGF0ZWREdXJhdGlvbiA9IDA7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIEdyb3VwO1xuICAgIH0oX05vZGUpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIEY6IEdyb3VwLFxuICAgICAgZDogW3tcbiAgICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgICAga2V5OiBcIm9uR3JvdXBJbml0aWFsaXNlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkdyb3VwSW5pdGlhbGlzZSgpIHsvLyBjYWxsZWQgd2hlbiBncm91cCBnZXRzIGluaXRpYWxpc2VkXG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgICAga2V5OiBcImhhbmRsZUFkZEluY2lkZW50XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVBZGRJbmNpZGVudCh0YXJnZXQsIHBheWxvYWQpIHtcbiAgICAgICAgICBpZiAodGhpcy5pZCA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICB2YXIgaW5jaWRlbnRGcm9tRGVzY3JpcHRpb24gPSBwYXlsb2FkLmluY2lkZW50RnJvbURlc2NyaXB0aW9uO1xuICAgICAgICAgICAgdmFyIHRoZUluY2lkZW50ID0gaW5jaWRlbnRGcm9tRGVzY3JpcHRpb24ocGF5bG9hZC5pbmNpZGVudCwgcGF5bG9hZC5jb250ZXh0RGF0YSwgcGF5bG9hZC5hdWRpbyk7IC8vIGluIHRoZSBjYXNlIHRoYXQgYW4gYXVkaW8gY2xpcCB0cmllcyB0byBwcm9jZXNzIGFuIG5vbi1hdWRpbyBpbmNpZGVudCBvclxuICAgICAgICAgICAgLy8gYSBub24tYXVkaW8gaW5jaWRlbnQgdHJpZXMgdG8gcHJvY2VzcyBhbiBhdWRpbyBpbmNpZGVudCB0aGUgcmVzdWx0IGZyb20gaW5jaWRlbnRGcm9tRGVzY3JpcHRpb24gaXMgbnVsbFxuICAgICAgICAgICAgLy8gaW4gc3VjaCBhIGNhc2UgdGhlcmUgc2hvdWxkIGJlIG5vIGNhbmRpZGF0ZSByZXR1cm4sIHNvIHRoaXMuYnlwYXNzKClcblxuICAgICAgICAgICAgaWYgKHRoZUluY2lkZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmJ5cGFzcygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhlSW5jaWRlbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRoaXMuYnlwYXNzKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgICAga2V5OiBcImhhbmRsZU1vdmVJbmNpZGVudFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlTW92ZUluY2lkZW50KHRhcmdldCwgcGF5bG9hZCkge1xuICAgICAgICAgIGlmICh0aGlzLmlkID09PSB0YXJnZXQpIHtcbiAgICAgICAgICAgIHZhciByZXMgPSB0aGlzLmdldExlYWZCeUlkKHBheWxvYWQuaW5jaWRlbnRJZCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnlwYXNzKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRoaXMuYnlwYXNzKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgICAga2V5OiBcImhhbmRsZVJlbW92ZUluY2lkZW50XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVSZW1vdmVJbmNpZGVudCh0YXJnZXQsIHBheWxvYWQpIHtcbiAgICAgICAgICBpZiAodGhpcy5pZCA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICB2YXIgcmVzID0gdGhpcy5nZXRMZWFmQnlJZChwYXlsb2FkLmluY2lkZW50SWQsIHRydWUpO1xuXG4gICAgICAgICAgICBpZiAocmVzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmJ5cGFzcygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aGlzLmJ5cGFzcygpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICAgIGRlY29yYXRvcnM6IFtoYW5kbGVSZXNpemVdLFxuICAgICAgICBrZXk6IFwiaGFuZGxlUmVzaXplXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVSZXNpemUoKSB7fVxuICAgICAgfSwge1xuICAgICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAgICBrZXk6IFwicmVtb3ZlQ2hpbGRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUNoaWxkKGlkKSB7XG4gICAgICAgICAgdGhpcy5jaGlsZHJlbltpZF0ubGVhZi5sYXN0V2lzaCgpO1xuXG4gICAgICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoR3JvdXAucHJvdG90eXBlKSwgXCJyZW1vdmVDaGlsZFwiLCB0aGlzKS5jYWxsKHRoaXMsIGlkKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBoYXMgdGhlIGtleSBvZiB0aGUgbnBtIHBsdWdpbiBuYW1lIHRoZSBDaGFubmVsIG9mIHdoaWNoIG1hbmFnZXMgdGhlIHNwZWNpZmljIEluY2lkZW50XG4gICAgICAgICAqIFdpdGggdGhlIHNhbWUgbG9naWMgYWxsIEluY2lkZW50cyB0aGF0IGJlbG9uZyB0byB0aGlzIEdyb3VwIGFzIGNhdGVnb3Jpc2VkIGJ5IHBsdWdpbiAvIGNoYW5uZWwgb24gdGhlIHNhbWUgb2JqZWN0XG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICAgIGtleTogXCJnZXRJbmNpZGVudHNCeUNoYW5uZWxcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEluY2lkZW50c0J5Q2hhbm5lbCgpIHtcbiAgICAgICAgICB2YXIgYWRqdXN0TWlsbGlzZWNvbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICAgICAgdmFyIHBhcmVudE1pbGxpc2Vjb25kID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgICAgICAgIC8vIGluaXRpYWxseSBpdCBvbmx5IHB1dHMgaXRzZWxmIG9udGhlIGluY2lkZW50c0J5UGx1Z2luIGFycmF5LCBleGFjdGx5IGFzIHRoZSBwbGFpbiBJbmNpZGVudHMgZG9cbiAgICAgICAgICB2YXIgaW5jaWRlbnRzQnlQbHVnaW4gPSB7fTtcbiAgICAgICAgICBpbmNpZGVudHNCeVBsdWdpblsnbW90b3ItY29ydGV4LWpzJ10gPSBbe1xuICAgICAgICAgICAgbWlsbGlzZWNvbmQ6IGFkanVzdE1pbGxpc2Vjb25kLFxuICAgICAgICAgICAgcGFyZW50TWlsbGlzZWNvbmQ6IHBhcmVudE1pbGxpc2Vjb25kLFxuICAgICAgICAgICAgaW5jaWRlbnQ6IHRoaXMsXG4gICAgICAgICAgICBpZDogdGhpcy5pZFxuICAgICAgICAgIH1dOyAvLyBwcm9jZWVkIHRvIGdhdGhlciB0aGUgY29udGFpbmVkIGluY2lkZW50cyBhcyB3ZWxsXG5cbiAgICAgICAgICBmb3IgKHZhciBjaGlsZElkIGluIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5bY2hpbGRJZF07XG4gICAgICAgICAgICB2YXIgaW5jaWRlbnRzVG9BZGQgPSBjaGlsZC5sZWFmLmdldEluY2lkZW50c0J5Q2hhbm5lbChhZGp1c3RNaWxsaXNlY29uZCArIGNoaWxkLnBvc2l0aW9uLCBhZGp1c3RNaWxsaXNlY29uZCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBpbmNpZGVudHNUb0FkZCkge1xuICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGluY2lkZW50c0J5UGx1Z2luLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgaW5jaWRlbnRzQnlQbHVnaW5ba2V5XSA9IGluY2lkZW50c0J5UGx1Z2luW2tleV0uY29uY2F0KGluY2lkZW50c1RvQWRkW2tleV0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGluY2lkZW50c0J5UGx1Z2luW2tleV0gPSBpbmNpZGVudHNUb0FkZFtrZXldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGluY2lkZW50c0J5UGx1Z2luO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICAgIGtleTogXCJsYXN0V2lzaFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbGFzdFdpc2goKSB7XG4gICAgICAgICAgZm9yICh2YXIgY2hpbGRJZCBpbiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2NoaWxkSWRdLmxlYWYubGFzdFdpc2goKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgICAgZGVjb3JhdG9yczogW2Jsb2NrXSxcbiAgICAgICAga2V5OiBcInNldEJsb2NrXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRCbG9jaygpIHt9XG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICAgIGRlY29yYXRvcnM6IFt1bmJsb2NrXSxcbiAgICAgICAga2V5OiBcInVuYmxvY2tcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVuYmxvY2soKSB7fVxuICAgICAgfV1cbiAgICB9O1xuICB9LCBOb2RlKTtcblxuICB2YXIgbG9kYXNoX2ZpbHRlciA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbiAgLyoqXG4gICAqIExvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAgICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBpbmNsdWRlPVwiZmlsdGVyLHNvcnRCeSxmaW5kSW5kZXgsZmluZCxmb3JFYWNoLGNsb25lRGVlcFwiIGV4cG9ydHM9XCJucG1cImBcbiAgICogQ29weXJpZ2h0IEpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcy5mb3VuZGF0aW9uLz5cbiAgICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICAgKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICAgKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAgICovXG5cbiAgLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG4gIHZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuICAvKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG5cbiAgdmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcbiAgLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xuXG4gIHZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcbiAgLyoqIFVzZWQgYXMgdGhlIG1heGltdW0gbWVtb2l6ZSBjYWNoZSBzaXplLiAqL1xuXG4gIHZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuICAvKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cblxuICB2YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG4gIC8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xuXG4gIHZhciBJTkZJTklUWSA9IDEgLyAwLFxuICAgICAgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG4gIC8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cblxuICB2YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgICAgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgICBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nLFxuICAgICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJyxcbiAgICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG4gIHZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG4gIC8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cblxuICB2YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcbiAgICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLyxcbiAgICAgIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG4gIC8qKlxuICAgKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gICAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICAgKi9cblxuICB2YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuICAvKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cblxuICB2YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG4gIC8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cblxuICB2YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xuXG4gIHZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG4gIC8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cblxuICB2YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbiAgdHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbiAgdHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID0gdHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPSB0eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID0gdHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPSB0eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xuXG4gIHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGNvbW1vbmpzR2xvYmFsID09ICdvYmplY3QnICYmIGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGNvbW1vbmpzR2xvYmFsO1xuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xuXG4gIHZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuICAvKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cblxuICB2YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cblxuICB2YXIgZnJlZUV4cG9ydHMgPSAgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG5cbiAgdmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiAnb2JqZWN0JyA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG4gIC8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG5cbiAgdmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xuXG4gIHZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuICAvKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cblxuICB2YXIgbm9kZVV0aWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9KCk7XG4gIC8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG5cblxuICB2YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICovXG5cbiAgZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG5cbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gICAqIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gICAqIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICogIGVsc2UgYGZhbHNlYC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAgICovXG5cblxuICBmdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAgICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAgICovXG5cblxuICBmdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAgICovXG5cblxuICBmdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBgY2FjaGVgIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gY2FjaGVIYXMoY2FjaGUsIGtleSkge1xuICAgIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICovXG5cblxuICBmdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG4gICAgbWFwLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZXMuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuICAgIHNldC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG5cblxuICB2YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSxcbiAgICAgIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xuXG4gIHZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG4gIC8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cblxuICB2YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuICAvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cblxuICB2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cblxuICB2YXIgbWFza1NyY0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICAgIHJldHVybiB1aWQgPyAnU3ltYm9sKHNyYylfMS4nICsgdWlkIDogJyc7XG4gIH0oKTtcbiAgLyoqXG4gICAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAgICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gICAqIG9mIHZhbHVlcy5cbiAgICovXG5cblxuICB2YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cblxuICB2YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgKyBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKS5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJyk7XG4gIC8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xuXG4gIHZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgICBTeW1ib2wgPSByb290LlN5bWJvbCxcbiAgICAgIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXksXG4gICAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlLFxuICAgICAgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2UsXG4gICAgICBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcbiAgLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xuXG4gIHZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyxcbiAgICAgIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgICAgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG4gIC8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cblxuICB2YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUocm9vdCwgJ0RhdGFWaWV3JyksXG4gICAgICBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpLFxuICAgICAgUHJvbWlzZSA9IGdldE5hdGl2ZShyb290LCAnUHJvbWlzZScpLFxuICAgICAgU2V0ID0gZ2V0TmF0aXZlKHJvb3QsICdTZXQnKSxcbiAgICAgIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKSxcbiAgICAgIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cblxuICB2YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuICAvKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cblxuICB2YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZCxcbiAgICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICAgKi9cblxuICBmdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuICAgIHRoaXMuY2xlYXIoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBjbGVhclxuICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gICAgdGhpcy5zaXplID0gMDtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIGRlbGV0ZVxuICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICAgIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgZ2V0XG4gICAqIEBtZW1iZXJPZiBIYXNoXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG5cbiAgICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBoYXNcbiAgICogQG1lbWJlck9mIEhhc2hcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gZGF0YVtrZXldICE9PSB1bmRlZmluZWQgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgc2V0XG4gICAqIEBtZW1iZXJPZiBIYXNoXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gICAgZGF0YVtrZXldID0gbmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cblxuXG4gIEhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuICBIYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuICBIYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuICBIYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuICBIYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuICAvKipcbiAgICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICAgKi9cblxuICBmdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG4gICAgdGhpcy5jbGVhcigpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIGNsZWFyXG4gICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICovXG5cblxuICBmdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgICB0aGlzLl9fZGF0YV9fID0gW107XG4gICAgdGhpcy5zaXplID0gMDtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIGRlbGV0ZVxuICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuXG4gICAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgICAgZGF0YS5wb3AoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICAgIH1cblxuICAgIC0tdGhpcy5zaXplO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgZ2V0XG4gICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICovXG5cblxuICBmdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuICAgIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBoYXNcbiAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBzZXRcbiAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgKyt0aGlzLnNpemU7XG4gICAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cblxuXG4gIExpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbiAgTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG4gIExpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuICBMaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbiAgTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAgICovXG5cbiAgZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG4gICAgdGhpcy5jbGVhcigpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgY2xlYXJcbiAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgICB0aGlzLnNpemUgPSAwO1xuICAgIHRoaXMuX19kYXRhX18gPSB7XG4gICAgICAnaGFzaCc6IG5ldyBIYXNoKCksXG4gICAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSgpLFxuICAgICAgJ3N0cmluZyc6IG5ldyBIYXNoKClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBkZWxldGVcbiAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gICAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgZ2V0XG4gICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICAgIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBoYXNcbiAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gICAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIHNldFxuICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuXG5cbiAgTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbiAgTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuICBNYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG4gIE1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbiAgTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuICAvKipcbiAgICpcbiAgICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuICAgIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIGFkZFxuICAgKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAgICogQGFsaWFzIHB1c2hcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIGluc3RhbmNlLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG4gICAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiB0aGUgYXJyYXkgY2FjaGUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIGhhc1xuICAgKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbiAgfSAvLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuXG5cbiAgU2V0Q2FjaGUucHJvdG90eXBlLmFkZCA9IFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG4gIFNldENhY2hlLnByb3RvdHlwZS5oYXMgPSBzZXRDYWNoZUhhcztcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIGNsZWFyXG4gICAqIEBtZW1iZXJPZiBTdGFja1xuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gICAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoKTtcbiAgICB0aGlzLnNpemUgPSAwO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIGRlbGV0ZVxuICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG4gICAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgZ2V0XG4gICAqIEBtZW1iZXJPZiBTdGFja1xuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBoYXNcbiAgICogQG1lbWJlck9mIFN0YWNrXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIHNldFxuICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcblxuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuXG4gICAgICBpZiAoIU1hcCB8fCBwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkge1xuICAgICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICAgIH1cblxuICAgIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuXG5cbiAgU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcbiAgU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuICBTdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG4gIFN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcbiAgU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgKi9cblxuICBmdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmICEoc2tpcEluZGV4ZXMgJiYgKCAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICBrZXkgPT0gJ2xlbmd0aCcgfHwgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICBpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpIHx8IC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgIGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykgfHwgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgaXNJbmRleChrZXksIGxlbmd0aCkpKSkge1xuICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JFYWNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAqL1xuXG5cbiAgdmFyIGJhc2VFYWNoID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93bik7XG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maWx0ZXJgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGJhc2VGaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYG9iamVjdGBcbiAgICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuXG4gICAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICovXG5cblxuICB2YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93bmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgKi9cblxuICBmdW5jdGlvbiBiYXNlRm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICAgIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgICAgb2JqZWN0ID0gb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoID8gb2JqZWN0IDogdW5kZWZpbmVkO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAgICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gICAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAgICovXG5cblxuICBmdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICAgIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICAgIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkgPyBnZXRSYXdUYWcodmFsdWUpIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbiAgfVxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdoaWNoIHN1cHBvcnRzIHBhcnRpYWwgY29tcGFyaXNvbnNcbiAgICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICAgKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gICAqICAyIC0gUGFydGlhbCBjb21wYXJpc29uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gICAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAhaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkge1xuICAgICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGJhc2VJc0VxdWFsLCBzdGFjayk7XG4gIH1cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAgICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICAgKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgICBvYmpUYWcgPSBvYmpJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG9iamVjdCksXG4gICAgICAgIG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob3RoZXIpO1xuICAgIG9ialRhZyA9IG9ialRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb2JqVGFnO1xuICAgIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuICAgIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcsXG4gICAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyxcbiAgICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICAgIGlmIChpc1NhbWVUYWcgJiYgaXNCdWZmZXIob2JqZWN0KSkge1xuICAgICAgaWYgKCFpc0J1ZmZlcihvdGhlcikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBvYmpJc0FyciA9IHRydWU7XG4gICAgICBvYmpJc09iaiA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2soKSk7XG4gICAgICByZXR1cm4gb2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSA6IGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICB9XG5cbiAgICBpZiAoIShiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcpKSB7XG4gICAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgICBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG4gICAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjaygpKTtcbiAgICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaXNTYW1lVGFnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKCkpO1xuICAgIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAqIEBwYXJhbSB7QXJyYXl9IG1hdGNoRGF0YSBUaGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3MgdG8gbWF0Y2guXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEsIGN1c3RvbWl6ZXIpIHtcbiAgICB2YXIgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoLFxuICAgICAgICBsZW5ndGggPSBpbmRleCxcbiAgICAgICAgbm9DdXN0b21pemVyID0gIWN1c3RvbWl6ZXI7XG5cbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiAhbGVuZ3RoO1xuICAgIH1cblxuICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuXG4gICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgIHZhciBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcblxuICAgICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdID8gZGF0YVsxXSAhPT0gb2JqZWN0W2RhdGFbMF1dIDogIShkYXRhWzBdIGluIG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICAgIHZhciBrZXkgPSBkYXRhWzBdLFxuICAgICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgc3JjVmFsdWUgPSBkYXRhWzFdO1xuXG4gICAgICBpZiAobm9DdXN0b21pemVyICYmIGRhdGFbMl0pIHtcbiAgICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHN0YWNrID0gbmV3IFN0YWNrKCk7XG5cbiAgICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcsIGN1c3RvbWl6ZXIsIHN0YWNrKSA6IHJlc3VsdCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gICAqICBlbHNlIGBmYWxzZWAuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gICAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gICAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pdGVyYXRlZWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gW3ZhbHVlPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGl0ZXJhdGVlLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGJhc2VJdGVyYXRlZSh2YWx1ZSkge1xuICAgIC8vIERvbid0IHN0b3JlIHRoZSBgdHlwZW9mYCByZXN1bHQgaW4gYSB2YXJpYWJsZSB0byBhdm9pZCBhIEpJVCBidWcgaW4gU2FmYXJpIDkuXG4gICAgLy8gU2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTYwMzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGlkZW50aXR5O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKSA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKSA6IGJhc2VNYXRjaGVzKHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcGVydHkodmFsdWUpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICovXG5cblxuICBmdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGJhc2VNYXRjaGVzKHNvdXJjZSkge1xuICAgIHZhciBtYXRjaERhdGEgPSBnZXRNYXRjaERhdGEoc291cmNlKTtcblxuICAgIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUobWF0Y2hEYXRhWzBdWzBdLCBtYXRjaERhdGFbMF1bMV0pO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSk7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2Vzbid0IGNsb25lIGBzcmNWYWx1ZWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgICBpZiAoaXNLZXkocGF0aCkgJiYgaXNTdHJpY3RDb21wYXJhYmxlKHNyY1ZhbHVlKSkge1xuICAgICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKHRvS2V5KHBhdGgpLCBzcmNWYWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIHZhciBvYmpWYWx1ZSA9IGdldChvYmplY3QsIHBhdGgpO1xuICAgICAgcmV0dXJuIG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlID8gaGFzSW4ob2JqZWN0LCBwYXRoKSA6IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VQcm9wZXJ0eWAgd2hpY2ggc3VwcG9ydHMgZGVlcCBwYXRocy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcChwYXRoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gICAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gICAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHZhbHVlcyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gICAgfVxuXG4gICAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gdmFsdWUgKyAnJztcbiAgICByZXR1cm4gcmVzdWx0ID09ICcwJyAmJiAxIC8gdmFsdWUgPT0gLUlORklOSVRZID8gJy0wJyA6IHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICovXG5cblxuICBmdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgYGJhc2VFYWNoYCBvciBgYmFzZUVhY2hSaWdodGAgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAgICovXG5cblxuICBmdW5jdGlvbiBjcmVhdGVCYXNlRWFjaChlYWNoRnVuYywgZnJvbVJpZ2h0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgICByZXR1cm4gZWFjaEZ1bmMoY29sbGVjdGlvbiwgaXRlcmF0ZWUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGgsXG4gICAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcbiAgICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcblxuICAgICAgd2hpbGUgKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtpbmRleF0sIGluZGV4LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUJhc2VGb3IoZnJvbVJpZ2h0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgICBwcm9wcyA9IGtleXNGdW5jKG9iamVjdCksXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdO1xuXG4gICAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAgICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFyZS5cbiAgICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFycmF5cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gICAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuXG5cbiAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG5cbiAgICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgICAgc2VlbiA9IGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHID8gbmV3IFNldENhY2hlKCkgOiB1bmRlZmluZWQ7XG4gICAgc3RhY2suc2V0KGFycmF5LCBvdGhlcik7XG4gICAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7IC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cblxuICAgIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbCA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIGFyclZhbHVlLCBpbmRleCwgb3RoZXIsIGFycmF5LCBzdGFjaykgOiBjdXN0b21pemVyKGFyclZhbHVlLCBvdGhWYWx1ZSwgaW5kZXgsIGFycmF5LCBvdGhlciwgc3RhY2spO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29tcGFyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cblxuXG4gICAgICBpZiAoc2Vlbikge1xuICAgICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24gKG90aFZhbHVlLCBvdGhJbmRleCkge1xuICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlZW4ucHVzaChvdGhJbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCEoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSkpIHtcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN0YWNrWydkZWxldGUnXShhcnJheSk7XG4gICAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gICAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gICAqXG4gICAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAgICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgICAgaWYgKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGggfHwgb2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XG4gICAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xuXG4gICAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgICBpZiAob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCB8fCAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgY2FzZSBib29sVGFnOlxuICAgICAgY2FzZSBkYXRlVGFnOlxuICAgICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAgIC8vIENvZXJjZSBib29sZWFucyB0byBgMWAgb3IgYDBgIGFuZCBkYXRlcyB0byBtaWxsaXNlY29uZHMuXG4gICAgICAgIC8vIEludmFsaWQgZGF0ZXMgYXJlIGNvZXJjZWQgdG8gYE5hTmAuXG4gICAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgIHJldHVybiBvYmplY3QgPT0gb3RoZXIgKyAnJztcblxuICAgICAgY2FzZSBtYXBUYWc6XG4gICAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgICAgY2FzZSBzZXRUYWc6XG4gICAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUc7XG4gICAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cblxuXG4gICAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG5cbiAgICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJpdG1hc2sgfD0gQ09NUEFSRV9VTk9SREVSRURfRkxBRzsgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG5cbiAgICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gZXF1YWxBcnJheXMoY29udmVydChvYmplY3QpLCBjb252ZXJ0KG90aGVyKSwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcbiAgICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvclxuICAgKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgICAgb2JqUHJvcHMgPSBnZXRBbGxLZXlzKG9iamVjdCksXG4gICAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgICAgb3RoUHJvcHMgPSBnZXRBbGxLZXlzKG90aGVyKSxcbiAgICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gICAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBpbmRleCA9IG9iakxlbmd0aDtcblxuICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuXG4gICAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG5cblxuICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG5cbiAgICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuICAgIHZhciBza2lwQ3RvciA9IGlzUGFydGlhbDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2tleV07XG5cbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbCA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKSA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICAgIH0gLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG5cblxuICAgICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZCA/IG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykgOiBjb21wYXJlZCkpIHtcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjsgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG5cbiAgICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlciAmJiAhKHR5cGVvZiBvYmpDdG9yID09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiYgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgICByZXR1cm4gaXNLZXlhYmxlKGtleSkgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ10gOiBkYXRhLm1hcDtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3Mgb2YgYG9iamVjdGAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgICB2YXIgcmVzdWx0ID0ga2V5cyhvYmplY3QpLFxuICAgICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICB2YXIga2V5ID0gcmVzdWx0W2xlbmd0aF0sXG4gICAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICAgIHJlc3VsdFtsZW5ndGhdID0gW2tleSwgdmFsdWUsIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSldO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gICAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbiAgfVxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICAgIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gICAgfSBjYXRjaCAoZSkge31cblxuICAgIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcblxuICAgIGlmICh1bm1hc2tlZCkge1xuICAgICAgaWYgKGlzT3duKSB7XG4gICAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gICAqL1xuXG5cbiAgdmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbiAoc3ltYm9sKSB7XG4gICAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gICAgfSk7XG4gIH07XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICAgKi9cblxuICB2YXIgZ2V0VGFnID0gYmFzZUdldFRhZzsgLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuXG4gIGlmIChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnIHx8IE1hcCAmJiBnZXRUYWcobmV3IE1hcCgpKSAhPSBtYXBUYWcgfHwgUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcgfHwgU2V0ICYmIGdldFRhZyhuZXcgU2V0KCkpICE9IHNldFRhZyB8fCBXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCgpKSAhPSB3ZWFrTWFwVGFnKSB7XG4gICAgZ2V0VGFnID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksXG4gICAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOlxuICAgICAgICAgICAgcmV0dXJuIGRhdGFWaWV3VGFnO1xuXG4gICAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOlxuICAgICAgICAgICAgcmV0dXJuIG1hcFRhZztcblxuICAgICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZVRhZztcblxuICAgICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzpcbiAgICAgICAgICAgIHJldHVybiBzZXRUYWc7XG5cbiAgICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOlxuICAgICAgICAgICAgcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHBhdGhgIGV4aXN0cyBvbiBgb2JqZWN0YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgaGFzRnVuYykge1xuICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKTtcblxuICAgICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBvYmplY3QgPSBvYmplY3Rba2V5XTtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0IHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGxlbmd0aCA9IG9iamVjdCA9PSBudWxsID8gMCA6IG9iamVjdC5sZW5ndGg7XG4gICAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiYgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICAgIHJldHVybiAhIWxlbmd0aCAmJiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSAmJiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cbiAgICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8IG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICByZXR1cm4gdHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicgPyB2YWx1ZSAhPT0gJ19fcHJvdG9fXycgOiB2YWx1ZSA9PT0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIG1hc2tTcmNLZXkgaW4gZnVuYztcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgICBwcm90byA9IHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUgfHwgb2JqZWN0UHJvdG87XG4gICAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlmIHN1aXRhYmxlIGZvciBzdHJpY3RcbiAgICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSAmJiAhaXNPYmplY3QodmFsdWUpO1xuICB9XG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYG1hdGNoZXNQcm9wZXJ0eWAgZm9yIHNvdXJjZSB2YWx1ZXMgc3VpdGFibGVcbiAgICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKGtleSwgc3JjVmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iamVjdFtrZXldID09PSBzcmNWYWx1ZSAmJiAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCBrZXkgaW4gT2JqZWN0KG9iamVjdCkpO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAgICogY2FjaGUgd2hlbiBpdCBleGNlZWRzIGBNQVhfTUVNT0laRV9TSVpFYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAgICovXG5cblxuICBmdW5jdGlvbiBtZW1vaXplQ2FwcGVkKGZ1bmMpIHtcbiAgICB2YXIgcmVzdWx0ID0gbWVtb2l6ZShmdW5jLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAoY2FjaGUuc2l6ZSA9PT0gTUFYX01FTU9JWkVfU0laRSkge1xuICAgICAgICBjYWNoZS5jbGVhcigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ga2V5O1xuICAgIH0pO1xuICAgIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAgICovXG5cblxuICBmdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgKi9cblxuXG4gIHZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoMCkgPT09IDQ2XG4gICAgLyogLiAqL1xuICAgICkge1xuICAgICAgICByZXN1bHQucHVzaCgnJyk7XG4gICAgICB9XG5cbiAgICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbiAobWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuICAgICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogbnVtYmVyIHx8IG1hdGNoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KTtcbiAgLyoqXG4gICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAgICovXG5cbiAgZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSB2YWx1ZSArICcnO1xuICAgIHJldHVybiByZXN1bHQgPT0gJzAnICYmIDEgLyB2YWx1ZSA9PSAtSU5GSU5JVFkgPyAnLTAnIDogcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAgICovXG5cblxuICBmdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gICAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZ1bmMgKyAnJztcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG4gIC8qKlxuICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGFsbCBlbGVtZW50c1xuICAgKiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRocmVlXG4gICAqIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgKlxuICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLnJlbW92ZWAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDAuMS4wXG4gICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICogQHNlZSBfLnJlamVjdFxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgdXNlcnMgPSBbXG4gICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAqIF07XG4gICAqXG4gICAqIF8uZmlsdGVyKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICAgKlxuICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgKiBfLmZpbHRlcih1c2VycywgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAqXG4gICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICogXy5maWx0ZXIodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAgICpcbiAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAqIF8uZmlsdGVyKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICovXG5cblxuICBmdW5jdGlvbiBmaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlGaWx0ZXIgOiBiYXNlRmlsdGVyO1xuICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGJhc2VJdGVyYXRlZShwcmVkaWNhdGUpKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAgICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICAgKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAgICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAgICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gICAqXG4gICAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAgICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gICAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gICAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gICAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAwLjEuMFxuICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICAgKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gICAqXG4gICAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICAgKiB2YWx1ZXMob2JqZWN0KTtcbiAgICogLy8gPT4gWzEsIDJdXG4gICAqXG4gICAqIHZhbHVlcyhvdGhlcik7XG4gICAqIC8vID0+IFszLCA0XVxuICAgKlxuICAgKiBvYmplY3QuYSA9IDI7XG4gICAqIHZhbHVlcyhvYmplY3QpO1xuICAgKiAvLyA9PiBbMSwgMl1cbiAgICpcbiAgICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gICAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAgICogdmFsdWVzKG9iamVjdCk7XG4gICAqIC8vID0+IFsnYScsICdiJ11cbiAgICpcbiAgICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAgICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAgICovXG5cblxuICBmdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgcmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgIH1cblxuICAgIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpKCk7XG4gICAgcmV0dXJuIG1lbW9pemVkO1xuICB9IC8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxuXG5cbiAgbWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuICAvKipcbiAgICogUGVyZm9ybXMgYVxuICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgNC4wLjBcbiAgICogQGNhdGVnb3J5IExhbmdcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gICAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gICAqXG4gICAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIF8uZXEoJ2EnLCAnYScpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIF8uZXEoTmFOLCBOYU4pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMC4xLjBcbiAgICogQGNhdGVnb3J5IExhbmdcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAgICogIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqL1xuXG5cbiAgdmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzO1xuICB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG4gIH07XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAwLjEuMFxuICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBfLmlzQXJyYXkoJ2FiYycpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICovXG5cbiAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICAgKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gICAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDQuMC4wXG4gICAqIEBjYXRlZ29yeSBMYW5nXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICovXG5cbiAgZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDQuMy4wXG4gICAqIEBjYXRlZ29yeSBMYW5nXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKi9cblxuXG4gIHZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMC4xLjBcbiAgICogQGNhdGVnb3J5IExhbmdcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pc0Z1bmN0aW9uKF8pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gICAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG5cblxuICAgIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICAgKlxuICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICAgKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSA0LjAuMFxuICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pc0xlbmd0aCgzKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICpcbiAgICogXy5pc0xlbmd0aCgnMycpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICAgKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gICAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMC4xLjBcbiAgICogQGNhdGVnb3J5IExhbmdcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmlzT2JqZWN0KHt9KTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc09iamVjdChfLm5vb3ApO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNPYmplY3QobnVsbCk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAgICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSA0LjAuMFxuICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pc09iamVjdExpa2Uoe30pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICpcbiAgICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgNC4wLjBcbiAgICogQGNhdGVnb3J5IExhbmdcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICovXG5cblxuICBmdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHwgaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWc7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMy4wLjBcbiAgICogQGNhdGVnb3J5IExhbmdcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICovXG5cblxuICB2YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICAgKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgNC4wLjBcbiAgICogQGNhdGVnb3J5IExhbmdcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy50b1N0cmluZyhudWxsKTtcbiAgICogLy8gPT4gJydcbiAgICpcbiAgICogXy50b1N0cmluZygtMCk7XG4gICAqIC8vID0+ICctMCdcbiAgICpcbiAgICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICAgKiAvLyA9PiAnMSwyLDMnXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzXG4gICAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAzLjcuMFxuICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICAgKlxuICAgKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xuICAgKiAvLyA9PiAzXG4gICAqXG4gICAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICAgKiAvLyA9PiAzXG4gICAqXG4gICAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAgICogLy8gPT4gJ2RlZmF1bHQnXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDQuMC4wXG4gICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIG9iamVjdCA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAgICpcbiAgICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaGFzSW4ob2JqZWN0LCBwYXRoKSB7XG4gICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAgICpcbiAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAgICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBzaW5jZSAwLjEuMFxuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgKiAgIHRoaXMuYSA9IDE7XG4gICAqICAgdGhpcy5iID0gMjtcbiAgICogfVxuICAgKlxuICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgKlxuICAgKiBfLmtleXMobmV3IEZvbyk7XG4gICAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICpcbiAgICogXy5rZXlzKCdoaScpO1xuICAgKiAvLyA9PiBbJzAnLCAnMSddXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBzaW5jZSAwLjEuMFxuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gICAqXG4gICAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDIuNC4wXG4gICAqIEBjYXRlZ29yeSBVdGlsXG4gICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICogICB7ICdhJzogeyAnYic6IDIgfSB9LFxuICAgKiAgIHsgJ2EnOiB7ICdiJzogMSB9IH1cbiAgICogXTtcbiAgICpcbiAgICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iJykpO1xuICAgKiAvLyA9PiBbMiwgMV1cbiAgICpcbiAgICogXy5tYXAoXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYiddKSksICdhLmInKTtcbiAgICogLy8gPT4gWzEsIDJdXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gcHJvcGVydHkocGF0aCkge1xuICAgIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleShwYXRoKSkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSA0LjEzLjBcbiAgICogQGNhdGVnb3J5IFV0aWxcbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAgICpcbiAgICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAgICogLy8gPT4gW1tdLCBbXV1cbiAgICpcbiAgICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgNC4xMy4wXG4gICAqIEBjYXRlZ29yeSBVdGlsXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICAgKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBtb2R1bGUuZXhwb3J0cyA9IGZpbHRlcjtcbiAgfSk7XG5cbiAgdmFyIGxvZGFzaF9zb3J0YnkgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4gIC8qKlxuICAgKiBMb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gICAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgaW5jbHVkZT1cImZpbHRlcixzb3J0QnksZmluZEluZGV4LGZpbmQsZm9yRWFjaCxjbG9uZURlZXBcIiBleHBvcnRzPVwibnBtXCJgXG4gICAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanMuZm91bmRhdGlvbi8+XG4gICAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAgICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAgICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gICAqL1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xuICB2YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcbiAgLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xuXG4gIHZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG4gIC8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cblxuICB2YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG4gIC8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cblxuICB2YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcbiAgLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG5cbiAgdmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuICAvKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG5cbiAgdmFyIEhPVF9DT1VOVCA9IDgwMCxcbiAgICAgIEhPVF9TUEFOID0gMTY7XG4gIC8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xuXG4gIHZhciBJTkZJTklUWSA9IDEgLyAwLFxuICAgICAgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG4gIC8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cblxuICB2YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgICAgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgICBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nLFxuICAgICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJyxcbiAgICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG4gIHZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG4gIC8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cblxuICB2YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcbiAgICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLyxcbiAgICAgIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG4gIC8qKlxuICAgKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gICAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICAgKi9cblxuICB2YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuICAvKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cblxuICB2YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG4gIC8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cblxuICB2YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xuXG4gIHZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG4gIC8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cblxuICB2YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbiAgdHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbiAgdHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID0gdHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPSB0eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID0gdHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPSB0eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xuXG4gIHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGNvbW1vbmpzR2xvYmFsID09ICdvYmplY3QnICYmIGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGNvbW1vbmpzR2xvYmFsO1xuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xuXG4gIHZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuICAvKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cblxuICB2YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cblxuICB2YXIgZnJlZUV4cG9ydHMgPSAgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG5cbiAgdmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiAnb2JqZWN0JyA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG4gIC8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG5cbiAgdmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xuXG4gIHZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuICAvKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cblxuICB2YXIgbm9kZVV0aWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9KCk7XG4gIC8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG5cblxuICB2YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcbiAgLyoqXG4gICAqIEEgZmFzdGVyIGFsdGVybmF0aXZlIHRvIGBGdW5jdGlvbiNhcHBseWAsIHRoaXMgZnVuY3Rpb24gaW52b2tlcyBgZnVuY2BcbiAgICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICAgKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG5cbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcblxuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuXG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gIH1cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICovXG5cblxuICBmdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcblxuICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAgICogc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAgICogc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydEJ5YCB3aGljaCB1c2VzIGBjb21wYXJlcmAgdG8gZGVmaW5lIHRoZVxuICAgKiBzb3J0IG9yZGVyIG9mIGBhcnJheWAgYW5kIHJlcGxhY2VzIGNyaXRlcmlhIG9iamVjdHMgd2l0aCB0aGVpciBjb3JyZXNwb25kaW5nXG4gICAqIHZhbHVlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNvcnQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmVyIFRoZSBmdW5jdGlvbiB0byBkZWZpbmUgc29ydCBvcmRlci5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gYmFzZVNvcnRCeShhcnJheSwgY29tcGFyZXIpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIGFycmF5LnNvcnQoY29tcGFyZXIpO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBhcnJheVtsZW5ndGhdID0gYXJyYXlbbGVuZ3RoXS52YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAgICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAgICovXG5cblxuICBmdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAgICovXG5cblxuICBmdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBgY2FjaGVgIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gY2FjaGVIYXMoY2FjaGUsIGtleSkge1xuICAgIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICovXG5cblxuICBmdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG4gICAgbWFwLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZXMuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuICAgIHNldC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG5cblxuICB2YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSxcbiAgICAgIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xuXG4gIHZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG4gIC8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cblxuICB2YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuICAvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cblxuICB2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cblxuICB2YXIgbWFza1NyY0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICAgIHJldHVybiB1aWQgPyAnU3ltYm9sKHNyYylfMS4nICsgdWlkIDogJyc7XG4gIH0oKTtcbiAgLyoqXG4gICAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAgICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gICAqIG9mIHZhbHVlcy5cbiAgICovXG5cblxuICB2YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cblxuICB2YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgKyBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKS5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJyk7XG4gIC8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xuXG4gIHZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgICBTeW1ib2wgPSByb290LlN5bWJvbCxcbiAgICAgIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXksXG4gICAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlLFxuICAgICAgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2UsXG4gICAgICBzcHJlYWRhYmxlU3ltYm9sID0gU3ltYm9sID8gU3ltYm9sLmlzQ29uY2F0U3ByZWFkYWJsZSA6IHVuZGVmaW5lZCxcbiAgICAgIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcbiAgICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgICByZXR1cm4gZnVuYztcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9KCk7XG4gIC8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cblxuXG4gIHZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyxcbiAgICAgIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgICAgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCksXG4gICAgICBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICAgIG5hdGl2ZU5vdyA9IERhdGUubm93O1xuICAvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG5cbiAgdmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpLFxuICAgICAgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKSxcbiAgICAgIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKSxcbiAgICAgIFNldCA9IGdldE5hdGl2ZShyb290LCAnU2V0JyksXG4gICAgICBXZWFrTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdXZWFrTWFwJyksXG4gICAgICBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG4gIC8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG5cbiAgdmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcbiAgLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG5cbiAgdmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQsXG4gICAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAgICovXG5cbiAgZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcbiAgICB0aGlzLmNsZWFyKCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgY2xlYXJcbiAgICogQG1lbWJlck9mIEhhc2hcbiAgICovXG5cblxuICBmdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gICAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICAgIHRoaXMuc2l6ZSA9IDA7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBkZWxldGVcbiAgICogQG1lbWJlck9mIEhhc2hcbiAgICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIGdldFxuICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuXG4gICAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICAgIH1cblxuICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgaGFzXG4gICAqIEBtZW1iZXJPZiBIYXNoXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIHNldFxuICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICAgIGRhdGFba2V5XSA9IG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5cblxuICBIYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbiAgSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbiAgSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbiAgSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbiAgSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAgICovXG5cbiAgZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuICAgIHRoaXMuY2xlYXIoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBjbGVhclxuICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gICAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICAgIHRoaXMuc2l6ZSA9IDA7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBkZWxldGVcbiAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcblxuICAgIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICAgIGRhdGEucG9wKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgICB9XG5cbiAgICAtLXRoaXMuc2l6ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIGdldFxuICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcbiAgICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgaGFzXG4gICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gICAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgc2V0XG4gICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAgICovXG5cblxuICBmdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICsrdGhpcy5zaXplO1xuICAgICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5cblxuICBMaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG4gIExpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuICBMaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbiAgTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG4gIExpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuICAgIHRoaXMuY2xlYXIoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIGNsZWFyXG4gICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gICAgdGhpcy5zaXplID0gMDtcbiAgICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICAgJ2hhc2gnOiBuZXcgSGFzaCgpLFxuICAgICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSkoKSxcbiAgICAgICdzdHJpbmcnOiBuZXcgSGFzaCgpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgZGVsZXRlXG4gICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICAgIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gICAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIGdldFxuICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICovXG5cblxuICBmdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgaGFzXG4gICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICAgIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBzZXRcbiAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAgICovXG5cblxuICBmdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gICAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICAgIHNpemUgPSBkYXRhLnNpemU7XG4gICAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cblxuXG4gIE1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG4gIE1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbiAgTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuICBNYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG4gIE1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcbiAgLyoqXG4gICAqXG4gICAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICAgKi9cblxuICBmdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gdmFsdWVzID09IG51bGwgPyAwIDogdmFsdWVzLmxlbmd0aDtcbiAgICB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBhZGRcbiAgICogQG1lbWJlck9mIFNldENhY2hlXG4gICAqIEBhbGlhcyBwdXNoXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAgICovXG5cblxuICBmdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICAgIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBoYXNcbiAgICogQG1lbWJlck9mIFNldENhY2hlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBzZXRDYWNoZUhhcyh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG4gIH0gLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblxuXG4gIFNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuICBTZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICAgKi9cblxuICBmdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBjbGVhclxuICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICovXG5cblxuICBmdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICAgIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKCk7XG4gICAgdGhpcy5zaXplID0gMDtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBkZWxldGVcbiAgICogQG1lbWJlck9mIFN0YWNrXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIGdldFxuICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICovXG5cblxuICBmdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgaGFzXG4gICAqIEBtZW1iZXJPZiBTdGFja1xuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBzZXRcbiAgICogQG1lbWJlck9mIFN0YWNrXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG5cbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcblxuICAgICAgaWYgKCFNYXAgfHwgcGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpIHtcbiAgICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgICB9XG5cbiAgICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblxuXG4gIFN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG4gIFN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcbiAgU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuICBTdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG4gIFN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICovXG5cbiAgZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gICAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJiAhKHNraXBJbmRleGVzICYmICggLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAga2V5ID09ICdsZW5ndGgnIHx8IC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSB8fCAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICBpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpIHx8IC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpKSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfVxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgKi9cblxuXG4gIHZhciBiYXNlRWFjaCA9IGNyZWF0ZUJhc2VFYWNoKGJhc2VGb3JPd24pO1xuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmxhdHRlbmAgd2l0aCBzdXBwb3J0IGZvciByZXN0cmljdGluZyBmbGF0dGVuaW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbcHJlZGljYXRlPWlzRmxhdHRlbmFibGVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU3RyaWN0XSBSZXN0cmljdCB0byB2YWx1ZXMgdGhhdCBwYXNzIGBwcmVkaWNhdGVgIGNoZWNrcy5cbiAgICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdD1bXV0gVGhlIGluaXRpYWwgcmVzdWx0IHZhbHVlLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICBwcmVkaWNhdGUgfHwgKHByZWRpY2F0ZSA9IGlzRmxhdHRlbmFibGUpO1xuICAgIHJlc3VsdCB8fCAocmVzdWx0ID0gW10pO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcblxuICAgICAgaWYgKGRlcHRoID4gMCAmJiBwcmVkaWNhdGUodmFsdWUpKSB7XG4gICAgICAgIGlmIChkZXB0aCA+IDEpIHtcbiAgICAgICAgICAvLyBSZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICAgIGJhc2VGbGF0dGVuKHZhbHVlLCBkZXB0aCAtIDEsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXJyYXlQdXNoKHJlc3VsdCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuICAgKiBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAgICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgKi9cblxuXG4gIHZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpO1xuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgIHJldHVybiBvYmplY3QgJiYgYmFzZUZvcihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICovXG5cblxuICBmdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gICAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICAgIH1cblxuICAgIHJldHVybiBpbmRleCAmJiBpbmRleCA9PSBsZW5ndGggPyBvYmplY3QgOiB1bmRlZmluZWQ7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICAgKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAgICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gICAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gICAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgICB9XG5cbiAgICByZXR1cm4gc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSA/IGdldFJhd1RhZyh2YWx1ZSkgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LCBrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYga2V5IGluIE9iamVjdChvYmplY3QpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbiAgfVxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICAgKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gICAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAgICogIDIgLSBQYXJ0aWFsIGNvbXBhcmlzb25cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSB7XG4gICAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgYmFzZUlzRXF1YWwsIHN0YWNrKTtcbiAgfVxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICAgKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gICAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICAgIG9ialRhZyA9IG9iaklzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob2JqZWN0KSxcbiAgICAgICAgb3RoVGFnID0gb3RoSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvdGhlcik7XG4gICAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gICAgb3RoVGFnID0gb3RoVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvdGhUYWc7XG4gICAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyxcbiAgICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gICAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlcihvYmplY3QpKSB7XG4gICAgICBpZiAoIWlzQnVmZmVyKG90aGVyKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICAgIG9iaklzT2JqID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjaygpKTtcbiAgICAgIHJldHVybiBvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgIH1cblxuICAgIGlmICghKGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRykpIHtcbiAgICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcbiAgICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKCkpO1xuICAgICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2soKSk7XG4gICAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXRjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICAgIHZhciBpbmRleCA9IG1hdGNoRGF0YS5sZW5ndGgsXG4gICAgICAgIGxlbmd0aCA9IGluZGV4LFxuICAgICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuICFsZW5ndGg7XG4gICAgfVxuXG4gICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG5cbiAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuXG4gICAgICBpZiAobm9DdXN0b21pemVyICYmIGRhdGFbMl0gPyBkYXRhWzFdICE9PSBvYmplY3RbZGF0YVswXV0gOiAhKGRhdGFbMF0gaW4gb2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgICAgdmFyIGtleSA9IGRhdGFbMF0sXG4gICAgICAgICAgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgICBzcmNWYWx1ZSA9IGRhdGFbMV07XG5cbiAgICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSkge1xuICAgICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc3RhY2sgPSBuZXcgU3RhY2soKTtcblxuICAgICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWQgPyBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRywgY3VzdG9taXplciwgc3RhY2spIDogcmVzdWx0KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAgICogIGVsc2UgYGZhbHNlYC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLml0ZXJhdGVlYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSBbdmFsdWU9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYW4gaXRlcmF0ZWUuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgaXRlcmF0ZWUuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gYmFzZUl0ZXJhdGVlKHZhbHVlKSB7XG4gICAgLy8gRG9uJ3Qgc3RvcmUgdGhlIGB0eXBlb2ZgIHJlc3VsdCBpbiBhIHZhcmlhYmxlIHRvIGF2b2lkIGEgSklUIGJ1ZyBpbiBTYWZhcmkgOS5cbiAgICAvLyBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NjAzNCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gaWRlbnRpdHk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpID8gYmFzZU1hdGNoZXNQcm9wZXJ0eSh2YWx1ZVswXSwgdmFsdWVbMV0pIDogYmFzZU1hdGNoZXModmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9wZXJ0eSh2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICAgIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hcGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAgICovXG5cblxuICBmdW5jdGlvbiBiYXNlTWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gQXJyYXkoY29sbGVjdGlvbi5sZW5ndGgpIDogW107XG4gICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24gKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgIHJlc3VsdFsrK2luZGV4XSA9IGl0ZXJhdGVlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNvdXJjZWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gICAgdmFyIG1hdGNoRGF0YSA9IGdldE1hdGNoRGF0YShzb3VyY2UpO1xuXG4gICAgaWYgKG1hdGNoRGF0YS5sZW5ndGggPT0gMSAmJiBtYXRjaERhdGFbMF1bMl0pIHtcbiAgICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShtYXRjaERhdGFbMF1bMF0sIG1hdGNoRGF0YVswXVsxXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzUHJvcGVydHlgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNyY1ZhbHVlYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICAgIGlmIChpc0tleShwYXRoKSAmJiBpc1N0cmljdENvbXBhcmFibGUoc3JjVmFsdWUpKSB7XG4gICAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICByZXR1cm4gb2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiBvYmpWYWx1ZSA9PT0gc3JjVmFsdWUgPyBoYXNJbihvYmplY3QsIHBhdGgpIDogYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm9yZGVyQnlgIHdpdGhvdXQgcGFyYW0gZ3VhcmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb25bXXxPYmplY3RbXXxzdHJpbmdbXX0gaXRlcmF0ZWVzIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gb3JkZXJzIFRoZSBzb3J0IG9yZGVycyBvZiBgaXRlcmF0ZWVzYC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKSB7XG4gICAgdmFyIGluZGV4ID0gLTE7XG4gICAgaXRlcmF0ZWVzID0gYXJyYXlNYXAoaXRlcmF0ZWVzLmxlbmd0aCA/IGl0ZXJhdGVlcyA6IFtpZGVudGl0eV0sIGJhc2VVbmFyeShiYXNlSXRlcmF0ZWUpKTtcbiAgICB2YXIgcmVzdWx0ID0gYmFzZU1hcChjb2xsZWN0aW9uLCBmdW5jdGlvbiAodmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgdmFyIGNyaXRlcmlhID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBmdW5jdGlvbiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdGVlKHZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ2NyaXRlcmlhJzogY3JpdGVyaWEsXG4gICAgICAgICdpbmRleCc6ICsraW5kZXgsXG4gICAgICAgICd2YWx1ZSc6IHZhbHVlXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBiYXNlU29ydEJ5KHJlc3VsdCwgZnVuY3Rpb24gKG9iamVjdCwgb3RoZXIpIHtcbiAgICAgIHJldHVybiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUHJvcGVydHlgIHdoaWNoIHN1cHBvcnRzIGRlZXAgcGF0aHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGJhc2VQcm9wZXJ0eURlZXAocGF0aCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICByZXR1cm4gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICovXG5cblxuICBmdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICAgIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCBzdGFydCwgaWRlbnRpdHkpLCBmdW5jICsgJycpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0VG9TdHJpbmdgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAgICovXG5cblxuICB2YXIgYmFzZVNldFRvU3RyaW5nID0gIWRlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkgOiBmdW5jdGlvbiAoZnVuYywgc3RyaW5nKSB7XG4gICAgcmV0dXJuIGRlZmluZVByb3BlcnR5KGZ1bmMsICd0b1N0cmluZycsIHtcbiAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAgICd2YWx1ZSc6IGNvbnN0YW50KHN0cmluZyksXG4gICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgfSk7XG4gIH07XG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAgICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAgICovXG5cbiAgZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gICAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHZhbHVlcyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gICAgfVxuXG4gICAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gdmFsdWUgKyAnJztcbiAgICByZXR1cm4gcmVzdWx0ID09ICcwJyAmJiAxIC8gdmFsdWUgPT0gLUlORklOSVRZID8gJy0wJyA6IHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICovXG5cblxuICBmdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpO1xuICB9XG4gIC8qKlxuICAgKiBDb21wYXJlcyB2YWx1ZXMgdG8gc29ydCB0aGVtIGluIGFzY2VuZGluZyBvcmRlci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3IgZm9yIGB2YWx1ZWAuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gY29tcGFyZUFzY2VuZGluZyh2YWx1ZSwgb3RoZXIpIHtcbiAgICBpZiAodmFsdWUgIT09IG90aGVyKSB7XG4gICAgICB2YXIgdmFsSXNEZWZpbmVkID0gdmFsdWUgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgICB2YWxJc051bGwgPSB2YWx1ZSA9PT0gbnVsbCxcbiAgICAgICAgICB2YWxJc1JlZmxleGl2ZSA9IHZhbHVlID09PSB2YWx1ZSxcbiAgICAgICAgICB2YWxJc1N5bWJvbCA9IGlzU3ltYm9sKHZhbHVlKTtcbiAgICAgIHZhciBvdGhJc0RlZmluZWQgPSBvdGhlciAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgIG90aElzTnVsbCA9IG90aGVyID09PSBudWxsLFxuICAgICAgICAgIG90aElzUmVmbGV4aXZlID0gb3RoZXIgPT09IG90aGVyLFxuICAgICAgICAgIG90aElzU3ltYm9sID0gaXNTeW1ib2wob3RoZXIpO1xuXG4gICAgICBpZiAoIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wgJiYgIXZhbElzU3ltYm9sICYmIHZhbHVlID4gb3RoZXIgfHwgdmFsSXNTeW1ib2wgJiYgb3RoSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlICYmICFvdGhJc051bGwgJiYgIW90aElzU3ltYm9sIHx8IHZhbElzTnVsbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUgfHwgIXZhbElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSB8fCAhdmFsSXNSZWZsZXhpdmUpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG5cbiAgICAgIGlmICghdmFsSXNOdWxsICYmICF2YWxJc1N5bWJvbCAmJiAhb3RoSXNTeW1ib2wgJiYgdmFsdWUgPCBvdGhlciB8fCBvdGhJc1N5bWJvbCAmJiB2YWxJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUgJiYgIXZhbElzTnVsbCAmJiAhdmFsSXNTeW1ib2wgfHwgb3RoSXNOdWxsICYmIHZhbElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSB8fCAhb3RoSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlIHx8ICFvdGhJc1JlZmxleGl2ZSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8ub3JkZXJCeWAgdG8gY29tcGFyZSBtdWx0aXBsZSBwcm9wZXJ0aWVzIG9mIGEgdmFsdWUgdG8gYW5vdGhlclxuICAgKiBhbmQgc3RhYmxlIHNvcnQgdGhlbS5cbiAgICpcbiAgICogSWYgYG9yZGVyc2AgaXMgdW5zcGVjaWZpZWQsIGFsbCB2YWx1ZXMgYXJlIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIuIE90aGVyd2lzZSxcbiAgICogc3BlY2lmeSBhbiBvcmRlciBvZiBcImRlc2NcIiBmb3IgZGVzY2VuZGluZyBvciBcImFzY1wiIGZvciBhc2NlbmRpbmcgc29ydCBvcmRlclxuICAgKiBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbltdfHN0cmluZ1tdfSBvcmRlcnMgVGhlIG9yZGVyIHRvIHNvcnQgYnkgZm9yIGVhY2ggcHJvcGVydHkuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgb2JqZWN0YC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIG9iakNyaXRlcmlhID0gb2JqZWN0LmNyaXRlcmlhLFxuICAgICAgICBvdGhDcml0ZXJpYSA9IG90aGVyLmNyaXRlcmlhLFxuICAgICAgICBsZW5ndGggPSBvYmpDcml0ZXJpYS5sZW5ndGgsXG4gICAgICAgIG9yZGVyc0xlbmd0aCA9IG9yZGVycy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGNvbXBhcmVBc2NlbmRpbmcob2JqQ3JpdGVyaWFbaW5kZXhdLCBvdGhDcml0ZXJpYVtpbmRleF0pO1xuXG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIGlmIChpbmRleCA+PSBvcmRlcnNMZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9yZGVyID0gb3JkZXJzW2luZGV4XTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCAqIChvcmRlciA9PSAnZGVzYycgPyAtMSA6IDEpO1xuICAgICAgfVxuICAgIH0gLy8gRml4ZXMgYW4gYEFycmF5I3NvcnRgIGJ1ZyBpbiB0aGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIGFwcGxpY2F0aW9uc1xuICAgIC8vIHRoYXQgY2F1c2VzIGl0LCB1bmRlciBjZXJ0YWluIGNpcmN1bXN0YW5jZXMsIHRvIHByb3ZpZGUgdGhlIHNhbWUgdmFsdWUgZm9yXG4gICAgLy8gYG9iamVjdGAgYW5kIGBvdGhlcmAuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL3VuZGVyc2NvcmUvcHVsbC8xMjQ3XG4gICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAvL1xuICAgIC8vIFRoaXMgYWxzbyBlbnN1cmVzIGEgc3RhYmxlIHNvcnQgaW4gVjggYW5kIG90aGVyIGVuZ2luZXMuXG4gICAgLy8gU2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTkwIGZvciBtb3JlIGRldGFpbHMuXG5cblxuICAgIHJldHVybiBvYmplY3QuaW5kZXggLSBvdGhlci5pbmRleDtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIGBiYXNlRWFjaGAgb3IgYGJhc2VFYWNoUmlnaHRgIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2goZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuICAgICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTEsXG4gICAgICAgICAgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG5cbiAgICAgIHdoaWxlIChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBtZXRob2RzIGxpa2UgYF8uZm9ySW5gIGFuZCBgXy5mb3JPd25gLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAgICovXG5cblxuICBmdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksXG4gICAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcblxuICAgICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gICAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gICAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIG90aExlbmd0aCA9IG90aGVyLmxlbmd0aDtcblxuICAgIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cblxuXG4gICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQoYXJyYXkpO1xuXG4gICAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICAgIHNlZW4gPSBiaXRtYXNrICYgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA/IG5ldyBTZXRDYWNoZSgpIDogdW5kZWZpbmVkO1xuICAgIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICAgIHN0YWNrLnNldChvdGhlciwgYXJyYXkpOyAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdO1xuXG4gICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWwgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGNvbXBhcmVkKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG5cblxuICAgICAgaWYgKHNlZW4pIHtcbiAgICAgICAgaWYgKCFhcnJheVNvbWUob3RoZXIsIGZ1bmN0aW9uIChvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICBpZiAoIWNhY2hlSGFzKHNlZW4sIG90aEluZGV4KSAmJiAoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkpIHtcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdGFja1snZGVsZXRlJ10oYXJyYXkpO1xuICAgIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICAgKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICAgKlxuICAgKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gICAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICAgIGlmIChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoIHx8IG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgICBvdGhlciA9IG90aGVyLmJ1ZmZlcjtcblxuICAgICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgICAgaWYgKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGggfHwgIWVxdWFsRnVuYyhuZXcgVWludDhBcnJheShvYmplY3QpLCBuZXcgVWludDhBcnJheShvdGhlcikpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgIGNhc2UgYm9vbFRhZzpcbiAgICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgICAvLyBJbnZhbGlkIGRhdGVzIGFyZSBjb2VyY2VkIHRvIGBOYU5gLlxuICAgICAgICByZXR1cm4gZXEoK29iamVjdCwgK290aGVyKTtcblxuICAgICAgY2FzZSBlcnJvclRhZzpcbiAgICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcblxuICAgICAgY2FzZSByZWdleHBUYWc6XG4gICAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncywgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyxcbiAgICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuICAgICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICByZXR1cm4gb2JqZWN0ID09IG90aGVyICsgJyc7XG5cbiAgICAgIGNhc2UgbWFwVGFnOlxuICAgICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHO1xuICAgICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSk7XG5cbiAgICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG5cblxuICAgICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuXG4gICAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICAgIH1cblxuICAgICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7IC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuXG4gICAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XG4gICAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAgICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICAgIG9ialByb3BzID0gZ2V0QWxsS2V5cyhvYmplY3QpLFxuICAgICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICAgIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG5cbiAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcblxuICAgICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuXG5cbiAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuXG4gICAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgIHN0YWNrLnNldChvdGhlciwgb2JqZWN0KTtcbiAgICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWwgPyBjdXN0b21pemVyKG90aFZhbHVlLCBvYmpWYWx1ZSwga2V5LCBvdGhlciwgb2JqZWN0LCBzdGFjaykgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgICB9IC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuXG5cbiAgICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWQgPyBvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIDogY29tcGFyZWQpKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICAgIH1cblxuICAgIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgICBvdGhDdG9yID0gb3RoZXIuY29uc3RydWN0b3I7IC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuXG4gICAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmICdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIgJiYgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gICAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5cywgZ2V0U3ltYm9scyk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAgICovXG5cblxuICBmdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gICAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gICAgcmV0dXJuIGlzS2V5YWJsZShrZXkpID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddIDogZGF0YS5tYXA7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbWF0Y2ggZGF0YSBvZiBgb2JqZWN0YC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBnZXRNYXRjaERhdGEob2JqZWN0KSB7XG4gICAgdmFyIHJlc3VsdCA9IGtleXMob2JqZWN0KSxcbiAgICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgdmFyIGtleSA9IHJlc3VsdFtsZW5ndGhdLFxuICAgICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICByZXN1bHRbbGVuZ3RoXSA9IFtrZXksIHZhbHVlLCBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gICAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICAgIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG4gIH1cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICAgIHRyeSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5cbiAgICBpZiAodW5tYXNrZWQpIHtcbiAgICAgIGlmIChpc093bikge1xuICAgICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICAgKi9cblxuXG4gIHZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgcmV0dXJuIGFycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMob2JqZWN0KSwgZnVuY3Rpb24gKHN5bWJvbCkge1xuICAgICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzeW1ib2wpO1xuICAgIH0pO1xuICB9O1xuICAvKipcbiAgICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAgICovXG5cbiAgdmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7IC8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cblxuICBpZiAoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZyB8fCBNYXAgJiYgZ2V0VGFnKG5ldyBNYXAoKSkgIT0gbWFwVGFnIHx8IFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnIHx8IFNldCAmJiBnZXRUYWcobmV3IFNldCgpKSAhPSBzZXRUYWcgfHwgV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXAoKSkgIT0gd2Vha01hcFRhZykge1xuICAgIGdldFRhZyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6ICcnO1xuXG4gICAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzpcbiAgICAgICAgICAgIHJldHVybiBkYXRhVmlld1RhZztcblxuICAgICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzpcbiAgICAgICAgICAgIHJldHVybiBtYXBUYWc7XG5cbiAgICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOlxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VUYWc7XG5cbiAgICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6XG4gICAgICAgICAgICByZXR1cm4gc2V0VGFnO1xuXG4gICAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzpcbiAgICAgICAgICAgIHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrIHByb3BlcnRpZXMuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaGFzUGF0aChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpIHtcbiAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG5cbiAgICAgIGlmICghKHJlc3VsdCA9IG9iamVjdCAhPSBudWxsICYmIGhhc0Z1bmMob2JqZWN0LCBrZXkpKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdCB8fCArK2luZGV4ICE9IGxlbmd0aCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBvYmplY3QubGVuZ3RoO1xuICAgIHJldHVybiAhIWxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpICYmIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmxhdHRlbmFibGUgYGFyZ3VtZW50c2Agb2JqZWN0IG9yIGFycmF5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZmxhdHRlbmFibGUsIGVsc2UgYGZhbHNlYC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBpc0ZsYXR0ZW5hYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSB8fCAhIShzcHJlYWRhYmxlU3ltYm9sICYmIHZhbHVlICYmIHZhbHVlW3NwcmVhZGFibGVTeW1ib2xdKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICAgIHJldHVybiAhIWxlbmd0aCAmJiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSAmJiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gICAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXG4gICAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLFxuICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7XG5cbiAgICBpZiAodHlwZSA9PSAnbnVtYmVyJyA/IGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkgOiB0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdCkge1xuICAgICAgcmV0dXJuIGVxKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuICAgIGlmICh0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHwgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHwgb2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgIHJldHVybiB0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyA/IHZhbHVlICE9PSAnX19wcm90b19fJyA6IHZhbHVlID09PSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICAgIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgbWFza1NyY0tleSBpbiBmdW5jO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICAgIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICAgIHByb3RvID0gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSB8fCBvYmplY3RQcm90bztcbiAgICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaWYgc3VpdGFibGUgZm9yIHN0cmljdFxuICAgKiAgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGVsc2UgYGZhbHNlYC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgbWF0Y2hlc1Byb3BlcnR5YCBmb3Igc291cmNlIHZhbHVlcyBzdWl0YWJsZVxuICAgKiBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUoa2V5LCBzcmNWYWx1ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmIChzcmNWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8IGtleSBpbiBPYmplY3Qob2JqZWN0KSk7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1lbW9pemVgIHdoaWNoIGNsZWFycyB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24nc1xuICAgKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIG1lbW9pemVDYXBwZWQoZnVuYykge1xuICAgIHZhciByZXN1bHQgPSBtZW1vaXplKGZ1bmMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBrZXk7XG4gICAgfSk7XG4gICAgdmFyIGNhY2hlID0gcmVzdWx0LmNhY2hlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCB0cmFuc2Zvcm1zIHRoZSByZXN0IGFycmF5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgcmVzdCBhcnJheSB0cmFuc2Zvcm0uXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCB0cmFuc2Zvcm0pIHtcbiAgICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gZnVuYy5sZW5ndGggLSAxIDogc3RhcnQsIDApO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgICB9XG5cbiAgICAgIGluZGV4ID0gLTE7XG4gICAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgICB9XG5cbiAgICAgIG90aGVyQXJnc1tzdGFydF0gPSB0cmFuc2Zvcm0oYXJyYXkpO1xuICAgICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYGZ1bmNgIHRvIHJldHVybiBgc3RyaW5nYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICAgKi9cblxuXG4gIHZhciBzZXRUb1N0cmluZyA9IHNob3J0T3V0KGJhc2VTZXRUb1N0cmluZyk7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAgICogb2YgYGZ1bmNgIHdoZW4gaXQncyBjYWxsZWQgYEhPVF9DT1VOVGAgb3IgbW9yZSB0aW1lcyBpbiBgSE9UX1NQQU5gXG4gICAqIG1pbGxpc2Vjb25kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAgICovXG5cbiAgZnVuY3Rpb24gc2hvcnRPdXQoZnVuYykge1xuICAgIHZhciBjb3VudCA9IDAsXG4gICAgICAgIGxhc3RDYWxsZWQgPSAwO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RhbXAgPSBuYXRpdmVOb3coKSxcbiAgICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuICAgICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuXG4gICAgICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb3VudCA9IDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAqL1xuXG5cbiAgdmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemVDYXBwZWQoZnVuY3Rpb24gKHN0cmluZykge1xuICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgIGlmIChzdHJpbmcuY2hhckNvZGVBdCgwKSA9PT0gNDZcbiAgICAvKiAuICovXG4gICAgKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgICAgIH1cblxuICAgIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uIChtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG4gICAgICByZXN1bHQucHVzaChxdW90ZSA/IHN1YlN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiBudW1iZXIgfHwgbWF0Y2gpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0pO1xuICAvKipcbiAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfHN5bWJvbH0gUmV0dXJucyB0aGUga2V5LlxuICAgKi9cblxuICBmdW5jdGlvbiB0b0tleSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IHZhbHVlICsgJyc7XG4gICAgcmV0dXJuIHJlc3VsdCA9PSAnMCcgJiYgMSAvIHZhbHVlID09IC1JTkZJTklUWSA/ICctMCcgOiByZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZnVuYyArICcnO1xuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMsIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIgYnkgdGhlIHJlc3VsdHMgb2ZcbiAgICogcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYSBjb2xsZWN0aW9uIHRocnUgZWFjaCBpdGVyYXRlZS4gVGhpcyBtZXRob2RcbiAgICogcGVyZm9ybXMgYSBzdGFibGUgc29ydCwgdGhhdCBpcywgaXQgcHJlc2VydmVzIHRoZSBvcmlnaW5hbCBzb3J0IG9yZGVyIG9mXG4gICAqIGVxdWFsIGVsZW1lbnRzLiBUaGUgaXRlcmF0ZWVzIGFyZSBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAwLjEuMFxuICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbaXRlcmF0ZWVzPVtfLmlkZW50aXR5XV1cbiAgICogIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgdXNlcnMgPSBbXG4gICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDggfSxcbiAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH0sXG4gICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzQgfVxuICAgKiBdO1xuICAgKlxuICAgKiBfLnNvcnRCeSh1c2VycywgW2Z1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlcjsgfV0pO1xuICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNl0sIFsnYmFybmV5JywgMzRdLCBbJ2ZyZWQnLCA0OF0sIFsnZnJlZCcsIDQwXV1cbiAgICpcbiAgICogXy5zb3J0QnkodXNlcnMsIFsndXNlcicsICdhZ2UnXSk7XG4gICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsIDM0XSwgWydiYXJuZXknLCAzNl0sIFsnZnJlZCcsIDQwXSwgWydmcmVkJywgNDhdXVxuICAgKi9cblxuXG4gIHZhciBzb3J0QnkgPSBiYXNlUmVzdChmdW5jdGlvbiAoY29sbGVjdGlvbiwgaXRlcmF0ZWVzKSB7XG4gICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciBsZW5ndGggPSBpdGVyYXRlZXMubGVuZ3RoO1xuXG4gICAgaWYgKGxlbmd0aCA+IDEgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgaXRlcmF0ZWVzWzBdLCBpdGVyYXRlZXNbMV0pKSB7XG4gICAgICBpdGVyYXRlZXMgPSBbXTtcbiAgICB9IGVsc2UgaWYgKGxlbmd0aCA+IDIgJiYgaXNJdGVyYXRlZUNhbGwoaXRlcmF0ZWVzWzBdLCBpdGVyYXRlZXNbMV0sIGl0ZXJhdGVlc1syXSkpIHtcbiAgICAgIGl0ZXJhdGVlcyA9IFtpdGVyYXRlZXNbMF1dO1xuICAgIH1cblxuICAgIHJldHVybiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBiYXNlRmxhdHRlbihpdGVyYXRlZXMsIDEpLCBbXSk7XG4gIH0pO1xuICAvKipcbiAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAgICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICAgKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAgICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAgICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gICAqXG4gICAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAgICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gICAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gICAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gICAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAwLjEuMFxuICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICAgKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gICAqXG4gICAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICAgKiB2YWx1ZXMob2JqZWN0KTtcbiAgICogLy8gPT4gWzEsIDJdXG4gICAqXG4gICAqIHZhbHVlcyhvdGhlcik7XG4gICAqIC8vID0+IFszLCA0XVxuICAgKlxuICAgKiBvYmplY3QuYSA9IDI7XG4gICAqIHZhbHVlcyhvYmplY3QpO1xuICAgKiAvLyA9PiBbMSwgMl1cbiAgICpcbiAgICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gICAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAgICogdmFsdWVzKG9iamVjdCk7XG4gICAqIC8vID0+IFsnYScsICdiJ11cbiAgICpcbiAgICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAgICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAgICovXG5cbiAgZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICB9XG5cbiAgICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKSgpO1xuICAgIHJldHVybiBtZW1vaXplZDtcbiAgfSAvLyBFeHBvc2UgYE1hcENhY2hlYC5cblxuXG4gIG1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcbiAgLyoqXG4gICAqIFBlcmZvcm1zIGFcbiAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDQuMC4wXG4gICAqIEBjYXRlZ29yeSBMYW5nXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICAgKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICAgKlxuICAgKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBfLmVxKCdhJywgJ2EnKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBfLmVxKE5hTiwgTmFOKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKi9cblxuICBmdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8IHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDAuMS4wXG4gICAqIEBjYXRlZ29yeSBMYW5nXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gICAqICBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKi9cblxuXG4gIHZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cztcbiAgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJiAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xuICB9O1xuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMC4xLjBcbiAgICogQGNhdGVnb3J5IExhbmdcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICpcbiAgICogXy5pc0FycmF5KCdhYmMnKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICpcbiAgICogXy5pc0FycmF5KF8ubm9vcCk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqL1xuXG4gIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAgICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICAgKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSA0LjAuMFxuICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSA0LjMuMFxuICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICovXG5cblxuICB2YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDAuMS4wXG4gICAqIEBjYXRlZ29yeSBMYW5nXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uaXNGdW5jdGlvbihfKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKi9cblxuICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAgIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuXG5cbiAgICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gICAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAgICpcbiAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAgICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgNC4wLjBcbiAgICogQGNhdGVnb3J5IExhbmdcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uaXNMZW5ndGgoMyk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICpcbiAgICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIF8uaXNMZW5ndGgoJzMnKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICovXG5cblxuICBmdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAgICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICAgKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDAuMS4wXG4gICAqIEBjYXRlZ29yeSBMYW5nXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pc09iamVjdCh7fSk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzT2JqZWN0KG51bGwpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gICAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgNC4wLjBcbiAgICogQGNhdGVnb3J5IExhbmdcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JztcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDQuMC4wXG4gICAqIEBjYXRlZ29yeSBMYW5nXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8IGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDMuMC4wXG4gICAqIEBjYXRlZ29yeSBMYW5nXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqL1xuXG5cbiAgdmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuICAvKipcbiAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAgICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDQuMC4wXG4gICAqIEBjYXRlZ29yeSBMYW5nXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8udG9TdHJpbmcobnVsbCk7XG4gICAqIC8vID0+ICcnXG4gICAqXG4gICAqIF8udG9TdHJpbmcoLTApO1xuICAgKiAvLyA9PiAnLTAnXG4gICAqXG4gICAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAgICogLy8gPT4gJzEsMiwzJ1xuICAgKi9cblxuICBmdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIHRoZSByZXNvbHZlZCB2YWx1ZSBpc1xuICAgKiBgdW5kZWZpbmVkYCwgdGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGluIGl0cyBwbGFjZS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMy43LjBcbiAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAgICpcbiAgICogXy5nZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAgICogLy8gPT4gM1xuICAgKlxuICAgKiBfLmdldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAgICogLy8gPT4gM1xuICAgKlxuICAgKiBfLmdldChvYmplY3QsICdhLmIuYycsICdkZWZhdWx0Jyk7XG4gICAqIC8vID0+ICdkZWZhdWx0J1xuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSA0LjAuMFxuICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gICAqXG4gICAqIF8uaGFzSW4ob2JqZWN0LCAnYScpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaGFzSW4ob2JqZWN0LCAnYS5iJyk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5oYXNJbihvYmplY3QsIFsnYScsICdiJ10pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaGFzSW4ob2JqZWN0LCAnYicpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhc0luKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gICAqXG4gICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gICAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAc2luY2UgMC4xLjBcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICogICB0aGlzLmEgPSAxO1xuICAgKiAgIHRoaXMuYiA9IDI7XG4gICAqIH1cbiAgICpcbiAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICpcbiAgICogXy5rZXlzKG5ldyBGb28pO1xuICAgKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAqXG4gICAqIF8ua2V5cygnaGknKTtcbiAgICogLy8gPT4gWycwJywgJzEnXVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gICAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDIuNC4wXG4gICAqIEBjYXRlZ29yeSBVdGlsXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbnN0YW50IGZ1bmN0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgb2JqZWN0cyA9IF8udGltZXMoMiwgXy5jb25zdGFudCh7ICdhJzogMSB9KSk7XG4gICAqXG4gICAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICAgKiAvLyA9PiBbeyAnYSc6IDEgfSwgeyAnYSc6IDEgfV1cbiAgICpcbiAgICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gICAqIC8vID0+IHRydWVcbiAgICovXG5cblxuICBmdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQHNpbmNlIDAuMS4wXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBVdGlsXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAgICpcbiAgICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMi40LjBcbiAgICogQGNhdGVnb3J5IFV0aWxcbiAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciBvYmplY3RzID0gW1xuICAgKiAgIHsgJ2EnOiB7ICdiJzogMiB9IH0sXG4gICAqICAgeyAnYSc6IHsgJ2InOiAxIH0gfVxuICAgKiBdO1xuICAgKlxuICAgKiBfLm1hcChvYmplY3RzLCBfLnByb3BlcnR5KCdhLmInKSk7XG4gICAqIC8vID0+IFsyLCAxXVxuICAgKlxuICAgKiBfLm1hcChfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJ10pKSwgJ2EuYicpO1xuICAgKiAvLyA9PiBbMSwgMl1cbiAgICovXG5cblxuICBmdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gICAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5KHRvS2V5KHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDQuMTMuMFxuICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICAgKlxuICAgKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICAgKiAvLyA9PiBbW10sIFtdXVxuICAgKlxuICAgKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICAvKipcbiAgICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSA0LjEzLjBcbiAgICogQGNhdGVnb3J5IFV0aWxcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gICAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIG1vZHVsZS5leHBvcnRzID0gc29ydEJ5O1xuICB9KTtcblxuICB2YXIgQ2xpcENoYW5uZWwgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uIChfQ2hhbm5lbCkge1xuICAgIF9pbmhlcml0cyhDbGlwQ2hhbm5lbCwgX0NoYW5uZWwpO1xuXG4gICAgZnVuY3Rpb24gQ2xpcENoYW5uZWwoKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2xpcENoYW5uZWwpO1xuXG4gICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKENsaXBDaGFubmVsKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoQ2xpcENoYW5uZWwsIFt7XG4gICAgICBrZXk6IFwib25Jbml0aWFsaXNlXCIsXG5cbiAgICAgIC8qXG4gICAgICAgIHRoaXMuaW5jaWRlbnRzIGlzIGEgY29sbGVjdGlvbiBvZiB7aW5jaWRlbnQsIGlkLCBtaWxsaXNlY29uZH0gb2JqZWN0cyBhbHdheXMga2VwdCBpbiBvcmRlclxuICAgICAgICAgICAgZnJvbSBsb3dlciB0byBoaWdoZXIgbWlsbGlzZWNvbmRcbiAgICAgICAgdGhpcy5pbmNpZGV0bnNCeUlkIGlzIGFuIGluZGV4IG9mIHRoZSBpbmNpZGVudHMga2VwdCBieSBpZCAodGhpcy5pbmNpZGVudHNbaW5jaWRlbnQtaWRdID0gSW5jaWRlbnQpXG4gICAgICAgICovXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gb25Jbml0aWFsaXNlKCkge1xuICAgICAgICB0aGlzLmluY2lkZW50cyA9IFtdO1xuICAgICAgICB0aGlzLmluY2lkZW50c0J5SWQgPSB7fTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2luY2lkZW50QnlJZFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pbmNpZGVudEJ5SWQoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5jaWRlbnRzQnlJZFtpZF07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9yZXNpemVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzaXplKGR1cmF0aW9uRnJhY3Rpb24pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmluY2lkZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuaW5jaWRlbnRzW2ldLm1pbGxpc2Vjb25kID0gdGhpcy5pbmNpZGVudHNbaV0ubWlsbGlzZWNvbmQgKiBkdXJhdGlvbkZyYWN0aW9uO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge2FycmF5fSBpbmNpZGVudHMgLSBhIGNvbGxlY2l0b24gb2YgYWxsIGluY2lkZW50cyB0byBiZSBhZGRlZCBvbiB0aGUgZm9ybTpcbiAgICAgICAgKlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlkXG4gICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRcbiAgICAgICAgICAgICAgICBpbmNpZGVudFxuICAgICAgICAgICAgfVxuICAgICAgICAqIEByZXR1cm5zIHtvYmplY3R9IC1cbiAgICAgICAgKiBlaXRoZXI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmVzdWx0OnRydWUsXG4gICAgICAgICAgICAgICAgZXhlY3V0ZTogLy8gYSBmdW5jdGlvbiB0aGF0IHdoZW4gZXhlY3V0ZWQgaXQgd2lsbCBhZGQgdGhlIEluY2lkZW50cyBvbiB0aGUgQ2hhbm5lbHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9yXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmVzdWx0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjaGVja0FkZGl0aW9uXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tBZGRpdGlvbihpbmNpZGVudHMpIHtcbiAgICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgICB2YXIgY2FuZGlkYXRlSW5jaWRlbnRzQnlJZCA9IHt9O1xuICAgICAgICB2YXIgaW5jaWRlbnRzVG9Db25jYXQgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluY2lkZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNhbmRpZGF0ZUluY2lkZW50c0J5SWRbaW5jaWRlbnRzW2ldLmlkXSA9IGluY2lkZW50c1tpXS5pbmNpZGVudDtcbiAgICAgICAgICBpbmNpZGVudHNUb0NvbmNhdC5wdXNoKHtcbiAgICAgICAgICAgIGlkOiBpbmNpZGVudHNbaV0uaWQsXG4gICAgICAgICAgICBtaWxsaXNlY29uZDogaW5jaWRlbnRzW2ldLm1pbGxpc2Vjb25kXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuaW5jaWRlbnRzQnlJZCwgaW5jaWRlbnRzW2ldLmlkKSkge1xuICAgICAgICAgICAgaGVscGVyLmVycm9yKFwiSW5jaWRlbnQgd2l0aCB0aGUgaWQgXCIuY29uY2F0KGluY2lkZW50c1tpXS5pZCwgXCIgYWxyZWFkeSBleGlzdHMuIEFkZGl0aW9uIGlzIHJlamVjdGVkLlwiKSk7XG4gICAgICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgIHR5cGU6ICdBbHJlYWR5IGV4aXN0aW5nIGlkJyxcbiAgICAgICAgICAgICAgbWV0YToge1xuICAgICAgICAgICAgICAgIGlkOiBpbmNpZGVudHNbaV0uaWRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcnM6IGVycm9yc1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGV4ZWMgPSBmdW5jdGlvbiBleGVjRnVuY3QoKSB7XG4gICAgICAgICAgdGhhdC5pbmNpZGVudHNCeUlkID0gT2JqZWN0LmFzc2lnbih0aGF0LmluY2lkZW50c0J5SWQsIGNhbmRpZGF0ZUluY2lkZW50c0J5SWQpO1xuICAgICAgICAgIHRoYXQuaW5jaWRlbnRzID0gdGhhdC5pbmNpZGVudHMuY29uY2F0KGluY2lkZW50c1RvQ29uY2F0KTtcbiAgICAgICAgICB0aGF0LmluY2lkZW50cyA9IGxvZGFzaF9zb3J0YnkodGhhdC5pbmNpZGVudHMsIFtmdW5jdGlvbiAobGFuZUl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBsYW5lSXRlbS5taWxsaXNlY29uZDtcbiAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgaW5jaWRlbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdGhhdC5faW5jaWRlbnRCeUlkKGluY2lkZW50c1tfaV0uaWQpLl9vbkdldENvbnRleHRPbmNlKHRoYXQuY29udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzdWx0OiB0cnVlLFxuICAgICAgICAgIGV4ZWN1dGU6IGV4ZWNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICBAcGFyYW0ge2FycmF5fSBpbmNpZGVudHNBcnJheSAtIEEgY29sbGVjdGlvbiBvZiB0aGUgSW5jaWRldG5zIHRvIGdldCBlZGl0ZWQgaW4gdGhlIGZvcm06XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlkXG4gICAgICAgICAgICBtaWxsaXNlY29uZFxuICAgICAgICAgICAgaW5jaWRlbnRcbiAgICAgICAgfVxuICAgICAgICBAcGFyYW0ge2ludH0gbWlsbGlzZWNvbmRzRGVsdGEtIHRoZSBkZWx0YSBvZiB0aGUgc3RhciBwb2ludCBvZiB0aGUgcHJvdmlkZWQgaW5jaWRlbnRzXG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY2hlY2tFZGl0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tFZGl0KGluY2lkZW50c0FycmF5LCBtaWxsaXNlY29uZHNEZWx0YSkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGV4ZWMgPSBmdW5jdGlvbiBleGVjRnVuY3QoKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmNpZGVudHNBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGF0LmluY2lkZW50cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICBpZiAodGhhdC5pbmNpZGVudHNbal0uaWQgPT09IGluY2lkZW50c0FycmF5W2ldLmlkKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5pbmNpZGVudHNbal0ubWlsbGlzZWNvbmQgKz0gbWlsbGlzZWNvbmRzRGVsdGE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGF0LmluY2lkZW50cyA9IGxvZGFzaF9zb3J0YnkodGhhdC5pbmNpZGVudHMsIFtmdW5jdGlvbiAobGFuZUl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBsYW5lSXRlbS5taWxsaXNlY29uZDtcbiAgICAgICAgICB9XSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXN1bHQ6IHRydWUsXG4gICAgICAgICAgZXhlY3V0ZTogZXhlY1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjaGVja0RlbGV0ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrRGVsZXRlKGluY2lkZW50c0FycmF5KSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdmFyIGluY2lkZW50SWRzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmNpZGVudHNBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGluY2lkZW50SWRzLnB1c2goaW5jaWRlbnRzQXJyYXlbaV0uaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGV4ZWMgPSBmdW5jdGlvbiBleGVjRnVuY3QoKSB7XG4gICAgICAgICAgdmFyIG5ld0luY2lkZW50cyA9IGxvZGFzaF9maWx0ZXIodGhhdC5pbmNpZGVudHMsIGZ1bmN0aW9uIChpbmNpZGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGluY2lkZW50SWRzLmluZGV4T2YoaW5jaWRlbnQuaWQpID09PSAtMTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHRoYXQuaW5jaWRlbnRzID0gbmV3SW5jaWRlbnRzO1xuXG4gICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgaW5jaWRlbnRJZHMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgICAgZGVsZXRlIHRoYXQuaW5jaWRlbnRzQnlJZFtpbmNpZGVudElkc1tfaTJdXTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXN1bHQ6IHRydWUsXG4gICAgICAgICAgZXhlY3V0ZTogZXhlY1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge2FycmF5fSBpbmNpZGVudHMgLSBbe2lkLCBzdGFydCwgZW5kLCBzdGFydERlbHRhfV1cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImNoZWNrUmVzaXplZEluY2lkZW50c1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrUmVzaXplZEluY2lkZW50cyhpbmNpZGVudHMpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgIHZhciBleGVjID0gZnVuY3Rpb24gZXhlY0Z1bmN0KCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5jaWRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoYXQuaW5jaWRlbnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIGlmICh0aGF0LmluY2lkZW50c1tqXS5pZCA9PT0gaW5jaWRlbnRzW2ldLmlkKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5pbmNpZGVudHNbal0ubWlsbGlzZWNvbmQgKz0gaW5jaWRlbnRzW2ldLnN0YXJ0RGVsdGE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGF0LmluY2lkZW50cyA9IGxvZGFzaF9zb3J0YnkodGhhdC5pbmNpZGVudHMsIFtmdW5jdGlvbiAobGFuZUl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBsYW5lSXRlbS5taWxsaXNlY29uZDtcbiAgICAgICAgICB9XSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXN1bHQ6IHRydWUsXG4gICAgICAgICAgZXhlY3V0ZTogZXhlY1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgICBAcGFyYW0ge2ludH0gZnJvbSAtIHRoZSBtaWxsaXNlY29uZCB0byBzdGFydCBmcm9tXG4gICAgICAgICBAcGFyYW0ge2ludH0gdG8gLSB0aGUgbWlsbGlzZWNvbmQgdG8gZ28gdG9cbiAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBjb250ZXh0SWQgLSB0aGUgY29udGV4dCBpZCB0byBtb3ZlXG4gICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlUmVzZXQgLSBzZXQgdG8gdHJ1ZSB3aGVuIHdlIHdhbnQgZnVsbCBmbGFzaFxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJtb3ZlVG9cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlVG8oZnJvbSwgdG8sIGNvbnRleHRJZCkge1xuICAgICAgICB2YXIgZm9yY2VSZXNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG5cbiAgICAgICAgaWYgKGZvcmNlUmVzZXQgPT09IHRydWUpIHtcbiAgICAgICAgICAvLyBpbmNpZGVudHM6IFt7aWQsIG1pbGxpc2Vjb25kfSwge30sIHt9Li4uXVxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBsYW5lSXRlbSA9IHRoaXMuaW5jaWRlbnRzW2ldO1xuXG4gICAgICAgICAgICB2YXIgaW5jaWRlbnQgPSB0aGlzLl9pbmNpZGVudEJ5SWQobGFuZUl0ZW0uaWQpO1xuXG4gICAgICAgICAgICBpZiAodG8gPCBsYW5lSXRlbS5taWxsaXNlY29uZCkge1xuICAgICAgICAgICAgICBpbmNpZGVudC5vblByb2dyZXNzKDAsIDAsIGNvbnRleHRJZCwgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRvID4gbGFuZUl0ZW0ubWlsbGlzZWNvbmQgKyBpbmNpZGVudC5kdXJhdGlvbikge1xuICAgICAgICAgICAgICBpbmNpZGVudC5vblByb2dyZXNzKDEsIGluY2lkZW50LmR1cmF0aW9uLCBjb250ZXh0SWQsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaW5jaWRlbnQub25Qcm9ncmVzcygodG8gLSBsYW5lSXRlbS5taWxsaXNlY29uZCkgLyBpbmNpZGVudC5kdXJhdGlvbiwgdG8gLSBsYW5lSXRlbS5taWxsaXNlY29uZCwgY29udGV4dElkLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgIHZhciBwYXJ0aWNpcGF0aW5nSXRlbXM7XG5cbiAgICAgICAgICBpZiAodG8gPiBmcm9tKSB7XG4gICAgICAgICAgICBwYXJ0aWNpcGF0aW5nSXRlbXMgPSBsb2Rhc2hfZmlsdGVyKHRoaXMuaW5jaWRlbnRzLCBmdW5jdGlvbiAobGFuZUl0ZW0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuICgvLyBpdCBlbmRzIGFmdGVyIGZyb20gYW5kIGJlZm9yZSB0byBtaWxsaXNlY29uZFxuICAgICAgICAgICAgICAgIC8vIG9yIGl0IGVuZHMgYWZ0ZXIgdGhlIHRhcmdldCBtaWxsaXNlY29uZCBidXQgYWxzbyBzdGFydHMgYmVmb3JlIGl0XG4gICAgICAgICAgICAgICAgbGFuZUl0ZW0ubWlsbGlzZWNvbmQgKyB0aGF0Ll9pbmNpZGVudEJ5SWQobGFuZUl0ZW0uaWQpLmR1cmF0aW9uID49IGZyb20gJiYgbGFuZUl0ZW0ubWlsbGlzZWNvbmQgKyB0aGF0Ll9pbmNpZGVudEJ5SWQobGFuZUl0ZW0uaWQpLmR1cmF0aW9uIDw9IHRvIHx8IHRoYXQuX2luY2lkZW50QnlJZChsYW5lSXRlbS5pZCkuZHVyYXRpb24gKyBsYW5lSXRlbS5taWxsaXNlY29uZCA+PSB0byAmJiBsYW5lSXRlbS5taWxsaXNlY29uZCA8PSB0b1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnRpY2lwYXRpbmdJdGVtcyA9IGxvZGFzaF9maWx0ZXIodGhpcy5pbmNpZGVudHMsIGZ1bmN0aW9uIChsYW5lSXRlbSkge1xuICAgICAgICAgICAgICByZXR1cm4gKC8vIGl0IGVuZHMgYWZ0ZXIgZnJvbSBhbmQgYmVmb3JlIHRvIG1pbGxpc2Vjb25kXG4gICAgICAgICAgICAgICAgLy8gb3IgaXQgZW5kcyBhZnRlciB0aGUgdGFyZ2V0IG1pbGxpc2Vjb25kIGJ1dCBhbHNvIHN0YXJ0cyBiZWZvcmUgaXRcbiAgICAgICAgICAgICAgICBsYW5lSXRlbS5taWxsaXNlY29uZCArIHRoYXQuX2luY2lkZW50QnlJZChsYW5lSXRlbS5pZCkuZHVyYXRpb24gPj0gdG8gJiYgbGFuZUl0ZW0ubWlsbGlzZWNvbmQgKyB0aGF0Ll9pbmNpZGVudEJ5SWQobGFuZUl0ZW0uaWQpLmR1cmF0aW9uIDw9IGZyb20gfHwgdGhhdC5faW5jaWRlbnRCeUlkKGxhbmVJdGVtLmlkKS5kdXJhdGlvbiArIGxhbmVJdGVtLm1pbGxpc2Vjb25kID49IGZyb20gJiYgbGFuZUl0ZW0ubWlsbGlzZWNvbmQgPD0gZnJvbVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgcGFydGljaXBhdGluZ0l0ZW1zLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgICAgICAgIHZhciBfbGFuZUl0ZW0gPSBwYXJ0aWNpcGF0aW5nSXRlbXNbX2kzXTtcblxuICAgICAgICAgICAgdmFyIGNvbnRleHRBd2FyZUNsaXBJbmNpZGVudCA9IHRoaXMuX2luY2lkZW50QnlJZChfbGFuZUl0ZW0uaWQpOyAvLyBvblByb2dyZXNzKGZyYWN0aW9uLCBtaWxsaXNlY29uZHMsIGNvbnRleHRJZCwgZm9yY2VSZXNldCA9IGZhbHNlKSB7XG5cblxuICAgICAgICAgICAgdmFyIG92ZXJjYW1lRW5kID0gKHRvIC0gX2xhbmVJdGVtLm1pbGxpc2Vjb25kKSAvIGNvbnRleHRBd2FyZUNsaXBJbmNpZGVudC5kdXJhdGlvbiA+PSAxO1xuICAgICAgICAgICAgdmFyIGZyYWN0aW9uID0gb3ZlcmNhbWVFbmQgPyAxIDogKHRvIC0gX2xhbmVJdGVtLm1pbGxpc2Vjb25kKSAvIGNvbnRleHRBd2FyZUNsaXBJbmNpZGVudC5kdXJhdGlvbjtcbiAgICAgICAgICAgIHZhciBtaWxsaXNlY29uZCA9IG92ZXJjYW1lRW5kID8gY29udGV4dEF3YXJlQ2xpcEluY2lkZW50LmR1cmF0aW9uIDogdG8gLSBfbGFuZUl0ZW0ubWlsbGlzZWNvbmQ7XG4gICAgICAgICAgICBjb250ZXh0QXdhcmVDbGlwSW5jaWRlbnQub25Qcm9ncmVzcyhmcmFjdGlvbiwgbWlsbGlzZWNvbmQsIGNvbnRleHRJZCwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyB0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCA9IHRvO1xuXG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIENsaXBDaGFubmVsO1xuICB9KENoYW5uZWwpO1xuXG4gIC8qKlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vZ3JlL2Jlemllci1lYXNpbmdcbiAgICogQmV6aWVyRWFzaW5nIC0gdXNlIGJlemllciBjdXJ2ZSBmb3IgdHJhbnNpdGlvbiBlYXNpbmcgZnVuY3Rpb25cbiAgICogYnkgR2HDq3RhbiBSZW5hdWRlYXUgMjAxNCAtIDIwMTUg4oCTIE1JVCBMaWNlbnNlXG4gICAqL1xuICAvLyBUaGVzZSB2YWx1ZXMgYXJlIGVzdGFibGlzaGVkIGJ5IGVtcGlyaWNpc20gd2l0aCB0ZXN0cyAodHJhZGVvZmY6IHBlcmZvcm1hbmNlIFZTIHByZWNpc2lvbilcbiAgdmFyIE5FV1RPTl9JVEVSQVRJT05TID0gNDtcbiAgdmFyIE5FV1RPTl9NSU5fU0xPUEUgPSAwLjAwMTtcbiAgdmFyIFNVQkRJVklTSU9OX1BSRUNJU0lPTiA9IDAuMDAwMDAwMTtcbiAgdmFyIFNVQkRJVklTSU9OX01BWF9JVEVSQVRJT05TID0gMTA7XG4gIHZhciBrU3BsaW5lVGFibGVTaXplID0gMTE7XG4gIHZhciBrU2FtcGxlU3RlcFNpemUgPSAxLjAgLyAoa1NwbGluZVRhYmxlU2l6ZSAtIDEuMCk7XG4gIHZhciBmbG9hdDMyQXJyYXlTdXBwb3J0ZWQgPSB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAnZnVuY3Rpb24nO1xuXG4gIGZ1bmN0aW9uIEEoYUExLCBhQTIpIHtcbiAgICByZXR1cm4gMS4wIC0gMy4wICogYUEyICsgMy4wICogYUExO1xuICB9XG5cbiAgZnVuY3Rpb24gQihhQTEsIGFBMikge1xuICAgIHJldHVybiAzLjAgKiBhQTIgLSA2LjAgKiBhQTE7XG4gIH1cblxuICBmdW5jdGlvbiBDKGFBMSkge1xuICAgIHJldHVybiAzLjAgKiBhQTE7XG4gIH0gLy8gUmV0dXJucyB4KHQpIGdpdmVuIHQsIHgxLCBhbmQgeDIsIG9yIHkodCkgZ2l2ZW4gdCwgeTEsIGFuZCB5Mi5cblxuXG4gIGZ1bmN0aW9uIGNhbGNCZXppZXIoYVQsIGFBMSwgYUEyKSB7XG4gICAgcmV0dXJuICgoQShhQTEsIGFBMikgKiBhVCArIEIoYUExLCBhQTIpKSAqIGFUICsgQyhhQTEpKSAqIGFUO1xuICB9IC8vIFJldHVybnMgZHgvZHQgZ2l2ZW4gdCwgeDEsIGFuZCB4Miwgb3IgZHkvZHQgZ2l2ZW4gdCwgeTEsIGFuZCB5Mi5cblxuXG4gIGZ1bmN0aW9uIGdldFNsb3BlKGFULCBhQTEsIGFBMikge1xuICAgIHJldHVybiAzLjAgKiBBKGFBMSwgYUEyKSAqIGFUICogYVQgKyAyLjAgKiBCKGFBMSwgYUEyKSAqIGFUICsgQyhhQTEpO1xuICB9XG5cbiAgZnVuY3Rpb24gYmluYXJ5U3ViZGl2aWRlKGFYLCBhQSwgYUIsIG1YMSwgbVgyKSB7XG4gICAgdmFyIGN1cnJlbnRYLFxuICAgICAgICBjdXJyZW50VCxcbiAgICAgICAgaSA9IDA7XG5cbiAgICBkbyB7XG4gICAgICBjdXJyZW50VCA9IGFBICsgKGFCIC0gYUEpIC8gMi4wO1xuICAgICAgY3VycmVudFggPSBjYWxjQmV6aWVyKGN1cnJlbnRULCBtWDEsIG1YMikgLSBhWDtcblxuICAgICAgaWYgKGN1cnJlbnRYID4gMC4wKSB7XG4gICAgICAgIGFCID0gY3VycmVudFQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhQSA9IGN1cnJlbnRUO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKE1hdGguYWJzKGN1cnJlbnRYKSA+IFNVQkRJVklTSU9OX1BSRUNJU0lPTiAmJiArK2kgPCBTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyk7XG5cbiAgICByZXR1cm4gY3VycmVudFQ7XG4gIH1cblxuICBmdW5jdGlvbiBuZXd0b25SYXBoc29uSXRlcmF0ZShhWCwgYUd1ZXNzVCwgbVgxLCBtWDIpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5FV1RPTl9JVEVSQVRJT05TOyArK2kpIHtcbiAgICAgIHZhciBjdXJyZW50U2xvcGUgPSBnZXRTbG9wZShhR3Vlc3NULCBtWDEsIG1YMik7XG5cbiAgICAgIGlmIChjdXJyZW50U2xvcGUgPT09IDAuMCkge1xuICAgICAgICByZXR1cm4gYUd1ZXNzVDtcbiAgICAgIH1cblxuICAgICAgdmFyIGN1cnJlbnRYID0gY2FsY0JlemllcihhR3Vlc3NULCBtWDEsIG1YMikgLSBhWDtcbiAgICAgIGFHdWVzc1QgLT0gY3VycmVudFggLyBjdXJyZW50U2xvcGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFHdWVzc1Q7XG4gIH1cblxuICBmdW5jdGlvbiBMaW5lYXJFYXNpbmcoeCkge1xuICAgIHJldHVybiB4O1xuICB9XG5cbiAgdmFyIHNyYyA9IGZ1bmN0aW9uIGJlemllcihtWDEsIG1ZMSwgbVgyLCBtWTIpIHtcbiAgICBpZiAoISgwIDw9IG1YMSAmJiBtWDEgPD0gMSAmJiAwIDw9IG1YMiAmJiBtWDIgPD0gMSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYmV6aWVyIHggdmFsdWVzIG11c3QgYmUgaW4gWzAsIDFdIHJhbmdlJyk7XG4gICAgfVxuXG4gICAgaWYgKG1YMSA9PT0gbVkxICYmIG1YMiA9PT0gbVkyKSB7XG4gICAgICByZXR1cm4gTGluZWFyRWFzaW5nO1xuICAgIH0gLy8gUHJlY29tcHV0ZSBzYW1wbGVzIHRhYmxlXG5cblxuICAgIHZhciBzYW1wbGVWYWx1ZXMgPSBmbG9hdDMyQXJyYXlTdXBwb3J0ZWQgPyBuZXcgRmxvYXQzMkFycmF5KGtTcGxpbmVUYWJsZVNpemUpIDogbmV3IEFycmF5KGtTcGxpbmVUYWJsZVNpemUpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrU3BsaW5lVGFibGVTaXplOyArK2kpIHtcbiAgICAgIHNhbXBsZVZhbHVlc1tpXSA9IGNhbGNCZXppZXIoaSAqIGtTYW1wbGVTdGVwU2l6ZSwgbVgxLCBtWDIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFRGb3JYKGFYKSB7XG4gICAgICB2YXIgaW50ZXJ2YWxTdGFydCA9IDAuMDtcbiAgICAgIHZhciBjdXJyZW50U2FtcGxlID0gMTtcbiAgICAgIHZhciBsYXN0U2FtcGxlID0ga1NwbGluZVRhYmxlU2l6ZSAtIDE7XG5cbiAgICAgIGZvciAoOyBjdXJyZW50U2FtcGxlICE9PSBsYXN0U2FtcGxlICYmIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSA8PSBhWDsgKytjdXJyZW50U2FtcGxlKSB7XG4gICAgICAgIGludGVydmFsU3RhcnQgKz0ga1NhbXBsZVN0ZXBTaXplO1xuICAgICAgfVxuXG4gICAgICAtLWN1cnJlbnRTYW1wbGU7IC8vIEludGVycG9sYXRlIHRvIHByb3ZpZGUgYW4gaW5pdGlhbCBndWVzcyBmb3IgdFxuXG4gICAgICB2YXIgZGlzdCA9IChhWCAtIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSkgLyAoc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGUgKyAxXSAtIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSk7XG4gICAgICB2YXIgZ3Vlc3NGb3JUID0gaW50ZXJ2YWxTdGFydCArIGRpc3QgKiBrU2FtcGxlU3RlcFNpemU7XG4gICAgICB2YXIgaW5pdGlhbFNsb3BlID0gZ2V0U2xvcGUoZ3Vlc3NGb3JULCBtWDEsIG1YMik7XG5cbiAgICAgIGlmIChpbml0aWFsU2xvcGUgPj0gTkVXVE9OX01JTl9TTE9QRSkge1xuICAgICAgICByZXR1cm4gbmV3dG9uUmFwaHNvbkl0ZXJhdGUoYVgsIGd1ZXNzRm9yVCwgbVgxLCBtWDIpO1xuICAgICAgfSBlbHNlIGlmIChpbml0aWFsU2xvcGUgPT09IDAuMCkge1xuICAgICAgICByZXR1cm4gZ3Vlc3NGb3JUO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGJpbmFyeVN1YmRpdmlkZShhWCwgaW50ZXJ2YWxTdGFydCwgaW50ZXJ2YWxTdGFydCArIGtTYW1wbGVTdGVwU2l6ZSwgbVgxLCBtWDIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiBCZXppZXJFYXNpbmcoeCkge1xuICAgICAgLy8gQmVjYXVzZSBKYXZhU2NyaXB0IG51bWJlciBhcmUgaW1wcmVjaXNlLCB3ZSBzaG91bGQgZ3VhcmFudGVlIHRoZSBleHRyZW1lcyBhcmUgcmlnaHQuXG4gICAgICBpZiAoeCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYWxjQmV6aWVyKGdldFRGb3JYKHgpLCBtWTEsIG1ZMik7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBnZXRJbmNpZGVudHNCeUNoYW5uZWwocGxkKSB7XG4gICAgcGxkLmRlc2NyaXB0b3IudmFsdWUgPSBmdW5jdGlvbiBnZXRJbmNpZGVudHNCeUNoYW5uZWxGdW5jdCgpIHtcbiAgICAgIHZhciBhZGp1c3RNaWxsaXNlY29uZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgIHZhciBwYXJlbnRNaWxsaXNlY29uZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICAgIHZhciBpbmNpZGVudHNCeVBsdWdpbiA9IHt9O1xuICAgICAgaW5jaWRlbnRzQnlQbHVnaW5bdGhpcy5tY19wbHVnaW5fbnBtX25hbWVdID0gW3tcbiAgICAgICAgbWlsbGlzZWNvbmQ6IGFkanVzdE1pbGxpc2Vjb25kLFxuICAgICAgICBwYXJlbnRNaWxsaXNlY29uZDogcGFyZW50TWlsbGlzZWNvbmQsXG4gICAgICAgIGluY2lkZW50OiB0aGlzLFxuICAgICAgICBpZDogdGhpcy5pZFxuICAgICAgfV07XG4gICAgICByZXR1cm4gaW5jaWRlbnRzQnlQbHVnaW47XG4gICAgfTtcbiAgfVxuXG4gIC8qXG4gIGRuYTpcbiAgLSBvcmlnaW5hbElkXG4gIC0gY29udGV4dFxuICAqL1xuXG4gIHZhciBNb25vSW5jaWRlbnQgPSBfZGVjb3JhdGUobnVsbCwgZnVuY3Rpb24gKF9pbml0aWFsaXplKSB7XG4gICAgdmFyIE1vbm9JbmNpZGVudCA9IGZ1bmN0aW9uIE1vbm9JbmNpZGVudCgpIHtcbiAgICAgIHZhciBhdHRycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgdmFyIGRuYSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTW9ub0luY2lkZW50KTtcblxuICAgICAgX2luaXRpYWxpemUodGhpcyk7XG5cbiAgICAgIC8vIHN1cGVyKHByb3BzKTtcbiAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgIHRoaXMuZG5hID0gZG5hO1xuICAgICAgdGhpcy5jb250ZXh0ID0gZG5hLmNvbnRleHQ7XG4gICAgICB0aGlzLm1jaWQgPSBkbmEubWNpZDtcbiAgICAgIHRoaXMuaWQgPSBwcm9wcy5pZCB8fCBnZXRBbklkKCk7XG4gICAgICB0aGlzLm1vZGVsSWQgPSBwcm9wcy5tb2RlbElkOyAvLyB0aGlzIHBhcmFtZXRlciBpcyBpbml0aWFsaXNlZCB0byBmYWxzZS4gT25jZSB0aGUgb25HZXRDb250ZXh0IG1ldGhvZCBnZXRzIGludm9rZWQgdGhpcyBwYXJhbWV0ZXJcbiAgICAgIC8vIGlzIHNldCB0byB0cnVlIHNvIHdlIHByZXZlbnQgbXVsdGlwbGUgZXhlY3V0aW9ucyBvZiB0aGUgb25HZXRDb250ZXh0IG1ldGhvZFxuXG4gICAgICB0aGlzLmdvdENvbnRleHQgPSBmYWxzZTtcbiAgICAgIC8qXG4gICAgICAgICAgdGhlc2UgYXJlIHRoZSBkZWZhdWx0IHZhbHVlcyB0aGF0IGRlZmluZSBjaGFubmVsaW5nIGZvciB0aGUgZGVmYXVsdCBJbmNpZGVudHMuIFRoZXNlIHZhbHVlcyBnZXQgb3Zld3JpZGVuIHRocm91Z2hcbiAgICAgICAgICB0aGUgbG9hZFBsdWdpbiBtZXRob2Qgb2YgTUMgd2l0aCB0aGUgdmFsdWVzIGZvdW5kIG9uIHRoZSBtYWluLmpzIGZpbGUgb2YgdGhlIHBsdWdpblxuICAgICAgICAgICovXG5cbiAgICAgIHRoaXMucGx1Z2luX2NoYW5uZWxfY2xhc3MgPSBDaGFubmVsO1xuICAgICAgdGhpcy5tY19wbHVnaW5fbnBtX25hbWUgPSAnbW90b3ItY29ydGV4LWpzJztcblxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgJ3BsdWdpbl9jaGFubmVsX2NsYXNzJykpIHtcbiAgICAgICAgdGhpcy5wbHVnaW5fY2hhbm5lbF9jbGFzcyA9IHByb3BzLnBsdWdpbl9jaGFubmVsX2NsYXNzO1xuICAgICAgfVxuXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAnbWNfcGx1Z2luX25wbV9uYW1lJykpIHtcbiAgICAgICAgdGhpcy5tY19wbHVnaW5fbnBtX25hbWUgPSBwcm9wcy5tY19wbHVnaW5fbnBtX25hbWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaGFzSW5jaWRlbnRzID0gZmFsc2U7XG4gICAgICAvKlxuICAgICAgICAgIGluaXRpYWxWYWx1ZXMgaXMgYW4gb2JqZWN0IGhvbGRpbmcgdGhlIGF1dG9tYXRpY2FsbHkgY29tcHV0ZWQgaW5pdGlhbCB2YWx1ZXMgb2YgdGhlIGFuaW1hdGVkQXR0cnNcbiAgICAgICAgICAoaWYgYW55KS4gVGhlIGluaXRpYWxWYWx1ZXMgYXJlIGNhbGN1bGF0ZWQgYnkgdGhlIEF0dHJpYnV0ZXNDaGFubmVsIChvbmx5IEluY2lkZW50cyBiZWxvbmdpbmcgdG9cbiAgICAgICAgICBhbiBBdHRyaWJ1dGVzQ2hhbm5lbCBoYXZlIGluaXRpYWxWYWx1ZXMpLlxuICAgICAgICAgIFRoZSBrZXlzIHNldCBvZiB0aGlzIG9iamVjdCBpcyBpZGVudGljYWwgdG8gdGhlIG9iamVjdCBhdHRycy5hbmltYXRlZEF0dHJzXG4gICAgICAgICAgVGhlIG9ubHkgdGhpbmcgdGhlIGdlbmVyaWMgQXR0cmlidXRlc0NoYW5uZWwgY2FuJ3QgY2FsY3VsYXRlIGlzIHRoZSBpbml0aWFsIHZhbHVlIG9mIGFuIGFuaW1hdGVkIGF0dHJcbiAgICAgICAgICBvZiBhIHNwZWNpZmljIGVsZW1lbnQgd2hlbiB0aGVyZSBhcmUgbm8gb3RoZXIgSW5jaWRlbnRzIGVudGVyZWQgb24gaXRzIGxhbmVzIHlldC4gVGhlc2UgdmFsdWVzIGFyZVxuICAgICAgICAgIHRoZSBcInNjcmF0Y2hWYWx1ZXNcIiBhbmQgdGhleSBhcmUgc3Ryb25nbHkgZGVwZW5kZW5kIG9uIHRoZSBuYXR1cmUgb2YgdGhlIGxpYi4gRS5nLiBmb3IgYSBDU1MgYW5pbWF0aW9uXG4gICAgICAgICAgd2hhdCB3ZSBhcmUgbG9va2luZyBmb3IgY2FuIGJlIGZvdW5kIG9uIHRoZSBjb21wdXRlZFN0eWxlLlxuICAgICAgICAgIFRoZSBpbml0aWFsVmFsdWVzIGFyZSB0aGUgdmFsdWVzIHRoYXQgYXJlIGFjdHVhbGx5IGdvaW5nIHRvIGJlIHVzZWQgYnlcbiAgICAgICAgICB0aGUgTW9ub0luY2lkZW50IGluIHRoZSByZWFsIGV4ZWN1dGlvbiBvZiB0aGVtXG4gICAgICAgICAgKi9cblxuICAgICAgdGhpcy5pbml0aWFsVmFsdWVzID0ge307XG4gICAgICAvKlxuICAgICAgICAgIFRoZSBpbml0aWFsIHZhbHVlcyBkZWZpbmVkIGJ5IHRoZSB1c2VyIHZpYSB0aGUgaW5pdGlhbFZhbHVlcyBrZXkgb24gdGhlXG4gICAgICAgICAgYXR0cmlidXRlcyAoaWYgcHJlc2VudClcbiAgICAgICAgICAqL1xuXG4gICAgICB0aGlzLnVzZXJEZWZpbmVkSW5pdGlhbFZhbHVlcyA9IGF0dHJzLmluaXRpYWxWYWx1ZXMgfHwge307XG4gICAgICAvKlxuICAgICAgICAgIFRoZSBpbml0aWFsVmFsdWVzIG9mIHRoZSBJbmNpZGVudCBhcyBwYXNzZWQgYnkgdGhlIEF0dHJpYnV0ZSBDaGFubmVsLlxuICAgICAgICAgIFRoZXNlIHZhbHVlcyBhcmUgYmVlbiBhbHRlcmVkIGJ5IHRoZSB1c2VyRGVmaW5lZEluaXRpYWxWYWx1ZXMgKGlmIGFueSlcbiAgICAgICAgICBidXQgd2UgbmVlZCB0aGVtIGZvciBwYXNzaW5nIHRoZW0gb24gb3RoZXIgSW5jaWRlbnRzIG9uIGVkaXQgYW5kIGRlbGV0ZSBvcGVyYXRpb25zXG4gICAgICAgICAgKi9cblxuICAgICAgdGhpcy5wdXJlSW5pdGlhbFZhbHVlcyA9IG51bGw7XG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59IC0gaWYgYXV0b0dlbmVyYXRlZCBpcyBzZXQgdG8gdHJ1ZSwgaXQgbWVhbnMgdGhhdCB0aGlzIE1vbm9JbmNpZGVudCBoYXMgYmVlbiBhdXRvLWdlbmVyYXRlZCBieSBpdHMgcGFyZW50IG9uIGluaXRpYWxpc2F0aW9uLlxuICAgICAgICogVGhpcyBoYXBwZW5zIHdoZW4gcGx1Z2lucyBleHBvcnQgSW5jaWRlbnRzIHRoYXQgb24gaW5pdGlhbGlzYXRpb24gdGhleSBhdXRvbWF0aWNhbGx5IGNyZWF0ZSBvdGhlciBpbmNpZGVudHMgYW5kIGF1dG9tYXRpY2FsbHkgcHV0IHRoZW1cbiAgICAgICAqIG9uIHNwZWNpZmljIHBvaW50cyBvbiB0aGVpciB0aW1lbGluZS5cbiAgICAgICAqL1xuXG4gICAgICB0aGlzLmF1dG9HZW5lcmF0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMub25Jbml0aWFsaXNlKGF0dHJzLCBwcm9wcyk7XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICBGOiBNb25vSW5jaWRlbnQsXG4gICAgICBkOiBbe1xuICAgICAgICBraW5kOiBcImdldFwiLFxuICAgICAgICBrZXk6IFwic2VsZWN0b3JcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdG9yKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLnNlbGVjdG9yO1xuICAgICAgICB9XG4gICAgICAgIC8qIHNob3J0Y3V0cyBmb3IgYXR0cnMuYXR0cnMgYW5kIGF0dHJzLmFuaW1hdGVkQXR0cnMgKi9cblxuICAgICAgfSwge1xuICAgICAgICBraW5kOiBcImdldFwiLFxuICAgICAgICBrZXk6IFwiYW5pbUF0dHJpYnV0ZXNcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFuaW1BdHRyaWJ1dGVzKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmF0dHJzLmFuaW1hdGVkQXR0cnM7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJzZXRcIixcbiAgICAgICAga2V5OiBcImFuaW1BdHRyaWJ1dGVzXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhbmltQXR0cmlidXRlcyh2YWx1ZSkge1xuICAgICAgICAgIHRoaXMuYXR0cnMuYW5pbWF0ZWRBdHRyc1t0aGlzLmF0dHJpYnV0ZUtleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICBUaGlzIG1ldGhvZCBzaG91ZGwgYmUgb3ZlcndyaXR0ZW4gYnkgdGhlIEluY2lkZW50cyBvZiB0aGUgcGx1Z2lucy4gVGhlIG1ldGhvZCByZXR1cm5zXG4gICAgICAgICAgdGhlIGluaXRpYWwgdmFsdWUgdGhhdCB0aGUgZWxlbWVudCBvZiBpdCBoYXMgYXMgdGhlIGxpYnJhcnkgY2FsY3VsYXRlcyAvIGRlZmluZXMgdGhlbS4gVGhlXG4gICAgICAgICAgcmV0dXJuZWQgdmFsdWUgcmVwcmVzZW50cyB0aGUgdmVyeSBpbml0aWFsIHZhbHVlIG9mIHRoZSBlbGVtZW50J3MgYXR0cmlidXRlIGJlZm9yZVxuICAgICAgICAgIGFueSBJbmNpZGVudCB0aGF0IGFsdGVycyBpdCBnZXRzIGFkZGVkLlxuICAgICAgICAgICBAcmV0dXJucyB7bWl4ZWR9IC0gdGhlIGluaXRpYWwgdmFsdWUgb2YgdGhlIGVsZW1lbnQncyBhdHRyaWJ1dGUganVzdCB3aGVuIHRoZSBIVE1MICYgQ1NTXG4gICAgICAgICAgb2YgdGhlIENsaXAgZ2V0cyByZW5kZXJlZFxuICAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgICAga2V5OiBcImdldFNjcmF0Y2hWYWx1ZVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2NyYXRjaFZhbHVlKCkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwiZ2V0XCIsXG4gICAgICAgIGtleTogXCJlbGVtZW50XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBlbGVtZW50KCkge1xuICAgICAgICAgIGlmICh0aGlzLmNvbnRleCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuZ2V0RWxlbWVudEJ5TUNJRCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5nZXRFbGVtZW50QnlNQ0lEKHRoaXMubWNpZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5nZXRFbGVtZW50cyh0aGlzLnNlbGVjdG9yKVswXTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBraW5kOiBcImdldFwiLFxuICAgICAgICBrZXk6IFwiYXR0cmlidXRlS2V5XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRyaWJ1dGVLZXkoKSB7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuYXR0cnMuYW5pbWF0ZWRBdHRycylbMF07XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJnZXRcIixcbiAgICAgICAga2V5OiBcInRhcmdldFZhbHVlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0YXJnZXRWYWx1ZSgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5hbmltQXR0cmlidXRlc1t0aGlzLmF0dHJpYnV0ZUtleV07XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgICAga2V5OiBcImdldEVsZW1lbnRBdHRyaWJ1dGVcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVsZW1lbnRBdHRyaWJ1dGUoYXR0cikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHIpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICAgIGRlY29yYXRvcnM6IFtnZXRJbmNpZGVudHNCeUNoYW5uZWxdLFxuICAgICAgICBrZXk6IFwiZ2V0SW5jaWRlbnRzQnlDaGFubmVsXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbmNpZGVudHNCeUNoYW5uZWwoKSB7fVxuICAgICAgfSwge1xuICAgICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAgICBrZXk6IFwiaGFzVXNlckRlZmluZWRJbml0aWFsVmFsdWVcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhc1VzZXJEZWZpbmVkSW5pdGlhbFZhbHVlKCkge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy51c2VyRGVmaW5lZEluaXRpYWxWYWx1ZXMsIHRoaXMuYXR0cmlidXRlS2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICAgIGtleTogXCJzZXRJbml0aWFsVmFsdWVcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEluaXRpYWxWYWx1ZSh2YWx1ZSkge1xuICAgICAgICAgIHZhciBzdG9yZVB1cmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG5cbiAgICAgICAgICBpZiAoc3RvcmVQdXJlID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLnB1cmVJbml0aWFsVmFsdWVzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh2YWx1ZSkpOyAvLyBrZWVwIGEgY29weSBvZiB0aGVcbiAgICAgICAgICAgIC8vIHBhc3NlZCBpbml0aWFsIHZhbHVlc1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghdGhpcy5oYXNVc2VyRGVmaW5lZEluaXRpYWxWYWx1ZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxWYWx1ZXNbdGhpcy5hdHRyaWJ1dGVLZXldID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKF90eXBlb2YodGhpcy50YXJnZXRWYWx1ZSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAvLyBpZiBpdCBpcyBhIGNvbWJvIGF0dHJpYnV0ZVxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMudXNlckRlZmluZWRJbml0aWFsVmFsdWVzW3RoaXMuYXR0cmlidXRlS2V5XSkge1xuICAgICAgICAgICAgICB2YWx1ZVtrZXldID0gdGhpcy51c2VyRGVmaW5lZEluaXRpYWxWYWx1ZXNbdGhpcy5hdHRyaWJ1dGVLZXldW2tleV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbFZhbHVlc1t0aGlzLmF0dHJpYnV0ZUtleV0gPSB2YWx1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsVmFsdWVzW3RoaXMuYXR0cmlidXRlS2V5XSA9IHRoaXMudXNlckRlZmluZWRJbml0aWFsVmFsdWVzW3RoaXMuYXR0cmlidXRlS2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJnZXRcIixcbiAgICAgICAga2V5OiBcImluaXRpYWxWYWx1ZVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbFZhbHVlKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmluaXRpYWxWYWx1ZXNbdGhpcy5hdHRyaWJ1dGVLZXldO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICAgIGtleTogXCJnZXRJbml0aWFsVmFsdWVcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEluaXRpYWxWYWx1ZSgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5pbml0aWFsVmFsdWVzW3RoaXMuYXR0cmlidXRlS2V5XTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAgICBrZXk6IFwiX29uR2V0Q29udGV4dE9uY2VcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkdldENvbnRleHRPbmNlKCkge1xuICAgICAgICAgIC8vIGlmIHRoZSBNb25vSW5jaWRlbnQgYmVsb25ncyB0byBhIGZyYWdtZW50ZWQgY29udGV4dCB0aGVyZSBhYnNvbHV0ZWx5XG4gICAgICAgICAgLy8gbm8gcmVhc29uIHRvIHJ1biB0aGUgZ2V0Q29udGV4dCBtZXRob2Qgb2YgaXRcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5mcmFnbWVudCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5nb3RDb250ZXh0KSB7XG4gICAgICAgICAgICAgIHRoaXMub25HZXRDb250ZXh0KCk7XG4gICAgICAgICAgICAgIHRoaXMuZ290Q29udGV4dCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLm1jaWQpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuY29udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICAgIGtleTogXCJvbkdldENvbnRleHRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uR2V0Q29udGV4dCgpIHtcbiAgICAgICAgICBoZWxwZXIuaW5mbygnT3ZlcndyaXR0ZSB0aGUgXCJvbkdldENvbnRleHRcIiBtZXRob2Qgd2l0aCB0aGUgY29kZSB5b3Ugd2FudCB0byBnZXQgZXhlY3V0ZWQnLCAnaW5mbycpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICAgIGtleTogXCJsYXN0V2lzaFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbGFzdFdpc2goKSB7fVxuICAgICAgfSwge1xuICAgICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAgICBrZXk6IFwib25Jbml0aWFsaXNlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkluaXRpYWxpc2UoKSB7XG4gICAgICAgICAgaGVscGVyLmluZm8oJ092ZXJ3cml0dGUgdGhlIFwib25JbmlhbGlzZVwiIG1ldGhvZCB3aXRoIHRoZSBjb2RlIHlvdSB3YW50IHRvIGdldCBleGVjdXRlZCcsICdpbmZvJyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCBjYWxsZWQgb24gcHJvZ3Jlc3Mgb2YgdGhlIHRpbWVkIGluY2lkZW50LlxuICAgICAgICAgKiBAcGFyYW0ge2Zsb2F0fSBmcmFjdGlvbiAtIGEgbnVtYmVyIGZyb20gMCB0byAxIHJlcHJlc2VudGluZyB0aGUgZnJhY3Rpb24gb2YgZHVyYXRpb24gY292ZXJlZFxuICAgICAgICAgKiBAcGFyYW0ge2ludH0gbWlsbGlzZWNvbmRzIC0gdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgcGFzc2VkIGZyb20gc3RhcnQgb2YgdGhlIGluY2lkZW50XG4gICAgICAgICAqL1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAgICAgfSwge1xuICAgICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAgICBrZXk6IFwib25Qcm9ncmVzc1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25Qcm9ncmVzcyhmcmFjdGlvbiwgbWlsbGlzZWNvbmRzKSB7fVxuICAgICAgfSwge1xuICAgICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAgICBkZWNvcmF0b3JzOiBbYmxvY2tdLFxuICAgICAgICBrZXk6IFwic2V0QmxvY2tcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEJsb2NrKCkge31cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgICAgZGVjb3JhdG9yczogW3VuYmxvY2tdLFxuICAgICAgICBrZXk6IFwidW5ibG9ja1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdW5ibG9jaygpIHt9XG4gICAgICB9XVxuICAgIH07XG4gIH0pO1xuXG4gIHZhciBDbGlwQ29weSA9XG4gIC8qI19fUFVSRV9fKi9cbiAgZnVuY3Rpb24gKF9Nb25vSW5jaWRlbnQpIHtcbiAgICBfaW5oZXJpdHMoQ2xpcENvcHksIF9Nb25vSW5jaWRlbnQpO1xuXG4gICAgZnVuY3Rpb24gQ2xpcENvcHkoYXR0cnMsIHByb3BzLCBkbmEpIHtcbiAgICAgIHZhciBfdGhpcztcblxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENsaXBDb3B5KTtcblxuICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQ2xpcENvcHkpLmNhbGwodGhpcywgYXR0cnMsIHByb3BzLCBkbmEpKTtcbiAgICAgIF90aGlzLnJ1blRpbWVJbmZvID0ge1xuICAgICAgICBjdXJyZW50TWlsbGlzZWNvbmQ6IDBcbiAgICAgIH07XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKENsaXBDb3B5LCBbe1xuICAgICAga2V5OiBcImxhc3RXaXNoXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbGFzdFdpc2goKSB7XG4gICAgICAgIHRoaXMub3duQ2xpcC5vd25Db250ZXh0LnVubW91bnQoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwib25HZXRDb250ZXh0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gb25HZXRDb250ZXh0KCkge1xuICAgICAgICAvLyBJbiBvcmRlciB0byByZW5kZXIgaXRzZWxmIG9uIHRoZSBnaXZlbiBlbGVtZW50IGZpcnN0IGl0IG5lZWRzIHRoZSBwcm9wcyAoaW5jbHVkaW5nIGh0bWwgYW5kIGNzcylcbiAgICAgICAgLy8gZnJvbSB0aGUgcmVhbCBDbGlwIGl0IGNvcGllc1xuICAgICAgICB2YXIgY29uc3RydWN0aW9uQXJncyA9IHRoaXMuRGVzY3JpcHRpdmVJbmNpZGVudC5yZWFsQ2xpcC5leHBvcnRDb25zdHJ1Y3Rpb25Bcmd1bWVudHMoKTsgLy8gaXQgcHJvcGVybHkgc2V0cyBpdHMgb3duIGhvc3Qgb24gdGhlIHByb3BzIHRvIHVzZSB0byBpbml0aWFsaXNlIGl0cyBvd24gY2xpcFxuXG4gICAgICAgIHZhciBob3N0ID0gaGVscGVyLmdldEVsZW1lbnRCeU1DSUQodGhpcy5jb250ZXh0LCB0aGlzLm1jaWQpO1xuXG4gICAgICAgIHZhciBob3N0ZWRQcm9wcyA9IF9vYmplY3RTcHJlYWQyKHt9LCBjb25zdHJ1Y3Rpb25BcmdzLnByb3BzLCB7XG4gICAgICAgICAgc2VsZWN0b3I6IHVuZGVmaW5lZCxcbiAgICAgICAgICBob3N0OiBob3N0XG4gICAgICAgIH0pOyAvLyB3ZSBjcmVhdGUgYSBjbGlwIGJlY2F1c2UgQ2xpcHMgb24gY3JlYXRpb24gcmVuZGVyIGFuZCB0aHVzIGhhdmUgdGhlaXIgb3duIGNvbnRleHRcbiAgICAgICAgLy8gdGhpcy5kbmEuZGVzY3JpcHRpdmVJbmNpZGVudC5jb25zdHJ1Y3Rvci5JbmNpZGVudCBrZWVwcyBhIHJlZmVyZW5jZSB0byB0aGUgbm9uLWF1ZGlvIHJlYWwgQ2xpcFxuICAgICAgICAvLyBDbGFzcy4gTm8gYXVkaW8gaXMgaW52b2x2ZWQgb24gdGhpcyBwcm9jZXNzXG5cblxuICAgICAgICB0aGlzLm93bkNsaXAgPSBuZXcgdGhpcy5EZXNjcmlwdGl2ZUluY2lkZW50LmNvbnN0cnVjdG9yLkluY2lkZW50KGNvbnN0cnVjdGlvbkFyZ3MuYXR0cnMsIGhvc3RlZFByb3BzKTtcbiAgICAgICAgdGhpcy5vd25DbGlwLkRlc2NyaXB0aXZlSW5jaWRlbnQgPSB0aGlzLkRlc2NyaXB0aXZlSW5jaWRlbnQ7XG4gICAgICAgIHRoaXMub3duQ2xpcC5jb250ZXh0TG9hZGVkID0gdGhpcy5jb250ZXh0TG9hZGVkLmJpbmQodGhpcyk7IC8vIGNvbnNvbGUubG9nKHRoaXMub3duQ2xpcCk7XG4gICAgICAgIC8vIGZsdXNoZXMgdGhlIHJlYWxDbGlwIHdpdGggaXRzIG93bkNsaXAncyBjb250ZXh0XG5cbiAgICAgICAgdGhpcy5EZXNjcmlwdGl2ZUluY2lkZW50LnJlYWxDbGlwLmFkZENvbnRleHQoe1xuICAgICAgICAgIGNsaXBJZDogdGhpcy5pZCxcbiAgICAgICAgICBjb250ZXh0OiB0aGlzLm93bkNsaXAub3duQ29udGV4dFxuICAgICAgICB9LCB0cnVlKTsgLy8gZXZlbiB0aG91Z2ggd2UgaGF2ZSBjcmVhdGVkIGFuIG93biBjbGlwLCB3ZSBoYXZlIG1hZGUgbm8gY2hlY2tzIGF0IGFsbCBuZWl0aGVyXG4gICAgICAgIC8vIHdlIGFkZGVkIHRoZSBpbmNpZGVudHMgb2YgdGhlIHJlYWwgY2xpcCB0byBpdC4gVGhhdCBpcyBiZWN1YXNlIHBsYXlpbmcgYW5kIG1vdmluZ1xuICAgICAgICAvLyB0aGlzIGNsaXAgY29weSBtZWFucyBkaXJlY3RseSBtb3ZpbmcgdGhlIHJlYWwgY2xpcCBvbiB0aGUgY29udGV4dCBvZiB0aGUgb3duIGNsaXAuXG4gICAgICAgIC8vIFNvIHRoZSBvbmx5IHRoaW5nIHdlIG5lZWQgaGVyZSBpcyB0aGUgY29udGV4dCBhbmQgbm90aGluZyBtb3JlLlxuXG4gICAgICAgIHRoaXMuY29udGV4dFJlYWR5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY29udGV4dExvYWRlZFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnRleHRMb2FkZWQoKSB7XG4gICAgICAgIHRoaXMuY29udGV4dFJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy51bmJsb2NrKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIm9uUHJvZ3Jlc3NcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBvblByb2dyZXNzKGZyYWN0aW9uLCBtaWxsaXNlY29uZHMpIHtcbiAgICAgICAgdmFyIGZvcmNlUmVzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gICAgICAgIGlmICh0aGlzLm93bkNsaXAub3duQ29udGV4dC5sb2FkaW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5zZXRCbG9jaygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLkRlc2NyaXB0aXZlSW5jaWRlbnQucmVhbENsaXAuaW5zdGFudGlhdGVkQ2hhbm5lbHMpIHtcbiAgICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuRGVzY3JpcHRpdmVJbmNpZGVudC5yZWFsQ2xpcC5pbnN0YW50aWF0ZWRDaGFubmVsc1trZXldO1xuICAgICAgICAgIGNoYW5uZWwubW92ZVRvKHRoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kLCBtaWxsaXNlY29uZHMsIHRoaXMuaWQsIGZvcmNlUmVzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQgPSBtaWxsaXNlY29uZHM7XG4gICAgICAgIHRoaXMub3duQ2xpcC5vbkFmdGVyUHJvZ3Jlc3MoZnJhY3Rpb24sIG1pbGxpc2Vjb25kcyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImR1cmF0aW9uXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuRGVzY3JpcHRpdmVJbmNpZGVudC5yZWFsQ2xpcC5kdXJhdGlvbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChtaWxsaXNlY29uZHMpIHtcbiAgICAgICAgdGhpcy5EZXNjcmlwdGl2ZUluY2lkZW50LnJlYWxDbGlwLl9yZXNpemUobWlsbGlzZWNvbmRzIC8gdGhpcy5yZWFsQ2xpcC5kdXJhdGlvbik7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIENsaXBDb3B5O1xuICB9KE1vbm9JbmNpZGVudCk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbmdyZWRpZW50cyAtXG4gICAqIHtcbiAgICogICAgICBpZFxuICAgKiAgICAgIGF0dHJzXG4gICAqICAgICAgcHJvcHNcbiAgICogICAgICBJbmNpZGVudFxuICAgKiAgICAgIHBsdWdpbl9ucG1fbmFtZVxuICAgKiAgICAgIENoYW5uZWxcbiAgICogICAgICBjb250ZXh0IChvcHRpb25hbClcbiAgICogICAgICBtY2lkIChvcHRpb25hbClcbiAgICogICAgICBkbmFFeHRyYXNcbiAgICogfVxuICAgKiAqL1xuXG4gIGZ1bmN0aW9uIGluY2lkZW50RnJvbUluZ3JlZGllbnRzKGluZ3JlZGllbnRzKSB7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaW5ncmVkaWVudHMsICdkbmFFeHRyYXMnKSkge1xuICAgICAgaW5ncmVkaWVudHMuZG5hRXh0cmFzID0ge307XG4gICAgfVxuXG4gICAgdmFyIGluY2lkZW50ID0gbmV3IGluZ3JlZGllbnRzLkluY2lkZW50KGluZ3JlZGllbnRzLmF0dHJzLCBfb2JqZWN0U3ByZWFkMih7fSwgaW5ncmVkaWVudHMucHJvcHMsIHtcbiAgICAgIGlkOiBpbmdyZWRpZW50cy5pZCB8fCBnZXRBbklkKClcbiAgICB9KSwgX29iamVjdFNwcmVhZDIoe30sIGluZ3JlZGllbnRzLmRuYUV4dHJhcywge1xuICAgICAgY29udGV4dDogaW5ncmVkaWVudHMuY29udGV4dCxcbiAgICAgIG1jaWQ6IGluZ3JlZGllbnRzLm1jaWRcbiAgICB9KSk7XG4gICAgaW5jaWRlbnQubWNfcGx1Z2luX25wbV9uYW1lID0gaW5ncmVkaWVudHMucGx1Z2luX25wbV9uYW1lO1xuICAgIGluY2lkZW50LnBsdWdpbl9jaGFubmVsX2NsYXNzID0gaW5ncmVkaWVudHMuQ2hhbm5lbDtcbiAgICBpbmNpZGVudC5EZXNjcmlwdGl2ZUluY2lkZW50ID0gaW5ncmVkaWVudHMuRGVzY3JpcHRpdmVJbmNpZGVudDtcbiAgICByZXR1cm4gaW5jaWRlbnQ7XG4gIH1cblxuICB2YXIgZWFzaW5nID0ge1xuICAgIGxpbmVhcjogZnVuY3Rpb24gbGluZWFyKGZyYWN0aW9uKSB7XG4gICAgICByZXR1cm4gZnJhY3Rpb247XG4gICAgfSxcbiAgICBlYXNlSW5RdWFkOiBmdW5jdGlvbiBlYXNlSW5RdWFkKGZyYWN0aW9uKSB7XG4gICAgICByZXR1cm4gZnJhY3Rpb24gKiBmcmFjdGlvbjtcbiAgICB9LFxuICAgIGVhc2VPdXRRdWFkOiBmdW5jdGlvbiBlYXNlT3V0UXVhZChmcmFjdGlvbikge1xuICAgICAgcmV0dXJuIGZyYWN0aW9uICogKDIgLSBmcmFjdGlvbik7XG4gICAgfSxcbiAgICBlYXNlSW5PdXRRdWFkOiBmdW5jdGlvbiBlYXNlSW5PdXRRdWFkKGZyYWN0aW9uKSB7XG4gICAgICByZXR1cm4gZnJhY3Rpb24gPCAwLjUgPyAyICogZnJhY3Rpb24gKiBmcmFjdGlvbiA6IC0xICsgKDQgLSAyICogZnJhY3Rpb24pICogZnJhY3Rpb247XG4gICAgfSxcbiAgICBlYXNlSW5DdWJpYzogZnVuY3Rpb24gZWFzZUluQ3ViaWMoZnJhY3Rpb24pIHtcbiAgICAgIHJldHVybiBmcmFjdGlvbiAqIGZyYWN0aW9uICogZnJhY3Rpb247XG4gICAgfSxcbiAgICBlYXNlT3V0Q3ViaWM6IGZ1bmN0aW9uIGVhc2VPdXRDdWJpYyhmcmFjdGlvbikge1xuICAgICAgcmV0dXJuIC0tZnJhY3Rpb24gKiBmcmFjdGlvbiAqIGZyYWN0aW9uICsgMTtcbiAgICB9LFxuICAgIGVhc2VJbk91dEN1YmljOiBmdW5jdGlvbiBlYXNlSW5PdXRDdWJpYyhmcmFjdGlvbikge1xuICAgICAgcmV0dXJuIGZyYWN0aW9uIDwgMC41ID8gNCAqIGZyYWN0aW9uICogZnJhY3Rpb24gKiBmcmFjdGlvbiA6IChmcmFjdGlvbiAtIDEpICogKDIgKiBmcmFjdGlvbiAtIDIpICogKDIgKiBmcmFjdGlvbiAtIDIpICsgMTtcbiAgICB9LFxuICAgIGVhc2VJblF1YXJ0OiBmdW5jdGlvbiBlYXNlSW5RdWFydChmcmFjdGlvbikge1xuICAgICAgcmV0dXJuIGZyYWN0aW9uICogZnJhY3Rpb24gKiBmcmFjdGlvbiAqIGZyYWN0aW9uO1xuICAgIH0sXG4gICAgZWFzZU91dFF1YXJ0OiBmdW5jdGlvbiBlYXNlT3V0UXVhcnQoZnJhY3Rpb24pIHtcbiAgICAgIHJldHVybiAxIC0gLS1mcmFjdGlvbiAqIGZyYWN0aW9uICogZnJhY3Rpb24gKiBmcmFjdGlvbjtcbiAgICB9LFxuICAgIGVhc2VJbk91dFF1YXJ0OiBmdW5jdGlvbiBlYXNlSW5PdXRRdWFydChmcmFjdGlvbikge1xuICAgICAgcmV0dXJuIGZyYWN0aW9uIDwgMC41ID8gOCAqIGZyYWN0aW9uICogZnJhY3Rpb24gKiBmcmFjdGlvbiAqIGZyYWN0aW9uIDogMSAtIDggKiAtLWZyYWN0aW9uICogZnJhY3Rpb24gKiBmcmFjdGlvbiAqIGZyYWN0aW9uO1xuICAgIH0sXG4gICAgZWFzZUluUXVpbnQ6IGZ1bmN0aW9uIGVhc2VJblF1aW50KGZyYWN0aW9uKSB7XG4gICAgICByZXR1cm4gZnJhY3Rpb24gKiBmcmFjdGlvbiAqIGZyYWN0aW9uICogZnJhY3Rpb24gKiBmcmFjdGlvbjtcbiAgICB9LFxuICAgIGVhc2VPdXRRdWludDogZnVuY3Rpb24gZWFzZU91dFF1aW50KGZyYWN0aW9uKSB7XG4gICAgICByZXR1cm4gMSArIC0tZnJhY3Rpb24gKiBmcmFjdGlvbiAqIGZyYWN0aW9uICogZnJhY3Rpb24gKiBmcmFjdGlvbjtcbiAgICB9LFxuICAgIGVhc2VJbk91dFF1aW50OiBmdW5jdGlvbiBlYXNlSW5PdXRRdWludChmcmFjdGlvbikge1xuICAgICAgcmV0dXJuIGZyYWN0aW9uIDwgMC41ID8gMTYgKiBmcmFjdGlvbiAqIGZyYWN0aW9uICogZnJhY3Rpb24gKiBmcmFjdGlvbiAqIGZyYWN0aW9uIDogMSArIDE2ICogLS1mcmFjdGlvbiAqIGZyYWN0aW9uICogZnJhY3Rpb24gKiBmcmFjdGlvbiAqIGZyYWN0aW9uO1xuICAgIH0sXG4gICAgZWFzZUluU2luZTogZnVuY3Rpb24gZWFzZUluU2luZShmcmFjdGlvbikge1xuICAgICAgcmV0dXJuIC0xICogTWF0aC5jb3MoZnJhY3Rpb24gLyAxICogKE1hdGguUEkgLyAyKSkgKyAxO1xuICAgIH0sXG4gICAgZWFzZU91dFNpbmU6IGZ1bmN0aW9uIGVhc2VPdXRTaW5lKGZyYWN0aW9uKSB7XG4gICAgICByZXR1cm4gMSAqIE1hdGguc2luKGZyYWN0aW9uIC8gMSAqIChNYXRoLlBJIC8gMikpO1xuICAgIH0sXG4gICAgZWFzZUluT3V0U2luZTogZnVuY3Rpb24gZWFzZUluT3V0U2luZShmcmFjdGlvbikge1xuICAgICAgcmV0dXJuIC0xIC8gMiAqIChNYXRoLmNvcyhNYXRoLlBJICogZnJhY3Rpb24gLyAxKSAtIDEpO1xuICAgIH0sXG4gICAgZWFzZUluRXhwbzogZnVuY3Rpb24gZWFzZUluRXhwbyhmcmFjdGlvbikge1xuICAgICAgcmV0dXJuIGZyYWN0aW9uID09IDAgPyAxIDogMSAqIE1hdGgucG93KDIsIDEwICogKGZyYWN0aW9uIC8gMSAtIDEpKTtcbiAgICB9LFxuICAgIGVhc2VPdXRFeHBvOiBmdW5jdGlvbiBlYXNlT3V0RXhwbyhmcmFjdGlvbikge1xuICAgICAgcmV0dXJuIGZyYWN0aW9uID09IDEgPyAxIDogMSAqICgtTWF0aC5wb3coMiwgLTEwICogZnJhY3Rpb24gLyAxKSArIDEpO1xuICAgIH0sXG4gICAgZWFzZUluT3V0RXhwbzogZnVuY3Rpb24gZWFzZUluT3V0RXhwbyhmcmFjdGlvbikge1xuICAgICAgaWYgKGZyYWN0aW9uID09IDApIHJldHVybiAwO1xuICAgICAgaWYgKGZyYWN0aW9uID09IDEpIHJldHVybiAxO1xuICAgICAgaWYgKChmcmFjdGlvbiAvPSAxIC8gMikgPCAxKSByZXR1cm4gMSAvIDIgKiBNYXRoLnBvdygyLCAxMCAqIChmcmFjdGlvbiAtIDEpKTtcbiAgICAgIHJldHVybiAxIC8gMiAqICgtTWF0aC5wb3coMiwgLTEwICogLS1mcmFjdGlvbikgKyAyKTtcbiAgICB9LFxuICAgIGVhc2VJbkNpcmM6IGZ1bmN0aW9uIGVhc2VJbkNpcmMoZnJhY3Rpb24pIHtcbiAgICAgIGlmIChmcmFjdGlvbiA+PSAxKSByZXR1cm4gZnJhY3Rpb247XG4gICAgICByZXR1cm4gLTEgKiAoTWF0aC5zcXJ0KDEgLSAoZnJhY3Rpb24gLz0gMSkgKiBmcmFjdGlvbikgLSAxKTtcbiAgICB9LFxuICAgIGVhc2VPdXRDaXJjOiBmdW5jdGlvbiBlYXNlT3V0Q2lyYyhmcmFjdGlvbikge1xuICAgICAgcmV0dXJuIDEgKiBNYXRoLnNxcnQoMSAtIChmcmFjdGlvbiA9IGZyYWN0aW9uIC8gMSAtIDEpICogZnJhY3Rpb24pO1xuICAgIH0sXG4gICAgZWFzZUluT3V0Q2lyYzogZnVuY3Rpb24gZWFzZUluT3V0Q2lyYyhmcmFjdGlvbikge1xuICAgICAgaWYgKChmcmFjdGlvbiAvPSAxIC8gMikgPCAxKSByZXR1cm4gLTEgLyAyICogKE1hdGguc3FydCgxIC0gZnJhY3Rpb24gKiBmcmFjdGlvbikgLSAxKTtcbiAgICAgIHJldHVybiAxIC8gMiAqIChNYXRoLnNxcnQoMSAtIChmcmFjdGlvbiAtPSAyKSAqIGZyYWN0aW9uKSArIDEpO1xuICAgIH0sXG4gICAgZWFzZUluRWxhc3RpYzogZnVuY3Rpb24gZWFzZUluRWxhc3RpYyhmcmFjdGlvbikge1xuICAgICAgdmFyIHMgPSAxLjcwMTU4O1xuICAgICAgdmFyIHAgPSAwO1xuICAgICAgdmFyIGEgPSAxO1xuICAgICAgaWYgKGZyYWN0aW9uID09IDApIHJldHVybiAwO1xuICAgICAgaWYgKChmcmFjdGlvbiAvPSAxKSA9PSAxKSByZXR1cm4gMTtcbiAgICAgIGlmICghcCkgcCA9IDEgKiAwLjM7XG5cbiAgICAgIGlmIChhIDwgTWF0aC5hYnMoMSkpIHtcbiAgICAgICAgYSA9IDE7XG4gICAgICAgIHMgPSBwIC8gNDtcbiAgICAgIH0gZWxzZSBzID0gcCAvICgyICogTWF0aC5QSSkgKiBNYXRoLmFzaW4oMSAvIGEpO1xuXG4gICAgICByZXR1cm4gLShhICogTWF0aC5wb3coMiwgMTAgKiAoZnJhY3Rpb24gLT0gMSkpICogTWF0aC5zaW4oKGZyYWN0aW9uICogMSAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApKTtcbiAgICB9LFxuICAgIGVhc2VPdXRFbGFzdGljOiBmdW5jdGlvbiBlYXNlT3V0RWxhc3RpYyhmcmFjdGlvbikge1xuICAgICAgdmFyIHMgPSAxLjcwMTU4O1xuICAgICAgdmFyIHAgPSAwO1xuICAgICAgdmFyIGEgPSAxO1xuICAgICAgaWYgKGZyYWN0aW9uID09IDApIHJldHVybiAwO1xuICAgICAgaWYgKChmcmFjdGlvbiAvPSAxKSA9PSAxKSByZXR1cm4gMTtcbiAgICAgIGlmICghcCkgcCA9IDEgKiAwLjM7XG5cbiAgICAgIGlmIChhIDwgTWF0aC5hYnMoMSkpIHtcbiAgICAgICAgYSA9IDE7XG4gICAgICAgIHMgPSBwIC8gNDtcbiAgICAgIH0gZWxzZSBzID0gcCAvICgyICogTWF0aC5QSSkgKiBNYXRoLmFzaW4oMSAvIGEpO1xuXG4gICAgICByZXR1cm4gYSAqIE1hdGgucG93KDIsIC0xMCAqIGZyYWN0aW9uKSAqIE1hdGguc2luKChmcmFjdGlvbiAqIDEgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSArIDE7XG4gICAgfSxcbiAgICBlYXNlSW5PdXRFbGFzdGljOiBmdW5jdGlvbiBlYXNlSW5PdXRFbGFzdGljKGZyYWN0aW9uKSB7XG4gICAgICB2YXIgcyA9IDEuNzAxNTg7XG4gICAgICB2YXIgcCA9IDA7XG4gICAgICB2YXIgYSA9IDE7XG4gICAgICBpZiAoZnJhY3Rpb24gPT0gMCkgcmV0dXJuIDA7XG4gICAgICBpZiAoKGZyYWN0aW9uIC89IDEgLyAyKSA9PSAyKSByZXR1cm4gMTtcbiAgICAgIGlmICghcCkgcCA9IDEgKiAoMC4zICogMS41KTtcblxuICAgICAgaWYgKGEgPCBNYXRoLmFicygxKSkge1xuICAgICAgICBhID0gMTtcbiAgICAgICAgcyA9IHAgLyA0O1xuICAgICAgfSBlbHNlIHMgPSBwIC8gKDIgKiBNYXRoLlBJKSAqIE1hdGguYXNpbigxIC8gYSk7XG5cbiAgICAgIGlmIChmcmFjdGlvbiA8IDEpIHJldHVybiAtMC41ICogKGEgKiBNYXRoLnBvdygyLCAxMCAqIChmcmFjdGlvbiAtPSAxKSkgKiBNYXRoLnNpbigoZnJhY3Rpb24gKiAxIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkpO1xuICAgICAgcmV0dXJuIGEgKiBNYXRoLnBvdygyLCAtMTAgKiAoZnJhY3Rpb24gLT0gMSkpICogTWF0aC5zaW4oKGZyYWN0aW9uICogMSAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApICogMC41ICsgMTtcbiAgICB9LFxuICAgIGVhc2VJbkJhY2s6IGZ1bmN0aW9uIGVhc2VJbkJhY2soZnJhY3Rpb24pIHtcbiAgICAgIHZhciBzID0gMS43MDE1ODtcbiAgICAgIHJldHVybiAxICogKGZyYWN0aW9uIC89IDEpICogZnJhY3Rpb24gKiAoKHMgKyAxKSAqIGZyYWN0aW9uIC0gcyk7XG4gICAgfSxcbiAgICBlYXNlT3V0QmFjazogZnVuY3Rpb24gZWFzZU91dEJhY2soZnJhY3Rpb24pIHtcbiAgICAgIHZhciBzID0gMS43MDE1ODtcbiAgICAgIHJldHVybiAxICogKChmcmFjdGlvbiA9IGZyYWN0aW9uIC8gMSAtIDEpICogZnJhY3Rpb24gKiAoKHMgKyAxKSAqIGZyYWN0aW9uICsgcykgKyAxKTtcbiAgICB9LFxuICAgIGVhc2VJbk91dEJhY2s6IGZ1bmN0aW9uIGVhc2VJbk91dEJhY2soZnJhY3Rpb24pIHtcbiAgICAgIHZhciBzID0gMS43MDE1ODtcbiAgICAgIGlmICgoZnJhY3Rpb24gLz0gMSAvIDIpIDwgMSkgcmV0dXJuIDEgLyAyICogKGZyYWN0aW9uICogZnJhY3Rpb24gKiAoKChzICo9IDEuNTI1KSArIDEpICogZnJhY3Rpb24gLSBzKSk7XG4gICAgICByZXR1cm4gMSAvIDIgKiAoKGZyYWN0aW9uIC09IDIpICogZnJhY3Rpb24gKiAoKChzICo9IDEuNTI1KSArIDEpICogZnJhY3Rpb24gKyBzKSArIDIpO1xuICAgIH0sXG4gICAgZWFzZUluQm91bmNlOiBmdW5jdGlvbiBlYXNlSW5Cb3VuY2UoZnJhY3Rpb24pIHtcbiAgICAgIHJldHVybiAxIC0gZWFzaW5nLmVhc2VPdXRCb3VuY2UoMSAtIGZyYWN0aW9uKTtcbiAgICB9LFxuICAgIGVhc2VPdXRCb3VuY2U6IGZ1bmN0aW9uIGVhc2VPdXRCb3VuY2UoZnJhY3Rpb24pIHtcbiAgICAgIGlmICgoZnJhY3Rpb24gLz0gMSkgPCAxIC8gMi43NSkge1xuICAgICAgICByZXR1cm4gMSAqICg3LjU2MjUgKiBmcmFjdGlvbiAqIGZyYWN0aW9uKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZyYWN0aW9uIDwgMiAvIDIuNzUpIHtcbiAgICAgICAgcmV0dXJuIDEgKiAoNy41NjI1ICogKGZyYWN0aW9uIC09IDEuNSAvIDIuNzUpICogZnJhY3Rpb24gKyAwLjc1KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZyYWN0aW9uIDwgMi41IC8gMi43NSkge1xuICAgICAgICByZXR1cm4gMSAqICg3LjU2MjUgKiAoZnJhY3Rpb24gLT0gMi4yNSAvIDIuNzUpICogZnJhY3Rpb24gKyAwLjkzNzUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMSAqICg3LjU2MjUgKiAoZnJhY3Rpb24gLT0gMi42MjUgLyAyLjc1KSAqIGZyYWN0aW9uICsgMC45ODQzNzUpO1xuICAgIH0sXG4gICAgZWFzZUluT3V0Qm91bmNlOiBmdW5jdGlvbiBlYXNlSW5PdXRCb3VuY2UoZnJhY3Rpb24pIHtcbiAgICAgIGlmIChmcmFjdGlvbiA8IDEgLyAyKSByZXR1cm4gZWFzaW5nLmVhc2VJbkJvdW5jZShmcmFjdGlvbiAqIDIpICogMC41O1xuICAgICAgcmV0dXJuIGVhc2luZy5lYXNlT3V0Qm91bmNlKGZyYWN0aW9uICogMiAtIDEpICogMC41ICsgMSAqIDAuNTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIENvbnRleHRBd2FyZUNsaXBJbmNpZGVudCA9IF9kZWNvcmF0ZShudWxsLCBmdW5jdGlvbiAoX2luaXRpYWxpemUsIF9MZWFmKSB7XG4gICAgdmFyIENvbnRleHRBd2FyZUNsaXBJbmNpZGVudCA9XG4gICAgLyojX19QVVJFX18qL1xuICAgIGZ1bmN0aW9uIChfTGVhZjIpIHtcbiAgICAgIF9pbmhlcml0cyhDb250ZXh0QXdhcmVDbGlwSW5jaWRlbnQsIF9MZWFmMik7XG5cbiAgICAgIGZ1bmN0aW9uIENvbnRleHRBd2FyZUNsaXBJbmNpZGVudChjb25zdHJ1Y3Rpb25JbmdyZWRpZW50cywgY29udGV4dERhdGEsIG1jaWQsIGRlc2NyaXB0aXZlSW5jaWRlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzO1xuXG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb250ZXh0QXdhcmVDbGlwSW5jaWRlbnQpO1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGNvbnN0cnVjdGlvbkluZ3JlZGllbnRzLnByb3BzKTtcbiAgICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQ29udGV4dEF3YXJlQ2xpcEluY2lkZW50KS5jYWxsKHRoaXMsIHtcbiAgICAgICAgICBpZDogXCJcIi5jb25jYXQoY29uc3RydWN0aW9uSW5ncmVkaWVudHMuaW5jaWRlbnRJZCwgXCJfXCIpLmNvbmNhdChtY2lkKVxuICAgICAgICB9KSk7IC8vIGEgcHJvcGVydHkgdG8gaG9sZCBhbGwgb2YgdGhlIGNvbnRleHRzXG5cbiAgICAgICAgX2luaXRpYWxpemUoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgICAgIF90aGlzLmNvbnRleHRzID0ge307XG4gICAgICAgIF90aGlzLmNvbnN0cnVjdGlvbkluZ3JlZGllbnRzID0gY29uc3RydWN0aW9uSW5ncmVkaWVudHM7XG4gICAgICAgIF90aGlzLm1jaWQgPSBtY2lkO1xuICAgICAgICBfdGhpcy5fZHVyYXRpb24gPSBkZXNjcmlwdGl2ZUluY2lkZW50LnJlYWxDbGlwLmR1cmF0aW9uO1xuICAgICAgICBfdGhpcy5EZXNjcmlwdGl2ZUluY2lkZW50ID0gZGVzY3JpcHRpdmVJbmNpZGVudDtcbiAgICAgICAgX3RoaXMubWNfcGx1Z2luX25wbV9uYW1lID0gY29uc3RydWN0aW9uSW5ncmVkaWVudHMucGx1Z2luX25wbV9uYW1lO1xuICAgICAgICBfdGhpcy5wbHVnaW5fY2hhbm5lbF9jbGFzcyA9IGNvbnN0cnVjdGlvbkluZ3JlZGllbnRzLkNoYW5uZWw7XG5cbiAgICAgICAgX3RoaXMuYWRkQ29udGV4dChjb250ZXh0RGF0YSk7XG5cbiAgICAgICAgZGVzY3JpcHRpdmVJbmNpZGVudC5yZWFsQ2xpcC5zdWJzY3JpYmVUb0R1cmF0aW9uQ2hhbmdlKGZ1bmN0aW9uIChuZXdEdXJhdGlvbikge1xuICAgICAgICAgIF90aGlzLl9kdXJhdGlvbiA9IG5ld0R1cmF0aW9uO1xuXG4gICAgICAgICAgX3RoaXMucHV0TWVzc2FnZU9uUGlwZSgncmVjYWxjRHVyYXRpb24nLCB7fSwgJ0dyb3VwcycsIHtcbiAgICAgICAgICAgIHNlbGZFeGVjdXRlOiB0cnVlLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBfRElSRUNUSU9OUy5fVVBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLmVhc2luZyA9IGVhc2luZy5saW5lYXI7XG5cbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfdGhpcy5wcm9wcywgJ2Vhc2luZycpKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoX3RoaXMucHJvcHMuZWFzaW5nKSkge1xuICAgICAgICAgICAgX3RoaXMuZWFzaW5nID0gc3JjKF90aGlzLnByb3BzLmVhc2luZ1swXSwgX3RoaXMucHJvcHMuZWFzaW5nWzFdLCBfdGhpcy5wcm9wcy5lYXNpbmdbMl0sIF90aGlzLnByb3BzLmVhc2luZ1szXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLmVhc2luZyA9IGVhc2luZ1tfdGhpcy5wcm9wcy5lYXNpbmddO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRleHRBd2FyZUNsaXBJbmNpZGVudDtcbiAgICB9KF9MZWFmKTtcblxuICAgIHJldHVybiB7XG4gICAgICBGOiBDb250ZXh0QXdhcmVDbGlwSW5jaWRlbnQsXG4gICAgICBkOiBbe1xuICAgICAgICBraW5kOiBcImdldFwiLFxuICAgICAgICBrZXk6IFwib3JpZ2luYWxDb250ZXh0XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvcmlnaW5hbENvbnRleHQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dHNbdGhpcy5vcmlnaW5hbENvbnRleHRLZXldO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwiZ2V0XCIsXG4gICAgICAgIGtleTogXCJkdXJhdGlvblwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZHVyYXRpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2R1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICAgIGtleTogXCJvblByb2dyZXNzXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvblByb2dyZXNzKGZyYWN0aW9uLCBtaWxsaXNlY29uZHMsIGNvbnRleHRJZCkge1xuICAgICAgICAgIHZhciBmb3JjZVJlc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcbiAgICAgICAgICB2YXIgZWFzZWRfTUlfZnJhY3Rpb24gPSB0aGlzLmVhc2luZyhmcmFjdGlvbikgfHwgMDtcbiAgICAgICAgICB2YXIgZWFzZWRfTUlfbWlsbGlzZWNvbmQgPSBlYXNlZF9NSV9mcmFjdGlvbiAqIHRoaXMuZHVyYXRpb247IC8vIGNvbnNvbGUubG9nKGZyYWN0aW9uLCBlYXNlZF9NSV9mcmFjdGlvbiwgbWlsbGlzZWNvbmRzLCBlYXNlZF9NSV9taWxsaXNlY29uZCk7XG5cbiAgICAgICAgICB0aGlzLmNvbnRleHRzW2NvbnRleHRJZF0ub25Qcm9ncmVzcyhlYXNlZF9NSV9mcmFjdGlvbiwgZWFzZWRfTUlfbWlsbGlzZWNvbmQsIGZvcmNlUmVzZXQpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICAgIGtleTogXCJhZGRDb250ZXh0XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRDb250ZXh0KGNvbnRleHREYXRhKSB7XG4gICAgICAgICAgdmFyIGZvcmNlR2V0Q29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgICAgICAgICAvLyBpZiBpdCdzIHRoZSBmaXJzdCBjb250ZXh0IHRvIGJlIGFkZGVkIHRoZW4gaXQncyB0aGUgb3JpZ2luYWxcbiAgICAgICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5jb250ZXh0cykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbmFsQ29udGV4dEtleSA9IGNvbnRleHREYXRhLmNsaXBJZDtcbiAgICAgICAgICB9IC8vIGluc3RhbnRpYXRlcyB0aGUgQ2xpcCBzbyBpdCByZW5kZXJzXG5cblxuICAgICAgICAgIHZhciBpbmdyZWRpZW50c1RvUGFzcyA9IF9vYmplY3RTcHJlYWQyKHt9LCB0aGlzLmNvbnN0cnVjdGlvbkluZ3JlZGllbnRzLCB7XG4gICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0RGF0YS5jb250ZXh0LFxuICAgICAgICAgICAgbWNpZDogdGhpcy5tY2lkLFxuICAgICAgICAgICAgSW5jaWRlbnQ6IENsaXBDb3B5LFxuICAgICAgICAgICAgRGVzY3JpcHRpdmVJbmNpZGVudDogdGhpcy5EZXNjcmlwdGl2ZUluY2lkZW50XG4gICAgICAgICAgfSk7IC8vIGFuZCBwdXRzIGl0IG9uIHRoZSBjb3JyZXNwb25kaW5nIGNvbnRleHQga2V5XG5cblxuICAgICAgICAgIHRoaXMuY29udGV4dHNbY29udGV4dERhdGEuY2xpcElkXSA9IGluY2lkZW50RnJvbUluZ3JlZGllbnRzKGluZ3JlZGllbnRzVG9QYXNzKTtcblxuICAgICAgICAgIGlmIChmb3JjZUdldENvbnRleHQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dHNbY29udGV4dERhdGEuY2xpcElkXS5fb25HZXRDb250ZXh0T25jZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAgICBrZXk6IFwiaGFuZGxlQWRkQ29udGV4dFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlQWRkQ29udGV4dCh0YXJnZXQsIHBheWxvYWQpIHtcbiAgICAgICAgICB0aGlzLmFkZENvbnRleHQocGF5bG9hZCwgdHJ1ZSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgICAgZGVjb3JhdG9yczogW2dldEluY2lkZW50c0J5Q2hhbm5lbF0sXG4gICAgICAgIGtleTogXCJnZXRJbmNpZGVudHNCeUNoYW5uZWxcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEluY2lkZW50c0J5Q2hhbm5lbCgpIHt9IC8vIG1hc3NpdmUgZWRpdGluZyBtZXRob2RzIHRoYXQgYXBwbHkgdGhlIHJlcXVlc3QgbWFzc2l2ZWx5IHRvIGFsbCBvZiB0aGVcbiAgICAgICAgLy8gSW5jaWRlbnRzIG9mIGFsbCBvZiB0aGUgY29udGV4dHNcblxuICAgICAgfSwge1xuICAgICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAgICBrZXk6IFwiZ290Q29udGV4dFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ290Q29udGV4dCgpIHtcbiAgICAgICAgICBmb3IgKHZhciBjb250ZXh0IGluIHRoaXMuY29udGV4dHMpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dHNbY29udGV4dF0uZ290Q29udGV4dCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAgICBrZXk6IFwiX29uR2V0Q29udGV4dE9uY2VcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkdldENvbnRleHRPbmNlKCkge1xuICAgICAgICAgIGZvciAodmFyIGNvbnRleHQgaW4gdGhpcy5jb250ZXh0cykge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0c1tjb250ZXh0XS5fb25HZXRDb250ZXh0T25jZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAgICBrZXk6IFwibGFzdFdpc2hcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxhc3RXaXNoKCkge1xuICAgICAgICAgIGZvciAodmFyIGNvbnRleHQgaW4gdGhpcy5jb250ZXh0cykge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0c1tjb250ZXh0XS5sYXN0V2lzaCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAgICBrZXk6IFwib25HZXRDb250ZXh0XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkdldENvbnRleHQoKSB7XG4gICAgICAgICAgZm9yICh2YXIgY29udGV4dCBpbiB0aGlzLmNvbnRleHRzKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHRzW2NvbnRleHRdLm9uR2V0Q29udGV4dCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfV1cbiAgICB9O1xuICB9LCBMZWFmKTtcblxuICB2YXIgQ29udGV4dEF3YXJlSW5jaWRlbnQgPSBfZGVjb3JhdGUobnVsbCwgZnVuY3Rpb24gKF9pbml0aWFsaXplLCBfTGVhZikge1xuICAgIHZhciBDb250ZXh0QXdhcmVJbmNpZGVudCA9XG4gICAgLyojX19QVVJFX18qL1xuICAgIGZ1bmN0aW9uIChfTGVhZjIpIHtcbiAgICAgIF9pbmhlcml0cyhDb250ZXh0QXdhcmVJbmNpZGVudCwgX0xlYWYyKTtcblxuICAgICAgZnVuY3Rpb24gQ29udGV4dEF3YXJlSW5jaWRlbnQoY29uc3RydWN0aW9uSW5ncmVkaWVudHMsIGNvbnRleHREYXRhLCBtY2lkLCBhdHRyaWJ1dGUpIHtcbiAgICAgICAgdmFyIF90aGlzO1xuXG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb250ZXh0QXdhcmVJbmNpZGVudCk7XG5cbiAgICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQ29udGV4dEF3YXJlSW5jaWRlbnQpLmNhbGwodGhpcywgX29iamVjdFNwcmVhZDIoe30sIGNvbnN0cnVjdGlvbkluZ3JlZGllbnRzLnByb3BzLCB7XG4gICAgICAgICAgaWQ6IGF0dHJpYnV0ZSAhPT0gbnVsbCA/IFwiXCIuY29uY2F0KGNvbnN0cnVjdGlvbkluZ3JlZGllbnRzLmluY2lkZW50SWQsIFwiX1wiKS5jb25jYXQobWNpZCwgXCJfXCIpLmNvbmNhdChhdHRyaWJ1dGUpIDogXCJcIi5jb25jYXQoY29uc3RydWN0aW9uSW5ncmVkaWVudHMuaW5jaWRlbnRJZCwgXCJfXCIpLmNvbmNhdChtY2lkKVxuICAgICAgICB9KSkpOyAvLyBhIHByb3BlcnR5IHRvIGhvbGQgYWxsIG9mIHRoZSBjb250ZXh0c1xuXG4gICAgICAgIF9pbml0aWFsaXplKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgICAgICBfdGhpcy5jb250ZXh0cyA9IHt9O1xuICAgICAgICBfdGhpcy5jb25zdHJ1Y3Rpb25JbmdyZWRpZW50cyA9IGNvbnN0cnVjdGlvbkluZ3JlZGllbnRzO1xuICAgICAgICBfdGhpcy5tY2lkID0gbWNpZDtcbiAgICAgICAgX3RoaXMuYXR0cmlidXRlID0gYXR0cmlidXRlOyAvLyB0aGlzLl9kdXJhdGlvbiA9IGNvbnN0cnVjdGlvbkluZ3JlZGllbnRzLnByb3BzLmR1cmF0aW9uO1xuXG4gICAgICAgIF90aGlzLm1jX3BsdWdpbl9ucG1fbmFtZSA9IGNvbnN0cnVjdGlvbkluZ3JlZGllbnRzLnBsdWdpbl9ucG1fbmFtZTtcbiAgICAgICAgX3RoaXMucGx1Z2luX2NoYW5uZWxfY2xhc3MgPSBjb25zdHJ1Y3Rpb25JbmdyZWRpZW50cy5DaGFubmVsO1xuICAgICAgICBfdGhpcy5EZXNjcmlwdGl2ZUluY2lkZW50ID0gY29uc3RydWN0aW9uSW5ncmVkaWVudHMuRGVzY3JpcHRpdmVJbmNpZGVudDtcblxuICAgICAgICBfdGhpcy5hZGRDb250ZXh0KGNvbnRleHREYXRhKTtcblxuICAgICAgICBpZiAoYXR0cmlidXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKF90eXBlb2YoX3RoaXMuY29uc3RydWN0aW9uSW5ncmVkaWVudHMuYXR0cnMuYW5pbWF0ZWRBdHRyc1tfdGhpcy5hdHRyaWJ1dGVdKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIF90aGlzLm9yaWdpbmFsQW5pbWF0ZWRBdHRyaWJ1dGVWYWx1ZSA9IF9vYmplY3RTcHJlYWQyKHt9LCBfdGhpcy5jb25zdHJ1Y3Rpb25JbmdyZWRpZW50cy5hdHRycy5hbmltYXRlZEF0dHJzW190aGlzLmF0dHJpYnV0ZV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5vcmlnaW5hbEFuaW1hdGVkQXR0cmlidXRlVmFsdWUgPSBfdGhpcy5jb25zdHJ1Y3Rpb25JbmdyZWRpZW50cy5hdHRycy5hbmltYXRlZEF0dHJzW190aGlzLmF0dHJpYnV0ZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuZWFzaW5nID0gZWFzaW5nLmxpbmVhcjtcblxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF90aGlzLnByb3BzLCAnZWFzaW5nJykpIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShfdGhpcy5wcm9wcy5lYXNpbmcpKSB7XG4gICAgICAgICAgICBfdGhpcy5lYXNpbmcgPSBzcmMoX3RoaXMucHJvcHMuZWFzaW5nWzBdLCBfdGhpcy5wcm9wcy5lYXNpbmdbMV0sIF90aGlzLnByb3BzLmVhc2luZ1syXSwgX3RoaXMucHJvcHMuZWFzaW5nWzNdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3RoaXMuZWFzaW5nID0gZWFzaW5nW190aGlzLnByb3BzLmVhc2luZ107XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGV4dEF3YXJlSW5jaWRlbnQ7XG4gICAgfShfTGVhZik7XG5cbiAgICByZXR1cm4ge1xuICAgICAgRjogQ29udGV4dEF3YXJlSW5jaWRlbnQsXG4gICAgICBkOiBbe1xuICAgICAgICBraW5kOiBcImdldFwiLFxuICAgICAgICBrZXk6IFwib3JpZ2luYWxDb250ZXh0XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvcmlnaW5hbENvbnRleHQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dHNbdGhpcy5vcmlnaW5hbENvbnRleHRLZXldO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwiZ2V0XCIsXG4gICAgICAgIGtleTogXCJkdXJhdGlvblwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZHVyYXRpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIF9nZXQoX2dldFByb3RvdHlwZU9mKENvbnRleHRBd2FyZUluY2lkZW50LnByb3RvdHlwZSksIFwiZHVyYXRpb25cIiwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJzZXRcIixcbiAgICAgICAga2V5OiBcImR1cmF0aW9uXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkdXJhdGlvbihtaWxsaXNlY29uZHMpIHtcbiAgICAgICAgICBfc2V0KF9nZXRQcm90b3R5cGVPZihDb250ZXh0QXdhcmVJbmNpZGVudC5wcm90b3R5cGUpLCBcImR1cmF0aW9uXCIsIG1pbGxpc2Vjb25kcywgdGhpcywgdHJ1ZSk7XG5cbiAgICAgICAgICBmb3IgKHZhciBjb250ZXh0IGluIHRoaXMuY29udGV4dHMpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dHNbY29udGV4dF0uZHVyYXRpb24gPSBtaWxsaXNlY29uZHM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICAgIGtleTogXCJhZGRDb250ZXh0XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRDb250ZXh0KGNvbnRleHREYXRhKSB7XG4gICAgICAgICAgdmFyIGZvcmNlR2V0Q29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICAgICAgLy8gaWYgaXQncyB0aGUgZmlyc3QgY29udGV4dCB0byBiZSBhZGRlZCB0aGVuIGl0J3MgdGhlIG9yaWdpbmFsXG4gICAgICAgICAgdmFyIGlzVGhlT3JpZ2luYWxDb250ZXh0ID0gZmFsc2U7XG5cbiAgICAgICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5jb250ZXh0cykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbmFsQ29udGV4dEtleSA9IGNvbnRleHREYXRhLmNsaXBJZDtcbiAgICAgICAgICAgIHRoaXMub3JpZ2luYWxDbGlwQ29udGV4dCA9IGNvbnRleHREYXRhLmNvbnRleHQ7XG4gICAgICAgICAgICBpc1RoZU9yaWdpbmFsQ29udGV4dCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGluZ3JlZGllbnRzVG9QYXNzID0gX29iamVjdFNwcmVhZDIoe30sIHRoaXMuY29uc3RydWN0aW9uSW5ncmVkaWVudHMsIHtcbiAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHREYXRhLmNvbnRleHQsXG4gICAgICAgICAgICBtY2lkOiB0aGlzLm1jaWRcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciB3aGF0VG9BZGQgPSBpbmNpZGVudEZyb21JbmdyZWRpZW50cyhpbmdyZWRpZW50c1RvUGFzcyk7XG4gICAgICAgICAgdGhpcy5jb250ZXh0c1tjb250ZXh0RGF0YS5jbGlwSWRdID0gd2hhdFRvQWRkOyAvLyB3aGVuIHdlIGFkZCBhIG5ldyBjb250ZXh0IHdlIG11c3Qgc2V0IHRoZSBpbml0YWwgdmFsdWUgb2YgdGhlIG5ld2x5IGFkZGVkIEluY2lkZW50c1xuICAgICAgICAgIC8vIGJ1dCBvbmx5IGZvciBJbmNpZGVudHMgd2l0aCBhbmltYXRlZEF0dHJzXG5cbiAgICAgICAgICBpZiAoIWlzVGhlT3JpZ2luYWxDb250ZXh0ICYmIHRoaXMuYXR0cmlidXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHRzW2NvbnRleHREYXRhLmNsaXBJZF0uc2V0SW5pdGlhbFZhbHVlKHRoaXMuZ2V0SW5pdGlhbFZhbHVlKCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChmb3JjZUdldENvbnRleHQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dHNbY29udGV4dERhdGEuY2xpcElkXS5fb25HZXRDb250ZXh0T25jZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAgICBrZXk6IFwiaGFuZGxlQWRkQ29udGV4dFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlQWRkQ29udGV4dCh0YXJnZXQsIHBheWxvYWQpIHtcbiAgICAgICAgICB0aGlzLmFkZENvbnRleHQocGF5bG9hZCwgdHJ1ZSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgICAgZGVjb3JhdG9yczogW2dldEluY2lkZW50c0J5Q2hhbm5lbF0sXG4gICAgICAgIGtleTogXCJnZXRJbmNpZGVudHNCeUNoYW5uZWxcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEluY2lkZW50c0J5Q2hhbm5lbCgpIHt9XG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICAgIGtleTogXCJvblByb2dyZXNzXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvblByb2dyZXNzKGZyYWN0aW9uLCBtaWxsaXNlY29uZHMsIGNvbnRleHRJZCkge1xuICAgICAgICAgIC8qIE1vbm9JbmNpZGVudHMgYXJlIHRvdGFsbHkgYWdub3N0aWMgYWJvdXQgZGVsYXksIGhpYXR1cyBhbmQgcmVwZWF0cy5cbiAgICAgICAgICAgICAgQ0FJIGlzIG5vdCB0aGF0J3MgZXhhY3RseSB0aGUgcG9pbnQgd2hlcmUgdGhlc2UgcHJvcGVydGllcyBtYW5hZ2VtZW50IG9jY3Vycy5cbiAgICAgICAgICAgICAgSGF2aW5nIGFscmVkeSBzZXQgdGhlIGR1cmF0aW9uIG9mIHRoZSBDb250ZXh0QXdhcmVJbmNpZGVudCBhY2NvcmRpbmcgdG9cbiAgICAgICAgICAgICAgYWxsIG9mIHRoZXNlIHByb3BzLCBoZXJlIHRoZSBDQUkgZGVjaWRlcyBvbiB0aGUgcHJvZ3Jlc3MgdGhhdCBpdHMgTW9ub0luY2lkZW50c1xuICAgICAgICAgICAgICBhcmUgdG8gb24gYXQgdGhlIGdpdmVuIG1pbGxpc2Vjb25kIGFuZCBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIHByb3BzLlxuICAgICAgICAgICAgICAqL1xuICAgICAgICAgIC8vIHN0ZXAgMTogZmluZCB0aGUgZnVsbCBkZWxheS1kdXJhdGlvbi1oaWF0dXMgZHVyYXRpb24gb2Ygb25lIHJlcGVhdFxuICAgICAgICAgIHZhciByZXBlYXREdXJhdGlvbiA9IHRoaXMuZGVsYXkgKyB0aGlzLnByb3BzLmR1cmF0aW9uICsgdGhpcy5oaWF0dXM7IC8vIHN0ZXAgMi5hOiBmaW5kIHRoZSBydW5uaW5nIHJlcGVhdCBhbmQgbWlsbGlzZWNvbmQgb2YgdGhpcyByZXBlYXRcblxuICAgICAgICAgIHZhciBtaWxsaXNlY29uZFdpdGhpblJlcGVhdCA9IG1pbGxpc2Vjb25kcyAlIHJlcGVhdER1cmF0aW9uOyAvLyBzdGVwIDIuYjogZGVjaWRlIGJldHdlZW4gMCBhbmQgMVxuXG4gICAgICAgICAgaWYgKG1pbGxpc2Vjb25kcyAhPT0gMCAmJiBtaWxsaXNlY29uZFdpdGhpblJlcGVhdCA9PT0gMCkge1xuICAgICAgICAgICAgbWlsbGlzZWNvbmRXaXRoaW5SZXBlYXQgPSB0aGlzLmRlbGF5ICsgdGhpcy5wcm9wcy5kdXJhdGlvbjtcbiAgICAgICAgICB9IC8vIHN0ZXAgMzogZmluZCB0aGUgbWlsbGlzZWNvbmQgb2YgdGhlIE1vbm9JbmNpZGVudFxuXG5cbiAgICAgICAgICB2YXIgTUlfbWlsbGlzZWNvbmQgPSBtaWxsaXNlY29uZFdpdGhpblJlcGVhdCAtIHRoaXMuZGVsYXk7XG5cbiAgICAgICAgICBpZiAoTUlfbWlsbGlzZWNvbmQgPCAwKSB7XG4gICAgICAgICAgICBNSV9taWxsaXNlY29uZCA9IDA7XG4gICAgICAgICAgfSBlbHNlIGlmIChNSV9taWxsaXNlY29uZCA+IHRoaXMucHJvcHMuZHVyYXRpb24pIHtcbiAgICAgICAgICAgIC8vIGlmIGl0IGhhcyBzdGVwcGVkIGludG8gaGlhdHVzXG4gICAgICAgICAgICBNSV9taWxsaXNlY29uZCA9IHRoaXMucHJvcHMuZHVyYXRpb247XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIE1JX2ZyYWN0aW9uID0gTUlfbWlsbGlzZWNvbmQgLyB0aGlzLnByb3BzLmR1cmF0aW9uO1xuICAgICAgICAgIHZhciBlYXNlZF9NSV9mcmFjdGlvbiA9IHRoaXMuZWFzaW5nKE1JX2ZyYWN0aW9uKTtcbiAgICAgICAgICB2YXIgZWFzZWRfTUlfbWlsbGlzZWNvbmQgPSBlYXNlZF9NSV9mcmFjdGlvbiAqIHRoaXMucHJvcHMuZHVyYXRpb247XG5cbiAgICAgICAgICBpZiAoY29udGV4dElkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGNvbnRleHQgaW4gdGhpcy5jb250ZXh0cykge1xuICAgICAgICAgICAgICB0aGlzLmNvbnRleHRzW2NvbnRleHRdLm9uUHJvZ3Jlc3MoZWFzZWRfTUlfZnJhY3Rpb24sIGVhc2VkX01JX21pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuY29udGV4dHNbY29udGV4dElkXS5vblByb2dyZXNzKGVhc2VkX01JX2ZyYWN0aW9uLCBlYXNlZF9NSV9taWxsaXNlY29uZCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIE1FVEhPRFMgVEhBVCBBQ1QgQVMgXCJQUk9YWVwiIFRPIEFMTCBPRiBUSEUgSU5DSURFTlRTIEJFTE9OR0lORyBUT1xuICAgICAgICAgKiBUSEUgSU5DSURFTlRTIENPTExFQ1RJT04gT0YgVEhFIENPTlRFWFQgQVdBUkUgSU5DSURFTlRcbiAgICAgICAgICogKi9cblxuICAgICAgfSwge1xuICAgICAgICBraW5kOiBcImdldFwiLFxuICAgICAgICBrZXk6IFwiYW5pbWF0ZWRBdHRyaWJ1dGVWYWx1ZVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYW5pbWF0ZWRBdHRyaWJ1dGVWYWx1ZSgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rpb25JbmdyZWRpZW50cy5hdHRycy5hbmltYXRlZEF0dHJzW3RoaXMuYXR0cmlidXRlXTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBraW5kOiBcInNldFwiLFxuICAgICAgICBrZXk6IFwiYW5pbWF0ZWRBdHRyaWJ1dGVWYWx1ZVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYW5pbWF0ZWRBdHRyaWJ1dGVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICAgIHRoaXMuY29uc3RydWN0aW9uSW5ncmVkaWVudHMuYXR0cnMuYW5pbWF0ZWRBdHRyc1t0aGlzLmF0dHJpYnV0ZV0gPSB2YWx1ZTtcbiAgICAgICAgfSAvLyBtYXNzaXZlIGVkaXRpbmcgbWV0aG9kcyB0aGF0IGFwcGx5IHRoZSByZXF1ZXN0IG1hc3NpdmVseSB0byBhbGwgb2YgdGhlXG4gICAgICAgIC8vIEluY2lkZW50cyBvZiBhbGwgb2YgdGhlIGNvbnRleHRzXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgICAga2V5OiBcImdvdENvbnRleHRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdvdENvbnRleHQoKSB7XG4gICAgICAgICAgZm9yICh2YXIgY29udGV4dCBpbiB0aGlzLmNvbnRleHRzKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHRzW2NvbnRleHRdLmdvdENvbnRleHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgICAga2V5OiBcIl9vbkdldENvbnRleHRPbmNlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25HZXRDb250ZXh0T25jZSgpIHtcbiAgICAgICAgICBmb3IgKHZhciBjb250ZXh0IGluIHRoaXMuY29udGV4dHMpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dHNbY29udGV4dF0uX29uR2V0Q29udGV4dE9uY2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgICAga2V5OiBcImxhc3RXaXNoXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBsYXN0V2lzaCgpIHtcbiAgICAgICAgICBmb3IgKHZhciBjb250ZXh0IGluIHRoaXMuY29udGV4dHMpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dHNbY29udGV4dF0ubGFzdFdpc2goKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgICAga2V5OiBcIm9uR2V0Q29udGV4dFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25HZXRDb250ZXh0KCkge1xuICAgICAgICAgIGZvciAodmFyIGNvbnRleHQgaW4gdGhpcy5jb250ZXh0cykge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0c1tjb250ZXh0XS5vbkdldENvbnRleHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgICAga2V5OiBcImdldEluaXRpYWxWYWx1ZVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5pdGlhbFZhbHVlKCkge1xuICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG5cbiAgICAgICAgICBpZiAoYXR0cmlidXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5vcmlnaW5hbENvbnRleHQuZ2V0SW5pdGlhbFZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJnZXRcIixcbiAgICAgICAga2V5OiBcImluaXRpYWxWYWx1ZVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbFZhbHVlKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmdldEluaXRpYWxWYWx1ZSgpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwiZ2V0XCIsXG4gICAgICAgIGtleTogXCJzY3JhdGNoVmFsdWVcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNjcmF0Y2hWYWx1ZSgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5vcmlnaW5hbENvbnRleHQuc2NyYXRjaFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwiZ2V0XCIsXG4gICAgICAgIGtleTogXCJwdXJlSW5pdGlhbFZhbHVlc1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcHVyZUluaXRpYWxWYWx1ZXMoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYWxDb250ZXh0LnB1cmVJbml0aWFsVmFsdWVzO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICAgIGtleTogXCJzZXRJbml0aWFsVmFsdWVcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEluaXRpYWxWYWx1ZSgpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG4gICAgICAgICAgdmFyIHN0b3JlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuXG4gICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZ2V0U2NyYXRjaFZhbHVlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgY29udGV4dCBpbiB0aGlzLmNvbnRleHRzKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHRzW2NvbnRleHRdLnNldEluaXRpYWxWYWx1ZShKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHZhbHVlKSksIHN0b3JlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgICAga2V5OiBcImdldFNjcmF0Y2hWYWx1ZVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2NyYXRjaFZhbHVlKCkge1xuICAgICAgICAgIHZhciBjb250ZXh0SWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG5cbiAgICAgICAgICBpZiAoY29udGV4dElkID09PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dHNLZXlzID0gT2JqZWN0LmtleXModGhpcy5jb250ZXh0cyk7XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5vcmlnaW5hbENsaXBDb250ZXh0LCAnbm9uRnJhZ21lbnRlZENvbnRleHQnKSkge1xuICAgICAgICAgICAgICB2YXIgaW5ncmVkaWVudHNUb1Bhc3MgPSBfb2JqZWN0U3ByZWFkMih7fSwgdGhpcy5jb25zdHJ1Y3Rpb25JbmdyZWRpZW50cywge1xuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMub3JpZ2luYWxDbGlwQ29udGV4dC5ub25GcmFnbWVudGVkQ29udGV4dCxcbiAgICAgICAgICAgICAgICBtY2lkOiB0aGlzLm1jaWRcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgdmFyIHRlbXBJbmNpZGVudCA9IGluY2lkZW50RnJvbUluZ3JlZGllbnRzKGluZ3JlZGllbnRzVG9QYXNzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRlbXBJbmNpZGVudC5nZXRTY3JhdGNoVmFsdWUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbnRleHRzS2V5cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYWxDb250ZXh0LmdldFNjcmF0Y2hWYWx1ZSgpO1xuICAgICAgICAgICAgfSAvLyBwcmVmZXIgYW5vdGhlciAobm90IHRoZSBvcmlnaW5hbCkgY29udGV4dCB0byBwcm92aWRlIHNjcmF0Y2ggdmFsdWVzXG5cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dHNbY29udGV4dHNLZXlzWzFdXS5nZXRTY3JhdGNoVmFsdWUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0c1tjb250ZXh0SWRdLmdldFNjcmF0Y2hWYWx1ZSgpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICAgIGtleTogXCJzZXRDb21wb0F0dHJLZXlWYWx1ZVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q29tcG9BdHRyS2V5VmFsdWUoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgIGZvciAodmFyIGNvbnRleHQgaW4gdGhpcy5jb250ZXh0cykge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0c1tjb250ZXh0XS5hdHRycy5hbmltYXRlZEF0dHJzW3RoaXMuYXR0cmlidXRlXVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHRzW2NvbnRleHRdLmxhc3RXaXNoKCk7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHRzW2NvbnRleHRdLm9uR2V0Q29udGV4dCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAgICBrZXk6IFwicGxheVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcGxheShmcmFjdGlvbiwgbXMsIGNvbnRleHRJZCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRleHRzW2NvbnRleHRJZF0ucGxheShtcyk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgICAga2V5OiBcInN0b3BcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3AoY29udGV4dElkKSB7XG4gICAgICAgICAgdGhpcy5jb250ZXh0c1tjb250ZXh0SWRdLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfV1cbiAgICB9O1xuICB9LCBMZWFmKTtcblxuICB2YXIgQW5pbWF0ZWRBdHRyaWJ1dGVzU3BsaXR0ZXIgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uIChfR3JvdXApIHtcbiAgICBfaW5oZXJpdHMoQW5pbWF0ZWRBdHRyaWJ1dGVzU3BsaXR0ZXIsIF9Hcm91cCk7XG5cbiAgICBmdW5jdGlvbiBBbmltYXRlZEF0dHJpYnV0ZXNTcGxpdHRlcihkZXNjcmlwdGl2ZUluY2lkZW50LCBjb250ZXh0RGF0YSwgbWNpZCwgc2VsZWN0b3IpIHtcbiAgICAgIHZhciBfdGhpcztcblxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFuaW1hdGVkQXR0cmlidXRlc1NwbGl0dGVyKTtcblxuICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQW5pbWF0ZWRBdHRyaWJ1dGVzU3BsaXR0ZXIpLmNhbGwodGhpcywge30sIHtcbiAgICAgICAgaWQ6IFwiXCIuY29uY2F0KGRlc2NyaXB0aXZlSW5jaWRlbnQuaWQsIFwiX1wiKS5jb25jYXQobWNpZClcbiAgICAgIH0pKTtcbiAgICAgIF90aGlzLm1jaWQgPSBtY2lkO1xuICAgICAgX3RoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcblxuICAgICAgX3RoaXMuc2V0VXAoZGVzY3JpcHRpdmVJbmNpZGVudCwgY29udGV4dERhdGEpO1xuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEFuaW1hdGVkQXR0cmlidXRlc1NwbGl0dGVyLCBbe1xuICAgICAga2V5OiBcInNldFVwXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VXAoZGVzY3JpcHRpdmVJbmNpZGVudCwgY29udGV4dERhdGEpIHtcbiAgICAgICAgZm9yICh2YXIgYXR0ciBpbiBkZXNjcmlwdGl2ZUluY2lkZW50LmF0dHJzLmFuaW1hdGVkQXR0cnMpIHtcbiAgICAgICAgICB2YXIgc2luZ2xlQW5pbWF0ZWRBdHRycyA9IHt9O1xuICAgICAgICAgIHNpbmdsZUFuaW1hdGVkQXR0cnNbYXR0cl0gPSBkZXNjcmlwdGl2ZUluY2lkZW50LmF0dHJzLmFuaW1hdGVkQXR0cnNbYXR0cl07XG5cbiAgICAgICAgICB2YXIgYXR0cnNUb1Bhc3MgPSBfb2JqZWN0U3ByZWFkMih7fSwgZGVzY3JpcHRpdmVJbmNpZGVudC5hdHRycywge1xuICAgICAgICAgICAgYW5pbWF0ZWRBdHRyczogc2luZ2xlQW5pbWF0ZWRBdHRyc1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIHByb3BzVG9QYXNzID0gX29iamVjdFNwcmVhZDIoe30sIGRlc2NyaXB0aXZlSW5jaWRlbnQucHJvcHMsIHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiB0aGlzLnNlbGVjdG9yXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgY29uc3RydWN0aW9uSW5ncmVkaWVudHMgPSB7XG4gICAgICAgICAgICBpbmNpZGVudElkOiBkZXNjcmlwdGl2ZUluY2lkZW50LmlkLFxuICAgICAgICAgICAgYXR0cnM6IGF0dHJzVG9QYXNzLFxuICAgICAgICAgICAgcHJvcHM6IHByb3BzVG9QYXNzLFxuICAgICAgICAgICAgSW5jaWRlbnQ6IGRlc2NyaXB0aXZlSW5jaWRlbnQuY29uc3RydWN0b3IuSW5jaWRlbnQsXG4gICAgICAgICAgICBwbHVnaW5fbnBtX25hbWU6IGRlc2NyaXB0aXZlSW5jaWRlbnQuY29uc3RydWN0b3IucGx1Z2luX25wbV9uYW1lLFxuICAgICAgICAgICAgQ2hhbm5lbDogZGVzY3JpcHRpdmVJbmNpZGVudC5jb25zdHJ1Y3Rvci5DaGFubmVsLFxuICAgICAgICAgICAgRGVzY3JpcHRpdmVJbmNpZGVudDogZGVzY3JpcHRpdmVJbmNpZGVudFxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIGNvbnRleHRBd2FyZUluY2lkZW50ID0gbmV3IENvbnRleHRBd2FyZUluY2lkZW50KGNvbnN0cnVjdGlvbkluZ3JlZGllbnRzLCBjb250ZXh0RGF0YSwgdGhpcy5tY2lkLCBhdHRyKTtcbiAgICAgICAgICB0aGlzLmFkZENoaWxkKGNvbnRleHRBd2FyZUluY2lkZW50LCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBBbmltYXRlZEF0dHJpYnV0ZXNTcGxpdHRlcjtcbiAgfShHcm91cCk7XG5cbiAgdmFyIEVsZW1lbnRTcGxpdHRlciA9XG4gIC8qI19fUFVSRV9fKi9cbiAgZnVuY3Rpb24gKF9Hcm91cCkge1xuICAgIF9pbmhlcml0cyhFbGVtZW50U3BsaXR0ZXIsIF9Hcm91cCk7XG5cbiAgICBmdW5jdGlvbiBFbGVtZW50U3BsaXR0ZXIoZGVzY3JpcHRpdmVJbmNpZGVudCwgY29udGV4dERhdGEpIHtcbiAgICAgIHZhciBfdGhpcztcblxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVsZW1lbnRTcGxpdHRlcik7XG5cbiAgICAgIC8vIHdlIG1ha2Ugc3VyZSB0aGUgRE9NQXdhcmVJbmNpZGVudCB0YWtlcyB0aGUgc2FtZSBpZCBhcyB0aGUgRGVzY3JpcHRpdmUgSW5jaWRlbnRcbiAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEVsZW1lbnRTcGxpdHRlcikuY2FsbCh0aGlzLCB7fSwge1xuICAgICAgICBpZDogZGVzY3JpcHRpdmVJbmNpZGVudC5pZFxuICAgICAgfSkpOyAvLyBhIHByb3BlcnR5IHRvIGhvbGQgYWxsIG9mIHRoZSBjb250ZXh0c1xuXG4gICAgICBfdGhpcy5jb250ZXh0cyA9IHt9O1xuICAgICAgX3RoaXMuY29udGV4dHNbY29udGV4dERhdGEuY2xpcElkXSA9IGNvbnRleHREYXRhLmNvbnRleHQ7XG4gICAgICBfdGhpcy5vcmlnaW5hbENvbnRleHRLZXkgPSBjb250ZXh0RGF0YS5jbGlwSWQ7XG4gICAgICBfdGhpcy5pbnN0YW50aWF0ZWRDb3BpZXNDb250ZXh0cyA9IGNvbnRleHREYXRhLmluc3RhbnRpYXRlZENvcGllc0NvbnRleHRzO1xuXG4gICAgICBfdGhpcy5zZXRVcChkZXNjcmlwdGl2ZUluY2lkZW50LCBjb250ZXh0RGF0YSk7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoRWxlbWVudFNwbGl0dGVyLCBbe1xuICAgICAga2V5OiBcInNldFVwXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VXAoZGVzY3JpcHRpdmVJbmNpZGVudCwgY29udGV4dERhdGEpIHtcbiAgICAgICAgLy8gdGhlIGVsZW1lbnRzIG9mIHRoZSBvcmlnaW5hbCBjb250ZXh0XG4gICAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMub3JpZ2luYWxDb250ZXh0LmdldEVsZW1lbnRzKGRlc2NyaXB0aXZlSW5jaWRlbnQuc2VsZWN0b3IoKSk7IC8vIHRoZSBlbGVtZW50cyBmb3IgZWFjaCBvZiB0aGUgY29waWVkIGNvbnRleHRzXG4gICAgICAgIC8vIGNvbnN0IGNvcGllc0VsZW1lbnRzID0ge307XG4gICAgICAgIC8vIGZvciAobGV0IGNvbnRleHRLZXkgaW4gdGhpcy5pbnN0YW50aWF0ZWRDb3BpZXNDb250ZXh0cykge1xuICAgICAgICAvLyAgICAgY29waWVzRWxlbWVudHNbY29udGV4dEtleV0gPSBBcnJheS5mcm9tKHRoaXMuaW5zdGFudGlhdGVkQ29waWVzQ29udGV4dHNbY29udGV4dEtleV0ucm9vdEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChkZXNjcmlwdGl2ZUluY2lkZW50LnByb3BzLnNlbGVjdG9yKSk7XG4gICAgICAgIC8vIH1cblxuICAgICAgICB2YXIgdG90YWxFbGVtZW50cyA9IGVsZW1lbnRzLmxlbmd0aDtcbiAgICAgICAgdmFyIGVsZW1lbnQsIG1jaWQ7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3RhbEVsZW1lbnRzOyBpKyspIHtcbiAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudHNbaV07IC8vIHNldCB0aGUgbWNpZCBvZiB0aGUgZWxlbWVudCBvbiBpbmRleCBpIG9mIHRoZSBvcmlnaW5hbCBjb250ZXh0XG5cbiAgICAgICAgICBtY2lkID0gdGhpcy5fZ2V0RWxlbWVudE1DSUQoZWxlbWVudCk7IC8vIHNldCB0aGUgc2FtZSBtY2lkIGZvciB0aGUgZWxlbWVudHMgb2YgdGhlIHNhbWUgY29udGV4dCBpbiBhbGwgb2YgdGhlIGluc3RhbnRpYXRlZENvcGllc0NvbnRleHRzXG5cbiAgICAgICAgICBmb3IgKHZhciBjb250ZXh0S2V5IGluIHRoaXMuaW5zdGFudGlhdGVkQ29waWVzQ29udGV4dHMpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gcGVyZnJvcm1hbmNlIGltcHJvdmVtZW50IHZpYSBzZWxlY3Rpbmcgb25jZSBlbGVtZW50cyBwZXIgY29udGV4dFxuICAgICAgICAgICAgdGhpcy5fc2V0RWxlbWVudE1DSUQodGhpcy5pbnN0YW50aWF0ZWRDb3BpZXNDb250ZXh0c1tjb250ZXh0S2V5XSwgdGhpcy5pbnN0YW50aWF0ZWRDb3BpZXNDb250ZXh0c1tjb250ZXh0S2V5XS5nZXRFbGVtZW50cyhkZXNjcmlwdGl2ZUluY2lkZW50LnNlbGVjdG9yKCkpW2ldLCBtY2lkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9jcmVhdGVFbGVtZW50SW5jaWRlbnQoZWxlbWVudCwgZGVzY3JpcHRpdmVJbmNpZGVudCwgY29udGV4dERhdGEsIGksIHRvdGFsRWxlbWVudHMsIG1jaWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9nZXRFbGVtZW50TUNJRFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRFbGVtZW50TUNJRChlbGVtZW50KSB7XG4gICAgICAgIHZhciBtY2lkID0gdGhpcy5vcmlnaW5hbENvbnRleHQuZ2V0TUNJRChlbGVtZW50KTtcblxuICAgICAgICBpZiAoIW1jaWQpIHtcbiAgICAgICAgICBtY2lkID0gZ2V0QW5JZCh0cnVlKTtcbiAgICAgICAgICB0aGlzLm9yaWdpbmFsQ29udGV4dC5zZXRNQ0lEKGVsZW1lbnQsIG1jaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1jaWQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9zZXRFbGVtZW50TUNJRFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRFbGVtZW50TUNJRChjb250ZXh0LCBlbGVtZW50LCBtY2lkKSB7XG4gICAgICAgIHZhciBleGlzdGluZ01DSUQgPSBjb250ZXh0LmdldE1DSUQoZWxlbWVudCk7XG5cbiAgICAgICAgaWYgKCFleGlzdGluZ01DSUQpIHtcbiAgICAgICAgICBjb250ZXh0LnNldE1DSUQoZWxlbWVudCwgbWNpZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2NyZWF0ZUVsZW1lbnRJbmNpZGVudFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50SW5jaWRlbnQoZWxlbWVudCwgZGVzY3JpcHRpdmVJbmNpZGVudCwgY29udGV4dERhdGEsIGVsZW1lbnRJbmRleCwgdG90YWxFbGVtZW50cywgbWNpZCkge1xuICAgICAgICAvKiBlbGVtZW50cyBzcGxpdHRlciBtaWdodCBoYW5kbGUgZWl0aGVyIGF0dHJpYnV0ZSBJbmNpZGVudHMgKHRoYXQgaGF2ZSBhbmltYXRlZEF0dHJzKSBvciBJbmNpZGVudHNcbiAgICAgICAgICAgIHRoYXQgZG8gbm90IGhhdmUgYW5pbWF0ZWRBdHRycyBzdWNoIGFzIE1lZGlhUGxheWJhY2sgSW5jaWRlbnRzLlxuICAgICAgICAgICAgSW4gdGhlIGNhc2Ugb2YgYW4gYXR0cmlidXRlZCBJbmNpZGVudCB3ZSBwcm9jZWVkIGJ5IGNyZWF0aW5nIG9uZSBBdHRyaWJ1dGVTcGxpdHRlciBmb3IgZWFjaFxuICAgICAgICAgICAgd2hpbGUgb24gdGhlIGNhc2Ugb2YgYW4gbm9uLWF0dHJpYnVyZWQgSW5jaWRlbnQgd2UgZ28gYWhlYWQgYW5kXG4gICAgICAgICAgICAqL1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRlc2NyaXB0aXZlSW5jaWRlbnQuYXR0cnMsICdhbmltYXRlZEF0dHJzJykpIHtcbiAgICAgICAgICB2YXIgYW5pbWF0ZWRBdHRyaWJ1dGVTcGxpdHRlciA9IG5ldyBBbmltYXRlZEF0dHJpYnV0ZXNTcGxpdHRlcihkZXNjcmlwdGl2ZUluY2lkZW50LCBjb250ZXh0RGF0YSwgbWNpZCwgY29udGV4dERhdGEuY29udGV4dC5nZXRFbGVtZW50U2VsZWN0b3JCeU1DSUQobWNpZCkpO1xuICAgICAgICAgIHRoaXMuYWRkQ2hpbGQoYW5pbWF0ZWRBdHRyaWJ1dGVTcGxpdHRlciwgMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRlc2NyaXB0aXZlSW5jaWRlbnQuYXR0cnMsICdrZXlmcmFtZXMnKSkgOyBlbHNlIHtcbiAgICAgICAgICB2YXIgYXR0cnNUb1Bhc3MgPSBkZXNjcmlwdGl2ZUluY2lkZW50LmF0dHJzO1xuXG4gICAgICAgICAgdmFyIHByb3BzVG9QYXNzID0gX29iamVjdFNwcmVhZDIoe30sIGRlc2NyaXB0aXZlSW5jaWRlbnQucHJvcHMsIHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiB0aGlzLnNlbGVjdG9yXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgY29uc3RydWN0aW9uSW5ncmVkaWVudHMgPSB7XG4gICAgICAgICAgICBpbmNpZGVudElkOiBkZXNjcmlwdGl2ZUluY2lkZW50LmlkLFxuICAgICAgICAgICAgYXR0cnM6IGF0dHJzVG9QYXNzLFxuICAgICAgICAgICAgcHJvcHM6IHByb3BzVG9QYXNzLFxuICAgICAgICAgICAgSW5jaWRlbnQ6IGRlc2NyaXB0aXZlSW5jaWRlbnQuY29uc3RydWN0b3IuSW5jaWRlbnQsXG4gICAgICAgICAgICBwbHVnaW5fbnBtX25hbWU6IGRlc2NyaXB0aXZlSW5jaWRlbnQuY29uc3RydWN0b3IucGx1Z2luX25wbV9uYW1lLFxuICAgICAgICAgICAgQ2hhbm5lbDogZGVzY3JpcHRpdmVJbmNpZGVudC5jb25zdHJ1Y3Rvci5DaGFubmVsLFxuICAgICAgICAgICAgRGVzY3JpcHRpdmVJbmNpZGVudDogZGVzY3JpcHRpdmVJbmNpZGVudFxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIGNvbnRleHRBd2FyZUluY2lkZW50ID0gbmV3IENvbnRleHRBd2FyZUluY2lkZW50KGNvbnN0cnVjdGlvbkluZ3JlZGllbnRzLCBjb250ZXh0RGF0YSwgbWNpZCwgbnVsbCk7XG4gICAgICAgICAgdGhpcy5hZGRDaGlsZChjb250ZXh0QXdhcmVJbmNpZGVudCwgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwib3JpZ2luYWxDb250ZXh0XCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dHNbdGhpcy5vcmlnaW5hbENvbnRleHRLZXldO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBFbGVtZW50U3BsaXR0ZXI7XG4gIH0oR3JvdXApO1xuXG4gIC8qKlxuICAgKiBUaGlzIENsYXNzIGFjdHMgYXMgdGhlIERPTSBBd2FyZSBJbmNpZGVudCBmb3IgQ2xpcHMuIFdoZW4gY29uc3RydWN0ZWQgdGhlIEluY2lkZW50IHBhc3NlZCB0b1xuICAgKiBpdCBpcyBhIENsaXAgd2l0aCBGcmFnbWVudEhUTUwgY29udGV4dCBoYW5kbGVyLlxuICAgKiBPbiBhZGRpdGlvbiwgZWRpdCBvciBkZWxldGlvbiBvZiBJbmNpZGVudHMgb24gdGhlIEZyYWdtZW50ZWQgQ2xpcCdzIHRyZWUsIG9mIHRoZVxuICAgKiBEZXNjcmlwdGl2ZSBDbGlwIHRoaXMgRWxlbWVudENsaXBTcGxpdHRlciBpbXBsZW1lbnRzLCBhbGwgdXBkYXRlcyBvbiBsYW5lc1xuICAgKiBhbmQgZXZlcnl0aGluZyB0aGF0IHRoZXNlIGNsaXBzIG5lZWQgaW4gb3JkZXIgdG8gcnVuIGFyZSBtYWRlIGRpcmVjdGx5IHRvIHRoZVxuICAgKiBDb250ZXh0QXdhcmVJbmNpZGVudHMgb2YgdGhlIERlc2NyaXB0aXZlQ2xpcCdzIHJlYWwgQ2xpcC5cbiAgICovXG5cbiAgdmFyIEVsZW1lbnRDbGlwU3BsaXR0ZXIgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uIChfRFdJKSB7XG4gICAgX2luaGVyaXRzKEVsZW1lbnRDbGlwU3BsaXR0ZXIsIF9EV0kpO1xuXG4gICAgZnVuY3Rpb24gRWxlbWVudENsaXBTcGxpdHRlcihkZXNjcmlwdGl2ZUluY2lkZW50LCBjb250ZXh0RGF0YSkge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRWxlbWVudENsaXBTcGxpdHRlcik7XG5cbiAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEVsZW1lbnRDbGlwU3BsaXR0ZXIpLmNhbGwodGhpcywgZGVzY3JpcHRpdmVJbmNpZGVudCwgY29udGV4dERhdGEpKTtcbiAgICAgIF90aGlzLnJlYWxDbGlwID0gZGVzY3JpcHRpdmVJbmNpZGVudC5yZWFsQ2xpcDtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoRWxlbWVudENsaXBTcGxpdHRlciwgW3tcbiAgICAgIGtleTogXCJfY3JlYXRlRWxlbWVudEluY2lkZW50XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnRJbmNpZGVudChlbGVtZW50LCBkZXNjcmlwdGl2ZUluY2lkZW50LCBjb250ZXh0RGF0YSwgZWxlbWVudEluZGV4LCB0b3RhbEVsZW1lbnRzLCBtY2lkKSB7XG4gICAgICAgIHZhciBjb25zdHJ1Y3Rpb25Bcmd1bWVudHMgPSBkZXNjcmlwdGl2ZUluY2lkZW50LnJlYWxDbGlwLmV4cG9ydENvbnN0cnVjdGlvbkFyZ3VtZW50cygpO1xuICAgICAgICB2YXIgY29uc3RydWN0aW9uSW5ncmVkaWVudHMgPSB7XG4gICAgICAgICAgaW5jaWRlbnRJZDogZGVzY3JpcHRpdmVJbmNpZGVudC5pZCxcbiAgICAgICAgICBhdHRyczogY29uc3RydWN0aW9uQXJndW1lbnRzLmF0dHJzLFxuICAgICAgICAgIHByb3BzOiBfb2JqZWN0U3ByZWFkMih7fSwgY29uc3RydWN0aW9uQXJndW1lbnRzLnByb3BzLCB7XG4gICAgICAgICAgICBzZWxlY3RvcjogY29udGV4dERhdGEuY29udGV4dC5nZXRFbGVtZW50U2VsZWN0b3JCeU1DSUQobWNpZCksXG4gICAgICAgICAgICBydW5UaW1lSW5mbzogZGVzY3JpcHRpdmVJbmNpZGVudC5ydW5UaW1lSW5mb1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIEluY2lkZW50OiBkZXNjcmlwdGl2ZUluY2lkZW50LmNvbnN0cnVjdG9yLkluY2lkZW50LFxuICAgICAgICAgIHBsdWdpbl9ucG1fbmFtZTogZGVzY3JpcHRpdmVJbmNpZGVudC5jb25zdHJ1Y3Rvci5wbHVnaW5fbnBtX25hbWUsXG4gICAgICAgICAgQ2hhbm5lbDogQ2xpcENoYW5uZWwsXG4gICAgICAgICAgRGVzY3JpcHRpdmVJbmNpZGVudDogZGVzY3JpcHRpdmVJbmNpZGVudFxuICAgICAgICB9O1xuICAgICAgICB2YXIgY29udGV4dEF3YXJlQ2xpcEluY2lkZW50ID0gbmV3IENvbnRleHRBd2FyZUNsaXBJbmNpZGVudChjb25zdHJ1Y3Rpb25JbmdyZWRpZW50cywgY29udGV4dERhdGEsIG1jaWQsIGRlc2NyaXB0aXZlSW5jaWRlbnQpO1xuICAgICAgICB0aGlzLmFkZENoaWxkKGNvbnRleHRBd2FyZUNsaXBJbmNpZGVudCwgMCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImR1cmF0aW9uXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9nZXQoX2dldFByb3RvdHlwZU9mKEVsZW1lbnRDbGlwU3BsaXR0ZXIucHJvdG90eXBlKSwgXCJkdXJhdGlvblwiLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIC8qXG4gICAgICAgIEVsZW1lbnRDbGlwU3BsaXR0ZXIgc3BsaXQgdGhlIERlc2NyaXB0aXZlQ2xpcCB0byBlbGVtZW50IENvbnRleHRBd2FyZUluY2lkZW50c1xuICAgICAgICBBbGwgb2YgdGhlIGVsZW1lbnQgQ29udGV4dEF3YXJlQ2xpcEluY2lkZW50cyBpbnN0YW50aWF0ZWQgc2hhcmUgdGhlIHNhbWVcbiAgICAgICAgRGVzY3JpcHRpdmVDbGlwIGFuZCB0aHVzIHRoZSBzYW1lIHJlYWxDbGlwLiBTbyBFbGVtZW50Q2xpcFNwbGl0dGVyIGFyZVxuICAgICAgICB0aGUgTm9kZSBmcm9tIHdoZXJlIGEgcmVhbENsaXAgc3RhcnRzIHRvIGdldCBjb3BpZXMuXG4gICAgICAgIFJlc2l6aW5nIHRob3VnaCBtZWFucyByZXNpemluZyB0aGUgcmVhbENsaXAuIEluIG9yZGVyIHRvIGF2b2lkIHJlZHVuZHVuY3kgd2VcbiAgICAgICAgbWFuYWdlIHRoZSByZXNpemUgaGVyZSBhbmQgd2UgZG9uJ3QgcGFzcyBmdXJ0aGVyIGRvd24gdG8gdGhlIENvbnRleHRBd2FyZUNsaXBJbmNpZGVudHNcbiAgICAgICAgdGhlIHJlc2l6aW5nIGNvbW1hbmQuXG4gICAgICAgICovXG4gICAgICAsXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChtaWxsaXNlY29uZHMpIHtcbiAgICAgICAgdGhpcy5yZWFsQ2xpcC5fcmVzaXplKG1pbGxpc2Vjb25kcyAvIHRoaXMucmVhbENsaXAuZHVyYXRpb24pO1xuXG4gICAgICAgIHRoaXMuX2R1cmF0aW9uID0gbWlsbGlzZWNvbmRzO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBFbGVtZW50Q2xpcFNwbGl0dGVyO1xuICB9KEVsZW1lbnRTcGxpdHRlcik7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSByZWFsIEluY2lkZW50ICh3aXRoIGFsbCBvZiBpdHMgcmVhbCB0cmVlKSBvdXQgb2YgdGhlIERlc2NyaXB0aXZlIEluY2lkZW50LlxuICAgKiBAcGFyYW0ge29iamVjdH0gZGVzY3JpcHRpdmVJbmNpZGVudCAtIHRoZSBEZXNjcmlwdGl2ZSBJbmNpZGVudCB0aGF0IGRlZmluZXMgdGhlIEluY2lkZW50XG4gICAqIEBwYXJhbSB7Y29udGV4dERhdGF9IC0gdGhlIGNvbnRleHQgZGF0YSAob2JqZWN0IGNvbnRhaW5pbmcgaWQgYW5kIGFjdHVhbCBjb250ZXh0KSB0byBiZSB1c2VkIGZvciByZWFsXG4gICAqICAgICAgSW5jaWRlbnRzIGluaXRcbiAgICogQHBhcmFtIHtib29sZWFufSBhdWRpbyAtIGRlZmF1bHRzIHRvIGZhbHNlLiBJdCBkZWZpbmVzIHdoZXRoZXIgdGhlIG1ldGhvZCBpcyBiZWVuIHVzZWRcbiAgICogICAgICBieSBhIHJlYWwgQ2xpcCBvciB0aGUgQXVkaW8gY2xpcFxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSAtIHRoZSByZWFsIEluY2lkZW50XG4gICAqICovXG5cbiAgZnVuY3Rpb24gaW5jaWRlbnRGcm9tRGVzY3JpcHRpb24oZGVzY3JpcHRpdmVJbmNpZGVudCwgY29udGV4dERhdGEpIHtcbiAgICB2YXIgYXVkaW8gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gICAgLypcbiAgICAgIFJVTEVTOlxuICAgICAgLSBDbGlwcyBjYW4gb25seSBoYXZlIHNlbGVjdG9ycyAoYW5kIG5vdCBob3N0cykgYXMgdGhleSBwYXJ0aWNpcGF0ZSBvbiBhIERlc2MuIFRyZWVcbiAgICAgICAgICBhbmQgdGh1cyB0aGV5IGFyZSBDbGlwcyBBcyBJbmNpZGVudHMuIFRoZSBEZXNjcmlwdGl2ZUNsaXBzIGFyZSB0cmVhdGVkIGEgYml0XG4gICAgICAgICAgZGlmZmVyZW50IGNvbXBhcmVkIHRvIHRoZSByZXN0IG9mIHRoZSBJbmNpZGVudHMgYXMgdGhleSBjb3B5IGFsbCBvZiB0aGVcbiAgICAgICAgICBEZXNjcmlwdGlvbiBjaGFubmVscyBhbmQgbGFuZXNcbiAgICAgIC0gRGVzY3JpcHRpdmUgSW5jaWRlbnRzIGNhbiBlaXRoZXIgaGF2ZSBvciBub3QgaGF2ZSBzZWxlY3RvcnNcbiAgICAgIC0gRGVzY3JpcHRpdmUgQ29tcG9zIGFsd2F5cyBoYXZlIHNlbGVjdG9yc1xuICAgICAgIEFsbCBJbmNpZGVudHMgb2YgdGhlIHRyZWUsIG5vIG1hdHRlciB0aGVpciB0eXBlIGhhdmUgdGhlIHN0YXRpYyBwcm9wZXJ0aWVzOlxuICAgICAgLSBJbmNpZGVudCAod2hpY2ggaXMgdGhlIEluY2lkZW50IGNsYXNzIHRoZXkgbmVlZCB0byBpbml0aWFsaXNlKVxuICAgICAgLSBwbHVnaW5fbnBtX25hbWUgKHRoZSBwbHVnaW4gbmFtZSB0aGV5IGJvbG9uZyB0bylcbiAgICAgIC0gQ2hhbm5lbCAodGhlIENoYW5uZWwgY2xhc3MgdG8gaGFuZGxlIHRoZSBpbnN0YW5jZSlcbiAgICAgICovXG5cbiAgICAvKiBjaGVjayBmb3IgdGhlIGRlc2NyaXB0aXZlIGluY2lkZW50IGFuZCBhdWRpbyBjb21wYXRpYmlsaXR5LiBJZiBhdWRpbyBpcyB0cnVlIHRoZW4gd2UncmVcbiAgICAgICAgICB3b3JraW5nIG9uIHRoZSBhdWRpb0NsaXAgYW5kIHdlIG5lZWQgaW5jaWRlbnRzIHRoYXQgYXJlIGF0IGxlYXN0IFwib25cIiB3aGlsZSBpZiB0aGUgYXVkaW89PWZhbHNlXG4gICAgICAgICAgYW5kIHdlIGFyZSB3b3JraW5nIG9uIHRoZSByZWFsIHRyZWUgdGhlbiB3ZSByZWplY3QgdGhlIGNhc2VzIHRoYXQgdGhlIGluY2lkZW50IGlzIGF1ZGlvIFwib25seVwiXG4gICAgICAqL1xuICAgIGlmIChhdWRpbyA9PT0gdHJ1ZSAmJiBkZXNjcmlwdGl2ZUluY2lkZW50LmF1ZGlvID09PSAnb2ZmJyB8fCBhdWRpbyA9PT0gZmFsc2UgJiYgZGVzY3JpcHRpdmVJbmNpZGVudC5hdWRpbyA9PT0gJ29ubHknKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgaW5jaWRlbnRUb1JldHVybjtcblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGVzY3JpcHRpdmVJbmNpZGVudC5wcm9wcywgJ3NlbGVjdG9yJykpIHtcbiAgICAgIGlmIChhdWRpbyA9PT0gZmFsc2UgJiYgZGVzY3JpcHRpdmVJbmNpZGVudC5wcm9wcy5zZWxlY3Rvci5jaGFyQXQoMCkgPT09ICd+JyB8fCBhdWRpbyA9PT0gdHJ1ZSAmJiBkZXNjcmlwdGl2ZUluY2lkZW50LnByb3BzLnNlbGVjdG9yLmNoYXJBdCgwKSAhPT0gJ34nICYmIGRlc2NyaXB0aXZlSW5jaWRlbnQuY29uc3RydWN0b3IuaXNDbGlwID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGVzY3JpcHRpdmVJbmNpZGVudC5jb25zdHJ1Y3Rvci5pc0NsaXAgPT09IHRydWUpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGVzY3JpcHRpdmVJbmNpZGVudC5wcm9wcywgJ3NlbGVjdG9yJykgJiYgYXVkaW8gPT09IGZhbHNlKSB7XG4gICAgICAgIGluY2lkZW50VG9SZXR1cm4gPSBuZXcgRWxlbWVudENsaXBTcGxpdHRlcihkZXNjcmlwdGl2ZUluY2lkZW50LCBjb250ZXh0RGF0YSk7XG4gICAgICAgIGluY2lkZW50VG9SZXR1cm4ucGx1Z2luX2NoYW5uZWxfY2xhc3MgPSBDaGFubmVsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGF1ZGlvID09PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuIGRlc2NyaXB0aXZlSW5jaWRlbnQuYXVkaW9DbGlwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aXZlSW5jaWRlbnQucmVhbENsaXA7XG4gICAgICB9XG4gICAgfSAvLyBlbHNlIGlmIChkZXNjcmlwdGl2ZUluY2lkZW50LmNvbnN0cnVjdG9yLkluY2lkZW50ID09PSBHcm91cCkge1xuICAgIGVsc2UgaWYgKGRlc2NyaXB0aXZlSW5jaWRlbnQuY29uc3RydWN0b3IuaXNHcm91cCA9PT0gdHJ1ZSkge1xuICAgICAgICBpbmNpZGVudFRvUmV0dXJuID0gaW5jaWRlbnRGcm9tSW5ncmVkaWVudHMoe1xuICAgICAgICAgIGlkOiBkZXNjcmlwdGl2ZUluY2lkZW50LmlkLFxuICAgICAgICAgIGF0dHJzOiBkZXNjcmlwdGl2ZUluY2lkZW50LmF0dHJzLFxuICAgICAgICAgIHByb3BzOiBkZXNjcmlwdGl2ZUluY2lkZW50LnByb3BzLFxuICAgICAgICAgIEluY2lkZW50OiBkZXNjcmlwdGl2ZUluY2lkZW50LmNvbnN0cnVjdG9yLkluY2lkZW50LFxuICAgICAgICAgIHBsdWdpbl9ucG1fbmFtZTogZGVzY3JpcHRpdmVJbmNpZGVudC5jb25zdHJ1Y3Rvci5wbHVnaW5fbnBtX25hbWUsXG4gICAgICAgICAgQ2hhbm5lbDogZGVzY3JpcHRpdmVJbmNpZGVudC5jb25zdHJ1Y3Rvci5DaGFubmVsLFxuICAgICAgICAgIERlc2NyaXB0aXZlSW5jaWRlbnQ6IGRlc2NyaXB0aXZlSW5jaWRlbnRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yICh2YXIgaW5jSWQgaW4gZGVzY3JpcHRpdmVJbmNpZGVudC5jaGlsZHJlbikge1xuICAgICAgICAgIHZhciBjaGlsZEluY2lkZW50ID0gaW5jaWRlbnRGcm9tRGVzY3JpcHRpb24oZGVzY3JpcHRpdmVJbmNpZGVudC5jaGlsZHJlbltpbmNJZF0ubGVhZiwgY29udGV4dERhdGEpO1xuXG4gICAgICAgICAgaWYgKGNoaWxkSW5jaWRlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGluY2lkZW50VG9SZXR1cm4uYWRkQ2hpbGQoY2hpbGRJbmNpZGVudCwgZGVzY3JpcHRpdmVJbmNpZGVudC5jaGlsZHJlbltpbmNJZF0ucG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiBpdCBpcyBhbiBJbmNpZGVudCB0aGF0IGV4dGVuZHMgdGhlIEluY2lkZW50IChub3QgYSBHcm91cCkgdGhlblxuICAgICAgICAvLyB3ZSBzaG91bGQgYW5heWxzZSBpdCB0byBpdHMgZWxlbWVudC9hdHRyaWJ1dGUgSW5jaWRlbnRzIHN0YXJ0aW5nIGZyb21cbiAgICAgICAgLy8gdGhlIGVsZW1lbnRzLCB0aGF0J3Mgd2h5IHdlIGNyZWF0ZSBhbiBFbGVtZW50U3BsaXR0ZXIuIEl0IGlzIG91clxuICAgICAgICAvLyBzdGFydGluZyBwb2ludCB0byB3aGljaCB0aGUgSW5jaWRlbnQgd2lsbCBiZSBhbmFseXNlZCB0byBpdHNcbiAgICAgICAgLy8gZWxlbWVudC9hdHRyaWJ1dGVzIGNoaWxkcmVuLlxuICAgICAgICBpbmNpZGVudFRvUmV0dXJuID0gbmV3IEVsZW1lbnRTcGxpdHRlcihkZXNjcmlwdGl2ZUluY2lkZW50LCBjb250ZXh0RGF0YSk7XG4gICAgICB9XG5cbiAgICByZXR1cm4gaW5jaWRlbnRUb1JldHVybjtcbiAgfVxuXG4gIHZhciBzZWxmQ29udGFpbmVkSW5jaWRlbnRzTnBtTmFtZSA9ICdAa2lzc215YnV0dG9uL3NlbGYtY29udGFpbmVkLWluY2lkZW50cyc7XG5cbiAgdmFyIEV4dGVuZGFibGVDbGlwID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoX0dyb3VwKSB7XG4gICAgX2luaGVyaXRzKEV4dGVuZGFibGVDbGlwLCBfR3JvdXApO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHByb3BzIC0gYW4gb2JqZWN0IHRoYXQgc2hvdWxkIGNvbnRhaW4gYWxsIG9mIHRoZSBmb2xsb3dpbmcga2V5czpcbiAgICAgKiAtIGh0bWwgKHRoZSBodG1sIHRlbXBsYXRlIHRvIHJlbmRlcilcbiAgICAgKiAtIGNzcyAodGhlIGNzcyB0ZW1wbGF0ZSBvZiB0aGUgaXNvbGF0ZWQgdHJlZSlcbiAgICAgKiAtIGluaXRQYXJhbXMgKG9wdGlvbmFsIC8gdGhlIGluaXRpYWxpc2F0aW9uIHBhcmFtZXRlcmVzIHRoYXQgd2lsbCBiZSBwYXNzZWQgYm90aCBvbiB0aGUgY3NzIGFuZCB0aGUgaHRtbCB0ZW1wbGF0ZXMgaW4gb3JkZXIgdG8gcmVuZGVyKVxuICAgICAqIC0gaG9zdCAoYW4gRWxlbWVudCBvYmplY3QgdGhhdCB3aWxsIGhvc3QgdGhlIGlzb2xhdGVkIHRyZWUpXG4gICAgICogLSBjb250YWluZXJQYXJhbXMgKGFuIG9iamVjdCB0aGF0IGhvbGRzIHBhcmFtZXRlcnMgdG8gYWZmZWN0IHRoZSBjb250YWluZXIgb2YgdGhlIGlzb2xhdGVkIHRyZWUsIGUuZy4gd2lkdGgsIGhlaWdodCBldGMpXG4gICAgICogLSB0eXBlIChvcHRpb25hbCwgZGVmYXVsdHMgdG8gXCJpZnJhbWVcIikgdGhlIHR5cGUgb2YgdGhlIENsaXAuIEl0IGNhbiBiZSBvbmUgb2YgdGhlOlxuICAgICAqICAtIGlmcmFtZVxuICAgICAqICAtIHBsYWluXG4gICAgICovXG4gICAgZnVuY3Rpb24gRXh0ZW5kYWJsZUNsaXAoYXR0cnMsIHByb3BzKSB7XG4gICAgICB2YXIgX3RoaXM7XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFeHRlbmRhYmxlQ2xpcCk7XG5cbiAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEV4dGVuZGFibGVDbGlwKS5jYWxsKHRoaXMsIGF0dHJzLCBwcm9wcykpO1xuICAgICAgX3RoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgIF90aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICBfdGhpcy5pc1RoZUNsaXAgPSB0cnVlO1xuICAgICAgX3RoaXMuYmxvY2tpbmdXYWl0aW5ncyA9IHt9O1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgY25hbm5lbHMgYXR0cmlidXRlIGhvbGRzIGEgbGlzdCBvZiBhbGwgaW50YW50aWF0ZWQgQ2hhbm5lbHMgb2YgdGhlIEluY2lkZW50cyBiZWxvbmdpbmcgdG8gdGhlIGNsaXBcbiAgICAgICAqIHRoaXMgYXR0cmlidXRlIGlzIG9ubHkgdmFsdWFibGUgd2hlbiB0aGUgR3JvdXAgYmVjb21lcyB0aGUgQ2xpcFxuICAgICAgICogVGhlIGZvcm1hdCBvZiB0aGUgYXR0cmlidXRlIGlzOlxuICAgICAgICogIGtleS12YWx1ZSBwYWlycyBpbiB0aGUgbWFubmVyOlxuICAgICAgICogPG1jX3BsdWdpbl9ucG1fbmFtZT46IENoYW5uZWwgb2JqZWN0XG4gICAgICAgKi9cblxuICAgICAgX3RoaXMuaW5zdGFudGlhdGVkQ2hhbm5lbHMgPSB7fTtcbiAgICAgIF90aGlzLmlzSG9zdGVkQ2xpcCA9IHRydWU7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBpbnN0YW50aWF0ZWRDb3BpZXNDb250ZXh0cyBpcyBhIGtleS12YWx1ZSBwYWlycyBjb2xsZWNpdG9uIGhvbGRpbmcgdGhlXG4gICAgICAgKiBjb250ZXh0cyBvZiBhbGwgaW5zdGFudGlhdGVkIENsaXBDb3BpZXNcbiAgICAgICAqICovXG5cbiAgICAgIF90aGlzLmluc3RhbnRpYXRlZENvcGllc0NvbnRleHRzID0ge307XG5cbiAgICAgIF90aGlzLm9uQ2xpcEluaXRpYWxpc2UoKTtcblxuICAgICAgX3RoaXMucnVuVGltZUluZm8gPSBfdGhpcy5wcm9wcy5ydW5UaW1lSW5mbztcbiAgICAgIF90aGlzLmR1cmF0aW9uU3VicyA9IFtdOyAvLyB0aGUgYXVkaW9DbGlwIHByb3BlcnR5IGRlZmluZXMgd2V0aGVyIHRoZSBDbGlwIGlzIEF1ZGlvIG9yIG5vdC4gRGVmYXVsdHMgdG8gZmFsc2VcbiAgICAgIC8vIGFuZCBzaG91bGQgYmUgb3Zlcml0ZW4gdG8gdHJ1ZSBvbiBBdWRpbyBDbGlwXG5cbiAgICAgIF90aGlzLmF1ZGlvQ2xpcCA9IGZhbHNlO1xuICAgICAgX3RoaXMuY29udGV4dFJlYWR5ID0gdHJ1ZTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoRXh0ZW5kYWJsZUNsaXAsIFt7XG4gICAgICBrZXk6IFwib25DbGlwSW5pdGlhbGlzZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uQ2xpcEluaXRpYWxpc2UoKSB7Ly8gY2FsbGVkIHdoZW4gZ3JvdXAgZ2V0cyBpbml0aWFsaXNlZFxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjb250ZXh0TG9hZGluZ1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnRleHRMb2FkaW5nKCkge1xuICAgICAgICB0aGlzLmNvbnRleHRSZWFkeSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjb250ZXh0TG9hZGVkXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY29udGV4dExvYWRlZCgpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0UmVhZHkgPSB0cnVlO1xuICAgICAgICB0aGlzLnVuYmxvY2soKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0RWxlbWVudHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFbGVtZW50cyhzZWxlY3Rvcikge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5ob3N0ICE9PSBudWxsICYmIHRoaXMucHJvcHMuaG9zdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5nZXRFbGVtZW50cyhzZWxlY3Rvcik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWxlbWVudHMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBjb250ZXh0S2V5IGluIHRoaXMuaW5zdGFudGlhdGVkQ29waWVzQ29udGV4dHMpIHtcbiAgICAgICAgICB2YXIgY29udGV4dEVsZW1lbnRzID0gdGhpcy5pbnN0YW50aWF0ZWRDb3BpZXNDb250ZXh0c1tjb250ZXh0S2V5XS5nZXRFbGVtZW50cyhzZWxlY3Rvcik7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRleHRFbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZWxlbWVudHMucHVzaChjb250ZXh0RWxlbWVudHNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBtZXRob2QgaXMgYmVlbiBjYWxsZWQgd2hlbiBhIG5ldyBDbGlwQ29weSBlbnRlcnMgdGhlIHJlYWwgdHJlZSBzdWNjZXNzZnVsbHkuXG4gICAgICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dERhdGEgLSBrZXlzOiBjbGlwSWQsIGNvbnRleHRcbiAgICAgICAqICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYWRkQ29udGV4dFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZENvbnRleHQoY29udGV4dERhdGEpIHtcbiAgICAgICAgdGhpcy5pbnN0YW50aWF0ZWRDb3BpZXNDb250ZXh0c1tjb250ZXh0RGF0YS5jbGlwSWRdID0gY29udGV4dERhdGEuY29udGV4dDtcbiAgICAgICAgY29udGV4dERhdGEuaW5zdGFudGlhdGVkQ29waWVzQ29udGV4dHMgPSB0aGlzLmluc3RhbnRpYXRlZENvcGllc0NvbnRleHRzO1xuICAgICAgICB2YXIgcmVzID0gdGhpcy5wdXRNZXNzYWdlT25QaXBlKCdhZGRDb250ZXh0JywgY29udGV4dERhdGEsIHt9LCB7XG4gICAgICAgICAgc2VsZkV4ZWN1dGU6IGZhbHNlLFxuICAgICAgICAgIGRpcmVjdGlvbjogX0RJUkVDVElPTlMuX0RPV05cbiAgICAgICAgfSk7IC8vIGlmIHRoZSBhZGRlZCBjb250ZXh0IGlzIHRoZSBmaXJzdCBvbmUgdG8gZW50ZXIgdGhlIHJlYWxDbGlwIHdlIG11c3RcbiAgICAgICAgLy8gcmVjYWxjdWxhdGUgdGhlIHNjcmF0Y2ggdmFsdWVzIG9mIGFsbCBvZiBvdXIgZmlyc3QgSW5jaWRlbnRzIG9uIG91ciBpbnN0YW50aWF0ZWRDaGFubmVsc1xuXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLmluc3RhbnRpYXRlZENvcGllc0NvbnRleHRzKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAvLyBpZiBpdCBpcyB0aGUgZmlyc3Qgb25lIHRvIGJlIGFkZGVkXG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuaW5zdGFudGlhdGVkQ2hhbm5lbHMpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFudGlhdGVkQ2hhbm5lbHNba2V5XS5yZWNhbGNTY3JhdGNoVmFsdWVzKGNvbnRleHREYXRhLmNsaXBJZCk7XG4gICAgICAgICAgfSAvLyBhbHNvIHdlIHN0b3JlIHRoaXMgbm9uIGZyYWdtZW50ZWQgY29udGV4dCBvbiBvdXIgY29udGV4dCBzbyBpdCBjYW4gYmVcbiAgICAgICAgICAvLyB1c2VkIG9uIEluY2lkZW50cyBhZGRpdGlvbiBmb3IgY2FsY3VsYXRpbmcgc2NyYXRjaCB2YWx1ZXNcblxuXG4gICAgICAgICAgdGhpcy5jb250ZXh0Lm5vbkZyYWdtZW50ZWRDb250ZXh0ID0gY29udGV4dERhdGEuY29udGV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgICAvKlxuICAgICAgICBFeHRlbmRhYmxlQ2xpcCAoYXMgaXRzIG5hbWUgaW1wbGllcykgaXMgYSBDbGFzcyB0aGF0IHNob3VsZCBiZSBleHRlbmRlZCBieVxuICAgICAgICBhbnkgc3BlY2lmaWMga2luZCBvZiBDbGlwLCBzdWNoIGFzIEZyYWdtZW50ZWQgb3IgU0NHcm91cC4gVGhpcyBtZXRob2QgbXVzdFxuICAgICAgICBiZSBvdmVyaXR0ZW4gYnkgdGhlIG5ldyBDbGFzc2VzLiBUaGlzIGRlZmluaXRpb24gaGVyZSBpcyBqdXN0IGZvciByZWZlcmVuY2UgLyBoZWxwXG4gICAgICAgIHB1cnBvc2VzXG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZXhwb3J0Q29uc3RydWN0aW9uQXJndW1lbnRzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZXhwb3J0Q29uc3RydWN0aW9uQXJndW1lbnRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGF0dHJzOiB0aGlzLmF0dHJzLFxuICAgICAgICAgIHByb3BzOiB0aGlzLnByb3BzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIGNvbXBsZXRlbHkgcmVzaXplcyB0aGUgQ2xpcCB3aXRob3V0IGFueSBjaGVja3NcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9yZXNpemVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzaXplKGR1cmF0aW9uRnJhY3Rpb24pIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuaW5zdGFudGlhdGVkQ2hhbm5lbHMpIHtcbiAgICAgICAgICB0aGlzLmluc3RhbnRpYXRlZENoYW5uZWxzW2tleV0uX3Jlc2l6ZShkdXJhdGlvbkZyYWN0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0TmV3RHVyYXRpb24odGhpcy5kdXJhdGlvbiAqIGR1cmF0aW9uRnJhY3Rpb24pO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kdXJhdGlvblN1YnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLmR1cmF0aW9uU3Vic1tpXSh0aGlzLmR1cmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyoqICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgRWRpdGluZyBjb21tYW5kcyBpbnB1dCBtZXRob2RzXG4gICAgICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBjb21tYW5kIGNvbWVzIGZvcm0gdGhlIENsaXAncyBwYXJlbnQgRGVzY3JpcHRvciBjbGFzcy4gVGhlIHBheWxvYWRcbiAgICAgICAqIGlzIGlkZW50aWNhbCB0byB0aGUgcGF5bG9hZCB0aGF0IGNvbWVzIHRvIHRoZSBEZXNjcmlwdGlvbiBjbGFzczpcbiAgICAgICAqIHtcbiAgICAgICAqICBpbmNpZGVudDogdGhlIERlc2NyaXB0aXZlIEluY2lkZW50IHRvIGJlIGFkZGVkXG4gICAgICAgKiAgbWlsbGlzZWNvbmQ6IHRoZSBtaWxsaXNlY29uZCB0byBhZGQgaXRcbiAgICAgICAqICBwYXJlbnRHcm91cElkOiB0aGUgaWQgb2YgdGhlIEdyb3VwIHRvIHdoaWNoIHdlIHdhbnQgdG8gdGhlIEluY2lkZW50IHRvXG4gICAgICAgKiB9XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJhZGRJbmNpZGVudFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEluY2lkZW50KHBheWxvYWQpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGNhbmRpZGF0ZXMgPSB0aGlzLnB1dE1lc3NhZ2VPblBpcGUoJ2FkZEluY2lkZW50Jywge1xuICAgICAgICAgIGluY2lkZW50OiBwYXlsb2FkLmluY2lkZW50LFxuICAgICAgICAgIG1pbGxpc2Vjb25kOiBwYXlsb2FkLm1pbGxpc2Vjb25kLFxuICAgICAgICAgIHBhcmVudEdyb3VwSWQ6IHBheWxvYWQucGFyZW50R3JvdXBJZCxcbiAgICAgICAgICBpbmNpZGVudEZyb21EZXNjcmlwdGlvbjogaW5jaWRlbnRGcm9tRGVzY3JpcHRpb24sXG4gICAgICAgICAgY29udGV4dERhdGE6IHtcbiAgICAgICAgICAgIGNsaXBJZDogdGhpcy5pZCxcbiAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuY29udGV4dCxcbiAgICAgICAgICAgIGluc3RhbnRpYXRlZENvcGllc0NvbnRleHRzOiB0aGlzLmluc3RhbnRpYXRlZENvcGllc0NvbnRleHRzXG4gICAgICAgICAgfSxcbiAgICAgICAgICBhdWRpbzogdGhpcy5hdWRpb0NsaXBcbiAgICAgICAgfSwgcGF5bG9hZC5wYXJlbnRHcm91cElkLCB7XG4gICAgICAgICAgc2VsZkV4ZWN1dGU6IHRydWUsXG4gICAgICAgICAgZGlyZWN0aW9uOiBfRElSRUNUSU9OUy5fRE9XTlxuICAgICAgICB9KTsgLy8gY29uY2F0ZW5hdGUgY2FuZGlkYXRlc1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhjYW5kaWRhdGVzKTtcblxuICAgICAgICB2YXIgdG90YWxJbmNpZGVudHNCeVBsdWdpbiA9IHt9O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FuZGlkYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBpbmNpZGVudHNCeVBsdWdpbiA9IGNhbmRpZGF0ZXNbaV0ucmVzcG9uc2UuZ2V0SW5jaWRlbnRzQnlDaGFubmVsKGNhbmRpZGF0ZXNbaV0ucG9zaXRpb25EZWx0YSArIHBheWxvYWQubWlsbGlzZWNvbmQpO1xuXG4gICAgICAgICAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBpbmNpZGVudHNCeVBsdWdpbikge1xuICAgICAgICAgICAgdmFyIF90b3RhbEluY2lkZW50c0J5UGx1ZztcblxuICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodG90YWxJbmNpZGVudHNCeVBsdWdpbiwgcGx1Z2luTmFtZSkpIHtcbiAgICAgICAgICAgICAgdG90YWxJbmNpZGVudHNCeVBsdWdpbltwbHVnaW5OYW1lXSA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAoX3RvdGFsSW5jaWRlbnRzQnlQbHVnID0gdG90YWxJbmNpZGVudHNCeVBsdWdpbltwbHVnaW5OYW1lXSkucHVzaC5hcHBseShfdG90YWxJbmNpZGVudHNCeVBsdWcsIF90b0NvbnN1bWFibGVBcnJheShpbmNpZGVudHNCeVBsdWdpbltwbHVnaW5OYW1lXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBjb25zb2xlLmxvZyh0b3RhbEluY2lkZW50c0J5UGx1Z2luKTtcblxuXG4gICAgICAgIHZhciByZXMgPSB0aGlzLmNoZWNrQWRkaXRpb24odG90YWxJbmNpZGVudHNCeVBsdWdpbik7XG5cbiAgICAgICAgaWYgKHJlcy5yZXN1bHQgPT09IHRydWUpIHtcbiAgICAgICAgICB2YXIgc3VjY2Vzc0NhbGxiYWNrID0gZnVuY3Rpb24gc3VjY2Vzc0NhbGxiYWNrKCkge1xuICAgICAgICAgICAgcmVzLmV4ZWN1dGUoKTsgLy8gdXAgdG8gdGhhdCBwb2ludCB0aGUgb25seSBjb250ZXh0IEluY2lkZW50IHRoYXQgaGFzIGJlZW4gaW5pdGlhbGlzZWQgb24gdGhlXG4gICAgICAgICAgICAvLyBDb250ZXh0QXdhcmVJbmNpZGVudHMgb2YgdGhlIGNhbmRpZGF0ZXMgaXMgdGhlIG9yaWdpbmFsIGNvbnRleHQgb2YgdGhlXG4gICAgICAgICAgICAvLyBFeHRlbmRhYmxlQ2xpcC5cblxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGNhbmRpZGF0ZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgIGNhbmRpZGF0ZXNbX2ldLnJlc3BvbmRlci5hZGRDaGlsZChjYW5kaWRhdGVzW19pXS5yZXNwb25zZSwgcGF5bG9hZC5taWxsaXNlY29uZCk7IC8vIHJlY2FsY3VsYXRlIGR1cmF0aW9uIHRoZSBncm91cHMgdGhhdCB3ZSBhZGRlZFxuICAgICAgICAgICAgICAvLyB0aGUgaW5jaWRlbnRzIHRvIGFsb25nIHdpdGggdGhlaXIgcGFyZW50c1xuXG5cbiAgICAgICAgICAgICAgY2FuZGlkYXRlc1tfaV0ucmVzcG9uZGVyLnB1dE1lc3NhZ2VPblBpcGUoJ3JlY2FsY0R1cmF0aW9uJywge30sICdHcm91cHMnLCB7XG4gICAgICAgICAgICAgICAgc2VsZkV4ZWN1dGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBfRElSRUNUSU9OUy5fVVBcbiAgICAgICAgICAgICAgfSk7IC8vIHdlIGFsc28gbmVlZCB0byBhZGQgZXZlcnkgZXhpc3RpbmcgKGNvcGllZCkgY29udGV4dCB0byB0aGUgQ29udGV4dEF3YXJlSW5jaWRlbnRzXG4gICAgICAgICAgICAgIC8vIGNyZWF0ZWQgb24gdGhlIGNhbmRpZGF0ZXMgcHJvY2Vzc1xuXG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgY29udGV4dEtleSBpbiBfdGhpczIuaW5zdGFudGlhdGVkQ29waWVzQ29udGV4dHMpIHtcbiAgICAgICAgICAgICAgICBjYW5kaWRhdGVzW19pXS5yZXNwb25kZXIucHV0TWVzc2FnZU9uUGlwZSgnYWRkQ29udGV4dCcsIHtcbiAgICAgICAgICAgICAgICAgIGNsaXBJZDogY29udGV4dEtleSxcbiAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IF90aGlzMi5pbnN0YW50aWF0ZWRDb3BpZXNDb250ZXh0c1tjb250ZXh0S2V5XVxuICAgICAgICAgICAgICAgIH0sICdDb250ZXh0QXdhcmVJbmNpZGVudHMnLCB7XG4gICAgICAgICAgICAgICAgICBzZWxmRXhlY3V0ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICBkaXJlY3Rpb246IF9ESVJFQ1RJT05TLl9ET1dOXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3VsdDogdHJ1ZSxcbiAgICAgICAgICAgIGV4ZWN1dGU6IHN1Y2Nlc3NDYWxsYmFja1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfSAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAvLyBJTkNJREVOVFMgTUFOQUdFTUVOVCBNRVRIT0RTXG4gICAgICAvLyBQT0xZTU9SUEhJU00gQVBQTElFRC4gSUYgVEhFIEdST1VQIEhBUyBOTyBQQVJFTlQgSVQgQUNUUyBBUyBBIFNDRU5FLiBJRiBUSEUgR1JPVVAgSEFTIFBBUkVOVCBJVCBBQ1RTIEFTXG4gICAgICAvLyBBIFwiVFJBTlNQQVJFTlQgR1JPVVBcIlxuXG4gICAgICAvKipcbiAgICAgICAgICogVGhlIG1ldGhvZCByZXR1cm5zIGVpdGhlcjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXN1bHQ6dHJ1ZSxcbiAgICAgICAgICAgICAgICBleGVjdXRlOiAvLyBhbiBhcnJheSBvZiBmdW5jdGlvbnMgdGhhdCB3aGVuIGV4ZWN1dGVkIGl0IHdpbGwgYWRkIHRoZSBJbmNpZGVudHMgb24gdGhlIENoYW5uZWxzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvclxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3JzXG4gICAgICAgICAgICB9XG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY2hlY2tBZGRpdGlvblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrQWRkaXRpb24oaW5jaWRlbnRzQnlJZCkge1xuICAgICAgICB2YXIgdHlwZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ2FsbC1vci1ub3RoaW5nJztcbiAgICAgICAgLy8gcHJlcGFyZSB0aGUgcmV0dXJuIHBheWxvYWRcbiAgICAgICAgdmFyIHRvUmV0dXJuUmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgdmFyIHRvUmV0dXJuRXJyb3JzID0gW107XG4gICAgICAgIHZhciB0b1JldHVybkV4ZWN1dGFibGVzID0gW107IC8vIGZvciBlYWNoIGtleSBvZiB0aGUgaW5jaWRlbnRzQnlJZCBvYmplY3QgcGVyZm9ybSB0aGUgY2hlY2tcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gaW5jaWRlbnRzQnlJZCkge1xuICAgICAgICAgIC8vIGlmIHRoZSBjbGlwIGhhZCBubyBjaGFubmVsIGluc3RhbnRpYXRlZCBmb3IgdGhlIHNwZWNpZmljIGtleSAocGx1Z2luIGlkKSB5ZXQgY3JlYXRlIGl0XG4gICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5pbnN0YW50aWF0ZWRDaGFubmVscywga2V5KSkge1xuICAgICAgICAgICAgLy8gaW50c3RhbnRpYXRlIHRoZSBjaGFubmVsIG9mIHRoZSBwbHVnaW4gYnkgdXNpbmcgdGhlIHJlZmVyZW5jZSB0byB0aGUgY2xhc3MgZGVmaW5pdGlvbiBzdG9yZWQgb25cbiAgICAgICAgICAgIC8vIHRoZSB2ZXJ5IGZpcnN0IGluY2lkZW50IG9mIHRoZSBhcnJheVxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coaW5jaWRlbnRzQnlJZFtrZXldWzBdLmluY2lkZW50LnBsdWdpbl9jaGFubmVsX2NsYXNzKTtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFudGlhdGVkQ2hhbm5lbHNba2V5XSA9IG5ldyBpbmNpZGVudHNCeUlkW2tleV1bMF0uaW5jaWRlbnQucGx1Z2luX2NoYW5uZWxfY2xhc3Moe1xuICAgICAgICAgICAgICBydW5UaW1lSW5mbzogdGhpcy5ydW5UaW1lSW5mbyxcbiAgICAgICAgICAgICAgY29udGV4dDogdGhpcy5jb250ZXh0LFxuICAgICAgICAgICAgICBzdWJzY3JpYmU6IHRoaXMucHJvcHMuc3Vic2NyaWJlIC8vIGFsbCBjaGFubmVscyBjYW4gc3Vic2NyaWJlIHRvIHN0YXRlIG9yIGN1cnJlbnQgbWlsbGlzZWNvbmQgY2hhbmdlc1xuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IC8vIHBlcmZvcm0gdGhlIGNoZWNrXG5cblxuICAgICAgICAgIHZhciBwbHVnaW5SZXN1bHQgPSB0aGlzLmluc3RhbnRpYXRlZENoYW5uZWxzW2tleV0uYWRkSW5jaWRlbnRzKGluY2lkZW50c0J5SWRba2V5XSwgdHlwZSk7XG4gICAgICAgICAgdG9SZXR1cm5SZXN1bHQgPSB0b1JldHVyblJlc3VsdCAmJiBwbHVnaW5SZXN1bHQucmVzdWx0O1xuXG4gICAgICAgICAgaWYgKHBsdWdpblJlc3VsdC5yZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0b1JldHVybkVycm9ycyA9IHRvUmV0dXJuRXJyb3JzLmNvbmNhdChwbHVnaW5SZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9SZXR1cm5FeGVjdXRhYmxlcy5wdXNoKHBsdWdpblJlc3VsdC5leGVjdXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gZW5mIG9mIGl0ZXJhdGlvbiBvbiB0aGUgaW5jaWRlbnRzQnlJZCBrZXlzXG5cblxuICAgICAgICB2YXIgdG9SZXR1cm5FeGVjdXRlID0gZnVuY3Rpb24gdG9SZXR1cm5FeGVjdXRlRnVuY3QoKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b1JldHVybkV4ZWN1dGFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0b1JldHVybkV4ZWN1dGFibGVzW2ldKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBhZGRpdGlvblJlc3VsdCA9IHtcbiAgICAgICAgICByZXN1bHQ6IHRvUmV0dXJuUmVzdWx0LFxuICAgICAgICAgIGVycm9yczogdG9SZXR1cm5FcnJvcnMsXG4gICAgICAgICAgZXhlY3V0ZTogdG9SZXR1cm5FeGVjdXRlXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhZGRpdGlvblJlc3VsdDtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBjb21tYW5kIGNvbWVzIGZvcm0gdGhlIENsaXAncyBwYXJlbnQgRGVzY3JpcHRvciBjbGFzcy4gVGhlIHBheWxvYWRcbiAgICAgICAqIGlzIGlkZW50aWNhbCB0byB0aGUgcGF5bG9hZCB0aGF0IGNvbWVzIHRvIHRoZSBEZXNjcmlwdGlvbiBjbGFzczpcbiAgICAgICAqIHtcbiAgICAgICAqICBpbmNpZGVudDogdGhlIERlc2NyaXB0aXZlIEluY2lkZW50IHRvIGJlIHJlcG9zaXRpb25lZFxuICAgICAgICogIG1pbGxpc2Vjb25kOiB0aGUgbmV3IG1pbGxpc2Vjb25kIHRvIHB1dCBpdFxuICAgICAgICogIHBhcmVudEdyb3VwSWQ6IHRoZSBpZCBvZiB0aGVcbiAgICAgICAqIH1cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIm1vdmVJbmNpZGVudFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmVJbmNpZGVudChwYXlsb2FkKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGVzID0gdGhpcy5wdXRNZXNzYWdlT25QaXBlKCdtb3ZlSW5jaWRlbnQnLCB7XG4gICAgICAgICAgaW5jaWRlbnRJZDogcGF5bG9hZC5pZCxcbiAgICAgICAgICBtaWxsaXNlY29uZDogcGF5bG9hZC5taWxsaXNlY29uZCxcbiAgICAgICAgICBwYXJlbnRHcm91cElkOiBwYXlsb2FkLnBhcmVudEdyb3VwSWQsXG4gICAgICAgICAgY29udGV4dERhdGE6IHtcbiAgICAgICAgICAgIGNsaXBJZDogdGhpcy5pZCxcbiAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuY29udGV4dFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYXVkaW86IHRoaXMuYXVkaW9DbGlwXG4gICAgICAgIH0sIHBheWxvYWQucGFyZW50R3JvdXBJZCwge1xuICAgICAgICAgIHNlbGZFeGVjdXRlOiB0cnVlLFxuICAgICAgICAgIGRpcmVjdGlvbjogX0RJUkVDVElPTlMuX0RPV05cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB0b3RhbEluY2lkZW50c0J5UGx1Z2luID0ge307XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYW5kaWRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGluY2lkZW50c0J5UGx1Z2luID0gY2FuZGlkYXRlc1tpXS5yZXNwb25zZS5nZXRJbmNpZGVudHNCeUNoYW5uZWwoY2FuZGlkYXRlc1tpXS5wb3NpdGlvbkRlbHRhICsgcGF5bG9hZC5taWxsaXNlY29uZCk7XG5cbiAgICAgICAgICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIGluY2lkZW50c0J5UGx1Z2luKSB7XG4gICAgICAgICAgICB2YXIgX3RvdGFsSW5jaWRlbnRzQnlQbHVnMjtcblxuICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodG90YWxJbmNpZGVudHNCeVBsdWdpbiwgcGx1Z2luTmFtZSkpIHtcbiAgICAgICAgICAgICAgdG90YWxJbmNpZGVudHNCeVBsdWdpbltwbHVnaW5OYW1lXSA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAoX3RvdGFsSW5jaWRlbnRzQnlQbHVnMiA9IHRvdGFsSW5jaWRlbnRzQnlQbHVnaW5bcGx1Z2luTmFtZV0pLnB1c2guYXBwbHkoX3RvdGFsSW5jaWRlbnRzQnlQbHVnMiwgX3RvQ29uc3VtYWJsZUFycmF5KGluY2lkZW50c0J5UGx1Z2luW3BsdWdpbk5hbWVdKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlcyA9IHRoaXMuY2hlY2tNb3ZlKHRvdGFsSW5jaWRlbnRzQnlQbHVnaW4sIHBheWxvYWQucG9zaXRpb25EZWx0YSk7XG5cbiAgICAgICAgaWYgKHJlcy5yZXN1bHQgPT09IHRydWUpIHtcbiAgICAgICAgICB2YXIgc3VjY2Vzc0NhbGxiYWNrID0gZnVuY3Rpb24gc3VjY2Vzc0NhbGxiYWNrKCkge1xuICAgICAgICAgICAgcmVzLmV4ZWN1dGUoKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgY2FuZGlkYXRlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgICAgIGNhbmRpZGF0ZXNbX2kyXS5yZXNwb25kZXIuZWRpdFBvc2l0aW9uKGNhbmRpZGF0ZXNbX2kyXS5yZXNwb25zZS5pZCwgcGF5bG9hZC5taWxsaXNlY29uZCk7IC8vIHJlY2FsY3VsYXRlIGR1cmF0aW9uIHRoZSBncm91cHMgdGhhdCB3ZSBhZGRlZFxuICAgICAgICAgICAgICAvLyB0aGUgaW5jaWRlbnRzIHRvIGFsb25nIHdpdGggdGhlaXIgcGFyZW50c1xuXG5cbiAgICAgICAgICAgICAgY2FuZGlkYXRlc1tfaTJdLnJlc3BvbmRlci5wdXRNZXNzYWdlT25QaXBlKCdyZWNhbGNEdXJhdGlvbicsIHt9LCAnR3JvdXBzJywge1xuICAgICAgICAgICAgICAgIHNlbGZFeGVjdXRlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogX0RJUkVDVElPTlMuX1VQXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdWx0OiB0cnVlLFxuICAgICAgICAgICAgZXhlY3V0ZTogc3VjY2Vzc0NhbGxiYWNrXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAgICogVGhlIGNoZWNrRWRpdCBtZXRob2Qgc2VydmVzIGV4YWN0bHkgd2hhdCBpdHMgbmFtZSBpbXBsaWVzLiBUbyBjaGVjayBpZiB0aGUgZWRpdCBvZiBhbiBJbmNpZGVudCAoZWRpdCBvZiBJbmNpZGVudCdzIHBvc2l0aW9uIGdpdmVuIGluIG1pbGxpc2Vjb25kcyBkZWx0YSlcbiAgICAgICAgICogaXMgdmFsaWQgYW5kIGFjY2VwdGVkLCBhY2NvcmRpbmcgdG8gdGhlIHJ1bGVzIGRlZmluZWQgb24gdGhlIGNoYW5uZWxzLlxuICAgICAgICAgKiBUaGUgbWV0aG9kIGJvb2JsZXMgdXAgdW50aWwgaXQgcmVhY2hlcyB0aGUgQ2xpcC5cbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGluY2lkZW50IC0gdGhlIGluY2lkZW50IHRvIGVkaXRcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IG1pbGxpc2Vjb25kc0RlbHRhIC0gdGhlIG1pbGxpc2Vjb25kcyBkZWx0YSBvZiB0aGUgSW5jaWRlbnQncyBzdGFydCB0aW1lXG4gICAgICAgICBUaGUgbWV0aG9kIHNob3VsZCByZXR1cm4gZWl0aGVyOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJlc3VsdDp0cnVlLFxuICAgICAgICAgICAgICAgIGV4ZWN1dGU6IC8vIGFuIGFycmF5IG9mIGZ1bmN0aW9ucyB0aGF0IHdoZW4gZXhlY3V0ZWQgaXQgd2lsbCBlZGl0IHRoZSBJbmNpZGVudHMgb24gdGhlIENoYW5uZWxzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvclxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3JzXG4gICAgICAgICAgICB9XG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY2hlY2tNb3ZlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tNb3ZlKGluY2lkZW50c0J5SWQsIG1pbGxpc2Vjb25kc0RlbHRhKSB7XG4gICAgICAgIC8vIHByZXBhcmUgdGhlIHJldHVybiBwYXlsb2FkXG4gICAgICAgIHZhciB0b1JldHVyblJlc3VsdCA9IHRydWU7XG4gICAgICAgIHZhciB0b1JldHVybkVycm9ycyA9IFtdO1xuICAgICAgICB2YXIgdG9SZXR1cm5FeGVjdXRhYmxlcyA9IFtdOyAvLyBmb3IgZWFjaCBrZXkgb2YgdGhlIGluY2lkZW50c0J5SWQgb2JqZWN0IHBlcmZvcm0gdGhlIGNoZWNrXG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIGluY2lkZW50c0J5SWQpIHtcbiAgICAgICAgICAvLyBwZXJmb3JtIHRoZSBjaGVja1xuICAgICAgICAgIHZhciBwbHVnaW5SZXN1bHQgPSB0aGlzLmluc3RhbnRpYXRlZENoYW5uZWxzW2tleV0uZWRpdEluY2lkZW50cyhpbmNpZGVudHNCeUlkW2tleV0sIG1pbGxpc2Vjb25kc0RlbHRhKTtcbiAgICAgICAgICB0b1JldHVyblJlc3VsdCA9IHRvUmV0dXJuUmVzdWx0ICYmIHBsdWdpblJlc3VsdC5yZXN1bHQ7XG5cbiAgICAgICAgICBpZiAocGx1Z2luUmVzdWx0LnJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRvUmV0dXJuRXJyb3JzID0gdG9SZXR1cm5FcnJvcnMuY29uY2F0KHBsdWdpblJlc3VsdC5lcnJvcnMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b1JldHVybkV4ZWN1dGFibGVzLnB1c2gocGx1Z2luUmVzdWx0LmV4ZWN1dGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBlbmYgb2YgaXRlcmF0aW9uIG9uIHRoZSBpbmNpZGVudHNCeUlkIGtleXNcblxuXG4gICAgICAgIHZhciB0b1JldHVybkV4ZWN1dGUgPSBmdW5jdGlvbiB0b1JldHVybkV4ZWN1dGVGdW5jdCgpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvUmV0dXJuRXhlY3V0YWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRvUmV0dXJuRXhlY3V0YWJsZXNbaV0oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGVkaXRSZXN1bHQgPSB7XG4gICAgICAgICAgcmVzdWx0OiB0b1JldHVyblJlc3VsdCxcbiAgICAgICAgICBlcnJvcnM6IHRvUmV0dXJuRXJyb3JzLFxuICAgICAgICAgIGV4ZWN1dGU6IHRvUmV0dXJuRXhlY3V0ZVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZWRpdFJlc3VsdDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicmVtb3ZlSW5jaWRlbnRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVJbmNpZGVudChwYXlsb2FkKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGVzID0gdGhpcy5wdXRNZXNzYWdlT25QaXBlKCdyZW1vdmVJbmNpZGVudCcsIHtcbiAgICAgICAgICBpbmNpZGVudElkOiBwYXlsb2FkLmlkLFxuICAgICAgICAgIHBhcmVudEdyb3VwSWQ6IHBheWxvYWQucGFyZW50R3JvdXBJZCxcbiAgICAgICAgICBjb250ZXh0RGF0YToge1xuICAgICAgICAgICAgY2xpcElkOiB0aGlzLmlkLFxuICAgICAgICAgICAgY29udGV4dDogdGhpcy5jb250ZXh0XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhdWRpbzogdGhpcy5hdWRpb0NsaXBcbiAgICAgICAgfSwgcGF5bG9hZC5wYXJlbnRHcm91cElkLCB7XG4gICAgICAgICAgc2VsZkV4ZWN1dGU6IHRydWUsXG4gICAgICAgICAgZGlyZWN0aW9uOiBfRElSRUNUSU9OUy5fRE9XTlxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHRvdGFsSW5jaWRlbnRzQnlQbHVnaW4gPSB7fTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbmRpZGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgaW5jaWRlbnRzQnlQbHVnaW4gPSBjYW5kaWRhdGVzW2ldLnJlc3BvbnNlLmdldEluY2lkZW50c0J5Q2hhbm5lbCgpO1xuXG4gICAgICAgICAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBpbmNpZGVudHNCeVBsdWdpbikge1xuICAgICAgICAgICAgdmFyIF90b3RhbEluY2lkZW50c0J5UGx1ZzM7XG5cbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRvdGFsSW5jaWRlbnRzQnlQbHVnaW4sIHBsdWdpbk5hbWUpKSB7XG4gICAgICAgICAgICAgIHRvdGFsSW5jaWRlbnRzQnlQbHVnaW5bcGx1Z2luTmFtZV0gPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgKF90b3RhbEluY2lkZW50c0J5UGx1ZzMgPSB0b3RhbEluY2lkZW50c0J5UGx1Z2luW3BsdWdpbk5hbWVdKS5wdXNoLmFwcGx5KF90b3RhbEluY2lkZW50c0J5UGx1ZzMsIF90b0NvbnN1bWFibGVBcnJheShpbmNpZGVudHNCeVBsdWdpbltwbHVnaW5OYW1lXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXMgPSB0aGlzLmNoZWNrRGVsZXRlKHRvdGFsSW5jaWRlbnRzQnlQbHVnaW4pO1xuXG4gICAgICAgIGlmIChyZXMucmVzdWx0ID09PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIHN1Y2Nlc3NDYWxsYmFjayA9IGZ1bmN0aW9uIHN1Y2Nlc3NDYWxsYmFjaygpIHtcbiAgICAgICAgICAgIHJlcy5leGVjdXRlKCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IGNhbmRpZGF0ZXMubGVuZ3RoOyBfaTMrKykge1xuICAgICAgICAgICAgICBjYW5kaWRhdGVzW19pM10ucmVzcG9uZGVyLnJlbW92ZUNoaWxkKGNhbmRpZGF0ZXNbX2kzXS5yZXNwb25zZS5pZCk7IC8vIHJlY2FsY3VsYXRlIGR1cmF0aW9uIHRoZSBncm91cHMgdGhhdCB3ZSBhZGRlZFxuICAgICAgICAgICAgICAvLyB0aGUgaW5jaWRlbnRzIHRvIGFsb25nIHdpdGggdGhlaXIgcGFyZW50c1xuXG5cbiAgICAgICAgICAgICAgY2FuZGlkYXRlc1tfaTNdLnJlc3BvbmRlci5wdXRNZXNzYWdlT25QaXBlKCdyZWNhbGNEdXJhdGlvbicsIHt9LCAnR3JvdXBzJywge1xuICAgICAgICAgICAgICAgIHNlbGZFeGVjdXRlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogX0RJUkVDVElPTlMuX1VQXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdWx0OiB0cnVlLFxuICAgICAgICAgICAgZXhlY3V0ZTogc3VjY2Vzc0NhbGxiYWNrXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAgICogVGhlIGNoZWNrRGVsZXRlIG1ldGhvZCBzZXJ2ZXMgZXhhY3RseSB3aGF0IGl0cyBuYW1lIGltcGxpZXMuIFRvIGNoZWNrIGlmIHRoZSBkZWxldGlvbiBvZiBhbiBJbmNpZGVudFxuICAgICAgICAgKiBpcyB2YWxpZCBhbmQgYWNjZXB0ZWQsIGFjY29yZGluZyB0byB0aGUgcnVsZXMgZGVmaW5lZCBvbiB0aGUgY2hhbm5lbHMuXG4gICAgICAgICAqIFRoZSBtZXRob2QgYm9vYmxlcyB1cCB1bnRpbCBpdCByZWFjaGVzIHRoZSBDbGlwLlxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gaW5jaWRlbnQgLSB0aGUgaW5jaWRlbnQgdG8gZWRpdFxuICAgICAgICAgIFRoZSByZXN1bHQgbWlnaHQgYmUgZWl0aGVyOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJlc3VsdDp0cnVlLFxuICAgICAgICAgICAgICAgIGV4ZWN1dGU6IC8vIGFuIGFycmF5IG9mIGZ1bmN0aW9ucyB0aGF0IHdoZW4gZXhlY3V0ZWQgaXQgd2lsbCByZW1vdmUgdGhlIEluY2lkZW50IG9uIHRoZSBDaGFubmVsc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3JcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXN1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yc1xuICAgICAgICAgICAgfVxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImNoZWNrRGVsZXRlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tEZWxldGUoaW5jaWRlbnRzQnlJZCkge1xuICAgICAgICAvLyBwcmVwYXJlIHRoZSByZXR1cm4gcGF5bG9hZFxuICAgICAgICB2YXIgdG9SZXR1cm5SZXN1bHQgPSB0cnVlO1xuICAgICAgICB2YXIgdG9SZXR1cm5FcnJvcnMgPSBbXTtcbiAgICAgICAgdmFyIHRvUmV0dXJuRXhlY3V0YWJsZXMgPSBbXTsgLy8gZm9yIGVhY2gga2V5IG9mIHRoZSBpbmNpZGVudHNCeUlkIG9iamVjdCBwZXJmb3JtIHRoZSBjaGVja1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBpbmNpZGVudHNCeUlkKSB7XG4gICAgICAgICAgLy8gcGVyZm9ybSB0aGUgY2hlY2tcbiAgICAgICAgICB2YXIgcGx1Z2luUmVzdWx0ID0gdGhpcy5pbnN0YW50aWF0ZWRDaGFubmVsc1trZXldLnJlbW92ZUluY2lkZW50cyhpbmNpZGVudHNCeUlkW2tleV0pO1xuICAgICAgICAgIHRvUmV0dXJuUmVzdWx0ID0gdG9SZXR1cm5SZXN1bHQgJiYgcGx1Z2luUmVzdWx0LnJlc3VsdDtcblxuICAgICAgICAgIGlmIChwbHVnaW5SZXN1bHQucmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdG9SZXR1cm5FcnJvcnMgPSB0b1JldHVybkVycm9ycy5jb25jYXQocGx1Z2luUmVzdWx0LmVycm9ycyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvUmV0dXJuRXhlY3V0YWJsZXMucHVzaChwbHVnaW5SZXN1bHQuZXhlY3V0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGVuZiBvZiBpdGVyYXRpb24gb24gdGhlIGluY2lkZW50c0J5SWQga2V5c1xuXG5cbiAgICAgICAgdmFyIHRvUmV0dXJuRXhlY3V0ZSA9IGZ1bmN0aW9uIHRvUmV0dXJuRXhlY3V0ZUZ1bmN0KCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9SZXR1cm5FeGVjdXRhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdG9SZXR1cm5FeGVjdXRhYmxlc1tpXSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcmVtb3ZlUmVzdWx0ID0ge1xuICAgICAgICAgIHJlc3VsdDogdG9SZXR1cm5SZXN1bHQsXG4gICAgICAgICAgZXJyb3JzOiB0b1JldHVybkVycm9ycyxcbiAgICAgICAgICBleGVjdXRlOiB0b1JldHVybkV4ZWN1dGVcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlbW92ZVJlc3VsdDtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBjb21tYW5kIGlzIGludm9rZWQgYnkgdGhlIENsaXAncyBwYXJlbnQgRGVzY3JpcHRvciBjbGFzcy4gVGhlIHBheWxvYWRcbiAgICAgICAqIGlzIGlkZW50aWNhbCB0byB0aGUgcGF5bG9hZCB0aGF0IGNvbWVzIHRvIHRoZSBEZXNjcmlwdGlvbiBjbGFzczpcbiAgICAgICAqIHtcbiAgICAgICAqICBpZDogdGhlIGlkIG9mIHRoZSBJbmNpZGVudCB0byByZXNpemVcbiAgICAgICAqICBuZXdTaXplOiB0aGUgbWlsbGlzZWNvbmRzIG9mIHRoZSBuZXcgZHVyYXRpb25cbiAgICAgICAqICBmcmFjdGlvbjogdGhlIGRpdmlzaW9uIG9mIHRoZSBuZXcgZHVyYXRpb24gdG8gdGhlIGN1cnJlbnRcbiAgICAgICAqIH1cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInJlc2l6ZUluY2lkZW50XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplSW5jaWRlbnQocGF5bG9hZCkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlcyA9IHRoaXMucHV0TWVzc2FnZU9uUGlwZSgncmVzaXplJywge1xuICAgICAgICAgIGluY2lkZW50SWQ6IHBheWxvYWQuaWQsXG4gICAgICAgICAgbmV3U2l6ZTogcGF5bG9hZC5uZXdTaXplLFxuICAgICAgICAgIGZyYWN0aW9uOiBwYXlsb2FkLmZyYWN0aW9uLFxuICAgICAgICAgIGNvbnRleHREYXRhOiB7XG4gICAgICAgICAgICBjbGlwSWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICBjb250ZXh0OiB0aGlzLmNvbnRleHRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGF1ZGlvOiB0aGlzLmF1ZGlvQ2xpcFxuICAgICAgICB9LCBwYXlsb2FkLmlkLCB7XG4gICAgICAgICAgc2VsZkV4ZWN1dGU6IGZhbHNlLFxuICAgICAgICAgIGRpcmVjdGlvbjogX0RJUkVDVElPTlMuX0RPV05cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB0b3RhbEluY2lkZW50c0J5UGx1Z2luID0ge307XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYW5kaWRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGluY2lkZW50c0J5UGx1Z2luID0gY2FuZGlkYXRlc1tpXS5yZXNwb25zZS5nZXRJbmNpZGVudHNCeUNoYW5uZWwoY2FuZGlkYXRlc1tpXS5wb3NpdGlvbkRlbHRhKTtcblxuICAgICAgICAgIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gaW5jaWRlbnRzQnlQbHVnaW4pIHtcbiAgICAgICAgICAgIHZhciBfdG90YWxJbmNpZGVudHNCeVBsdWc0O1xuXG4gICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0b3RhbEluY2lkZW50c0J5UGx1Z2luLCBwbHVnaW5OYW1lKSkge1xuICAgICAgICAgICAgICB0b3RhbEluY2lkZW50c0J5UGx1Z2luW3BsdWdpbk5hbWVdID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIChfdG90YWxJbmNpZGVudHNCeVBsdWc0ID0gdG90YWxJbmNpZGVudHNCeVBsdWdpbltwbHVnaW5OYW1lXSkucHVzaC5hcHBseShfdG90YWxJbmNpZGVudHNCeVBsdWc0LCBfdG9Db25zdW1hYmxlQXJyYXkoaW5jaWRlbnRzQnlQbHVnaW5bcGx1Z2luTmFtZV0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcG9zaXRpb25EZWx0YSA9IDA7XG5cbiAgICAgICAgaWYgKGNhbmRpZGF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHBvc2l0aW9uRGVsdGEgPSBjYW5kaWRhdGVzWzBdLnBvc2l0aW9uRGVsdGE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzID0gdGhpcy5jaGVja1Jlc2l6ZShwYXlsb2FkLmZyYWN0aW9uLCB0b3RhbEluY2lkZW50c0J5UGx1Z2luLCBwb3NpdGlvbkRlbHRhKTtcblxuICAgICAgICBpZiAocmVzLnJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBzdWNjZXNzQ2FsbGJhY2sgPSBmdW5jdGlvbiBzdWNjZXNzQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICByZXMuZXhlY3V0ZSgpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBjYW5kaWRhdGVzLmxlbmd0aDsgX2k0KyspIHtcbiAgICAgICAgICAgICAgY2FuZGlkYXRlc1tfaTRdLnJlc3BvbmRlci5zZXROZXdEdXJhdGlvbihwYXlsb2FkLm5ld1NpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdWx0OiB0cnVlLFxuICAgICAgICAgICAgZXhlY3V0ZTogc3VjY2Vzc0NhbGxiYWNrXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIGNoZWNrcyBpZiBhIGR1cmF0aW9uIGVkaXQgaXMgZmVhc2libGUgYW5kIGRvZXNuJ3QgY2F1c2UgY29uZmxpY3RzXG4gICAgICAgKiBAcGFyYW0ge2ludH0gZHVyYXRpb24gLSB0aGUgbmV3IGR1cmF0aW9uXG4gICAgICAgKiAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImNoZWNrUmVzaXplXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tSZXNpemUoZHVyYXRpb25GcmFjdGlvbiwgaW5jaWRlbnRzQnlJZCkge1xuICAgICAgICB2YXIgYWRqdXN0TWlsbGlzZWNvbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gICAgICAgIC8vIHByZXBhcmUgdGhlIHJldHVybiBwYXlsb2FkXG4gICAgICAgIHZhciB0b1JldHVyblJlc3VsdCA9IHRydWU7XG4gICAgICAgIHZhciB0b1JldHVybkVycm9ycyA9IFtdO1xuICAgICAgICB2YXIgdG9SZXR1cm5FeGVjdXRhYmxlcyA9IFtdOyAvLyBmb3IgZWFjaCBrZXkgb2YgdGhlIGluY2lkZW50c0J5SWQgb2JqZWN0IHBlcmZvcm0gdGhlIGNoZWNrXG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIGluY2lkZW50c0J5SWQpIHtcbiAgICAgICAgICAvLyBwZXJmb3JtIHRoZSBjaGVja1xuICAgICAgICAgIHZhciBhZGp1c3RlZEluY2lkZW50cyA9IGhlbHBlci5zeXN0b2xlRGlhc3RvbGVQcm9qZWN0aW9ucyhpbmNpZGVudHNCeUlkW2tleV0sIGR1cmF0aW9uRnJhY3Rpb24sIGFkanVzdE1pbGxpc2Vjb25kKTtcbiAgICAgICAgICB2YXIgcGx1Z2luUmVzdWx0ID0gdGhpcy5pbnN0YW50aWF0ZWRDaGFubmVsc1trZXldLmNoZWNrUmVzaXplZEluY2lkZW50cyhhZGp1c3RlZEluY2lkZW50cyk7XG4gICAgICAgICAgdG9SZXR1cm5SZXN1bHQgPSB0b1JldHVyblJlc3VsdCAmJiBwbHVnaW5SZXN1bHQucmVzdWx0O1xuXG4gICAgICAgICAgaWYgKHBsdWdpblJlc3VsdC5yZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0b1JldHVybkVycm9ycyA9IHRvUmV0dXJuRXJyb3JzLmNvbmNhdChwbHVnaW5SZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9SZXR1cm5FeGVjdXRhYmxlcy5wdXNoKHBsdWdpblJlc3VsdC5leGVjdXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gZW5mIG9mIGl0ZXJhdGlvbiBvbiB0aGUgaW5jaWRlbnRzQnlJZCBrZXlzXG5cblxuICAgICAgICB2YXIgdG9SZXR1cm5FeGVjdXRlID0gZnVuY3Rpb24gdG9SZXR1cm5FeGVjdXRlRnVuY3QoKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b1JldHVybkV4ZWN1dGFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0b1JldHVybkV4ZWN1dGFibGVzW2ldKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBlZGl0UmVzdWx0ID0ge1xuICAgICAgICAgIHJlc3VsdDogdG9SZXR1cm5SZXN1bHQsXG4gICAgICAgICAgZXJyb3JzOiB0b1JldHVybkVycm9ycyxcbiAgICAgICAgICBleGVjdXRlOiB0b1JldHVybkV4ZWN1dGVcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVkaXRSZXN1bHQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldEluY2lkZW50c0J5Q2hhbm5lbFwiLFxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgYW4gb2JqZWN0IHdpdGgga2V5cyB0aGUga2V5cyBvZiBhbGwgdGhlIHBsdWdpbnMgSW5jaWRlbnRzIG9mIHdoaWNoIGFwcGVhciBpbiB0aGVcbiAgICAgICAqIHRyZWUgb2YgdGhlIEdyb3VwLiBBbGwgSW5jaWRlbnRzIGFyZSBwcm9qZWN0ZWQgdG8gdGhlIEdyb3VwJ3MgdGltZWxpbmUuXG4gICAgICAgKiBUaGUgYXJyYXkgaW5jbHVkZXMgdGhlIEdyb3VwJ3MgcHJvamVjdGlvbiB0b29cbiAgICAgICAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEluY2lkZW50c0J5Q2hhbm5lbCgpIHtcbiAgICAgICAgdmFyIGFkanVzdE1pbGxpc2Vjb25kID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgICB2YXIgaW5jaWRlbnRzQnlQbHVnaW4gPSB7fTtcbiAgICAgICAgaW5jaWRlbnRzQnlQbHVnaW5bc2VsZkNvbnRhaW5lZEluY2lkZW50c05wbU5hbWVdID0gW3tcbiAgICAgICAgICBtaWxsaXNlY29uZDogYWRqdXN0TWlsbGlzZWNvbmQsXG4gICAgICAgICAgaW5jaWRlbnQ6IHRoaXMsXG4gICAgICAgICAgaWQ6IHRoaXMuaWRcbiAgICAgICAgfV07XG4gICAgICAgIHJldHVybiBpbmNpZGVudHNCeVBsdWdpbjtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0Vm9sdW1lXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Vm9sdW1lKG5ld1ZhbCkge1xuICAgICAgICB0aGlzLnZvbHVtZSA9IHBhcnNlRmxvYXQobmV3VmFsKTsgLy8gdGhpcy5wdXRNZXNzYWdlT25QaXBlKHBpcGVNZXNzYWdlcy5fR0FJTl9DSEFOR0UsIHsgZ2FpbjogbmV3VmFsIH0sIGZhbHNlLCBcImRvd25cIik7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEV2ZW50aG91Z2ggQ2xpcHMgaGF2ZSB0aGVpciBvd24gY29udGV4dCwgc3RpbGwgdGhleSBtaWdodCBiZWxvbmcgdG8gYW5vdGhlciBDbGlwJ3NcbiAgICAgICAqIHRyZWUgKENBU0kpLiBJbiBzdWNoIGEgY2FzZSB0aGlzIG1ldGhvZCBnaXZlcyB0aGUgb3BvcnR1bml0eSB0byBzZXQgdGhpbmdzIHVwXG4gICAgICAgKiBhbmQgZG8gb3BlcmF0aW9ucyByZWxhdGVkIHdpdGggdGhlaXIgcGFyZW50J3MgY29udGV4dCAoc3VjaCBhcyBzdWJzY3JpYmluZyB0byBhdWRpbyBlZmZlY3Qgbm9kZXMpXG4gICAgICAgKiAqL1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX29uR2V0Q29udGV4dE9uY2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25HZXRDb250ZXh0T25jZShwYXJlbnRDbGlwQ29udGV4dCkge30gLy8gc3BlY2lhbCByZWNhbGNEdXJhdGlvbiBoYW5kbGluZyBzbyBhbnkgcG90ZW50aWFsIGNsaXAgY29waWVzIHVwZGF0ZSB0aGVpciB0cmVlc1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaGFuZGxlUmVjYWxjRHVyYXRpb25cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVSZWNhbGNEdXJhdGlvbih0YXJnZXQsIHBheWxvYWQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NhbGN1bGF0ZUR1cmF0aW9uKCkpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZHVyYXRpb25TdWJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmR1cmF0aW9uU3Vic1tpXSh0aGlzLmR1cmF0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogTWV0aG9kIGNhbGxlZCBvbiBwcm9ncmVzcyBvZiB0aGUgdGltZWQgaW5jaWRlbnQuXG4gICAgICAgKiBAcGFyYW0ge2Zsb2F0fSBmcmFjdGlvbiAtIGEgbnVtYmVyIGZyb20gMCB0byAxIHJlcHJlc2VudGluZyB0aGUgZnJhY3Rpb24gb2YgZHVyYXRpb24gY292ZXJlZFxuICAgICAgICogQHBhcmFtIHtpbnR9IG1pbGxpc2Vjb25kcyAtIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHBhc3NlZCBmcm9tIHN0YXJ0IG9mIHRoZSBpbmNpZGVudFxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRleHRJZCAtIGRlZmF1bHRzIHRvIHRoZSBpZCBvZiB0aGUgcmVhbENsaXAgaXRzZWxmLiBEb24ndCBmb3JnZXQgdGhhdCBhIHJlYWxDbGlwXG4gICAgICAgKiAgICAgIG1pZ2h0IGJlbG9uZyB0byBhIHNlbGVjdG9yIENsaXAgKHNvIGl0J3MgYSBGcmFnbWVudGVkIENsaXApLCB3aXRoIG1hbnkgXCJyZWFsXCIgQ2xpcENvcGllcy4gQWxsIENsaXBDb3BpZXMgaG9sZFxuICAgICAgICogICAgICBhIHJlZmVyZW5jZSB0byB0aGlzIENsaXAgdmlhIHRoZWlyIFwicmVhbENsaXBcIiBwcm9wZXJ0eS4gV2hlbmV2ZXIgYW55XG4gICAgICAgKiAgICAgIG9mIHRoZXNlIENsaXBDb3BpZXMgcHJvZ3Jlc3NlcyAodmlhIHRoZSBvblByb2dyZXNzIG1ldGhvZCkgY2FsbHNcbiAgICAgICAqICAgICAgdGhlIFwib25Qcm9ncmVzc1wiIG9mIHRoZSByZWFsQ2xpcCwgcGFzc2luZyB0aGVpciBpZCBzbyB0aGUgQ29udGV4dEF3YXJlSW5jaWRlbnRzXG4gICAgICAgKiAgICAgIHRoYXQgd2lsbCBhbHNvIHByb2dyZXNzIHZpYSB0aGUgQ2hhbm5lbHMga25vdyB3aGljaCBzcGVjaWZpYyBJbmNpZGVudCB0byBwcm9ncmVzcy5cbiAgICAgICAqICAgICAgVGhhdCdzIHRoZSByZXN1bHQgb2Yga2VlcGluZyBqdXN0IG9uZSByZWFsIHRyZWUsIGJlbG9uZ2luZyBhbHdheXMgdG8gdGhlIHJlYWxDbGlwXG4gICAgICAgKiAgICAgIChlaXRoZXIgRnJhZ21lbnRlZCBvciBIb3N0ZWQpIGVuZGluZyB0byBDb250ZXh0QXdhcmVJbmNpZGVudCBsZWFmcyB0aGF0XG4gICAgICAgKiAgICAgIGFyZSB0aGUgb25lcyB0byBob2xkIHRoZSBDbGlwQ29waWVzIGluc3RhbmNlcy5cbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yY2VSZXNldCAtIHNldCB0byB0cnVlIGluIGNhc2VzIHdlIHdhbnQgZnVsbCBmbGFzaCBvZiB0aGUgc3RhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIm9uUHJvZ3Jlc3NcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBvblByb2dyZXNzKGZyYWN0aW9uLCBtaWxsaXNlY29uZHMsIGNvbnRleHRJZCkge1xuICAgICAgICB2YXIgZm9yY2VSZXNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG5cbiAgICAgICAgaWYgKHRoaXMuY29udGV4dFJlYWR5ID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMuc2V0QmxvY2soKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNvbnRleHRJZCkge1xuICAgICAgICAgIGNvbnRleHRJZCA9IHRoaXMuaWQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5pbnN0YW50aWF0ZWRDaGFubmVscykge1xuICAgICAgICAgIHZhciBjaGFubmVsID0gdGhpcy5pbnN0YW50aWF0ZWRDaGFubmVsc1trZXldO1xuICAgICAgICAgIGNoYW5uZWwubW92ZVRvKHRoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kLCBtaWxsaXNlY29uZHMsIGNvbnRleHRJZCwgZm9yY2VSZXNldCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9uQWZ0ZXJQcm9ncmVzcyhmcmFjdGlvbiwgbWlsbGlzZWNvbmRzKTtcbiAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwib25BZnRlclByb2dyZXNzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gb25BZnRlclByb2dyZXNzKGZyYWN0aW9uLCBtaWxsaXNlY29uZHMpIHt9XG4gICAgfSwge1xuICAgICAga2V5OiBcImZsYXNoXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZmxhc2goKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmluc3RhbnRpYXRlZENoYW5uZWxzKSB7XG4gICAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmluc3RhbnRpYXRlZENoYW5uZWxzW2tleV07XG4gICAgICAgICAgY2hhbm5lbC5tb3ZlVG8oMCwgdGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQsIHRoaXMuaWQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9IC8vIGR1cmF0aW9uIGNoYW5nZXMgcHViL3N1YlxuXG4gICAgfSwge1xuICAgICAga2V5OiBcInN1YnNjcmliZVRvRHVyYXRpb25DaGFuZ2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdWJzY3JpYmVUb0R1cmF0aW9uQ2hhbmdlKG1ldGhvZCkge1xuICAgICAgICB0aGlzLmR1cmF0aW9uU3Vicy5wdXNoKG1ldGhvZCk7XG4gICAgICB9XG4gICAgICAvKiogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuICAgICAgLyoqICoqKioqKiBCTE9DS0lORyBXQUlUSU5HUyBTRVQgLyBSRU1PVkUgKioqKioqKioqKioqKiogKi9cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImhhbmRsZVNldEJsb2NraW5nV2FpdGluZ1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVNldEJsb2NraW5nV2FpdGluZyh0YXJnZXQsIHBheWxvYWQpIHt9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImhhbmRsZVJlbW92ZUJsb2NraW5nV2FpdGluZ1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVJlbW92ZUJsb2NraW5nV2FpdGluZyh0YXJnZXQsIHBheWxvYWQpIHt9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNvbnRleHRcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vd25Db250ZXh0O1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBFeHRlbmRhYmxlQ2xpcDtcbiAgfShHcm91cCk7XG5cbiAgdmFyIEF1ZGlvTm9kZSA9XG4gIC8qI19fUFVSRV9fKi9cbiAgZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEF1ZGlvTm9kZSgpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBdWRpb05vZGUpO1xuXG4gICAgICAvLyBhdWRpbyBjb250ZXh0IGluaXRpYWxpc2F0aW9uXG4gICAgICB0aGlzLm91dHB1dCA9IGF1ZGlvQ29udGV4dC5jcmVhdGVHYWluKCk7XG4gICAgICB0aGlzLmdhaW5Ob2RlID0gYXVkaW9Db250ZXh0LmNyZWF0ZUdhaW4oKTtcblxuICAgICAgaWYgKGF1ZGlvQ29udGV4dC5jcmVhdGVTdGVyZW9QYW5uZXIpIHtcbiAgICAgICAgdGhpcy5wYW5uZXJOb2RlID0gYXVkaW9Db250ZXh0LmNyZWF0ZVN0ZXJlb1Bhbm5lcigpOyAvLyBpZiBpdCBpcyBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXJcbiAgICAgIH0gLy8gdGhpcy5oaWdocGFzc05vZGUgPSBhdWRpb0NvbnRleHQuY3JlYXRlQmlxdWFkRmlsdGVyKCk7XG4gICAgICAvLyB0aGlzLmxvd3Bhc3NOb2RlID0gYXVkaW9Db250ZXh0LmNyZWF0ZUJpcXVhZEZpbHRlcigpO1xuICAgICAgLy8gdGhpcy5sb3dwYXNzTm9kZS5jb25uZWN0KHRoaXMuaGlnaHBhc3NOb2RlKTtcbiAgICAgIC8vIHRoaXMuaGlnaHBhc3NOb2RlLmNvbm5lY3QodGhpcy5wYW5uZXJOb2RlKTtcblxuXG4gICAgICBpZiAoYXVkaW9Db250ZXh0LmNyZWF0ZVN0ZXJlb1Bhbm5lcikge1xuICAgICAgICB0aGlzLnBhbm5lck5vZGUuY29ubmVjdCh0aGlzLmdhaW5Ob2RlKTtcbiAgICAgICAgdGhpcy5nYWluTm9kZS5jb25uZWN0KHRoaXMub3V0cHV0KTtcbiAgICAgICAgdGhpcy5pbnB1dCA9IHRoaXMucGFubmVyTm9kZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZ2Fpbk5vZGUuY29ubmVjdCh0aGlzLm91dHB1dCk7XG4gICAgICAgIHRoaXMuaW5wdXQgPSB0aGlzLmdhaW5Ob2RlO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhBdWRpb05vZGUsIFt7XG4gICAgICBrZXk6IFwiY29ubmVjdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbm5lY3QobWFzdGVyKSB7XG4gICAgICAgIHRoaXMub3V0cHV0LmNvbm5lY3QobWFzdGVyKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZGlzY29ubmVjdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgICAgdGhpcy5vdXRwdXQuZGlzY29ubmVjdCgpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBBdWRpb05vZGU7XG4gIH0oKTtcblxuICBmdW5jdGlvbiBfYmFzZTY0VG9BcnJheUJ1ZmZlcihiYXNlNjQpIHtcbiAgICB2YXIgYmluYXJ5X3N0cmluZyA9IHdpbmRvdy5hdG9iKGJhc2U2NCk7XG4gICAgdmFyIGxlbiA9IGJpbmFyeV9zdHJpbmcubGVuZ3RoO1xuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbik7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBieXRlc1tpXSA9IGJpbmFyeV9zdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnl0ZXMuYnVmZmVyO1xuICB9XG5cbiAgdmFyIGRhdGFtY2lkUmVnZXggPSAvXFxbZGF0YSgtbWNpZD1cIitcXHcrXCIpK1xcXS9nO1xuXG4gIHZhciBQdWJTdWIgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQdWJTdWIoKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUHViU3ViKTtcblxuICAgICAgdGhpcy5zdWJzY3JpYmVycyA9IFtdO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhQdWJTdWIsIFt7XG4gICAgICBrZXk6IFwic3ViXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc3ViKGlkLCBtZXRob2QpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVycy5wdXNoKG1ldGhvZCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInB1YlwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHB1Yihhcmd1bWVudCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3Vic2NyaWJlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLnN1YnNjcmliZXJzW2ldKGFyZ3VtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBQdWJTdWI7XG4gIH0oKTtcbiAgLyoqXG4gICAqIFNwZWNzOlxuICAgKiBBdWRpb0NvbnRleHQgSGFuZGxlciBrZWVwcyBhbGwgdGhlIGF1ZGlvIHNvdXJjZXMuXG4gICAqIFRoZSBhdWRpbyBzb3VyY2VzIGFyZSBwYXNzZWQgaW4gdGhlIGZvbGxvd2luZyBmb3JtYXQ6XG4gICAqIC0gc3JjICh0aGUgc291cmNlIG9mIHRoZSBzb3VuZClcbiAgICogLSBiYXNlNjQgKGJvb2xlYW4sIGRlZmF1bHRzIHRvIGZhbHNlLiBJZiB0aGUgc291bmQgaXMgYmFzZTY0IGl0J3MgYmVlbiB0cmVhdGVkXG4gICAqICAgICAgaW4gYSBkaWZmZXJlbnQgd2F5KVxuICAgKiAtIGlkIChtdXN0IGJlIHVuaXF1ZSlcbiAgICogLSBjbGFzc2VzIChhbiBhcnJheSBvZiBiZWxvbmdpbmcgY2xhc3NlcylcbiAgICpcbiAgICogVGhlIFNvdW5kQ29udGV4dEhhbmxkZXIgY3JlYXRlcyBhIG1lZGlhIGVsZW1lbnQgb2YgdGhlIGZvbGxvd2luZyBmb3JtYXQ6XG4gICAqIG1lZGlhOiB7XG4gICAqICBzcmNcbiAgICogIGlkXG4gICAqICBjbGFzc2VzXG4gICAqICBiYXNlNjRcbiAgICogIGJ1ZmZlclxuICAgKiAgbm9kZXM6IHtcbiAgICogICAgICBzdGVyZW9cbiAgICogICAgICBoaWdocGFzc1xuICAgKiAgICAgIGxvd3Bhc3NcbiAgICogICAgICBnYWluXG4gICAqICAgICAgYXVkaW9Ob2RlXG4gICAqICB9XG4gICAqIH1cbiAgICpcbiAgICogRmluYWxseSB0aGUgU291bmRDb250ZXh0SGFuZGxlciBoYXMgaXRzIG93biBub2RlcyAodGhlIG1hc3Rlcikgd2hpY2ggbG9vayBsaWtlIHRoaXM6XG4gICAqIG1hc3Rlcjoge1xuICAgKiAgICAgIHN0ZXJlb1xuICAgKiAgICAgIGhpZ2hwYXNzXG4gICAqICAgICAgbG93cGFzc1xuICAgKiAgICAgIGdhaW5cbiAgICogfVxuICAgKiAqL1xuXG5cbiAgdmFyIEF1ZGlvQ29udGV4dEhhbmRsZXIgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBdWRpb0NvbnRleHRIYW5kbGVyKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIGF1ZGlvU291cmNlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICB2YXIgbWFzdGVyTm9kZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXVkaW9Db250ZXh0SGFuZGxlcik7XG5cbiAgICAgIC8vIHZhcmlhYmxlcyB0byBiZSB1c2VkIGZvciBjaGVja2luZyBjb250ZXh0IHJlZGluZXNzXG4gICAgICB0aGlzLnRvdGFsU291cmNlcyA9IGF1ZGlvU291cmNlcy5sZW5ndGg7IC8vIGluaXRpYWxpc2F0aW9uIG9mIHRoZSBmaW5hbCBhdWRpbyByZXNvdXJjZXMgY29sbGVjaXRvblxuXG4gICAgICB0aGlzLmF1ZGlvU291cmNlcyA9IHt9O1xuICAgICAgdGhpcy5lbGVtZW50c0J5TUNJRCA9IHt9OyAvLyBpdGVyYXRlIG9uIGF1ZGlvU291cmNlIHRvIGNyZWF0ZSB0aGUgYXVkaW9Tb3VyY2VzIGNvbGxlY3Rpb25cblxuICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoaSkge1xuICAgICAgICB2YXIgYXVkaW9Tb3VyY2UgPSBhdWRpb1NvdXJjZXNbaV07XG4gICAgICAgIHZhciBhdWRpb1Jlc291cmNlID0ge1xuICAgICAgICAgIG1jaWQ6IGF1ZGlvU291cmNlLm1jaWQgfHwgZ2V0QW5JZCgpLFxuICAgICAgICAgIGlkOiBhdWRpb1NvdXJjZS5pZCxcbiAgICAgICAgICBzcmM6IGF1ZGlvU291cmNlLnNyYyxcbiAgICAgICAgICBjbGFzc2VzOiBhdWRpb1NvdXJjZS5jbGFzc2VzIHx8IFtdLFxuICAgICAgICAgIGJhc2U2NDogYXVkaW9Tb3VyY2UuYmFzZTY0IHx8IGZhbHNlLFxuICAgICAgICAgIHB1YlN1YjogbmV3IFB1YlN1YigpLFxuICAgICAgICAgIHNvdW5kTG9hZGVkOiBmYWxzZSxcbiAgICAgICAgICBzdGFydFZhbHVlczogYXVkaW9Tb3VyY2Uuc3RhcnRWYWx1ZXMgfHwge31cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuYXVkaW9Tb3VyY2VzW2F1ZGlvUmVzb3VyY2UuaWRdID0gYXVkaW9SZXNvdXJjZTtcbiAgICAgICAgX3RoaXMuZWxlbWVudHNCeU1DSURbYXVkaW9SZXNvdXJjZS5tY2lkXSA9IGF1ZGlvUmVzb3VyY2U7XG5cbiAgICAgICAgaWYgKGF1ZGlvU291cmNlLmJhc2U2NCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGF1ZGlvQ29udGV4dC5kZWNvZGVBdWRpb0RhdGEoX2Jhc2U2NFRvQXJyYXlCdWZmZXIoYXVkaW9Tb3VyY2Uuc3JjKSwgZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICAgICAgX3RoaXMuX3NldEJ1ZmZlcihhdWRpb1Jlc291cmNlLCBidWZmZXIsIG1hc3Rlck5vZGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgcmVxdWVzdC5vcGVuKCdHRVQnLCBhdWRpb1Jlc291cmNlLnNyYywgdHJ1ZSk7XG4gICAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInOyAvLyBEZWNvZGUgYXN5bmNocm9ub3VzbHlcblxuICAgICAgICAgIF90aGlzLnNvdW5kTG9hZGVkID0gZmFsc2U7XG5cbiAgICAgICAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGF1ZGlvQ29udGV4dC5kZWNvZGVBdWRpb0RhdGEocmVxdWVzdC5yZXNwb25zZSwgZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICAgICAgICBfdGhpcy5fc2V0QnVmZmVyKGF1ZGlvUmVzb3VyY2UsIGJ1ZmZlciwgbWFzdGVyTm9kZSk7XG4gICAgICAgICAgICB9LCBfdGhpcy5vbkVycm9yKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcmVxdWVzdC5zZW5kKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXVkaW9Tb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIF9sb29wKGkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbnRleHQgPSB7XG4gICAgICAgIGRvY3VtZW50OiBkb2N1bWVudCxcbiAgICAgICAgd2luZG93OiB3aW5kb3csXG4gICAgICAgIHJvb3RFbGVtZW50OiBkb2N1bWVudC5ib2R5LFxuICAgICAgICB1bm1vdW50OiBmdW5jdGlvbiB1bm1vdW50KCkge30sXG4gICAgICAgIG1hc3Rlck5vZGU6IG1hc3Rlck5vZGUsXG4gICAgICAgIGF1ZGlvQ29udGV4dDogYXVkaW9Db250ZXh0LFxuICAgICAgICBnZXRFbGVtZW50czogdGhpcy5nZXRFbGVtZW50cy5iaW5kKHRoaXMpLFxuICAgICAgICBnZXRNQ0lEOiB0aGlzLmdldE1DSUQuYmluZCh0aGlzKSxcbiAgICAgICAgc2V0TUNJRDogdGhpcy5zZXRNQ0lELmJpbmQodGhpcyksXG4gICAgICAgIGdldEVsZW1lbnRTZWxlY3RvckJ5TUNJRDogdGhpcy5nZXRFbGVtZW50U2VsZWN0b3JCeU1DSUQuYmluZCh0aGlzKSxcbiAgICAgICAgZ2V0RWxlbWVudEJ5TUNJRDogdGhpcy5nZXRFbGVtZW50QnlNQ0lELmJpbmQodGhpcylcbiAgICAgIH07XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEF1ZGlvQ29udGV4dEhhbmRsZXIsIFt7XG4gICAgICBrZXk6IFwiX3NldEJ1ZmZlclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRCdWZmZXIoYXVkaW9SZXNvdXJjZSwgYnVmZmVyLCBtYXN0ZXJOb2RlKSB7XG4gICAgICAgIGF1ZGlvUmVzb3VyY2Uuc291bmRMb2FkZWQgPSB0cnVlO1xuICAgICAgICBhdWRpb1Jlc291cmNlLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgYXVkaW9SZXNvdXJjZS5lZmZlY3RzQXVkaW9Ob2RlID0gbmV3IEF1ZGlvTm9kZSgpO1xuICAgICAgICBhdWRpb1Jlc291cmNlLmVmZmVjdHNBdWRpb05vZGUuY29ubmVjdChtYXN0ZXJOb2RlLmlucHV0KTtcbiAgICAgICAgYXVkaW9SZXNvdXJjZS5wdWJTdWIucHViKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldEVsZW1lbnRCeU1DSURcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFbGVtZW50QnlNQ0lEKG1jaWQpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmVsZW1lbnRzQnlNQ0lELCBtY2lkKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRzQnlNQ0lEW21jaWRdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldEVsZW1lbnRzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWxlbWVudHMoc2VsZWN0b3IpIHtcbiAgICAgICAgaWYgKHNlbGVjdG9yLmNoYXJBdCgwKSA9PT0gJ34nKSB7XG4gICAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5zdWJzdHIoMSk7XG5cbiAgICAgICAgICBpZiAoc2VsZWN0b3IuY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5hdWRpb1NvdXJjZXMsIHNlbGVjdG9yLnN1YnN0cigxKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFt0aGlzLmF1ZGlvU291cmNlc1tzZWxlY3Rvci5zdWJzdHIoMSldXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWxlY3Rvci5jaGFyQXQoMCkgPT09ICcuJykge1xuICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IHNlbGVjdG9yLnN1YnN0cigxKTtcbiAgICAgICAgICAgIHZhciB0b1JldHVybiA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBzb3VyY2UgaW4gdGhpcy5hdWRpb1NvdXJjZXMpIHtcbiAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jbGFzc2VzLmluZGV4T2YoY2xhc3NOYW1lKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdG9SZXR1cm4ucHVzaChzb3VyY2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0b1JldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YW1jaWRSZWdleC5leGVjKHNlbGVjdG9yKSkge1xuICAgICAgICAgIHZhciBtY2lkID0gc2VsZWN0b3Iuc3BsaXQoJ1wiJylbMV07XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHNCeU1DSURbbWNpZF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldE1DSURcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNQ0lEKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQubWNpZDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0TUNJRFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE1DSUQoZWxlbWVudCwgbWNpZCkge1xuICAgICAgICBlbGVtZW50Lm1jaWQgPSBtY2lkO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRFbGVtZW50U2VsZWN0b3JCeU1DSURcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFbGVtZW50U2VsZWN0b3JCeU1DSUQobWNpZCkge1xuICAgICAgICByZXR1cm4gXCJbZGF0YS1tY2lkPVxcXCJcIi5jb25jYXQobWNpZCwgXCJcXFwiXVwiKTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQXVkaW9Db250ZXh0SGFuZGxlcjtcbiAgfSgpO1xuXG4gIHZhciBBdWRpb0NsaXAgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uIChfRXh0ZW5kYWJsZUNsaXApIHtcbiAgICBfaW5oZXJpdHMoQXVkaW9DbGlwLCBfRXh0ZW5kYWJsZUNsaXApO1xuXG4gICAgZnVuY3Rpb24gQXVkaW9DbGlwKGF0dHJzLCBwcm9wcykge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXVkaW9DbGlwKTtcblxuICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQXVkaW9DbGlwKS5jYWxsKHRoaXMsIGF0dHJzLCBwcm9wcykpO1xuICAgICAgX3RoaXMuYXVkaW9Ob2RlID0gbmV3IEF1ZGlvTm9kZSgpO1xuXG4gICAgICBfdGhpcy5hdWRpb05vZGUuY29ubmVjdChhdWRpb0NvbnRleHQuZGVzdGluYXRpb24pO1xuXG4gICAgICB2YXIgY29udGV4dEhhbmxkZXIgPSBuZXcgQXVkaW9Db250ZXh0SGFuZGxlcihfdGhpcy5wcm9wcy5hdWRpb1NvdXJjZXMsIF90aGlzLmF1ZGlvTm9kZSk7XG4gICAgICBfdGhpcy5vd25Db250ZXh0ID0gX29iamVjdFNwcmVhZDIoe30sIGNvbnRleHRIYW5sZGVyLmNvbnRleHQsIHtcbiAgICAgICAgaXNIb3N0ZWRDbGlwOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIF90aGlzLmF1ZGlvQ2xpcCA9IHRydWU7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEF1ZGlvQ2xpcCwgW3tcbiAgICAgIGtleTogXCJvblByb2dyZXNzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gb25Qcm9ncmVzcyhmcmFjdGlvbiwgbXMsIGNvbnRleHRJZCkge1xuICAgICAgICB2YXIgZm9yY2VSZXNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG5cbiAgICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoQXVkaW9DbGlwLnByb3RvdHlwZSksIFwib25Qcm9ncmVzc1wiLCB0aGlzKS5jYWxsKHRoaXMsIGZyYWN0aW9uLCBtcywgdGhpcy5pZCwgZm9yY2VSZXNldCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9vbkdldENvbnRleHRPbmNlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX29uR2V0Q29udGV4dE9uY2UocGFyZW50Q2xpcENvbnRleHQpIHtcbiAgICAgICAgLypcbiAgICAgICAgICAgIGNvbnRleHQubWFzdGVyIHtnYWluLCBwYW4sIGhpZ2hwYXNzLCBsb3dwYXNzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgLy8gYXMgaGlnaHBhc3MgaXMgdGhlIGZpcnN0IG5vZGUgb2YgbWFzdGVyIGluIHJvd1xuICAgICAgICB0aGlzLmF1ZGlvTm9kZS5kaXNjb25uZWN0KCk7XG4gICAgICAgIHRoaXMucGFyZW50Q2xpcENvbnRleHQgPSBwYXJlbnRDbGlwQ29udGV4dDtcbiAgICAgICAgdGhpcy5hdWRpb05vZGUuY29ubmVjdChwYXJlbnRDbGlwQ29udGV4dC5tYXN0ZXJOb2RlLmlucHV0KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibGFzdFdpc2hcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBsYXN0V2lzaCgpIHtcbiAgICAgICAgdGhpcy5hdWRpb05vZGUub3V0cHV0LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgdGhpcy5hdWRpb05vZGUub3V0cHV0LmNvbm5lY3QoYXVkaW9Db250ZXh0LmRlc3RpbmF0aW9uKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0Vm9sdW1lXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Vm9sdW1lKHZvbCkge1xuICAgICAgICB0aGlzLmF1ZGlvTm9kZS5vdXRwdXQuZ2Fpbi52YWx1ZSA9IHZvbDtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQXVkaW9DbGlwO1xuICB9KEV4dGVuZGFibGVDbGlwKTtcblxuICAvKipcbiAgICogRWZmZWN0IGNsYXNzIHRha2VzIG9uIGNvbnN0cnVjdG9yOlxuICAgKiBhdHRyczpcbiAgICogIC0gYW5pbWF0ZWRBdHRyczogdmFsaWQgYW5pbWF0ZWQgYXR0cmlidXRlcyBhcmUgXCJnYWluXCIsIFwicGFuXCJcbiAgICogIC1cbiAgICogKi9cblxuICB2YXIgRWZmZWN0ID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoX01vbm9JbmNpZGVudCkge1xuICAgIF9pbmhlcml0cyhFZmZlY3QsIF9Nb25vSW5jaWRlbnQpO1xuXG4gICAgZnVuY3Rpb24gRWZmZWN0KCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVmZmVjdCk7XG5cbiAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoRWZmZWN0KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoRWZmZWN0LCBbe1xuICAgICAga2V5OiBcIm9uUHJvZ3Jlc3NcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBvblByb2dyZXNzKGZyYWN0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgICBpZiAodGhpcy5lbGVtZW50LnNvdW5kTG9hZGVkID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMuc2V0QmxvY2soJ2xvYWRpbmcgc291bmQnKTtcbiAgICAgICAgICB0aGlzLmVsZW1lbnQucHViU3ViLnN1Yih0aGlzLmlkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy51bmJsb2NrKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlS2V5ID09PSAnZ2FpbicpIHtcbiAgICAgICAgICB2YXIgZ2FpbiA9ICh0aGlzLnRhcmdldFZhbHVlIC0gdGhpcy5nZXRJbml0aWFsVmFsdWUoKSkgKiBmcmFjdGlvbiArIHRoaXMuZ2V0SW5pdGlhbFZhbHVlKCk7IC8vIGNvbnNvbGUubG9nKHRoaXMucHJvcHMubm9kZXMuc3RlcmVvUGFuLnBhbi52YWx1ZSk7XG5cbiAgICAgICAgICB0aGlzLmVsZW1lbnQuZWZmZWN0c0F1ZGlvTm9kZS5nYWluTm9kZS5nYWluLnZhbHVlID0gZ2FpbjtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmF0dHJpYnV0ZUtleSA9PT0gJ3BhbicpIHtcbiAgICAgICAgICB2YXIgcGFuID0gKHRoaXMudGFyZ2V0VmFsdWUgLSB0aGlzLmdldEluaXRpYWxWYWx1ZSgpKSAqIGZyYWN0aW9uICsgdGhpcy5nZXRJbml0aWFsVmFsdWUoKTsgLy8gY29uc29sZS5sb2codGhpcy5wcm9wcy5ub2Rlcy5zdGVyZW9QYW4ucGFuLnZhbHVlKTtcblxuICAgICAgICAgIHRoaXMuZWxlbWVudC5lZmZlY3RzQXVkaW9Ob2RlLnBhbm5lck5vZGUucGFuLnZhbHVlID0gcGFuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldFNjcmF0Y2hWYWx1ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNjcmF0Y2hWYWx1ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlS2V5ID09PSAncGFuJykge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5lbGVtZW50LnN0YXJ0VmFsdWVzLCAncGFuJykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQuc3RhcnRWYWx1ZXMucGFuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlS2V5ID09PSAnZ2FpbicpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuZWxlbWVudC5zdGFydFZhbHVlcywgJ2dhaW4nKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5zdGFydFZhbHVlcy5nYWluO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEVmZmVjdDtcbiAgfShNb25vSW5jaWRlbnQpO1xuXG4gIHZhciBkYXRhU2VwYXJhdG9yID0gJ3x8fCc7XG5cbiAgdmFyIEF1ZGlvUGxheWJhY2tDaGFubmVsID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoX0NsaXBzQ2hhbm5lbCkge1xuICAgIF9pbmhlcml0cyhBdWRpb1BsYXliYWNrQ2hhbm5lbCwgX0NsaXBzQ2hhbm5lbCk7XG5cbiAgICBmdW5jdGlvbiBBdWRpb1BsYXliYWNrQ2hhbm5lbChwcm9wcykge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXVkaW9QbGF5YmFja0NoYW5uZWwpO1xuXG4gICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihBdWRpb1BsYXliYWNrQ2hhbm5lbCkuY2FsbCh0aGlzLCBwcm9wcykpOyAvLyBrZWVwcyB0aGUgbGlzdCBvZiB0aGUgaWRzIG9mIE1lZGlhSW5jaWRlbnRzIHRoYXQgYXJlIGN1cnJlbnRseSBiZWVuIHBsYXllZFxuICAgICAgLy8gaW4gdGhlIGZvcm0gYCR7aWR9fHx8JFtjb250ZXh0SWR9YFxuXG4gICAgICBfdGhpcy5wbGF5aW5nSW5jaWRlbnRzSWRzID0gW107IC8vIHdoZW4gdGhlIENoYW5uZWwncyBDbGlwIGVudGVycyB0aGUgdHJhbnNpdGlvbmFsIHN0YXRlIHRoZSBDaGFubmVsIGlnbm9yZXNcbiAgICAgIC8vIG1vdmVUb3MuIFdoZW4gdGhlIHRyYW5zaXRpb24gZW5kcyB0aG91Z2gsIG5vIG1hdHRlciB0aGUgY3VycmVudE1pbGxpc2Vjb25kXG4gICAgICAvLyBpdHMgQ2xpcCB3YXMgaXQgc2hvdWxkIHJlY2FsYyB3aGljaCBzb3VyY2VzIHRvIHBsYXkgYXMgaWYgd2Ugd2VyZSBnb2luZyBmcm9tXG4gICAgICAvLyAwIHRvIHRoZSB0aGUgdGFyZ2V0IG1pbGxpc2Vjb25kIGJlY2F1c2Ugb2YgdGhlIGRpZmZlcmVudCB3YXkgdGhlIFBsYXliYWNrIG9wZXJhdGVzXG4gICAgICAvLyAoaXQgaGFzIG5vIG9uUHJvZ3Jlc3MpLiBGb3IgdGhpcywgaXQncyB2ZXJ5IGltcG9ydGFudCB0byBzdG9yZSB0aGUgaW5mb3JtYXRpb25cbiAgICAgIC8vIHRoYXQgaXQgZW50ZXJlZCB0aGUgdHJhbnNpdGlvbmFsIHN0YXRlIHNvIG9uIHRoZSBuZXh0IHBsYXlpbmcgc3RhdGUgbW92ZVRvXG4gICAgICAvLyB0byBmb3JjZSBhcyBmcm9tIG1zIDAuXG5cbiAgICAgIF90aGlzLnRyYW5zaXRpb25lZCA9IGZhbHNlO1xuICAgICAgcHJvcHMuc3Vic2NyaWJlKGdldEFuSWQoKSwgX3RoaXMuX3N0YXRlQ2hhbmdlLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLCAwLCAxLCB0cnVlKTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoQXVkaW9QbGF5YmFja0NoYW5uZWwsIFt7XG4gICAgICBrZXk6IFwiX3N0YXRlQ2hhbmdlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3N0YXRlQ2hhbmdlKG1zLCBzdGF0ZSkge1xuICAgICAgICBpZiAoc3RhdGUgPT09ICdwYXVzZWQnIHx8IHN0YXRlID09PSAnaWRsZScgfHwgc3RhdGUgPT09ICdibG9ja2VkJykge1xuICAgICAgICAgIHRoaXMuX3N0b3BQbGF5aW5nSW5jaWRlbnRzKCk7XG5cbiAgICAgICAgICB0aGlzLnRyYW5zaXRpb25lZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3N0b3BQbGF5aW5nSW5jaWRlbnRzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3N0b3BQbGF5aW5nSW5jaWRlbnRzKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGxheWluZ0luY2lkZW50c0lkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBpbmNpZGVudEluZm8gPSB0aGlzLnBsYXlpbmdJbmNpZGVudHNJZHNbaV0uc3BsaXQoZGF0YVNlcGFyYXRvcik7XG5cbiAgICAgICAgICB0aGlzLl9pbmNpZGVudEJ5SWQoaW5jaWRlbnRJbmZvWzBdKS5zdG9wKGluY2lkZW50SW5mb1sxXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBsYXlpbmdJbmNpZGVudHNJZHMgPSBbXTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICAgQHBhcmFtIHtpbnR9IGZyb20gLSB0aGUgbWlsbGlzZWNvbmQgdG8gc3RhcnQgZnJvbVxuICAgICAgICAgQHBhcmFtIHtpbnR9IHRvIC0gdGhlIG1pbGxpc2Vjb25kIHRvIGdvIHRvXG4gICAgICAgICBAcGFyYW0ge3N0cmluZ30gY29udGV4dElkIC0gdGhlIGNvbnRleHQgaWQgdG8gbW92ZVxuICAgICAgICAgQHBhcmFtIHtib29sZWFufSBmb3JjZVJlc2V0IC0gc2V0IHRvIHRydWUgd2hlbiB3ZSB3YW50IGZ1bGwgZmxhc2hcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibW92ZVRvXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZVRvKGZyb20sIHRvLCBjb250ZXh0SWQpIHtcbiAgICAgICAgdmFyIGZvcmNlUmVzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xuXG4gICAgICAgIGlmICh0aGlzLnJ1blRpbWVJbmZvLnN0YXRlID09PSAndHJhbnNpdGlvbmFsJyB8fCBmb3JjZVJlc2V0ID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy50cmFuc2l0aW9uZWQgPSB0cnVlO1xuXG4gICAgICAgICAgdGhpcy5fc3RvcFBsYXlpbmdJbmNpZGVudHMoKTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBsYW5lSXRlbSA9IHRoaXMuaW5jaWRlbnRzW2ldO1xuXG4gICAgICAgICAgICB2YXIgaW5jaWRlbnQgPSB0aGlzLl9pbmNpZGVudEJ5SWQobGFuZUl0ZW0uaWQpO1xuXG4gICAgICAgICAgICBpZiAodG8gPCBsYW5lSXRlbS5taWxsaXNlY29uZCkge1xuICAgICAgICAgICAgICBpbmNpZGVudC5vblByb2dyZXNzKDAsIDAsIGNvbnRleHRJZCwgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRvID4gbGFuZUl0ZW0ubWlsbGlzZWNvbmQgKyBpbmNpZGVudC5kdXJhdGlvbikge1xuICAgICAgICAgICAgICBpbmNpZGVudC5vblByb2dyZXNzKDEsIGluY2lkZW50LmR1cmF0aW9uLCBjb250ZXh0SWQsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaW5jaWRlbnQub25Qcm9ncmVzcygodG8gLSBsYW5lSXRlbS5taWxsaXNlY29uZCkgLyBpbmNpZGVudC5kdXJhdGlvbiwgdG8gLSBsYW5lSXRlbS5taWxsaXNlY29uZCwgY29udGV4dElkLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy50cmFuc2l0aW9uZWQgPT09IHRydWUpIHtcbiAgICAgICAgICBmcm9tID0gMDtcbiAgICAgICAgICB0aGlzLnRyYW5zaXRpb25lZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgIHZhciBzdGFydGluZ0FuaW1zID0gbG9kYXNoX2ZpbHRlcih0aGlzLmluY2lkZW50cywgZnVuY3Rpb24gKGxhbmVJdGVtKSB7XG4gICAgICAgICAgcmV0dXJuIGxhbmVJdGVtLm1pbGxpc2Vjb25kID49IGZyb20gJiYgbGFuZUl0ZW0ubWlsbGlzZWNvbmQgPCB0byAmJiBsYW5lSXRlbS5taWxsaXNlY29uZCArIHRoYXQuX2luY2lkZW50QnlJZChsYW5lSXRlbS5pZCkuZHVyYXRpb24gPiB0bztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGZpbmlzaGluZ0FuaW1zID0gbG9kYXNoX2ZpbHRlcih0aGlzLmluY2lkZW50cywgZnVuY3Rpb24gKGxhbmVJdGVtKSB7XG4gICAgICAgICAgcmV0dXJuIHRoYXQuX2luY2lkZW50QnlJZChsYW5lSXRlbS5pZCkuZHVyYXRpb24gKyBsYW5lSXRlbS5taWxsaXNlY29uZCA+IGZyb20gJiYgdGhhdC5faW5jaWRlbnRCeUlkKGxhbmVJdGVtLmlkKS5kdXJhdGlvbiArIGxhbmVJdGVtLm1pbGxpc2Vjb25kIDw9IHRvO1xuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgc3RhcnRpbmdBbmltcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICB2YXIgX2xhbmVJdGVtID0gc3RhcnRpbmdBbmltc1tfaV07XG5cbiAgICAgICAgICB2YXIgTWVkaWFJbmNpZGVudCA9IHRoaXMuX2luY2lkZW50QnlJZChfbGFuZUl0ZW0uaWQpOyAvLyBvblByb2dyZXNzKGZyYWN0aW9uLCBtaWxsaXNlY29uZHMsIGNvbnRleHRJZCwgZm9yY2VSZXNldCA9IGZhbHNlKSB7XG5cblxuICAgICAgICAgIHZhciBvdmVyY2FtZUVuZCA9ICh0byAtIF9sYW5lSXRlbS5taWxsaXNlY29uZCkgLyBNZWRpYUluY2lkZW50LmR1cmF0aW9uID49IDE7XG4gICAgICAgICAgdmFyIGZyYWN0aW9uID0gb3ZlcmNhbWVFbmQgPyAxIDogKHRvIC0gX2xhbmVJdGVtLm1pbGxpc2Vjb25kKSAvIE1lZGlhSW5jaWRlbnQuZHVyYXRpb247XG4gICAgICAgICAgdmFyIG1pbGxpc2Vjb25kID0gb3ZlcmNhbWVFbmQgPyBNZWRpYUluY2lkZW50LmR1cmF0aW9uIDogdG8gLSBfbGFuZUl0ZW0ubWlsbGlzZWNvbmQ7XG4gICAgICAgICAgdmFyIHN0YXJ0QXR0ZW1wdCA9IE1lZGlhSW5jaWRlbnQucGxheShmcmFjdGlvbiwgbWlsbGlzZWNvbmQsIGNvbnRleHRJZCk7XG5cbiAgICAgICAgICBpZiAoc3RhcnRBdHRlbXB0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLnBsYXlpbmdJbmNpZGVudHNJZHMucHVzaChcIlwiLmNvbmNhdChfbGFuZUl0ZW0uaWQpLmNvbmNhdChkYXRhU2VwYXJhdG9yKS5jb25jYXQoY29udGV4dElkKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgZmluaXNoaW5nQW5pbXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgIHZhciBfbGFuZUl0ZW0yID0gZmluaXNoaW5nQW5pbXNbX2kyXTtcblxuICAgICAgICAgIHZhciBfTWVkaWFJbmNpZGVudCA9IHRoaXMuX2luY2lkZW50QnlJZChfbGFuZUl0ZW0yLmlkKTtcblxuICAgICAgICAgIF9NZWRpYUluY2lkZW50LnN0b3AoY29udGV4dElkKTtcblxuICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMucGxheWluZ0luY2lkZW50c0lkcy5pbmRleE9mKFwiXCIuY29uY2F0KF9sYW5lSXRlbTIuaWQpLmNvbmNhdChkYXRhU2VwYXJhdG9yKS5jb25jYXQoY29udGV4dElkKSk7XG5cbiAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5wbGF5aW5nSW5jaWRlbnRzSWRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQgPSB0bztcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQXVkaW9QbGF5YmFja0NoYW5uZWw7XG4gIH0oQ2xpcENoYW5uZWwpO1xuXG4gIC8qXG4gIGRuYTpcbiAgLSBvcmlnaW5hbElkXG4gIC0gY29udGV4dFxuICAqL1xuXG4gIHZhciBNZWRpYVBsYXkgPSBfZGVjb3JhdGUobnVsbCwgZnVuY3Rpb24gKF9pbml0aWFsaXplKSB7XG4gICAgdmFyIE1lZGlhUGxheSA9IGZ1bmN0aW9uIE1lZGlhUGxheSgpIHtcbiAgICAgIHZhciBhdHRycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgdmFyIGRuYSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWVkaWFQbGF5KTtcblxuICAgICAgX2luaXRpYWxpemUodGhpcyk7XG5cbiAgICAgIC8vIHN1cGVyKHByb3BzKTtcbiAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgIHRoaXMuZG5hID0gZG5hO1xuICAgICAgdGhpcy5jb250ZXh0ID0gZG5hLmNvbnRleHQ7XG4gICAgICB0aGlzLm1jaWQgPSBkbmEubWNpZDtcbiAgICAgIHRoaXMuaWQgPSBwcm9wcy5pZCB8fCBnZXRBbklkKCk7XG4gICAgICB0aGlzLm1vZGVsSWQgPSBwcm9wcy5tb2RlbElkOyAvLyB0aGlzIHBhcmFtZXRlciBpcyBpbml0aWFsaXNlZCB0byBmYWxzZS4gT25jZSB0aGUgb25HZXRDb250ZXh0IG1ldGhvZCBnZXRzIGludm9rZWQgdGhpcyBwYXJhbWV0ZXJcbiAgICAgIC8vIGlzIHNldCB0byB0cnVlIHNvIHdlIHByZXZlbnQgbXVsdGlwbGUgZXhlY3V0aW9ucyBvZiB0aGUgb25HZXRDb250ZXh0IG1ldGhvZFxuXG4gICAgICB0aGlzLmdvdENvbnRleHQgPSBmYWxzZTtcbiAgICAgIC8qXG4gICAgICAgICAgdGhlc2UgYXJlIHRoZSBkZWZhdWx0IHZhbHVlcyB0aGF0IGRlZmluZSBjaGFubmVsaW5nIGZvciB0aGUgZGVmYXVsdCBJbmNpZGVudHMuIFRoZXNlIHZhbHVlcyBnZXQgb3Zld3JpZGVuIHRocm91Z2hcbiAgICAgICAgICB0aGUgbG9hZFBsdWdpbiBtZXRob2Qgb2YgTUMgd2l0aCB0aGUgdmFsdWVzIGZvdW5kIG9uIHRoZSBtYWluLmpzIGZpbGUgb2YgdGhlIHBsdWdpblxuICAgICAgICAgICovXG5cbiAgICAgIHRoaXMucGx1Z2luX2NoYW5uZWxfY2xhc3MgPSBBdWRpb1BsYXliYWNrQ2hhbm5lbDtcbiAgICAgIHRoaXMubWNfcGx1Z2luX25wbV9uYW1lID0gJ21vdG9yLWNvcnRleC1qcy1tZWRpYS1wbGF5YmFjayc7XG5cbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvcHMsICdwbHVnaW5fY2hhbm5lbF9jbGFzcycpKSB7XG4gICAgICAgIHRoaXMucGx1Z2luX2NoYW5uZWxfY2xhc3MgPSBwcm9wcy5wbHVnaW5fY2hhbm5lbF9jbGFzcztcbiAgICAgIH1cblxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgJ21jX3BsdWdpbl9ucG1fbmFtZScpKSB7XG4gICAgICAgIHRoaXMubWNfcGx1Z2luX25wbV9uYW1lID0gcHJvcHMubWNfcGx1Z2luX25wbV9uYW1lO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmhhc0luY2lkZW50cyA9IGZhbHNlO1xuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtib29sZWFufSAtIGlmIGF1dG9HZW5lcmF0ZWQgaXMgc2V0IHRvIHRydWUsIGl0IG1lYW5zIHRoYXQgdGhpcyBJbmNpZGVudCBoYXMgYmVlbiBhdXRvLWdlbmVyYXRlZCBieSBpdHMgcGFyZW50IG9uIGluaXRpYWxpc2F0aW9uLlxuICAgICAgICogVGhpcyBoYXBwZW5zIHdoZW4gcGx1Z2lucyBleHBvcnQgSW5jaWRlbnRzIHRoYXQgb24gaW5pdGlhbGlzYXRpb24gdGhleSBhdXRvbWF0aWNhbGx5IGNyZWF0ZSBvdGhlciBpbmNpZGVudHMgYW5kIGF1dG9tYXRpY2FsbHkgcHV0IHRoZW1cbiAgICAgICAqIG9uIHNwZWNpZmljIHBvaW50cyBvbiB0aGVpciB0aW1lbGluZS5cbiAgICAgICAqL1xuXG4gICAgICB0aGlzLmF1dG9HZW5lcmF0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMub25Jbml0aWFsaXNlKGF0dHJzLCBwcm9wcyk7XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICBGOiBNZWRpYVBsYXksXG4gICAgICBkOiBbe1xuICAgICAgICBraW5kOiBcImdldFwiLFxuICAgICAgICBrZXk6IFwic2VsZWN0b3JcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdG9yKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLnNlbGVjdG9yO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwiZ2V0XCIsXG4gICAgICAgIGtleTogXCJlbGVtZW50XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBlbGVtZW50KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuZ2V0RWxlbWVudEJ5TUNJRCh0aGlzLm1jaWQpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICAgIGRlY29yYXRvcnM6IFtnZXRJbmNpZGVudHNCeUNoYW5uZWxdLFxuICAgICAgICBrZXk6IFwiZ2V0SW5jaWRlbnRzQnlDaGFubmVsXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbmNpZGVudHNCeUNoYW5uZWwoKSB7fVxuICAgICAgfSwge1xuICAgICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAgICBrZXk6IFwiX29uR2V0Q29udGV4dE9uY2VcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkdldENvbnRleHRPbmNlKCkge1xuICAgICAgICAgIC8vIGlmIHRoZSBJbmNpZGVudCBiZWxvbmdzIHRvIGEgZnJhZ21lbnRlZCBjb250ZXh0IHRoZXJlIGFic29sdXRlbHlcbiAgICAgICAgICAvLyBubyByZWFzb24gdG8gcnVuIHRoZSBnZXRDb250ZXh0IG1ldGhvZCBvZiBpdFxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LmZyYWdtZW50ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0aGlzLmdvdENvbnRleHQpIHtcbiAgICAgICAgICAgICAgdGhpcy5vbkdldENvbnRleHQoKTtcbiAgICAgICAgICAgICAgdGhpcy5nb3RDb250ZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMubWNpZCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy5jb250ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgICAga2V5OiBcIm9uR2V0Q29udGV4dFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25HZXRDb250ZXh0KCkge1xuICAgICAgICAgIGhlbHBlci5pbmZvKCdPdmVyd3JpdHRlIHRoZSBcIm9uR2V0Q29udGV4dFwiIG1ldGhvZCB3aXRoIHRoZSBjb2RlIHlvdSB3YW50IHRvIGdldCBleGVjdXRlZCcsICdpbmZvJyk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgICAga2V5OiBcImxhc3RXaXNoXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBsYXN0V2lzaCgpIHt9XG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICAgIGtleTogXCJvbkluaXRpYWxpc2VcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uSW5pdGlhbGlzZSgpIHtcbiAgICAgICAgICBoZWxwZXIuaW5mbygnT3ZlcndyaXR0ZSB0aGUgXCJvbkluaWFsaXNlXCIgbWV0aG9kIHdpdGggdGhlIGNvZGUgeW91IHdhbnQgdG8gZ2V0IGV4ZWN1dGVkJywgJ2luZm8nKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIGNhbGxlZCBvbiBwcm9ncmVzcyBvZiB0aGUgdGltZWQgaW5jaWRlbnQuXG4gICAgICAgICAqIEBwYXJhbSB7ZmxvYXR9IGZyYWN0aW9uIC0gYSBudW1iZXIgZnJvbSAwIHRvIDEgcmVwcmVzZW50aW5nIHRoZSBmcmFjdGlvbiBvZiBkdXJhdGlvbiBjb3ZlcmVkXG4gICAgICAgICAqIEBwYXJhbSB7aW50fSBtaWxsaXNlY29uZHMgLSB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBwYXNzZWQgZnJvbSBzdGFydCBvZiB0aGUgaW5jaWRlbnRcbiAgICAgICAgICovXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICAgIGtleTogXCJvblByb2dyZXNzXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvblByb2dyZXNzKGZyYWN0aW9uLCBtaWxsaXNlY29uZHMpIHt9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzdGFydHMgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgbWVkaWEgZnJvbSB0aGUgc3BlY2lmaWVkIG1pbGxpc2Vjb25kXG4gICAgICAgICAqICovXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICAgIGtleTogXCJwbGF5XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwbGF5KG1pbGxpc2Vjb25kKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHN0b3BzIHRoZSBleGVjdXRpb24gb2YgdGhlIG1lZGlhXG4gICAgICAgICAqICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgICAga2V5OiBcInN0b3BcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3AoKSB7fVxuICAgICAgfSwge1xuICAgICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAgICBkZWNvcmF0b3JzOiBbYmxvY2tdLFxuICAgICAgICBrZXk6IFwic2V0QmxvY2tcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEJsb2NrKCkge31cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgICAgZGVjb3JhdG9yczogW3VuYmxvY2tdLFxuICAgICAgICBrZXk6IFwidW5ibG9ja1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdW5ibG9jaygpIHt9XG4gICAgICB9XVxuICAgIH07XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBleHBlY3RzIG9uIGl0cyBwcm9wczpcbiAgICogLSBzZWxlY3RvclxuICAgKiAtIGR1cmF0aW9uXG4gICAqIC0gc3RhcnRGcm9tIChvcHRpb25hbClcbiAgICogKi9cblxuICB2YXIgQXVkaW9QbGF5YmFjayA9XG4gIC8qI19fUFVSRV9fKi9cbiAgZnVuY3Rpb24gKF9NZWRpYVBsYXlJbmNpZGVudCkge1xuICAgIF9pbmhlcml0cyhBdWRpb1BsYXliYWNrLCBfTWVkaWFQbGF5SW5jaWRlbnQpO1xuXG4gICAgZnVuY3Rpb24gQXVkaW9QbGF5YmFjaygpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBdWRpb1BsYXliYWNrKTtcblxuICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihBdWRpb1BsYXliYWNrKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoQXVkaW9QbGF5YmFjaywgW3tcbiAgICAgIGtleTogXCJwbGF5XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcGxheShtaWxsaXNlY29uZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnQuc291bmRMb2FkZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhpcy5zZXRCbG9jaygnbG9hZGluZyBzb3VuZCcpO1xuICAgICAgICAgIHRoaXMuZWxlbWVudC5wdWJTdWIuc3ViKHRoaXMuaWQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnVuYmxvY2soKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RhcnRGcm9tID0gMDtcblxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMucHJvcHMsICdzdGFydEZyb20nKSkge1xuICAgICAgICAgIHN0YXJ0RnJvbSA9IHRoaXMucHJvcHMuc3RhcnRGcm9tO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hdWRpb05vZGUgPSBhdWRpb0NvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XG4gICAgICAgIHRoaXMuYXVkaW9Ob2RlLmJ1ZmZlciA9IHRoaXMuZWxlbWVudC5idWZmZXI7XG4gICAgICAgIHRoaXMuYXVkaW9Ob2RlLmNvbm5lY3QodGhpcy5lbGVtZW50LmVmZmVjdHNBdWRpb05vZGUuaW5wdXQpO1xuICAgICAgICB0aGlzLmF1ZGlvTm9kZS5zdGFydCgwLCAobWlsbGlzZWNvbmQgKyBzdGFydEZyb20pIC8gMTAwMCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzdG9wXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgdGhpcy5hdWRpb05vZGUuc3RvcCgpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBBdWRpb1BsYXliYWNrO1xuICB9KE1lZGlhUGxheSk7XG5cbiAgdmFyIG5wbV9uYW1lID0gJ0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgtc291bmRzeXN0ZW0nO1xuICB2YXIgaW5jaWRlbnRzID0gW3tcbiAgICBleHBvcnRhYmxlOiBBdWRpb1BsYXliYWNrLFxuICAgIG5hbWU6ICdBdWRpb1BsYXliYWNrJ1xuICB9LCB7XG4gICAgZXhwb3J0YWJsZTogRWZmZWN0LFxuICAgIG5hbWU6ICdBdWRpb0VmZmVjdCdcbiAgfV07XG4gIHZhciBDbGlwID0gQXVkaW9DbGlwO1xuICB2YXIgYXVkaW8gPSAnb25seSc7XG4gIHZhciBhdWRpb1BsdWdpbk1haW4gPSB7XG4gICAgbnBtX25hbWU6IG5wbV9uYW1lLFxuICAgIGluY2lkZW50czogaW5jaWRlbnRzLFxuICAgIENsaXA6IENsaXAsXG4gICAgYXVkaW86IGF1ZGlvXG4gIH07XG5cbiAgdmFyIGxvZGFzaF9maW5kaW5kZXggPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4gIC8qKlxuICAgKiBMb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gICAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgaW5jbHVkZT1cImZpbHRlcixzb3J0QnksZmluZEluZGV4LGZpbmQsZm9yRWFjaCxjbG9uZURlZXBcIiBleHBvcnRzPVwibnBtXCJgXG4gICAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanMuZm91bmRhdGlvbi8+XG4gICAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAgICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAgICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gICAqL1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xuICB2YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcbiAgLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xuXG4gIHZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG4gIC8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cblxuICB2YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG4gIC8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cblxuICB2YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcbiAgLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG5cbiAgdmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuICAvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cblxuICB2YXIgSU5GSU5JVFkgPSAxIC8gMCxcbiAgICAgIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxLFxuICAgICAgTUFYX0lOVEVHRVIgPSAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOCxcbiAgICAgIE5BTiA9IDAgLyAwO1xuICAvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG5cbiAgdmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICAgIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgICAgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJyxcbiAgICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nLFxuICAgICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXScsXG4gICAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuICB2YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuICAvKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG5cbiAgdmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgICByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC8sXG4gICAgICByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuICAvKipcbiAgICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICAgKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAgICovXG5cbiAgdmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcbiAgLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cblxuICB2YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG4gIC8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xuXG4gIHZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cblxuICB2YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuICAvKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG5cbiAgdmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG4gIC8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cblxuICB2YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG5cbiAgdmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG4gIC8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cblxuICB2YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuICAvKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG5cbiAgdmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG4gIHR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG4gIHR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID0gdHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID0gdHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcbiAgLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cblxuICB2YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG5cbiAgdmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgY29tbW9uanNHbG9iYWwgPT0gJ29iamVjdCcgJiYgY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgY29tbW9uanNHbG9iYWw7XG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG5cbiAgdmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG4gIC8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xuXG4gIHZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xuXG4gIHZhciBmcmVlRXhwb3J0cyA9ICBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cblxuICB2YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmICdvYmplY3QnID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcbiAgLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cblxuICB2YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG5cbiAgdmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG4gIC8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xuXG4gIHZhciBub2RlVXRpbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH0oKTtcbiAgLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cblxuXG4gIHZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgKi9cblxuICBmdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcblxuICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAgICogc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAgICogc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmluZEluZGV4YCBhbmQgYF8uZmluZExhc3RJbmRleGAgd2l0aG91dFxuICAgKiBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBiYXNlRmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSBmcm9tSW5kZXggKyAoZnJvbVJpZ2h0ID8gMSA6IC0xKTtcblxuICAgIHdoaWxlIChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfVxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICAgKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIGBjYWNoZWAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBjYWNoZUhhcyhjYWNoZSwga2V5KSB7XG4gICAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgYG1hcGAgdG8gaXRzIGtleS12YWx1ZSBwYWlycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcbiAgICBtYXAuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFyZykge1xuICAgICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBzZXRgIHRvIGFuIGFycmF5IG9mIGl0cyB2YWx1ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAgICovXG5cblxuICBmdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG4gICAgc2V0LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cblxuXG4gIHZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgICAgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuICAvKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG5cbiAgdmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcbiAgLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xuXG4gIHZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG4gIC8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xuXG4gIHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuICAvKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xuXG4gIHZhciBtYXNrU3JjS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gICAgcmV0dXJuIHVpZCA/ICdTeW1ib2woc3JjKV8xLicgKyB1aWQgOiAnJztcbiAgfSgpO1xuICAvKipcbiAgICogVXNlZCB0byByZXNvbHZlIHRoZVxuICAgKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAgICogb2YgdmFsdWVzLlxuICAgKi9cblxuXG4gIHZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuICAvKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xuXG4gIHZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnKTtcbiAgLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG5cbiAgdmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICAgIFN5bWJvbCA9IHJvb3QuU3ltYm9sLFxuICAgICAgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheSxcbiAgICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGUsXG4gICAgICBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZSxcbiAgICAgIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuICAvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG5cbiAgdmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLFxuICAgICAgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgICBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KSxcbiAgICAgIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuICAvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG5cbiAgdmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpLFxuICAgICAgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKSxcbiAgICAgIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKSxcbiAgICAgIFNldCA9IGdldE5hdGl2ZShyb290LCAnU2V0JyksXG4gICAgICBXZWFrTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdXZWFrTWFwJyksXG4gICAgICBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG4gIC8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG5cbiAgdmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcbiAgLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG5cbiAgdmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQsXG4gICAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAgICovXG5cbiAgZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcbiAgICB0aGlzLmNsZWFyKCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgY2xlYXJcbiAgICogQG1lbWJlck9mIEhhc2hcbiAgICovXG5cblxuICBmdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gICAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICAgIHRoaXMuc2l6ZSA9IDA7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBkZWxldGVcbiAgICogQG1lbWJlck9mIEhhc2hcbiAgICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIGdldFxuICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuXG4gICAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICAgIH1cblxuICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgaGFzXG4gICAqIEBtZW1iZXJPZiBIYXNoXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIHNldFxuICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICAgIGRhdGFba2V5XSA9IG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5cblxuICBIYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbiAgSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbiAgSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbiAgSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbiAgSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAgICovXG5cbiAgZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuICAgIHRoaXMuY2xlYXIoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBjbGVhclxuICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gICAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICAgIHRoaXMuc2l6ZSA9IDA7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBkZWxldGVcbiAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcblxuICAgIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICAgIGRhdGEucG9wKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgICB9XG5cbiAgICAtLXRoaXMuc2l6ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIGdldFxuICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcbiAgICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgaGFzXG4gICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gICAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgc2V0XG4gICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAgICovXG5cblxuICBmdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICsrdGhpcy5zaXplO1xuICAgICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5cblxuICBMaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG4gIExpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuICBMaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbiAgTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG4gIExpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuICAgIHRoaXMuY2xlYXIoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIGNsZWFyXG4gICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gICAgdGhpcy5zaXplID0gMDtcbiAgICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICAgJ2hhc2gnOiBuZXcgSGFzaCgpLFxuICAgICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSkoKSxcbiAgICAgICdzdHJpbmcnOiBuZXcgSGFzaCgpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgZGVsZXRlXG4gICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICAgIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gICAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIGdldFxuICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICovXG5cblxuICBmdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgaGFzXG4gICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICAgIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBzZXRcbiAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAgICovXG5cblxuICBmdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gICAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICAgIHNpemUgPSBkYXRhLnNpemU7XG4gICAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cblxuXG4gIE1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG4gIE1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbiAgTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuICBNYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG4gIE1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcbiAgLyoqXG4gICAqXG4gICAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICAgKi9cblxuICBmdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gdmFsdWVzID09IG51bGwgPyAwIDogdmFsdWVzLmxlbmd0aDtcbiAgICB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBhZGRcbiAgICogQG1lbWJlck9mIFNldENhY2hlXG4gICAqIEBhbGlhcyBwdXNoXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAgICovXG5cblxuICBmdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICAgIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBoYXNcbiAgICogQG1lbWJlck9mIFNldENhY2hlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBzZXRDYWNoZUhhcyh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG4gIH0gLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblxuXG4gIFNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuICBTZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICAgKi9cblxuICBmdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBjbGVhclxuICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICovXG5cblxuICBmdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICAgIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKCk7XG4gICAgdGhpcy5zaXplID0gMDtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBkZWxldGVcbiAgICogQG1lbWJlck9mIFN0YWNrXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIGdldFxuICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICovXG5cblxuICBmdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgaGFzXG4gICAqIEBtZW1iZXJPZiBTdGFja1xuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBzZXRcbiAgICogQG1lbWJlck9mIFN0YWNrXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG5cbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcblxuICAgICAgaWYgKCFNYXAgfHwgcGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpIHtcbiAgICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgICB9XG5cbiAgICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblxuXG4gIFN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG4gIFN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcbiAgU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuICBTdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG4gIFN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICovXG5cbiAgZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gICAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJiAhKHNraXBJbmRleGVzICYmICggLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAga2V5ID09ICdsZW5ndGgnIHx8IC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSB8fCAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICBpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpIHx8IC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpKSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfVxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICovXG5cblxuICBmdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gICAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICAgIH1cblxuICAgIHJldHVybiBpbmRleCAmJiBpbmRleCA9PSBsZW5ndGggPyBvYmplY3QgOiB1bmRlZmluZWQ7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICAgKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAgICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gICAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gICAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgICB9XG5cbiAgICByZXR1cm4gc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSA/IGdldFJhd1RhZyh2YWx1ZSkgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LCBrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYga2V5IGluIE9iamVjdChvYmplY3QpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbiAgfVxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICAgKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gICAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAgICogIDIgLSBQYXJ0aWFsIGNvbXBhcmlzb25cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSB7XG4gICAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgYmFzZUlzRXF1YWwsIHN0YWNrKTtcbiAgfVxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICAgKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gICAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICAgIG9ialRhZyA9IG9iaklzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob2JqZWN0KSxcbiAgICAgICAgb3RoVGFnID0gb3RoSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvdGhlcik7XG4gICAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gICAgb3RoVGFnID0gb3RoVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvdGhUYWc7XG4gICAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyxcbiAgICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gICAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlcihvYmplY3QpKSB7XG4gICAgICBpZiAoIWlzQnVmZmVyKG90aGVyKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICAgIG9iaklzT2JqID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjaygpKTtcbiAgICAgIHJldHVybiBvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgIH1cblxuICAgIGlmICghKGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRykpIHtcbiAgICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcbiAgICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKCkpO1xuICAgICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2soKSk7XG4gICAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXRjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICAgIHZhciBpbmRleCA9IG1hdGNoRGF0YS5sZW5ndGgsXG4gICAgICAgIGxlbmd0aCA9IGluZGV4LFxuICAgICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuICFsZW5ndGg7XG4gICAgfVxuXG4gICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG5cbiAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuXG4gICAgICBpZiAobm9DdXN0b21pemVyICYmIGRhdGFbMl0gPyBkYXRhWzFdICE9PSBvYmplY3RbZGF0YVswXV0gOiAhKGRhdGFbMF0gaW4gb2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgICAgdmFyIGtleSA9IGRhdGFbMF0sXG4gICAgICAgICAgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgICBzcmNWYWx1ZSA9IGRhdGFbMV07XG5cbiAgICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSkge1xuICAgICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc3RhY2sgPSBuZXcgU3RhY2soKTtcblxuICAgICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWQgPyBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRywgY3VzdG9taXplciwgc3RhY2spIDogcmVzdWx0KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAgICogIGVsc2UgYGZhbHNlYC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLml0ZXJhdGVlYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSBbdmFsdWU9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYW4gaXRlcmF0ZWUuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgaXRlcmF0ZWUuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gYmFzZUl0ZXJhdGVlKHZhbHVlKSB7XG4gICAgLy8gRG9uJ3Qgc3RvcmUgdGhlIGB0eXBlb2ZgIHJlc3VsdCBpbiBhIHZhcmlhYmxlIHRvIGF2b2lkIGEgSklUIGJ1ZyBpbiBTYWZhcmkgOS5cbiAgICAvLyBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NjAzNCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gaWRlbnRpdHk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpID8gYmFzZU1hdGNoZXNQcm9wZXJ0eSh2YWx1ZVswXSwgdmFsdWVbMV0pIDogYmFzZU1hdGNoZXModmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9wZXJ0eSh2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICAgIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNvdXJjZWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gICAgdmFyIG1hdGNoRGF0YSA9IGdldE1hdGNoRGF0YShzb3VyY2UpO1xuXG4gICAgaWYgKG1hdGNoRGF0YS5sZW5ndGggPT0gMSAmJiBtYXRjaERhdGFbMF1bMl0pIHtcbiAgICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShtYXRjaERhdGFbMF1bMF0sIG1hdGNoRGF0YVswXVsxXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzUHJvcGVydHlgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNyY1ZhbHVlYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICAgIGlmIChpc0tleShwYXRoKSAmJiBpc1N0cmljdENvbXBhcmFibGUoc3JjVmFsdWUpKSB7XG4gICAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICByZXR1cm4gb2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiBvYmpWYWx1ZSA9PT0gc3JjVmFsdWUgPyBoYXNJbihvYmplY3QsIHBhdGgpIDogYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVByb3BlcnR5YCB3aGljaCBzdXBwb3J0cyBkZWVwIHBhdGhzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAgICovXG5cblxuICBmdW5jdGlvbiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAgICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAgICovXG5cblxuICBmdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJztcbiAgICB9XG5cbiAgICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSB2YWx1ZSArICcnO1xuICAgIHJldHVybiByZXN1bHQgPT0gJzAnICYmIDEgLyB2YWx1ZSA9PSAtSU5GSU5JVFkgPyAnLTAnIDogcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGNhc3RQYXRoKHZhbHVlLCBvYmplY3QpIHtcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG4gIH1cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAgICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFyZS5cbiAgICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFycmF5cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gICAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuXG5cbiAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG5cbiAgICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgICAgc2VlbiA9IGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHID8gbmV3IFNldENhY2hlKCkgOiB1bmRlZmluZWQ7XG4gICAgc3RhY2suc2V0KGFycmF5LCBvdGhlcik7XG4gICAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7IC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cblxuICAgIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbCA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIGFyclZhbHVlLCBpbmRleCwgb3RoZXIsIGFycmF5LCBzdGFjaykgOiBjdXN0b21pemVyKGFyclZhbHVlLCBvdGhWYWx1ZSwgaW5kZXgsIGFycmF5LCBvdGhlciwgc3RhY2spO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29tcGFyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cblxuXG4gICAgICBpZiAoc2Vlbikge1xuICAgICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24gKG90aFZhbHVlLCBvdGhJbmRleCkge1xuICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlZW4ucHVzaChvdGhJbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCEoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSkpIHtcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN0YWNrWydkZWxldGUnXShhcnJheSk7XG4gICAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gICAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gICAqXG4gICAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAgICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgICAgaWYgKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGggfHwgb2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XG4gICAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xuXG4gICAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgICBpZiAob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCB8fCAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgY2FzZSBib29sVGFnOlxuICAgICAgY2FzZSBkYXRlVGFnOlxuICAgICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAgIC8vIENvZXJjZSBib29sZWFucyB0byBgMWAgb3IgYDBgIGFuZCBkYXRlcyB0byBtaWxsaXNlY29uZHMuXG4gICAgICAgIC8vIEludmFsaWQgZGF0ZXMgYXJlIGNvZXJjZWQgdG8gYE5hTmAuXG4gICAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgIHJldHVybiBvYmplY3QgPT0gb3RoZXIgKyAnJztcblxuICAgICAgY2FzZSBtYXBUYWc6XG4gICAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgICAgY2FzZSBzZXRUYWc6XG4gICAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUc7XG4gICAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cblxuXG4gICAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG5cbiAgICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJpdG1hc2sgfD0gQ09NUEFSRV9VTk9SREVSRURfRkxBRzsgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG5cbiAgICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gZXF1YWxBcnJheXMoY29udmVydChvYmplY3QpLCBjb252ZXJ0KG90aGVyKSwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcbiAgICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvclxuICAgKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgICAgb2JqUHJvcHMgPSBnZXRBbGxLZXlzKG9iamVjdCksXG4gICAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgICAgb3RoUHJvcHMgPSBnZXRBbGxLZXlzKG90aGVyKSxcbiAgICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gICAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBpbmRleCA9IG9iakxlbmd0aDtcblxuICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuXG4gICAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG5cblxuICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG5cbiAgICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuICAgIHZhciBza2lwQ3RvciA9IGlzUGFydGlhbDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2tleV07XG5cbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbCA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKSA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICAgIH0gLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG5cblxuICAgICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZCA/IG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykgOiBjb21wYXJlZCkpIHtcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjsgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG5cbiAgICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlciAmJiAhKHR5cGVvZiBvYmpDdG9yID09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiYgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgICByZXR1cm4gaXNLZXlhYmxlKGtleSkgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ10gOiBkYXRhLm1hcDtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3Mgb2YgYG9iamVjdGAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgICB2YXIgcmVzdWx0ID0ga2V5cyhvYmplY3QpLFxuICAgICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICB2YXIga2V5ID0gcmVzdWx0W2xlbmd0aF0sXG4gICAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICAgIHJlc3VsdFtsZW5ndGhdID0gW2tleSwgdmFsdWUsIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSldO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gICAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbiAgfVxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICAgIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gICAgfSBjYXRjaCAoZSkge31cblxuICAgIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcblxuICAgIGlmICh1bm1hc2tlZCkge1xuICAgICAgaWYgKGlzT3duKSB7XG4gICAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gICAqL1xuXG5cbiAgdmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbiAoc3ltYm9sKSB7XG4gICAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gICAgfSk7XG4gIH07XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICAgKi9cblxuICB2YXIgZ2V0VGFnID0gYmFzZUdldFRhZzsgLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuXG4gIGlmIChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnIHx8IE1hcCAmJiBnZXRUYWcobmV3IE1hcCgpKSAhPSBtYXBUYWcgfHwgUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcgfHwgU2V0ICYmIGdldFRhZyhuZXcgU2V0KCkpICE9IHNldFRhZyB8fCBXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCgpKSAhPSB3ZWFrTWFwVGFnKSB7XG4gICAgZ2V0VGFnID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksXG4gICAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOlxuICAgICAgICAgICAgcmV0dXJuIGRhdGFWaWV3VGFnO1xuXG4gICAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOlxuICAgICAgICAgICAgcmV0dXJuIG1hcFRhZztcblxuICAgICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZVRhZztcblxuICAgICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzpcbiAgICAgICAgICAgIHJldHVybiBzZXRUYWc7XG5cbiAgICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOlxuICAgICAgICAgICAgcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHBhdGhgIGV4aXN0cyBvbiBgb2JqZWN0YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgaGFzRnVuYykge1xuICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKTtcblxuICAgICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBvYmplY3QgPSBvYmplY3Rba2V5XTtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0IHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGxlbmd0aCA9IG9iamVjdCA9PSBudWxsID8gMCA6IG9iamVjdC5sZW5ndGg7XG4gICAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiYgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICAgIHJldHVybiAhIWxlbmd0aCAmJiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSAmJiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cbiAgICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8IG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICByZXR1cm4gdHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicgPyB2YWx1ZSAhPT0gJ19fcHJvdG9fXycgOiB2YWx1ZSA9PT0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIG1hc2tTcmNLZXkgaW4gZnVuYztcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgICBwcm90byA9IHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUgfHwgb2JqZWN0UHJvdG87XG4gICAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlmIHN1aXRhYmxlIGZvciBzdHJpY3RcbiAgICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSAmJiAhaXNPYmplY3QodmFsdWUpO1xuICB9XG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYG1hdGNoZXNQcm9wZXJ0eWAgZm9yIHNvdXJjZSB2YWx1ZXMgc3VpdGFibGVcbiAgICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKGtleSwgc3JjVmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iamVjdFtrZXldID09PSBzcmNWYWx1ZSAmJiAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCBrZXkgaW4gT2JqZWN0KG9iamVjdCkpO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAgICogY2FjaGUgd2hlbiBpdCBleGNlZWRzIGBNQVhfTUVNT0laRV9TSVpFYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAgICovXG5cblxuICBmdW5jdGlvbiBtZW1vaXplQ2FwcGVkKGZ1bmMpIHtcbiAgICB2YXIgcmVzdWx0ID0gbWVtb2l6ZShmdW5jLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAoY2FjaGUuc2l6ZSA9PT0gTUFYX01FTU9JWkVfU0laRSkge1xuICAgICAgICBjYWNoZS5jbGVhcigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ga2V5O1xuICAgIH0pO1xuICAgIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAgICovXG5cblxuICBmdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgKi9cblxuXG4gIHZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoMCkgPT09IDQ2XG4gICAgLyogLiAqL1xuICAgICkge1xuICAgICAgICByZXN1bHQucHVzaCgnJyk7XG4gICAgICB9XG5cbiAgICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbiAobWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuICAgICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogbnVtYmVyIHx8IG1hdGNoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KTtcbiAgLyoqXG4gICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAgICovXG5cbiAgZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSB2YWx1ZSArICcnO1xuICAgIHJldHVybiByZXN1bHQgPT0gJzAnICYmIDEgLyB2YWx1ZSA9PSAtSU5GSU5JVFkgPyAnLTAnIDogcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAgICovXG5cblxuICBmdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gICAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZ1bmMgKyAnJztcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdFxuICAgKiBlbGVtZW50IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMS4xLjBcbiAgICogQGNhdGVnb3J5IEFycmF5XG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYC0xYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIHVzZXJzID0gW1xuICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cbiAgICogXTtcbiAgICpcbiAgICogXy5maW5kSW5kZXgodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlciA9PSAnYmFybmV5JzsgfSk7XG4gICAqIC8vID0+IDBcbiAgICpcbiAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICogXy5maW5kSW5kZXgodXNlcnMsIHsgJ3VzZXInOiAnZnJlZCcsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICogLy8gPT4gMVxuICAgKlxuICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAqIF8uZmluZEluZGV4KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAqIC8vID0+IDBcbiAgICpcbiAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAqIF8uZmluZEluZGV4KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAqIC8vID0+IDJcbiAgICovXG5cblxuICBmdW5jdGlvbiBmaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIoZnJvbUluZGV4KTtcblxuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIGluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUl0ZXJhdGVlKHByZWRpY2F0ZSksIGluZGV4KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAgICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICAgKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAgICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAgICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gICAqXG4gICAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAgICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gICAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gICAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gICAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAwLjEuMFxuICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICAgKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gICAqXG4gICAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICAgKiB2YWx1ZXMob2JqZWN0KTtcbiAgICogLy8gPT4gWzEsIDJdXG4gICAqXG4gICAqIHZhbHVlcyhvdGhlcik7XG4gICAqIC8vID0+IFszLCA0XVxuICAgKlxuICAgKiBvYmplY3QuYSA9IDI7XG4gICAqIHZhbHVlcyhvYmplY3QpO1xuICAgKiAvLyA9PiBbMSwgMl1cbiAgICpcbiAgICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gICAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAgICogdmFsdWVzKG9iamVjdCk7XG4gICAqIC8vID0+IFsnYScsICdiJ11cbiAgICpcbiAgICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAgICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAgICovXG5cblxuICBmdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgcmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgIH1cblxuICAgIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpKCk7XG4gICAgcmV0dXJuIG1lbW9pemVkO1xuICB9IC8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxuXG5cbiAgbWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuICAvKipcbiAgICogUGVyZm9ybXMgYVxuICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgNC4wLjBcbiAgICogQGNhdGVnb3J5IExhbmdcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gICAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gICAqXG4gICAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIF8uZXEoJ2EnLCAnYScpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIF8uZXEoTmFOLCBOYU4pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMC4xLjBcbiAgICogQGNhdGVnb3J5IExhbmdcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAgICogIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqL1xuXG5cbiAgdmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzO1xuICB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG4gIH07XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAwLjEuMFxuICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBfLmlzQXJyYXkoJ2FiYycpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICovXG5cbiAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICAgKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gICAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDQuMC4wXG4gICAqIEBjYXRlZ29yeSBMYW5nXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICovXG5cbiAgZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDQuMy4wXG4gICAqIEBjYXRlZ29yeSBMYW5nXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKi9cblxuXG4gIHZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMC4xLjBcbiAgICogQGNhdGVnb3J5IExhbmdcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pc0Z1bmN0aW9uKF8pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gICAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG5cblxuICAgIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICAgKlxuICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICAgKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSA0LjAuMFxuICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pc0xlbmd0aCgzKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICpcbiAgICogXy5pc0xlbmd0aCgnMycpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICAgKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gICAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMC4xLjBcbiAgICogQGNhdGVnb3J5IExhbmdcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmlzT2JqZWN0KHt9KTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc09iamVjdChfLm5vb3ApO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNPYmplY3QobnVsbCk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAgICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSA0LjAuMFxuICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pc09iamVjdExpa2Uoe30pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICpcbiAgICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgNC4wLjBcbiAgICogQGNhdGVnb3J5IExhbmdcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICovXG5cblxuICBmdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHwgaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWc7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMy4wLjBcbiAgICogQGNhdGVnb3J5IExhbmdcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICovXG5cblxuICB2YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgZmluaXRlIG51bWJlci5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgNC4xMi4wXG4gICAqIEBjYXRlZ29yeSBMYW5nXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBudW1iZXIuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8udG9GaW5pdGUoMy4yKTtcbiAgICogLy8gPT4gMy4yXG4gICAqXG4gICAqIF8udG9GaW5pdGUoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAqIC8vID0+IDVlLTMyNFxuICAgKlxuICAgKiBfLnRvRmluaXRlKEluZmluaXR5KTtcbiAgICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAgICpcbiAgICogXy50b0Zpbml0ZSgnMy4yJyk7XG4gICAqIC8vID0+IDMuMlxuICAgKi9cblxuICBmdW5jdGlvbiB0b0Zpbml0ZSh2YWx1ZSkge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogMDtcbiAgICB9XG5cbiAgICB2YWx1ZSA9IHRvTnVtYmVyKHZhbHVlKTtcblxuICAgIGlmICh2YWx1ZSA9PT0gSU5GSU5JVFkgfHwgdmFsdWUgPT09IC1JTkZJTklUWSkge1xuICAgICAgdmFyIHNpZ24gPSB2YWx1ZSA8IDAgPyAtMSA6IDE7XG4gICAgICByZXR1cm4gc2lnbiAqIE1BWF9JTlRFR0VSO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyB2YWx1ZSA6IDA7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gaW50ZWdlci5cbiAgICpcbiAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAgICogW2BUb0ludGVnZXJgXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9pbnRlZ2VyKS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgNC4wLjBcbiAgICogQGNhdGVnb3J5IExhbmdcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8udG9JbnRlZ2VyKDMuMik7XG4gICAqIC8vID0+IDNcbiAgICpcbiAgICogXy50b0ludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAqIC8vID0+IDBcbiAgICpcbiAgICogXy50b0ludGVnZXIoSW5maW5pdHkpO1xuICAgKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICAgKlxuICAgKiBfLnRvSW50ZWdlcignMy4yJyk7XG4gICAqIC8vID0+IDNcbiAgICovXG5cblxuICBmdW5jdGlvbiB0b0ludGVnZXIodmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gdG9GaW5pdGUodmFsdWUpLFxuICAgICAgICByZW1haW5kZXIgPSByZXN1bHQgJSAxO1xuICAgIHJldHVybiByZXN1bHQgPT09IHJlc3VsdCA/IHJlbWFpbmRlciA/IHJlc3VsdCAtIHJlbWFpbmRlciA6IHJlc3VsdCA6IDA7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDQuMC4wXG4gICAqIEBjYXRlZ29yeSBMYW5nXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy50b051bWJlcigzLjIpO1xuICAgKiAvLyA9PiAzLjJcbiAgICpcbiAgICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICogLy8gPT4gNWUtMzI0XG4gICAqXG4gICAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICAgKiAvLyA9PiBJbmZpbml0eVxuICAgKlxuICAgKiBfLnRvTnVtYmVyKCczLjInKTtcbiAgICogLy8gPT4gMy4yXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIE5BTjtcbiAgICB9XG5cbiAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IG90aGVyICsgJycgOiBvdGhlcjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgICB9XG5cbiAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVUcmltLCAnJyk7XG4gICAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgICByZXR1cm4gaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KSA6IHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gICAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSA0LjAuMFxuICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLnRvU3RyaW5nKG51bGwpO1xuICAgKiAvLyA9PiAnJ1xuICAgKlxuICAgKiBfLnRvU3RyaW5nKC0wKTtcbiAgICogLy8gPT4gJy0wJ1xuICAgKlxuICAgKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gICAqIC8vID0+ICcxLDIsMydcbiAgICovXG5cblxuICBmdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIHRoZSByZXNvbHZlZCB2YWx1ZSBpc1xuICAgKiBgdW5kZWZpbmVkYCwgdGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGluIGl0cyBwbGFjZS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMy43LjBcbiAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAgICpcbiAgICogXy5nZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAgICogLy8gPT4gM1xuICAgKlxuICAgKiBfLmdldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAgICogLy8gPT4gM1xuICAgKlxuICAgKiBfLmdldChvYmplY3QsICdhLmIuYycsICdkZWZhdWx0Jyk7XG4gICAqIC8vID0+ICdkZWZhdWx0J1xuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSA0LjAuMFxuICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gICAqXG4gICAqIF8uaGFzSW4ob2JqZWN0LCAnYScpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaGFzSW4ob2JqZWN0LCAnYS5iJyk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5oYXNJbihvYmplY3QsIFsnYScsICdiJ10pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaGFzSW4ob2JqZWN0LCAnYicpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhc0luKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gICAqXG4gICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gICAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAc2luY2UgMC4xLjBcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICogICB0aGlzLmEgPSAxO1xuICAgKiAgIHRoaXMuYiA9IDI7XG4gICAqIH1cbiAgICpcbiAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICpcbiAgICogXy5rZXlzKG5ldyBGb28pO1xuICAgKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAqXG4gICAqIF8ua2V5cygnaGknKTtcbiAgICogLy8gPT4gWycwJywgJzEnXVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gICAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAc2luY2UgMC4xLjBcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IFV0aWxcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICAgKlxuICAgKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gICAqIC8vID0+IHRydWVcbiAgICovXG5cblxuICBmdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAyLjQuMFxuICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIG9iamVjdHMgPSBbXG4gICAqICAgeyAnYSc6IHsgJ2InOiAyIH0gfSxcbiAgICogICB7ICdhJzogeyAnYic6IDEgfSB9XG4gICAqIF07XG4gICAqXG4gICAqIF8ubWFwKG9iamVjdHMsIF8ucHJvcGVydHkoJ2EuYicpKTtcbiAgICogLy8gPT4gWzIsIDFdXG4gICAqXG4gICAqIF8ubWFwKF8uc29ydEJ5KG9iamVjdHMsIF8ucHJvcGVydHkoWydhJywgJ2InXSkpLCAnYS5iJyk7XG4gICAqIC8vID0+IFsxLCAyXVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHByb3BlcnR5KHBhdGgpIHtcbiAgICByZXR1cm4gaXNLZXkocGF0aCkgPyBiYXNlUHJvcGVydHkodG9LZXkocGF0aCkpIDogYmFzZVByb3BlcnR5RGVlcChwYXRoKTtcbiAgfVxuICAvKipcbiAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgNC4xMy4wXG4gICAqIEBjYXRlZ29yeSBVdGlsXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gICAqXG4gICAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gICAqIC8vID0+IFtbXSwgW11dXG4gICAqXG4gICAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICovXG5cblxuICBmdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDQuMTMuMFxuICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAgICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAgICovXG5cblxuICBmdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBmaW5kSW5kZXg7XG4gIH0pO1xuXG4gIHZhciBDb2xsZWN0aW9uID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29sbGVjdGlvbigpIHtcbiAgICAgIHZhciBpbml0aWFsQXJyYXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb2xsZWN0aW9uKTtcblxuICAgICAgdGhpcy5yZWFsQXJyYXkgPSBbXTtcblxuICAgICAgaWYgKGluaXRpYWxBcnJheSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMucmVhbEFycmF5ID0gaW5pdGlhbEFycmF5O1xuICAgICAgfVxuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhDb2xsZWN0aW9uLCBbe1xuICAgICAga2V5OiBcIl9oYXNPd25Qcm9wZXJ0eVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYXNPd25Qcm9wZXJ0eShrZXkpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnJlYWxBcnJheSwga2V5KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2dldFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXQoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWxBcnJheVtrZXldO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfc2V0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldChrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMucmVhbEFycmF5W2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2tleXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfa2V5cygpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMucmVhbEFycmF5KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2RlbGV0ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWxldGUoa2V5KSB7XG4gICAgICAgIHJldHVybiBkZWxldGUgdGhpcy5yZWFsQXJyYXlba2V5XTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogZXhwb3J0cyBhIENvbGxlY3Rpb24gb2JqZWN0XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfZXhwb3J0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2V4cG9ydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhbEFycmF5O1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBDb2xsZWN0aW9uO1xuICB9KCk7XG5cbiAgLypcbiAgbGFuZTpcbiAgICAgICAqIFtcbiAgICAgICAqICAgICAge1xuICAgICAgICogICAgICAgICAgaWQ6IHRoZSBpZCBvZiB0aGUgSW5jaWRlbnRcbiAgICAgICAqICAgICAgICAgIG1pbGxpc2Vjb25kOiB0aGUgbWlsbGlzZWNvbmQgb2YgdGhlIGNoYW5uZWwgdGhpcyBBbmltYXRpb24gKHRoYXQgYWZmZWN0cyB0aGUgc2VsZWN0b3IvYXR0cmlidXRlIHBhaXIpIHJ1bnNcbiAgICAgICAqICAgICAgfVxuICAgICAgICogIF1cbiAgKi9cbiAgZnVuY3Rpb24gdXBkYXRlRmluYWxWYWx1ZXMoYWZmZWN0ZWRJbmNpZGVudCwgaW5pdGlhbFZhbHVlcywgb3JpZ2luYWxGaW5hbFZhbHVlcywgZmluYWxWYWx1ZXMpIHtcbiAgICAvLyBjb25zb2xlLmxvZyhpbml0aWFsVmFsdWVzLCBvcmlnaW5hbEZpbmFsVmFsdWVzKTtcbiAgICB2YXIgY2hhbmdlID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gaW5pdGlhbFZhbHVlcykge1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3JpZ2luYWxGaW5hbFZhbHVlcywga2V5KSkge1xuICAgICAgICBjaGFuZ2UgPSB0cnVlO1xuICAgICAgICBmaW5hbFZhbHVlc1trZXldID0gaW5pdGlhbFZhbHVlc1trZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIGFmZmVjdGVkSW5jaWRlbnQuYW5pbWF0ZWRBdHRyaWJ1dGVWYWx1ZSA9IGZpbmFsVmFsdWVzO1xuICAgIHJldHVybiBjaGFuZ2U7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgYXMgaW5wdXQgdGhlIGluZGV4IG9mIHRoZSBhZmZlY3RlZCBpbmNpZGVudCBvbiB0aGUgbGFuZSxcbiAgICogdGhlIGxhbmUgYW5kIGl0IHJlLWNhbGN1bGF0ZXMgdGhlXG4gICAqIGluaXRpYWwgYW5kIGZpbmFsIHZhbHVlcyBvZiBhbGwgdGhlIGZvbGxvd2luZyBpbmNpZGVudHMgaW4gdGhlIGxhbmUuXG4gICAqIFRoZSBmdW5jdGlvbiBpcyB1c2VkIG9ubHkgaW4gY2FzZXMgb2YgY29tYm8gYXR0cmlidXRlc1xuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN0b3JlIC0gaWYgc2V0IHRvIHRydWUgdGhlIGZpcnN0IEluY2lkZW50IHRvIGJlIGVkaXRlZCBzdG9yZXMgdGhlXG4gICAqICAgICAgaW5pdGlhbCB2YWx1ZXMgYXMgaXRzIHB1cmVJbml0aWFsVmFsdWVzXG4gICAqICovXG5cblxuICBmdW5jdGlvbiBzZXRJbml0aWFsVmFsdWUobGFuZSwgaW5jaWRlbnRzQnlJZCwgbmV3SW5pdGlhbFZhbHVlcywgYWZmZWN0ZWRJbmRleCkge1xuICAgIHZhciBzdG9yZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogZmFsc2U7XG4gICAgdmFyIGFmZmVjdGVkSXRlbSA9IGxhbmVbYWZmZWN0ZWRJbmRleF07XG5cbiAgICB2YXIgYWZmZWN0ZWRJbmNpZGVudCA9IGluY2lkZW50c0J5SWQuX2dldChhZmZlY3RlZEl0ZW0uaWQpO1xuXG4gICAgYWZmZWN0ZWRJbmNpZGVudC5zZXRJbml0aWFsVmFsdWUobmV3SW5pdGlhbFZhbHVlcywgc3RvcmUpO1xuICAgIHZhciBjaGFuZ2UgPSB1cGRhdGVGaW5hbFZhbHVlcyhhZmZlY3RlZEluY2lkZW50LCBhZmZlY3RlZEluY2lkZW50LmluaXRpYWxWYWx1ZSwgYWZmZWN0ZWRJbmNpZGVudC5vcmlnaW5hbEFuaW1hdGVkQXR0cmlidXRlVmFsdWUsIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoYWZmZWN0ZWRJbmNpZGVudC5hbmltYXRlZEF0dHJpYnV0ZVZhbHVlKSkpOyAvLyAvIGlmIHRoZSBmaW5hbCB2YWx1ZXMgaGF2ZSBjaGFuZ2VkIGFjY29yZGluZyB0byB0aGUgbmV3IGluaXRpYWwgdmFsdWVzIGFuZCB0aGVyZSBpc1xuICAgIC8vIGEgZm9sbG93aW5nIGluY2lkZW50IG9uIHRoZSBsYW5lXG5cbiAgICBpZiAoY2hhbmdlKSB7XG4gICAgICBhZmZlY3RlZEluY2lkZW50Lmxhc3RXaXNoKCk7XG4gICAgICBhZmZlY3RlZEluY2lkZW50Lm9uR2V0Q29udGV4dCgpO1xuICAgIH1cblxuICAgIGlmIChjaGFuZ2UgJiYgYWZmZWN0ZWRJbmRleCA8IGxhbmUubGVuZ3RoIC0gMSkge1xuICAgICAgc2V0SW5pdGlhbFZhbHVlKGxhbmUsIGluY2lkZW50c0J5SWQsIGFmZmVjdGVkSW5jaWRlbnQuYW5pbWF0ZWRBdHRyaWJ1dGVWYWx1ZSwgYWZmZWN0ZWRJbmRleCArIDEsIGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhlIGdvYWwgb2YgdGhpcyBjbGFzcyBpcyB0byBnZXQgYW4gb3JpZ2luYWwgYXJyYXksIHByb3ZpZGUgYWxsIHRoZSBmdW5jdGlvbmFsaXR5XG4gICAqIG9mIHRoZSBDb2xsZWN0aW9uIGNsYXNzIGJ1dCBieSBrZWVwaW5nIHRoZSBvcmlnaW5hbEFycmF5IGNsZWFuIGFzIGl0IHdhcyBwcm92aWRlZC5cbiAgICovXG4gIHZhciBTYW5kYm94Q29sbGVjdGlvbiA9XG4gIC8qI19fUFVSRV9fKi9cbiAgZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNhbmRib3hDb2xsZWN0aW9uKG9yaWdpbmFsQXJyYXkpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTYW5kYm94Q29sbGVjdGlvbik7XG5cbiAgICAgIHRoaXMub3JpZ2luYWxBcnJheSA9IG9yaWdpbmFsQXJyYXk7XG4gICAgICB0aGlzLmV4dHJhQXJyYXkgPSB7fTtcbiAgICAgIHRoaXMuYWRkZWRLZXlzID0gW107XG4gICAgICB0aGlzLnJlbW92ZWRLZXlzID0gW107XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFNhbmRib3hDb2xsZWN0aW9uLCBbe1xuICAgICAga2V5OiBcIl9oYXNPd25Qcm9wZXJ0eVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYXNPd25Qcm9wZXJ0eShrZXkpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLm9yaWdpbmFsQXJyYXksIGtleSkgfHwgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuZXh0cmFBcnJheSwga2V5KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2dldFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXQoa2V5KSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5leHRyYUFycmF5LCBrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZXh0cmFBcnJheVtrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5vcmlnaW5hbEFycmF5LCBrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZXh0cmFBcnJheVtrZXldID0gX29iamVjdFNwcmVhZDIoe30sIHRoaXMub3JpZ2luYWxBcnJheVtrZXldKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0cmFBcnJheVtrZXldO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfc2V0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldChrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZXh0cmFBcnJheVtrZXldID0gdmFsdWU7XG5cbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5vcmlnaW5hbEFycmF5LCBrZXkpKSB7XG4gICAgICAgICAgdGhpcy5hZGRlZEtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGluZGV4T25SZW1vdmVkS2V5cyA9IHRoaXMucmVtb3ZlZEtleXMuaW5kZXhPZihrZXkpO1xuXG4gICAgICAgIGlmIChpbmRleE9uUmVtb3ZlZEtleXMgPiAtMSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlZEtleXMuc3BsaWNlKGluZGV4T25SZW1vdmVkS2V5cywgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2tleXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfa2V5cygpIHtcbiAgICAgICAgdmFyIGFsbEtleXMgPSBPYmplY3Qua2V5cyh0aGlzLm9yaWdpbmFsQXJyYXkpLmNvbmNhdCh0aGlzLmFkZGVkS2V5cyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJlbW92ZWRLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGluZGV4T25BcnJheSA9IHRoaXMucmVtb3ZlZEtleXMuaW5kZXhPZih0aGlzLnJlbW92ZWRLZXlzW2ldKTtcbiAgICAgICAgICBhbGxLZXlzLnNwbGljZShpbmRleE9uQXJyYXksIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFsbEtleXM7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9kZWxldGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVsZXRlKGtleSkge1xuICAgICAgICB2YXIgaW5kZXhPbkFkZGVkS2V5cyA9IHRoaXMuYWRkZWRLZXlzLmluZGV4T2Yoa2V5KTtcblxuICAgICAgICBpZiAoaW5kZXhPbkFkZGVkS2V5cyA+IC0xKSB7XG4gICAgICAgICAgdGhpcy5hZGRlZEtleXMuc3BsaWNlKGluZGV4T25BZGRlZEtleXMpO1xuICAgICAgICAgIHJldHVybiBkZWxldGUgdGhpcy5leHRyYUFycmF5W2tleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVkS2V5cy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9leHBvcnRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZXhwb3J0KCkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5leHRyYUFycmF5KSB7XG4gICAgICAgICAgdGhpcy5vcmlnaW5hbEFycmF5W2tleV0gPSB0aGlzLmV4dHJhQXJyYXlba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yZW1vdmVkS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLm9yaWdpbmFsQXJyYXlbdGhpcy5yZW1vdmVkS2V5c1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5vcmlnaW5hbEFycmF5O1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBTYW5kYm94Q29sbGVjdGlvbjtcbiAgfSgpO1xuXG4gIHZhciBTYW5kYm94SW5jaWRlbnRzQnlJZCA9XG4gIC8qI19fUFVSRV9fKi9cbiAgZnVuY3Rpb24gKF9TYW5kYm94Q29sbGVjdGlvbikge1xuICAgIF9pbmhlcml0cyhTYW5kYm94SW5jaWRlbnRzQnlJZCwgX1NhbmRib3hDb2xsZWN0aW9uKTtcblxuICAgIGZ1bmN0aW9uIFNhbmRib3hJbmNpZGVudHNCeUlkKCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNhbmRib3hJbmNpZGVudHNCeUlkKTtcblxuICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihTYW5kYm94SW5jaWRlbnRzQnlJZCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFNhbmRib3hJbmNpZGVudHNCeUlkLCBbe1xuICAgICAga2V5OiBcIl9nZXRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0KGtleSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuZXh0cmFBcnJheSwga2V5KSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmV4dHJhQXJyYXlba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMub3JpZ2luYWxBcnJheSwga2V5KSkge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5vcmlnaW5hbEFycmF5W2tleV07XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFNhbmRib3hJbmNpZGVudHNCeUlkO1xuICB9KFNhbmRib3hDb2xsZWN0aW9uKTtcblxuICB2YXIgU2FuZGJveExhbmVzID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoX1NhbmRib3hDb2xsZWN0aW9uKSB7XG4gICAgX2luaGVyaXRzKFNhbmRib3hMYW5lcywgX1NhbmRib3hDb2xsZWN0aW9uKTtcblxuICAgIGZ1bmN0aW9uIFNhbmRib3hMYW5lcygpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTYW5kYm94TGFuZXMpO1xuXG4gICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKFNhbmRib3hMYW5lcykuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFNhbmRib3hMYW5lcywgW3tcbiAgICAgIGtleTogXCJfZ2V0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldChrZXkpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmV4dHJhQXJyYXksIGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5leHRyYUFycmF5W2tleV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLm9yaWdpbmFsQXJyYXksIGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5leHRyYUFycmF5W2tleV0gPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3JpZ2luYWxBcnJheVtrZXldLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5leHRyYUFycmF5W2tleV0ucHVzaCh7XG4gICAgICAgICAgICBpZDogdGhpcy5vcmlnaW5hbEFycmF5W2tleV1baV0uaWQsXG4gICAgICAgICAgICAvLyBpbmNpZGVudDogdGhpcy5vcmlnaW5hbEFycmF5W2tleV1baV0uaW5jaWRlbnQsXG4gICAgICAgICAgICBtaWxsaXNlY29uZDogdGhpcy5vcmlnaW5hbEFycmF5W2tleV1baV0ubWlsbGlzZWNvbmQgKiAxXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5leHRyYUFycmF5W2tleV07XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFNhbmRib3hMYW5lcztcbiAgfShTYW5kYm94Q29sbGVjdGlvbik7XG5cbiAgdmFyIExhbmVzSGFuZGxlciA9XG4gIC8qI19fUFVSRV9fKi9cbiAgZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExhbmVzSGFuZGxlcigpIHtcbiAgICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMYW5lc0hhbmRsZXIpO1xuXG4gICAgICAvKlxuICAgICAgICAgICAqIEtlZXBzIHRoZSBsYW5lcyBvZiB0aGUgQ2hhbm5lbCBpbiB0aGUgZm9ybTpcbiAgICAgICAgICAgKiB7XG4gICAgICAgICAgICogIDxtb3RvcmNvcnRleC1pZD5fPGF0dHJpYnV0ZT46IFtcbiAgICAgICAgICAgKiAgICAgIHtcbiAgICAgICAgICAgKiAgICAgICAgICBpZDogdGhlIGlkIG9mIHRoZSBJbmNpZGVudFxuICAgICAgICAgICAqICAgICAgICAgIG1pbGxpc2Vjb25kOiB0aGUgbWlsbGlzZWNvbmQgb2YgdGhlIGNoYW5uZWwgdGhpcyBBbmltYXRpb24gKHRoYXQgYWZmZWN0cyB0aGUgc2VsZWN0b3IvYXR0cmlidXRlIHBhaXIpIHJ1bnNcbiAgICAgICAgICAgKiAgICAgIH1cbiAgICAgICAgICAgKiAgXVxuICAgICAgICAgICAqIH1cbiAgICAgICAgICAgLyoqIEB0eXBlIHt7fX1cbiAgICAgICAgICAgKi9cbiAgICAgIHRoaXMubGFuZXMgPSBuZXcgQ29sbGVjdGlvbih7fSk7XG5cbiAgICAgIGlmIChwcm9wcy5sYW5lcykge1xuICAgICAgICB0aGlzLmxhbmVzID0gcHJvcHMubGFuZXM7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29tYm9BdHRyaWJ1dGVzID0ge307XG5cbiAgICAgIGlmIChwcm9wcy5jb21ib0F0dHJpYnV0ZXMgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLmNvbWJvQXR0cmlidXRlcyA9IHByb3BzLmNvbWJvQXR0cmlidXRlcztcbiAgICAgIH1cblxuICAgICAgdGhpcy5ydW5UaW1lSW5mbyA9IHByb3BzLnJ1blRpbWVJbmZvO1xuICAgICAgLypcbiAgICAgICAgICBLZWVwcyBhbiBpbmRleGluZyBvZiB0aGUgbGFuZXMgZWFjaCBBbmltYXRpb24gYmVsb25ncyB0by4gVGhlIGZvcm0gaXMgdGhlIGZvbGxvd2luZzpcbiAgICAgICAgICBiZWxvbmdpbmdMYW5lS2V5c0J5QW5pbWF0aW9uSWQ6IHtcbiAgICAgICAgICAgICAgPGFuaW1hdGlvbl9pZD46IFtsYW5lS2V5MSwgbGFuZUtleTIsIC4uLl0sXG4gICAgICAgICAgICAgIDxhbmltYXRpb25faWQ+OiBbbGFuZUtleTIsIGxhbmVLZXkzLCAuLi5dLFxuICAgICAgICAgICAgICAuLi5cbiAgICAgICAgICB9XG4gICAgICAgICAgICovXG5cbiAgICAgIHRoaXMuYmVsb25naW5nTGFuZUtleXNCeUFuaW1hdGlvbklkID0gbmV3IENvbGxlY3Rpb24oe30pO1xuXG4gICAgICBpZiAocHJvcHMuYmVsb25naW5nTGFuZUtleXNCeUFuaW1hdGlvbklkKSB7XG4gICAgICAgIHRoaXMuYmVsb25naW5nTGFuZUtleXNCeUFuaW1hdGlvbklkID0gcHJvcHMuYmVsb25naW5nTGFuZUtleXNCeUFuaW1hdGlvbklkO1xuICAgICAgfVxuICAgICAgLypcbiAgICAgICAgICBrZWVwcyBhbGwgSW5jaWRlbnRzICh0aGF0IGFwcGVhciBvbiB0aGUgbGFuZXMpIG1hcHBlZCBvbiBhIGtleSAtIHZhbHVlIHBhaXJcbiAgICAgICAgICBvYmplY3Qgb24gd2hpY2ggdGhlIGtleXMgYXJlIHRoZSBpZHMgYW5kIHRoZSB2YWx1ZXMgdGhlIGNvcnJlc3BvbmRpbmcgSW5jaWRlbnRzLlxuICAgICAgICAgIFRoZSBJbmNpZGVudHMgb2YgdGhpcyBvYmplY3QgYXJlIENvbnRleHRBd2FyZUluY2lkZW50c1xuICAgICAgICAgICovXG5cblxuICAgICAgdGhpcy5pbmNpZGVudHNCeUlkID0gbmV3IENvbGxlY3Rpb24oe30pO1xuXG4gICAgICBpZiAocHJvcHMuaW5jaWRlbnRzQnlJZCkge1xuICAgICAgICB0aGlzLmluY2lkZW50c0J5SWQgPSBwcm9wcy5pbmNpZGVudHNCeUlkO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXNpemVzIGFsbCB0aGUgbGFuZXMgb2YgdGhlIExhbmVzIEhhbmRsZXIgYnkgdGhlIGR1cmF0aW9uRnJhY3Rpb24gcHJvdmlkZWQuXG4gICAgICogTm8gY2hlY2tzIGFyZSBwZXJmb3JtZWQuXG4gICAgICogVGhpcyBtZXRob2QgaXMgYmVlbiBpbnZva2VkIGluIGNhc2VzIHdoZXJlIGEgZnVsbCBDbGlwIGdldHMgcmVzaXplZCwgc28gbm8gY29uZmxpY3QgY2hlY2tzIG5lZWQgdG9cbiAgICAgKiBydW4uXG4gICAgICogQHBhcmFtIHtmbG9hdH0gZHVyYXRpb25GcmF0aW9uOiB0aGUgZnJhY3Rpb24gYmV0d2VlbiB0aGUgbmV3IGR1cmF0aW9uIGFuZCB0aGUgY3VycmVudFxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoTGFuZXNIYW5kbGVyLCBbe1xuICAgICAga2V5OiBcIl9yZXNpemVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzaXplKGR1cmF0aW9uRnJhY3Rpb24pIHtcbiAgICAgICAgdmFyIGtleXMgPSB0aGlzLmxhbmVzLl9rZXlzKCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgICB2YXIgdGhlTGFuZSA9IHRoaXMubGFuZXMuX2dldChrZXkpO1xuXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGVMYW5lLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB0aGVMYW5lW2pdLm1pbGxpc2Vjb25kID0gdGhlTGFuZVtqXS5taWxsaXNlY29uZCAqIGR1cmF0aW9uRnJhY3Rpb247XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIGl0IGNyZWF0ZXMgYSBuZXcgTGFuZXNIYW5kbGVyIHRoYXQgYWN0cyBhcyBhIHNhbmJveCBmb3IgdGVzdGluZyBjaGFuZ2VzXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjcmVhdGVUZXN0TGFuZXNTYW5ib3hcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVUZXN0TGFuZXNTYW5ib3goKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgICBsYW5lczogbmV3IFNhbmRib3hMYW5lcyh0aGlzLmxhbmVzLl9leHBvcnQoKSksXG4gICAgICAgICAgYmVsb25naW5nTGFuZUtleXNCeUFuaW1hdGlvbklkOiBuZXcgU2FuZGJveENvbGxlY3Rpb24odGhpcy5iZWxvbmdpbmdMYW5lS2V5c0J5QW5pbWF0aW9uSWQuX2V4cG9ydCgpKSxcbiAgICAgICAgICBpbmNpZGVudHNCeUlkOiBuZXcgU2FuZGJveEluY2lkZW50c0J5SWQodGhpcy5pbmNpZGVudHNCeUlkLl9leHBvcnQoKSlcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodGhpcy5jb21ib0F0dHJpYnV0ZXMpIHtcbiAgICAgICAgICBwcm9wcy5jb21ib0F0dHJpYnV0ZXMgPSB0aGlzLmNvbWJvQXR0cmlidXRlcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgTGFuZXNIYW5kbGVyKHByb3BzKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0TGFuZXNDb3B5XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGFuZXNDb3B5KGxhbmUpIHtcbiAgICAgICAgdmFyIGxhbmVUb1JldHVybiA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFuZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxhbmVUb1JldHVybi5wdXNoKHtcbiAgICAgICAgICAgIGlkOiBsYW5lW2ldLmlkLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmQ6IGxhbmVbaV0ubWlsbGlzZWNvbmQgKiAxXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGFuZVRvUmV0dXJuO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRMYW5lRWxlbWVudHNDbG9uZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldExhbmVFbGVtZW50c0Nsb25lKGxhbmVFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaWQ6IGxhbmVFbGVtZW50LmlkLFxuICAgICAgICAgIG1pbGxpc2Vjb25kOiBsYW5lRWxlbWVudC5taWxsaXNlY29uZCAqIDFcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYXBwbHlTYW5kYm94Q2hhbmdlc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5U2FuZGJveENoYW5nZXMoU2FuYm94T2JqZWN0KSB7XG4gICAgICAgIHRoaXMubGFuZXMgPSBuZXcgQ29sbGVjdGlvbihTYW5ib3hPYmplY3QubGFuZXMuX2V4cG9ydCgpKTtcbiAgICAgICAgdGhpcy5iZWxvbmdpbmdMYW5lS2V5c0J5QW5pbWF0aW9uSWQgPSBuZXcgQ29sbGVjdGlvbihTYW5ib3hPYmplY3QuYmVsb25naW5nTGFuZUtleXNCeUFuaW1hdGlvbklkLl9leHBvcnQoKSk7XG4gICAgICAgIHRoaXMuaW5jaWRlbnRzQnlJZCA9IG5ldyBDb2xsZWN0aW9uKFNhbmJveE9iamVjdC5pbmNpZGVudHNCeUlkLl9leHBvcnQoKSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldExhbmVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMYW5lKG1jaWQsIGF0dHIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFuZXMuX2dldChnZXRMYW5lS2V5KG1jaWQsIGF0dHIpKTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogcmV0dXJuIHRydWUgaWYgbGFuZSBleGlzdHMgb3IgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWNpZFxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaWZOb3RDcmVhdGVJdCAtIGlmIGlzIHNldCB0byB0cnVlIGFuZCB0aGUgbGFuZSBkb2Vzbid0IGV4aXN0IGl0IGNyZWF0ZXMgaXQgYnV0IHN0aWxsIHJldHVybmluZyBmYWxzZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibGFuZUV4aXN0c1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxhbmVFeGlzdHMobWNpZCwgYXR0cikge1xuICAgICAgICB2YXIgaWZOb3RDcmVhdGVJdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgICAgIHZhciBsYW5lS2V5ID0gZ2V0TGFuZUtleShtY2lkLCBhdHRyKTtcblxuICAgICAgICBpZiAoIXRoaXMubGFuZXMuX2hhc093blByb3BlcnR5KGxhbmVLZXkpKSB7XG4gICAgICAgICAgaWYgKGlmTm90Q3JlYXRlSXQpIHtcbiAgICAgICAgICAgIHRoaXMubGFuZXMuX3NldChsYW5lS2V5LCBbXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdBbmltIC0gYW4gb2JqZWN0IG9mIHRoZSBmb3JtIG9mIGEgbGFuZSBpdGVtICh3aXRoIGtleXMgXCJtaWxsaXNlY29uZFwiIGFuZCBcImluY2lkZW50XCJcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtY2lkXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0clxuICAgICAgICogQHBhcmFtIHthcnJheX0gZXhjbHVkZUlkc0Zyb21DaGVjayAtIG9wdGlvbmFsLiBJZiBleGlzdHMgaXQgZXhjbHVkZXMgYWxsIHRoZSBpZHMgb2YgdGhpcyBhcnJheSBmcm9tIGNoZWNrLiBUaGlzXG4gICAgICAgKiAgcGFyYW1ldGVyIGhhcyBiZWVuIGFkZGVkIGZvciB0aGUgZWRpdCBjaGVja3Mgd2hlcmUgYW4gYW5pbWF0aW9uIG1pZ2h0IG92ZXJsYXAgYW5vdGhlciBhbmltYXRpb24gdGhhdCBwYXJ0aWNpcGF0ZXMgb25cbiAgICAgICAqICB0aGUgbW92ZSwgc29tZXRoaW5nIHRoYXQgc2hvdWxkIG5vdCBoYXBwZW4gYXMgdGhlIGVkaXRlZCBhbmltYXRpb25zIHByZS1leGlzdGVkIHdpdGhvdXQgY29uZmxpY3RzIGFuZCB0aGUgbW92ZSBvZiBhbGxcbiAgICAgICAqICBvZiB0aGVtIHRvZ2V0aGVyIGd1YXJhbnRlZXMgdGhhdCB0aGVyZSBpcyBnb2luZyB0byBiZSBubyBjb25mbGljdCBiZXR3ZWVuIHRoZW0gZXZlbiBhZnRlciB0aGUgZWRpdFxuICAgICAgICogQHBhcmFtIHtpbnR9IHRlc3REdXJhdGlvbiAtIG9wdGlvbmFsLiBUaGlzIHBhcmFtZXRlciBpcyB1c2VkIHdoZW4gdGhlIGNoYW5uZWwgbmVlZHMgdG8gYWRkY2hlY2sgb3ZlcmxhcHMgYWZ0ZXIgZHVyYXRpb25cbiAgICAgICAqICBlZGl0cywgc28gdGhlIHRlc3REdXJhdGlvbiBpcyBwYXNzZWQgKHdlIGRvbid0IHdhbnQgdG8gcG9sdXRlIHRoZSBvcmlnaW5hbCBhbmltYXRpb24gb2JqZWN0IGFzIGl0IHJlZmVycyB0byB0aGUgcmVhbCBvbmUpXG4gICAgICAgKiBAcmV0dW5zIHthcnJheX0gLSBhIGxpc3Qgb2YgYWxsIG92ZXJsYXBwaW5nIGFuaW1hdGlvbnMgb2YgdGhlIGxhbmVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImdldE92ZXJsYXBwaW5nQW5pbXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRPdmVybGFwcGluZ0FuaW1zKG5ld0FuaW0sIG1jaWQsIGF0dHIpIHtcbiAgICAgICAgdmFyIGV4Y2x1ZGVJZHNGcm9tQ2hlY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IFtdO1xuICAgICAgICB2YXIgdGVzdER1cmF0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBudWxsO1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgdmFyIG92ZXJsYXBwaW5nQW5pbXMgPSBsb2Rhc2hfZmlsdGVyKHRoaXMubGFuZXMuX2dldChnZXRMYW5lS2V5KG1jaWQsIGF0dHIpKSwgZnVuY3Rpb24gKGV4aXN0aW5nQW5pbSkge1xuICAgICAgICAgIHZhciBkdXJhdGlvblRvVXNlT25DaGVja3MgPSBuZXdBbmltLmluY2lkZW50LmR1cmF0aW9uO1xuXG4gICAgICAgICAgaWYgKHRlc3REdXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICBkdXJhdGlvblRvVXNlT25DaGVja3MgPSB0ZXN0RHVyYXRpb247XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGV4aXN0aW5nQW5pbS5pZCAhPT0gbmV3QW5pbS5pbmNpZGVudC5pZCAmJiBleGNsdWRlSWRzRnJvbUNoZWNrLmluZGV4T2YoZXhpc3RpbmdBbmltLmlkKSA8IDAgJiYgKCAvLyBleGlzdGluZyBhbmltIHN0YXJ0cyB3aXRoaW4gdGhlIG5ldyBhbmltJ3MgZXh0ZW5kXG4gICAgICAgICAgZXhpc3RpbmdBbmltLm1pbGxpc2Vjb25kID49IG5ld0FuaW0ubWlsbGlzZWNvbmQgJiYgZXhpc3RpbmdBbmltLm1pbGxpc2Vjb25kIDwgZHVyYXRpb25Ub1VzZU9uQ2hlY2tzICsgbmV3QW5pbS5taWxsaXNlY29uZCB8fCAvLyBvciBlbmRzIHdpdGhpbiB0aGUgbmV3IGFuaW0ncyBleHRlbmRcbiAgICAgICAgICBleGlzdGluZ0FuaW0ubWlsbGlzZWNvbmQgKyB0aGF0LmluY2lkZW50c0J5SWQuX2dldChleGlzdGluZ0FuaW0uaWQpLmR1cmF0aW9uID4gbmV3QW5pbS5taWxsaXNlY29uZCAmJiBleGlzdGluZ0FuaW0ubWlsbGlzZWNvbmQgKyB0aGF0LmluY2lkZW50c0J5SWQuX2dldChleGlzdGluZ0FuaW0uaWQpLmR1cmF0aW9uIDw9IGR1cmF0aW9uVG9Vc2VPbkNoZWNrcyArIG5ld0FuaW0ubWlsbGlzZWNvbmQgfHwgLy8gb3IgaXQgc3RhcnRzIGJlZm9yZSBhbmQgZW5kcyBhZnRlciB0aGUgbmV3IGFuaW0ncyBleHRlbmRcbiAgICAgICAgICBleGlzdGluZ0FuaW0ubWlsbGlzZWNvbmQgPCBuZXdBbmltLm1pbGxpc2Vjb25kICYmIGV4aXN0aW5nQW5pbS5taWxsaXNlY29uZCArIHRoYXQuaW5jaWRlbnRzQnlJZC5fZ2V0KGV4aXN0aW5nQW5pbS5pZCkuZHVyYXRpb24gPiBkdXJhdGlvblRvVXNlT25DaGVja3MgKyBuZXdBbmltLm1pbGxpc2Vjb25kKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG92ZXJsYXBwaW5nQW5pbXM7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIGl0IGp1c3RzIGFkZHMgdGhlIGxhbmUgaXRlbSB0byB0aGUgbGFuZSBhbmQgYWRqdXN0cyB0aGUgaW5pdGlhbCB2YWx1ZXMgb2YgdGhlIEFuaW1zIGluIHNlcXVlbmNlXG4gICAgICAgKiBObyBjaGVja3MgYXJlIHBlcmZvcm1lZCwganVzdCBleGVjdXRpb24uXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWNpZFxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJcbiAgICAgICAqIEBwYXJhbSB7aW50fSBtaWxsaXNlY29uZFxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IGluY2lkZW50XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJhZGRFbGVtZW50VG9MYW5lXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRWxlbWVudFRvTGFuZShtY2lkLCBhdHRyLCBtaWxsaXNlY29uZCwgaW5jaWRlbnQpIHtcbiAgICAgICAgdmFyIGxhbmVLZXkgPSBnZXRMYW5lS2V5KG1jaWQsIGF0dHIpO1xuXG4gICAgICAgIHRoaXMuaW5jaWRlbnRzQnlJZC5fc2V0KGluY2lkZW50LmlkLCBpbmNpZGVudCk7XG5cbiAgICAgICAgdmFyIGxhbmVFbGVtZW50ID0ge1xuICAgICAgICAgIG1pbGxpc2Vjb25kOiBtaWxsaXNlY29uZCxcbiAgICAgICAgICBpZDogaW5jaWRlbnQuaWRcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5sYW5lRXhpc3RzKG1jaWQsIGF0dHIsIHRydWUpO1xuXG4gICAgICAgIHZhciB0aGVMYW5lID0gdGhpcy5sYW5lcy5fZ2V0KGxhbmVLZXkpO1xuXG4gICAgICAgIHRoZUxhbmUucHVzaChsYW5lRWxlbWVudCk7XG4gICAgICAgIHRoZUxhbmUgPSBsb2Rhc2hfc29ydGJ5KHRoZUxhbmUsIFsnbWlsbGlzZWNvbmQnXSk7XG5cbiAgICAgICAgdGhpcy5sYW5lcy5fc2V0KGxhbmVLZXksIHRoZUxhbmUpOyAvLyBpbmRleGluZyBzdHVmZlxuXG5cbiAgICAgICAgaWYgKCF0aGlzLmJlbG9uZ2luZ0xhbmVLZXlzQnlBbmltYXRpb25JZC5faGFzT3duUHJvcGVydHkoaW5jaWRlbnQuaWQpKSB7XG4gICAgICAgICAgdGhpcy5iZWxvbmdpbmdMYW5lS2V5c0J5QW5pbWF0aW9uSWQuX3NldChpbmNpZGVudC5pZCwgW10pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5iZWxvbmdpbmdMYW5lS2V5c0J5QW5pbWF0aW9uSWQuX2dldChpbmNpZGVudC5pZCkucHVzaChsYW5lS2V5KTsgLy8gaW5kZXhpbmdcblxuXG4gICAgICAgIHZhciBuZXdBbmltc0luZGV4ID0gbG9kYXNoX2ZpbmRpbmRleCh0aGVMYW5lLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgIHJldHVybiBpdGVtLmlkID09PSBpbmNpZGVudC5pZDtcbiAgICAgICAgfSk7IC8vIGhlbHBlci5sb2cobmV3QW5pbXNJbmRleCk7XG4gICAgICAgIC8vIHN0ZXAgMTogc2V0IHRoZSBpbnRpYWwgdmFsdWVzIG9mIHRoZSBuZXcgQW5pbWF0aW9uXG5cblxuICAgICAgICBpZiAobmV3QW5pbXNJbmRleCA9PT0gMCkge1xuICAgICAgICAgIC8vIGlmIHRoZSBuZXdseSBlbnRlcmVkIGFuaW1hdGlvbiBpcyB0aGUgZmlyc3Qgb2YgdGhlIGxhbmVcbiAgICAgICAgICBpZiAodGhlTGFuZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAvLyBhbmQgaXQgaGFzIG90aGVyIGFuaW1hdGlvbnMgdG9vXG4gICAgICAgICAgICBpbmNpZGVudC5zZXRJbml0aWFsVmFsdWUodGhpcy5pbmNpZGVudHNCeUlkLl9nZXQodGhlTGFuZVsxXS5pZCkucHVyZUluaXRpYWxWYWx1ZXMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbmNpZGVudC5zZXRJbml0aWFsVmFsdWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5jaWRlbnQuc2V0SW5pdGlhbFZhbHVlKHRoaXMuaW5jaWRlbnRzQnlJZC5fZ2V0KHRoZUxhbmVbbmV3QW5pbXNJbmRleCAtIDFdLmlkKS5hbmltYXRlZEF0dHJpYnV0ZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpZiB0aGUgYXR0cmlidXRlIG9mIHRoZSBsYW5lIGlzIGEgY29tcG8gYXR0cmlidXRlICovXG5cblxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuY29tYm9BdHRyaWJ1dGVzLCBhdHRyKSkge1xuICAgICAgICAgIHZhciBpbmNpZGVudEluaXRpYWxWYWx1ZXMgPSBpbmNpZGVudC5pbml0aWFsVmFsdWU7XG4gICAgICAgICAgc2V0SW5pdGlhbFZhbHVlKHRoZUxhbmUsIHRoaXMuaW5jaWRlbnRzQnlJZCwgaW5jaWRlbnRJbml0aWFsVmFsdWVzLCBuZXdBbmltc0luZGV4KTtcbiAgICAgICAgfSAvLyBzdGVwIDI6IHNldCB0aGUgaW5pdGFsIHZhbHVlcyBvZiB0aGUgZm9sbG93aW5nIEFuaW1hdGlvbiAoaWYgYW55KS5cblxuXG4gICAgICAgIGlmIChuZXdBbmltc0luZGV4ICsgMSA8IHRoZUxhbmUubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5pbmNpZGVudHNCeUlkLl9nZXQodGhlTGFuZVtuZXdBbmltc0luZGV4ICsgMV0uaWQpLnNldEluaXRpYWxWYWx1ZShpbmNpZGVudC5hbmltYXRlZEF0dHJpYnV0ZVZhbHVlKTtcblxuICAgICAgICAgIGlmICh0aGlzLmluY2lkZW50c0J5SWQuX2dldCh0aGVMYW5lW25ld0FuaW1zSW5kZXggKyAxXS5pZCkuZ290Q29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5pbmNpZGVudHNCeUlkLl9nZXQodGhlTGFuZVtuZXdBbmltc0luZGV4ICsgMV0uaWQpLmxhc3RXaXNoKCk7XG5cbiAgICAgICAgICAgIHRoaXMuaW5jaWRlbnRzQnlJZC5fZ2V0KHRoZUxhbmVbbmV3QW5pbXNJbmRleCArIDFdLmlkKS5vbkdldENvbnRleHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogaXQganVzdHMgdXBkYXRlcyB0aGUgbGFuZVxuICAgICAgICogTm8gY2hlY2tzIGFyZSBwZXJmb3JtZWQsIGp1c3QgZXhlY3V0aW9uXG4gICAgICAgKiBAcGFyYW0ge2FycmF5fSBhZmZlY3RlZEFuaW1hdGlvbnNJZHNcbiAgICAgICAqIEBwYXJhbSB7aW50fSBtaWxsaXNlY29uZERlbHRhXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJ1cGRhdGVMYW5lXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlTGFuZShhZmZlY3RlZEFuaW1hdGlvbnNJZHMsIG1pbGxpc2Vjb25kc0RlbHRhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgLy8gZmlyc3Qgd2UgZ3JvdXAgdGhlIGFmZmVjdGVkIGFuaW1hdGlvbnMgYnkgbGFuZXNcbiAgICAgICAgdmFyIGFmZmVjdGVkTGFuZXMgPSB7fTtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWZmZWN0ZWRBbmltYXRpb25zSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGJlbG9uZ2luZ0xhbmVzID0gdGhpcy5iZWxvbmdpbmdMYW5lS2V5c0J5QW5pbWF0aW9uSWQuX2dldChhZmZlY3RlZEFuaW1hdGlvbnNJZHNbaV0pO1xuXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBiZWxvbmdpbmdMYW5lcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIGxhbmVLZXkgPSBiZWxvbmdpbmdMYW5lc1tqXTtcblxuICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYWZmZWN0ZWRMYW5lcywgbGFuZUtleSkpIHtcbiAgICAgICAgICAgICAgYWZmZWN0ZWRMYW5lc1tsYW5lS2V5XSA9IHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zOiBbXSxcbiAgICAgICAgICAgICAgICBsYW5lOiB0aGF0LmxhbmVzLl9nZXQobGFuZUtleSksXG4gICAgICAgICAgICAgICAgbGFuZURhdGE6IGdldE1DSURhbmRBdHRyT3V0T2ZMYW5lS2V5KGJlbG9uZ2luZ0xhbmVzW2pdKVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhZmZlY3RlZExhbmVzW2xhbmVLZXldLmFuaW1hdGlvbnMucHVzaChhZmZlY3RlZEFuaW1hdGlvbnNJZHNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBmb3IgZWFjaCBvZiB0aGUgYWZmZWN0ZWQgbGFuZXNcblxuXG4gICAgICAgIGZvciAodmFyIF9sYW5lS2V5IGluIGFmZmVjdGVkTGFuZXMpIHtcbiAgICAgICAgICB2YXIgYWZmZWN0ZWRMYW5lID0gYWZmZWN0ZWRMYW5lc1tfbGFuZUtleV07XG4gICAgICAgICAgdmFyIGxhbmUgPSBhZmZlY3RlZExhbmUubGFuZTtcbiAgICAgICAgICB2YXIgbGFuZURhdGEgPSBhZmZlY3RlZExhbmUubGFuZURhdGE7XG5cbiAgICAgICAgICB2YXIgbGFuZUJlZm9yZUVkaXQgPSBsb2Rhc2hfc29ydGJ5KHRoaXMuZ2V0TGFuZXNDb3B5KGxhbmUpLCBbJ21pbGxpc2Vjb25kJ10pO1xuXG4gICAgICAgICAgdmFyIGlzQ29tYm9BdHRyID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuY29tYm9BdHRyaWJ1dGVzLCBsYW5lRGF0YS5hdHRyaWJ1dGUpOyAvLyBlZGl0IGxhbmUgaXRlbXMgbWlsbGlzZWNvbmRcblxuICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbGFuZS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgaWYgKGFmZmVjdGVkTGFuZS5hbmltYXRpb25zLmluZGV4T2YobGFuZVtrXS5pZCkgPj0gMCkge1xuICAgICAgICAgICAgICBsYW5lW2tdLm1pbGxpc2Vjb25kICs9IG1pbGxpc2Vjb25kc0RlbHRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gZW5kIGZvciBzZWFyY2hpbmcgZm9yIHRoZSBhbmltYXRpb25zIHdpdGhpbiB0aGUgbGFuZVxuXG5cbiAgICAgICAgICB2YXIgc29ydGVkTGFuZSA9IGxvZGFzaF9zb3J0YnkobGFuZSwgWydtaWxsaXNlY29uZCddKTtcblxuICAgICAgICAgIHRoaXMubGFuZXMuX3NldChfbGFuZUtleSwgc29ydGVkTGFuZSk7XG5cbiAgICAgICAgICBsYW5lID0gc29ydGVkTGFuZTtcblxuICAgICAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKF9pKSB7XG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uVG9DaGVjayA9IGFmZmVjdGVkTGFuZS5hbmltYXRpb25zW19pXTtcblxuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbkluZGV4QmVmb3JlRWRpdCA9IGxvZGFzaF9maW5kaW5kZXgobGFuZUJlZm9yZUVkaXQsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpdGVtLmlkID09PSBhbmltYXRpb25Ub0NoZWNrO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBhbmltYXRpb25JbmRleEFmdGVyRWRpdCA9IGxvZGFzaF9maW5kaW5kZXgobGFuZSwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uaWQgPT09IGFuaW1hdGlvblRvQ2hlY2s7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbiA9IF90aGlzLmluY2lkZW50c0J5SWQuX2dldChsYW5lW2FuaW1hdGlvbkluZGV4QWZ0ZXJFZGl0XS5pZCk7XG5cbiAgICAgICAgICAgIGlmIChhbmltYXRpb25JbmRleEJlZm9yZUVkaXQgIT09IGFuaW1hdGlvbkluZGV4QWZ0ZXJFZGl0IHx8IGFuaW1hdGlvbkluZGV4QWZ0ZXJFZGl0ID4gMSkge1xuICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uSW5kZXhCZWZvcmVFZGl0ICsgMSA8IGxhbmUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGFuaW1hdGlvbiB3YXMgbm90IHRoZSBsYXN0IGFuaW1hdGlvbiBvbiB0aGUgbGFuZSBiZWZvcmUgdGhlIGVkaXRcbiAgICAgICAgICAgICAgICAvLyB3ZSBzaG91bGQgdGFrZSBjYXJlIG9mIHRoZSBpbml0aWFsIHZhbHVlcyBvZiB0aGUgYW5pbWF0aW9uJ3MgcHJldmlvdXMgc3VjY2Vzc29yXG4gICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbkluZGV4QmVmb3JlRWRpdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGVkaXRlZCBhbmltYXRpb24gd2FzIHRoZSBmaXJzdCBvbmUgYmVmb3JlIHRoZSBlZGl0XG4gICAgICAgICAgICAgICAgICAvLyBwYXNzIGl0cyBpbml0aWFsIHZhbHVlcyB0byBpdHMgcHJldmlvdXMgc3VjY2Vzc29yIGFzIGl0cyBuZXcgaW5pdGlhbCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgIGlmIChpc0NvbWJvQXR0cikge1xuICAgICAgICAgICAgICAgICAgICBzZXRJbml0aWFsVmFsdWUobGFuZSwgX3RoaXMuaW5jaWRlbnRzQnlJZCwgYW5pbWF0aW9uLnB1cmVJbml0aWFsVmFsdWVzLCAwLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmluY2lkZW50c0J5SWQuX2dldChsYW5lQmVmb3JlRWRpdFsxXS5pZCkuc2V0SW5pdGlhbFZhbHVlKGFuaW1hdGlvbi5wdXJlSW5pdGlhbFZhbHVlcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaW5jaWRlbnRzQnlJZC5fZ2V0KGxhbmVCZWZvcmVFZGl0WzFdLmlkKS5vbkdldENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gZWxzZSBpZiB0aGUgZWRpdGVkIGFuaW1hdGlvbiB3YXMgbm90IHRoZSBmaXJzdCBvbmUgYmVmb3JlIHRoZSBlZGl0XG4gICAgICAgICAgICAgICAgICAvLyBtZWFuaW5nIGl0cyBwcmV2aW91cyBzdWNjZXNzb3IgaXMgbm90IHRoZSBmaXJzdCBvbmUgb24gdGhlIGxhbmUgYWZ0ZXIgdGhlIGVkaXRcbiAgICAgICAgICAgICAgICAgIC8vIGp1c3QgZ3JhYiB0aGUgdGFyZ2V0IHZhbHVlIG9mIHRoZSBuZXcgcHJldmlvdXMgYW5pbWF0aW9uIG9mIHRoZSBhbmltYXRpb24ncyBwcmV2aW91cyBzdWNjZXNzb3IgYW5kIHNldCBpdCBhcyBpbml0aWFsIHZhbHVlXG4gICAgICAgICAgICAgICAgICBpZiAoaXNDb21ib0F0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4VG9BZmZlY3QgPSBhbmltYXRpb25JbmRleEFmdGVyRWRpdCA+IGFuaW1hdGlvbkluZGV4QmVmb3JlRWRpdCA/IGFuaW1hdGlvbkluZGV4QmVmb3JlRWRpdCA6IGFuaW1hdGlvbkluZGV4QWZ0ZXJFZGl0O1xuICAgICAgICAgICAgICAgICAgICBzZXRJbml0aWFsVmFsdWUobGFuZSwgX3RoaXMuaW5jaWRlbnRzQnlJZCwgX3RoaXMuaW5jaWRlbnRzQnlJZC5fZ2V0KGxhbmVCZWZvcmVFZGl0W2FuaW1hdGlvbkluZGV4QmVmb3JlRWRpdCAtIDFdLmlkKS5hbmltYXRlZEF0dHJpYnV0ZVZhbHVlLCBpbmRleFRvQWZmZWN0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmluY2lkZW50c0J5SWQuX2dldChsYW5lQmVmb3JlRWRpdFthbmltYXRpb25JbmRleEJlZm9yZUVkaXQgKyAxXS5pZCkuc2V0SW5pdGlhbFZhbHVlKF90aGlzLmluY2lkZW50c0J5SWQuX2dldChsYW5lQmVmb3JlRWRpdFthbmltYXRpb25JbmRleEJlZm9yZUVkaXQgLSAxXS5pZCkuYW5pbWF0ZWRBdHRyaWJ1dGVWYWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaW5jaWRlbnRzQnlJZC5fZ2V0KGxhbmVCZWZvcmVFZGl0W2FuaW1hdGlvbkluZGV4QmVmb3JlRWRpdCArIDFdLmlkKS5vbkdldENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gLy8gZm9yIHRoZSBlZGl0ZWQgYW5pbWF0aW9uIGl0c2VsZiBub3c6XG5cblxuICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uSW5kZXhBZnRlckVkaXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBpcyBpdCB0aGUgZmlyc3Qgb25lIChhZnRlciBlZGl0KT9cbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIGluaXRpYWwgdmFsdWVzIG9mIHRoZSBwcmV2aW91c2x5IDAgaW5kZXhlZCBhbmltYXRpb24gb2YgdGhlIGxhbmVcbiAgICAgICAgICAgICAgICBpZiAoaXNDb21ib0F0dHIpIHtcbiAgICAgICAgICAgICAgICAgIHNldEluaXRpYWxWYWx1ZShsYW5lLCBfdGhpcy5pbmNpZGVudHNCeUlkLCBfdGhpcy5pbmNpZGVudHNCeUlkLl9nZXQobGFuZUJlZm9yZUVkaXRbMF0uaWQpLnB1cmVJbml0aWFsVmFsdWVzLCBhbmltYXRpb25JbmRleEFmdGVyRWRpdCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5zZXRJbml0aWFsVmFsdWUoX3RoaXMuaW5jaWRlbnRzQnlJZC5fZ2V0KGxhbmVCZWZvcmVFZGl0WzBdLmlkKS5wdXJlSW5pdGlhbFZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICBhbmltYXRpb24ub25HZXRDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGVsc2UgaWYgaXQgaXMgbm90IHRoZSBmaXJzdCBvbmUgYWZ0ZXIgZWRpdGRcbiAgICAgICAgICAgICAgICAvLyBqdXN0IGdyYWIgdGhlIHRhcmdldCB2YWx1ZSBvZiB0aGUgcHJldmlvdXMgYW5pbWF0aW9uIG9uIHRoZSB1cGRhdGVkIGxhbmUgYW5kIHNldCBpdCBhcyBpdHMgaW5pdGlhbCB2YWx1ZVxuICAgICAgICAgICAgICAgIGlmIChpc0NvbWJvQXR0cikge1xuICAgICAgICAgICAgICAgICAgc2V0SW5pdGlhbFZhbHVlKGxhbmUsIF90aGlzLmluY2lkZW50c0J5SWQsIF90aGlzLmluY2lkZW50c0J5SWQuX2dldChsYW5lW2FuaW1hdGlvbkluZGV4QWZ0ZXJFZGl0IC0gMV0uaWQpLmFuaW1hdGVkQXR0cmlidXRlVmFsdWUsIGFuaW1hdGlvbkluZGV4QWZ0ZXJFZGl0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLnNldEluaXRpYWxWYWx1ZShfdGhpcy5pbmNpZGVudHNCeUlkLl9nZXQobGFuZVthbmltYXRpb25JbmRleEFmdGVyRWRpdCAtIDFdLmlkKS5hbmltYXRlZEF0dHJpYnV0ZVZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5vbkdldENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gLy8gZm9yIGl0cyBuZXcgbmV4dCBhbmltYXRpb24gKGlmIGl0IGhhcyBvbmUpXG5cblxuICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uSW5kZXhBZnRlckVkaXQgKyAxIDwgbGFuZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBzZXQgaXRzIGluaXRpYWwgdmFsdWUgdG8gZXF1YWwgdGhlIHRhcmdldCB2YWx1ZSBvZiB0aGUgZWRpdGVkIGFuaW1hdGlvblxuICAgICAgICAgICAgICAgIGlmIChpc0NvbWJvQXR0cikge1xuICAgICAgICAgICAgICAgICAgc2V0SW5pdGlhbFZhbHVlKGxhbmUsIF90aGlzLmluY2lkZW50c0J5SWQsIGFuaW1hdGlvbi5hbmltYXRlZEF0dHJpYnV0ZVZhbHVlLCBhbmltYXRpb25JbmRleEFmdGVyRWRpdCArIDEsIHRydWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBfdGhpcy5pbmNpZGVudHNCeUlkLl9nZXQobGFuZVthbmltYXRpb25JbmRleEFmdGVyRWRpdCArIDFdLmlkKS5zZXRJbml0aWFsVmFsdWUoYW5pbWF0aW9uLmFuaW1hdGVkQXR0cmlidXRlVmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgICBfdGhpcy5pbmNpZGVudHNCeUlkLl9nZXQobGFuZVthbmltYXRpb25JbmRleEFmdGVyRWRpdCArIDFdLmlkKS5vbkdldENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFmZmVjdGVkTGFuZS5hbmltYXRpb25zLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgX2xvb3AoX2kpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBlbmQgZm9yIGVhY2ggb2YgdGhlIGJlbG9uZ2luZyBsYW5lcyBvZiB0aGUgYW5pbWF0aW9uXG5cbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogcmVtb3ZlcyB0aGUgbGlzdCBvZiBhbmltYXRpb25zIGFzIHByb3ZpZGVkXG4gICAgICAgKiBAcGFyYW0ge2FycmF5fSByZW1vdmVkQW5pbWF0aW9ucyAtIGFuIGFycmF5IHdpdGggdGhlIHJlbW92ZWQgYW5pbWF0aW9ucycgaWRzXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkZWxldGVBbmltYXRpb25zXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlQW5pbWF0aW9ucyhyZW1vdmVkQW5pbWF0aW9ucykge1xuICAgICAgICB2YXIgYWZmZWN0ZWRMYW5lcyA9IHt9O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVtb3ZlZEFuaW1hdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgaWQgPSByZW1vdmVkQW5pbWF0aW9uc1tpXTsgLy8gZm9yIGVhY2ggbGFuZSB0aGUgYWZmZWN0ZWQgQW5pbWF0aW9uIGFwcGVhcnMgaW5cblxuICAgICAgICAgIHZhciBiZWxvbmdpbmdMYW5lcyA9IHRoaXMuYmVsb25naW5nTGFuZUtleXNCeUFuaW1hdGlvbklkLl9nZXQoaWQpO1xuXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBiZWxvbmdpbmdMYW5lcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIGxhbmUgPSB0aGlzLmxhbmVzLl9nZXQoYmVsb25naW5nTGFuZXNbal0pO1xuXG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uSW5kZXhCZWZvcmVFZGl0ID0gLTE7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbGFuZS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICBpZiAobGFuZVtrXS5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25JbmRleEJlZm9yZUVkaXQgPSBrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIGhlbHBlci5sb2coYW5pbWF0aW9uSW5kZXhCZWZvcmVFZGl0KTtcblxuXG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uVG9EZWxldGUgPSBfb2JqZWN0U3ByZWFkMih7fSwgbGFuZVthbmltYXRpb25JbmRleEJlZm9yZUVkaXRdKTtcblxuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbk9iamVjdFRvRGVsZXRlID0gdGhpcy5pbmNpZGVudHNCeUlkLl9nZXQoYW5pbWF0aW9uVG9EZWxldGUuaWQpO1xuXG4gICAgICAgICAgICB2YXIgbGFuZURhdGEgPSBnZXRNQ0lEYW5kQXR0ck91dE9mTGFuZUtleShiZWxvbmdpbmdMYW5lc1tqXSk7IC8vIGdldHMgdGhlIGxhbmUgd2l0aG91dCB0aGUgcmVtb3ZlZCBhbmltYXRpb25cblxuICAgICAgICAgICAgdmFyIG5ld0xhbmUgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgX2sgPSAwOyBfayA8IGxhbmUubGVuZ3RoOyBfaysrKSB7XG4gICAgICAgICAgICAgIGlmIChsYW5lW19rXS5pZCAhPT0gaWQpIHtcbiAgICAgICAgICAgICAgICBuZXdMYW5lLnB1c2gobGFuZVtfa10pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMubGFuZXMuX3NldChiZWxvbmdpbmdMYW5lc1tqXSwgbmV3TGFuZSk7XG5cbiAgICAgICAgICAgIGxhbmUgPSB0aGlzLmxhbmVzLl9nZXQoYmVsb25naW5nTGFuZXNbal0pO1xuXG4gICAgICAgICAgICBpZiAobGFuZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgLy8gaW4gY2FzZSB0aGVyZSBhcmUgbm8gbW9yZSBhbmltYXRpb25zIG9uIHRoZSBsYW5lIGFueSBtb3JlIHdlIHJlc2V0XG4gICAgICAgICAgICAgIC8vIHRoZSBsYW5lIGJ5IHJ1bm5pbmcgdGhlIHByb2dyZXNzKDAsMCksIHNvIHRoYXQgdGhlIGFmZmVjdGVkIGVsZW1lbnRzXG4gICAgICAgICAgICAgIC8vIHdpbGwgZ2V0IGJhY2sgdG8gdGhlaXIgb3JpZ2luYWwgYXR0cmlidXRlIHZhbHVlXG4gICAgICAgICAgICAgIGFuaW1hdGlvbk9iamVjdFRvRGVsZXRlLm9uUHJvZ3Jlc3MoMCwgMCk7XG5cbiAgICAgICAgICAgICAgdGhpcy5sYW5lcy5fZGVsZXRlKGJlbG9uZ2luZ0xhbmVzW2pdKTtcblxuICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFmZmVjdGVkTGFuZXMsIGJlbG9uZ2luZ0xhbmVzW2pdKSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBhZmZlY3RlZExhbmVzW2JlbG9uZ2luZ0xhbmVzW2pdXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYWZmZWN0ZWRMYW5lc1tiZWxvbmdpbmdMYW5lc1tqXV0gPSBnZXRNQ0lEYW5kQXR0ck91dE9mTGFuZUtleShiZWxvbmdpbmdMYW5lc1tqXSk7XG5cbiAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbkluZGV4QmVmb3JlRWRpdCA8IGxhbmUubGVuZ3RoICYmIHRoaXMuaW5jaWRlbnRzQnlJZC5fZ2V0KGFuaW1hdGlvblRvRGVsZXRlLmlkKS5wdXJlSW5pdGlhbFZhbHVlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuY29tYm9BdHRyaWJ1dGVzLCBsYW5lRGF0YS5hdHRyaWJ1dGUpKSB7XG4gICAgICAgICAgICAgICAgICBzZXRJbml0aWFsVmFsdWUobGFuZSwgdGhpcy5pbmNpZGVudHNCeUlkLCB0aGlzLmluY2lkZW50c0J5SWQuX2dldChhbmltYXRpb25Ub0RlbGV0ZS5pZCkucHVyZUluaXRpYWxWYWx1ZXMsIGFuaW1hdGlvbkluZGV4QmVmb3JlRWRpdCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuaW5jaWRlbnRzQnlJZC5fZ2V0KGxhbmVbYW5pbWF0aW9uSW5kZXhCZWZvcmVFZGl0XS5pZCkuc2V0SW5pdGlhbFZhbHVlKHRoaXMuaW5jaWRlbnRzQnlJZC5fZ2V0KGFuaW1hdGlvblRvRGVsZXRlLmlkKS5wdXJlSW5pdGlhbFZhbHVlcyk7XG5cbiAgICAgICAgICAgICAgICAgIHRoaXMuaW5jaWRlbnRzQnlJZC5fZ2V0KGxhbmVbYW5pbWF0aW9uSW5kZXhCZWZvcmVFZGl0XS5pZCkub25HZXRDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5iZWxvbmdpbmdMYW5lS2V5c0J5QW5pbWF0aW9uSWQuX2RlbGV0ZShyZW1vdmVkQW5pbWF0aW9uc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYWZmZWN0ZWRMYW5lcztcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBtZXRob2QgaXMgcmVzcG9uc2libGUgZm9yIHJlY2FsY3VsYXRpbmcgdGhlIHNjcmF0Y2ggdmFsdWVzIG9mIHRoZSBmaXJzdFxuICAgICAgICogSW5jaWRlbnQgb2YgZWFjaCBvZiB0aGUgbGFuZXMgb2YgdGhlIExhbmVzSGFuZGxlciBhY2NvcmRpbmcgdG8gdGhlIHByb3ZpZGVkXG4gICAgICAgKiBjb250ZXh0IGlkXG4gICAgICAgKiAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInJlY2FsY1NjcmF0Y2hWYWx1ZXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWNhbGNTY3JhdGNoVmFsdWVzKGNvbnRleHRJZCkge1xuICAgICAgICB2YXIga2V5cyA9IHRoaXMubGFuZXMuX2tleXMoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICAgIHZhciB0aGVMYW5lID0gdGhpcy5sYW5lcy5fZ2V0KGtleSk7XG5cbiAgICAgICAgICBpZiAodGhlTGFuZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3RJbmNpZGVudCA9IHRoaXMuaW5jaWRlbnRzQnlJZC5fZ2V0KHRoZUxhbmVbMF0uaWQpO1xuXG4gICAgICAgICAgICB2YXIgbmV3U2NyYXRjaFZhbHVlID0gZmlyc3RJbmNpZGVudC5nZXRTY3JhdGNoVmFsdWUoY29udGV4dElkKTtcbiAgICAgICAgICAgIHZhciBsYW5lRGF0YSA9IGdldE1DSURhbmRBdHRyT3V0T2ZMYW5lS2V5KGtleSk7XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5jb21ib0F0dHJpYnV0ZXMsIGxhbmVEYXRhLmF0dHJpYnV0ZSkpIHtcbiAgICAgICAgICAgICAgLy8gaWYgaXQgaXMgYSBjb21ib1xuICAgICAgICAgICAgICBzZXRJbml0aWFsVmFsdWUodGhlTGFuZSwgdGhpcy5pbmNpZGVudHNCeUlkLCBuZXdTY3JhdGNoVmFsdWUsIDAsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gZWxzZSBpZiBpdCdzIG5vdCBhIGNvbWJvIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICBmaXJzdEluY2lkZW50LnNldEluaXRpYWxWYWx1ZShuZXdTY3JhdGNoVmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmaXJzdEluY2lkZW50Lmxhc3RXaXNoKCk7XG4gICAgICAgICAgICBmaXJzdEluY2lkZW50Lm9uR2V0Q29udGV4dCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBMYW5lc0hhbmRsZXI7XG4gIH0oKTtcblxuICB2YXIgQXR0cmlidXRlQ2hhbm5lbCA9XG4gIC8qI19fUFVSRV9fKi9cbiAgZnVuY3Rpb24gKF9DaGFubmVsKSB7XG4gICAgX2luaGVyaXRzKEF0dHJpYnV0ZUNoYW5uZWwsIF9DaGFubmVsKTtcblxuICAgIGZ1bmN0aW9uIEF0dHJpYnV0ZUNoYW5uZWwocHJvcHMpIHtcbiAgICAgIHZhciBfdGhpcztcblxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEF0dHJpYnV0ZUNoYW5uZWwpO1xuXG4gICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihBdHRyaWJ1dGVDaGFubmVsKS5jYWxsKHRoaXMsIHByb3BzKSk7XG4gICAgICAvKlxuICAgICAgICAgIGNvbWJvQXR0cmlidXRlcyBhcmUgYXR0cmlidXRlcyBvZiB0eXBlIG9iamVjdCwgaG9sZGluZyBhIG51bWJlciBvZiBvdGhlciBhdHRyaWJ1dGVzLlxuICAgICAgICAgIEUuZy4gQ1NTIFwidHJhbnNmb3JtXCIgYXR0cmlidXRlIGlzIGEgY29tYm8gdGhhdCBob2xkcyBhIG51bWJlciBvZiBvdGhlciBhdHRyaWJ1dGVzIHN1Y2ggYXM6XG4gICAgICAgICAgdHJhbnNsYXRlWCwgdHJhbnNsYXRlWSwgZXRjLiBUaGUgbGFuZXMgaGFuZGxlciBrZWVwcyBqdXN0IG9uZSBsYW5lIGZvciB0aGUgY29tYm8gYXR0cnNcbiAgICAgICAgICBpbiBhbiBvYmplY3QgZm9ybWF0IGtlZXBpbmcgdGhlIHZhbHVlIG9mIGVhY2ggYXR0cmlidXRlIGF0IGFueSBnaXZlbiBwb2ludC5cbiAgICAgICAgICBDb21ibyBhdHRyaWJ1dGVzIGFyZSBwYXNzZWQgb24gdGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBDaGFubmVsIGluIHRoZSBmb3JtYXQ6XG4gICAgICAgICAgcHJvcHMuY29tYm9BdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgIHRyYW5zaXRpb246IFsndHJhbnNsYXRlWCcsICd0cmFuc2xhdGVZJywgLi4uXSxcbiAgICAgICAgICAgICAgPHNvbWV0aGluZ19lbHNlPjogWyc8YXR0ck5hbWUxPicsICc8YXR0ck5hbWUyPicsIC4uLl1cbiAgICAgICAgICB9XG4gICAgICAgICAgKi9cblxuICAgICAgX3RoaXMuY29tYm9BdHRyaWJ1dGVzID0ge307XG4gICAgICAvKipcbiAgICAgICAqIEZvciBpbmNpZGVudHMgdGhhdCBkbyBub3QgaGF2ZSBhbmltYXRlZEF0dHJzIHRoZXJlIHNob3VsZCBiZSBvbmx5IG9uZSBsYW5lIHBlciBlbGVtZW50LlxuICAgICAgICogVGhlIGF0dHJpYnV0ZXMgQ2hhbm5lbCB3aWxsIHVzZSBhIGRlZmF1bHQgKGZha2UpLCBmaXhlZCBhdHRyaWJ1dGUgZm9yIHRoaXMgY2FzZXMgc28gaXQgYWx3YXlzIGVuZHNcbiAgICAgICAqIHVwIHdpdGgganVzdCBvbmUgbGFuZSBwZXIgZWxlbWVudDogPGVsZW1lbnRfaWQ+Xzx0aGlzLmZpeGVkQXR0cmlidXRlTmFtZT5cbiAgICAgICAqL1xuXG4gICAgICBfdGhpcy5maXhlZEF0dHJpYnV0ZU5hbWUgPSAnXyc7XG5cbiAgICAgIGlmIChwcm9wcy5jb21ib0F0dHJpYnV0ZXMgIT0gbnVsbCkge1xuICAgICAgICBfdGhpcy5jb21ib0F0dHJpYnV0ZXMgPSBwcm9wcy5jb21ib0F0dHJpYnV0ZXM7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLkxhbmVzSGFuZGxlciA9IG5ldyBMYW5lc0hhbmRsZXIoe1xuICAgICAgICBjb21ib0F0dHJpYnV0ZXM6IF90aGlzLmNvbWJvQXR0cmlidXRlcyxcbiAgICAgICAgcnVuVGltZUluZm86IF90aGlzLnJ1blRpbWVJbmZvXG4gICAgICB9KTsgLy8gdGhpcy50eXBlID0gXCJhdHRyaWJ1dGVzXCI7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoQXR0cmlidXRlQ2hhbm5lbCwgW3tcbiAgICAgIGtleTogXCJzZXRDb21ib0F0dHJpYnV0ZXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDb21ib0F0dHJpYnV0ZXMoY29tYm9BdHRyaWJ1dGVzKSB7XG4gICAgICAgIHRoaXMuY29tYm9BdHRyaWJ1dGVzID0gY29tYm9BdHRyaWJ1dGVzO1xuICAgICAgICB0aGlzLkxhbmVzSGFuZGxlciA9IG5ldyBMYW5lc0hhbmRsZXIoe1xuICAgICAgICAgIGNvbWJvQXR0cmlidXRlczogdGhpcy5jb21ib0F0dHJpYnV0ZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9yZXNpemVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzaXplKGR1cmF0aW9uRnJhY3Rpb24pIHtcbiAgICAgICAgdGhpcy5MYW5lc0hhbmRsZXIuX3Jlc2l6ZShkdXJhdGlvbkZyYWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIC8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgIERFQ0lTSU9OIE1FVEhPRFNcbiAgICAgICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuICAgICAgLyoqXG4gICAgICAgKiBBbGwgb2YgdGhlIGluY2lkZW50cyBjb21pbmcgdG8gdGhpcyBtZXRob2QgYXJlIGVsZW1lbnQtYXR0cmlidXRlIGluY2lkZW50cyBtZWFuaW5nIHRoYXQgdGhleSBvbmx5XG4gICAgICAgKiB0YXJnZXQganVzdCBvbmUgZWxlbWVudCBhbmQgYWxzbyB0aGV5IGluY2x1ZGUganVzdCBhIHNpbmdsZSBhdHRyaWJ1dGUgb24gdGhlIGluY2lkZW50LmF0dHJzLmFuaW1hdGVkQXR0cnNcbiAgICAgICAqIG9iamVjdFxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7YXJyYXl9IGluY2lkZW50cyAtIEEgY29sbGVjdGlvbiBvZiBJbmNpZGVudHMgaW4gdGhlIGZvcm06XG4gICAgICAgKiB7XG4gICAgICAgKiAgbWlsbGlzZWNvbmRcbiAgICAgICAqICBpbmNpZGVudFxuICAgICAgICogIGlkXG4gICAgICAgKiB9XG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIGNhbiBiZSBlaXRoZXIgXCJhbGwtb3Itbm90aGluZ1wiIChkZWZhdWx0KSBvciBcImtlZXAtcGFzc2luZ1wiLiBJZiB0eXBlID0gXCJhbGwtb3Itbm90aGluZ1wiXG4gICAgICAgKiAgdGhlIGFkZGl0aW9uIHBhc3NlcyBvbmx5IGlmIGFsbCBpbmNpZGVudHMgcGFzcy4gSWYgdHlwZSA9IFwia2VlcC1wYXNzaW5nXCIgdGhlIG1ldGhvZCB3aWxsIHN0aWxsIHJldHVybiB0cnVlXG4gICAgICAgKiAgYnV0IHdpbGwgYWxzbyBpbmNsdWRlIGFuIGVycm9ycyBhcnJheSBvbiBpdHMgcmV0dXJuIGFuZCBhbHNvIHdpbGwgb25seSBpbmNsdWRlIHRoZSBzdWNjZXNzIGNhbGxiYWNrcyBvblxuICAgICAgICogIHRoZSBleGVjdXRlIGtleSBvZiBpdHMgcmV0dXJuXG4gICAgICAgKiBAcmV0dXJucyBlaXRoZXI6XG4gICAgICAgKiAgIHtcbiAgICAgICAqICAgICAgIHJlc3VsdDp0cnVlLFxuICAgICAgICogICAgICAgZXhlY3V0ZTogLy8gYW4gYXJyYXkgb2YgZnVuY3Rpb25zIHRoYXQgd2hlbiBleGVjdXRlZCBpdCB3aWxsIGFkZCB0aGUgSW5jaWRlbnRzIG9uIHRoZSBDaGFubmVsc1xuICAgICAgICogICB9XG4gICAgICAgKiAgIG9yXG4gICAgICAgKiAgIHtcbiAgICAgICAqICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgKiAgICAgICBlcnJvcnNcbiAgICAgICAqICAgfVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY2hlY2tBZGRpdGlvblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrQWRkaXRpb24oaW5jaWRlbnRzKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIHZhciB0eXBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnYWxsLW9yLW5vdGhpbmcnO1xuICAgICAgICB2YXIgTGFuZXNIYW5kbGVyU2FuZGJveCA9IHRoaXMuTGFuZXNIYW5kbGVyLmNyZWF0ZVRlc3RMYW5lc1NhbmJveCgpO1xuICAgICAgICAvLyB0aGUgcGVybWFuZW50IGFuZCBwcmUtZXhpc3Rpbmcgb2JqZWN0cyBpdCBoYW5kbGVzLCBzdWNoIGFzIGNoYW5nZXMgb24gdGhlIGluaXRpYWwgdmFsdWVzIG9mIGV4aXN0aW5nIGFuaW1hdGlvbnMuXG4gICAgICAgIC8vIEJlY2F1c2Ugb2YgdGhlIGZhY3QgdGhlIExhbmVzU2FuZGJveEhhbmRsZXIgaXMgb25seSB0aGVyZSBmb3IgdGVzdGluZyB3ZSBkb24ndCB3YW50IHRvIGV4ZWN1dGUgdGhlc2UgY2hhbmdlc1xuICAgICAgICAvLyBkdXJpbmcgY2hlY2tzIGJ1dCBzdGlsbCB3ZSBuZWVkIHRvIGtub3cgdGhlbSBvbiBzdWNjZXNzLiBGb3IgdGhpcywgdGhlIG9uU3VjY2Vzc0FjdGlvbnMgYXJyYXkgaG9sZHMgYWxsIGV4ZWN1dGFibGVcbiAgICAgICAgLy8gZnVuY3Rpb25zIHJldHVyZWQgYnkgdmFyaW91cyBMYW5lc0hhbmRsZXJTYW5ib3ggZnVuY3Rpb25zIHNvIGl0IGNhbiBleGVjdXRlIHRoZW0gb24gc3VjY2Vzcy5cblxuICAgICAgICB2YXIgb25TdWNjZXNzQWN0aW9ucyA9IFtdO1xuICAgICAgICB2YXIgY29uZmxpY3RzID0gW107XG5cbiAgICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoaSkge1xuICAgICAgICAgIHZhciBpbmNpZGVudENvbmZsaWN0cyA9IGZhbHNlOyAvLyBhIGJvb2xlYW4gdGhhdCBrZWVwcyB0aGUgaW5mb3JtYXRpb24gd2hldGhlciB0aGUgaW5jaWRlbnQgY29uZmxpY3RzIG9yIG5vdFxuXG4gICAgICAgICAgdmFyIGxhbmVJdGVtID0gaW5jaWRlbnRzW2ldO1xuICAgICAgICAgIHZhciBpbmNpZGVudCA9IGxhbmVJdGVtLmluY2lkZW50O1xuICAgICAgICAgIHZhciBtY2lkID0gaW5jaWRlbnQubWNpZDtcbiAgICAgICAgICB2YXIgYXR0cmlidXRlID0gaW5jaWRlbnQuYXR0cmlidXRlIHx8IF90aGlzMi5maXhlZEF0dHJpYnV0ZU5hbWU7XG4gICAgICAgICAgTGFuZXNIYW5kbGVyU2FuZGJveC5sYW5lRXhpc3RzKG1jaWQsIGF0dHJpYnV0ZSk7IC8vIGNyZWF0ZSB0aGUgbGFuZSBpZiBpdCBkb2Vzbid0IGV4aXN0IGFscmVhZHlcblxuICAgICAgICAgIHZhciBvdmVybGFwcGluZ0FuaW1zID0gTGFuZXNIYW5kbGVyU2FuZGJveC5nZXRPdmVybGFwcGluZ0FuaW1zKGxhbmVJdGVtLCBtY2lkLCBhdHRyaWJ1dGUpOyAvLyBoZWxwZXIubG9nKG92ZXJsYXBwaW5nQW5pbSlcblxuICAgICAgICAgIGlmIChvdmVybGFwcGluZ0FuaW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGluY2lkZW50Q29uZmxpY3RzID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZsaWN0cy5wdXNoKHtcbiAgICAgICAgICAgICAgdHlwZTogJ3VuYXV0aG9yaXNlZCwgb3ZlcmxhcHBpbmcgaW5jaWRlbnRzIG9uIHRoZSBzYW1lIGVsZW1lbnQnLFxuICAgICAgICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgICAgICAgZWxlbWVudF9tY2lkOiBtY2lkLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZTogYXR0cmlidXRlLFxuICAgICAgICAgICAgICAgIGluY2lkZW50OiBsYW5lSXRlbSxcbiAgICAgICAgICAgICAgICBvdmVybGFwcGluZ0FuaW1zOiBvdmVybGFwcGluZ0FuaW1zXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghaW5jaWRlbnRDb25mbGljdHMpIHtcbiAgICAgICAgICAgIG9uU3VjY2Vzc0FjdGlvbnMucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIExhbmVzSGFuZGxlclNhbmRib3guYWRkRWxlbWVudFRvTGFuZShtY2lkLCBhdHRyaWJ1dGUsIGxhbmVJdGVtLm1pbGxpc2Vjb25kLCBpbmNpZGVudCk7XG5cbiAgICAgICAgICAgICAgaW5jaWRlbnQuX29uR2V0Q29udGV4dE9uY2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluY2lkZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIF9sb29wKGkpO1xuICAgICAgICB9IC8vIGVuZCBmb3IgZWFjaCBpbmNpZGVudFxuICAgICAgICAvLyBpZiB3ZSBoYXZlIGNvbmZsaWN0cyBhbmQgdGhlIHR5cGUgPSBcImFsbC1vci1ub3RoaW5nXCJcblxuXG4gICAgICAgIGlmIChjb25mbGljdHMubGVuZ3RoID4gMCAmJiB0eXBlID09PSAnYWxsLW9yLW5vdGhpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcnM6IGNvbmZsaWN0c1xuICAgICAgICAgIH07XG4gICAgICAgIH0gLy8gYXMgc29vbiBhcyB3ZSB3YW50IGFsbCBwYXNzaW5nIGFkZGl0aW9ucyB0byBnZXQgYXBwbGllZCB0aGUgTGFuZXMgSGFuZGxlciB3aWxsIGNyZWF0ZSBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIHJlc3VsdC5cbiAgICAgICAgLy8gVGhpcyBjYWxsYmFjayB3aWxsIGFwcGx5IGFsbCBwYXNzaW5nIGFkZGl0aW9ucy5cbiAgICAgICAgLy8gc3VjY2VzcyBtZXNzYWdlXG5cblxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGV4ZWMgPSBmdW5jdGlvbiBleGVjRnVuY3QoKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG9uU3VjY2Vzc0FjdGlvbnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBvblN1Y2Nlc3NBY3Rpb25zW19pXSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoYXQuTGFuZXNIYW5kbGVyLmFwcGx5U2FuZGJveENoYW5nZXMoTGFuZXNIYW5kbGVyU2FuZGJveCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXN1bHQ6IHRydWUsXG4gICAgICAgICAgZXJyb3JzOiBjb25mbGljdHMsXG4gICAgICAgICAgZXhlY3V0ZTogZXhlY1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgICAqIEl0IGluaXRpYWxseSBjaGVja3MgaWYgdGhlIGVkaXQgaXMgYWxsb3dlZCBhbmQgaWYgaXQgaXMgaXQgcmV0dW5zIGFuIGFycmF5IG9mIGV4ZWN1dGFibGUgZnVuY3Rpb25zXG4gICAgICAgICAqIHRoYXQgYXBwbHkgdGhlIGNoYW5nZVxuICAgICAgICAgKiBAcGFyYW0ge2FycmF5fSBpbmNpZGVudHMgLSB0aGUgbGlzdCBvZiB0aGUgbGFuZSBpdGVtcyB0byBlZGl0IGluIGFuIGFycmF5IGZvcm1hdCBbb2JqZWN0LCBvYmplY3QsIC4uLl1cbiAgICAgICAgICogQHBhcmFtIHtpbnR9IG1pbGxpc2Vjb25kc0RlbHRhIC0gdGhlIG1pbGxpc2Vjb25kcyBkZWx0YSB0byBhcHBseSB0byB0aGUgaW5jaWRlbnRzXG4gICAgICAgICAqIEByZXR1cm5zIHtvYmplY3R9IC1cbiAgICAgICAgICogZWl0aGVyOlxuICAgICAgICAge1xuICAgICAgICAgICAgcmVzdWx0OiB0cnVlLFxuICAgICAgICAgICAgZXhlY3V0ZTogLy8gYXJyYXkgb2YgZnVuY3Rpb25zIHRvIGJlIGV4ZWN1dGVkIGluIG9yZGVyIHRvIGFwcGx5IHRoZSBlZGl0XG4gICAgICAgICB9XG4gICAgICAgICBvclxuICAgICAgICAge1xuICAgICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAgICAgZXJyb3JzOiAvLyBhbiBhcnJheSBpbmNsdWRpbmcgYWxsIHRoZSBlcnJvcnMgLyBjb25mbGljdHMgZm91bmQgb24gZWRpdFxuICAgICAgICAgfVxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImNoZWNrRWRpdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrRWRpdChpbmNpZGVudHMsIG1pbGxpc2Vjb25kc0RlbHRhKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGluY2lkZW50cyk7XG4gICAgICAgIHZhciBhZmZlY3RlZEluY2lkZW50SWRzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhZmZlY3RlZEluY2lkZW50SWRzLnB1c2goaW5jaWRlbnRzW2ldLmlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBMYW5lc0hhbmRsZXJTYW5kYm94ID0gdGhpcy5MYW5lc0hhbmRsZXIuY3JlYXRlVGVzdExhbmVzU2FuYm94KCk7XG4gICAgICAgIHZhciBjb25mbGljdHMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBpbmNpZGVudHMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgIHZhciBpbmNpZGVudCA9IGluY2lkZW50c1tfaTJdLmluY2lkZW50O1xuICAgICAgICAgIHZhciBpbmNpZGVudElkID0gaW5jaWRlbnQuaWQ7XG4gICAgICAgICAgdmFyIG1jaWQgPSBpbmNpZGVudHNbX2kyXS5pbmNpZGVudC5tY2lkO1xuICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSBpbmNpZGVudHNbX2kyXS5pbmNpZGVudC5hdHRyaWJ1dGUgfHwgdGhpcy5maXhlZEF0dHJpYnV0ZU5hbWU7XG4gICAgICAgICAgdmFyIGxhbmUgPSBMYW5lc0hhbmRsZXJTYW5kYm94LmdldExhbmUobWNpZCwgYXR0cmlidXRlKTtcblxuICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbGFuZS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgaWYgKGxhbmVba10uaWQgPT09IGluY2lkZW50SWQpIHtcbiAgICAgICAgICAgICAgdmFyIGFmZmVjdGVkQW5pbSA9IGxhbmVba107XG4gICAgICAgICAgICAgIHZhciB0ZXN0TGFuZUVsZW1lbnQgPSBMYW5lc0hhbmRsZXJTYW5kYm94LmdldExhbmVFbGVtZW50c0Nsb25lKGFmZmVjdGVkQW5pbSk7XG4gICAgICAgICAgICAgIHRlc3RMYW5lRWxlbWVudC5taWxsaXNlY29uZCArPSBtaWxsaXNlY29uZHNEZWx0YTtcbiAgICAgICAgICAgICAgdGVzdExhbmVFbGVtZW50LmluY2lkZW50ID0gTGFuZXNIYW5kbGVyU2FuZGJveC5pbmNpZGVudHNCeUlkLl9nZXQodGVzdExhbmVFbGVtZW50LmlkKTtcbiAgICAgICAgICAgICAgdmFyIG92ZXJsYXBwaW5nQW5pbXMgPSBMYW5lc0hhbmRsZXJTYW5kYm94LmdldE92ZXJsYXBwaW5nQW5pbXModGVzdExhbmVFbGVtZW50LCBtY2lkLCBhdHRyaWJ1dGUsIGFmZmVjdGVkSW5jaWRlbnRJZHMpO1xuXG4gICAgICAgICAgICAgIGlmIChvdmVybGFwcGluZ0FuaW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25mbGljdHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAnYW5hdXRob3Jpc2VkLCBvdmVybGFwcGluZyBhbmltYXRpb25zIG9uIHRoZSBzYW1lIGVsZW1lbnQnLFxuICAgICAgICAgICAgICAgICAgbWV0YToge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50X21jaWQ6IG1jaWQsXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZTogYXR0cmlidXRlLFxuICAgICAgICAgICAgICAgICAgICBuZXdBbmltYXRpb246IHRlc3RMYW5lRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcHBpbmdBbmltczogb3ZlcmxhcHBpbmdBbmltc1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IC8vIGVuZCBvZiBpZiB3ZSBmb3VuZCB0aGUgc3BlY2lmaWMgYW5pbWF0aW9uIG9uIHRoZSBsYW5lJ3Mgc2VxdWVuY2VcblxuICAgICAgICAgIH0gLy8gZW5kIG9mIGVhY2ggbGFuZSdzIGl0ZW1cblxuICAgICAgICB9IC8vIGVuZCBmb3IgZWFjaCBhZmZlY3RlZCBhbmltYXRpb24ncyBpZFxuXG5cbiAgICAgICAgaWYgKGNvbmZsaWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcnM6IGNvbmZsaWN0c1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGV4ZWMgPSBmdW5jdGlvbiBleGVjRnVuY3QoKSB7XG4gICAgICAgICAgdGhhdC5MYW5lc0hhbmRsZXIudXBkYXRlTGFuZShhZmZlY3RlZEluY2lkZW50SWRzLCBtaWxsaXNlY29uZHNEZWx0YSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXN1bHQ6IHRydWUsXG4gICAgICAgICAgZXhlY3V0ZTogZXhlY1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge2FycmF5fSBpbmNpZGVudHMgLSBbe2lkLCBzdGFydCwgZW5kLCBzdGFydERlbHRhfV1cbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZnVsbENoYW5uZWxSZXNpemUgLSBpZiBzZXQgdG8gdHJ1ZSB0aGVuIHRoZSBmdWxsIGh0bWwgY2hhbm5lbCBpcyByZXNpemluZy4gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZSBhcyBpblxuICAgICAgICogIHRoYXQgY2FzZSBubyBjaGVja3Mgc2hvdWxkIGJlIGFjdHVhbGx5IHBlcmZvbWVkIG5vciB0aGUgcHJvamVjdGVkIGNhbmRpZGF0ZSBzaG91bGQgYmUgYXBwbGllZCBkaXJlY3RseVxuICAgICAgICogKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjaGVja1Jlc2l6ZWRJbmNpZGVudHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja1Jlc2l6ZWRJbmNpZGVudHMoaW5jaWRlbnRzKSB7XG4gICAgICAgIHZhciBmdWxsQ2hhbm5lbFJlc2l6ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICAgIHZhciBleGNsdWRlSWRzRnJvbUNoZWNrID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBleGNsdWRlSWRzRnJvbUNoZWNrLnB1c2goaW5jaWRlbnRzW2ldLmlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBMYW5lc0hhbmRsZXJTYW5kYm94ID0gdGhpcy5MYW5lc0hhbmRsZXIuY3JlYXRlVGVzdExhbmVzU2FuYm94KCk7XG4gICAgICAgIHZhciBjb25mbGljdHMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBpbmNpZGVudHMubGVuZ3RoOyBfaTMrKykge1xuICAgICAgICAgIC8vIGdldCB0aGUgQ29udGV4dEF3YXJlSW5jaWRlbnRcbiAgICAgICAgICB2YXIgaW5jaWRlbnQgPSB0aGlzLkxhbmVzSGFuZGxlci5pbmNpZGVudHNCeUlkLl9nZXQoaW5jaWRlbnRzW19pM10uaWQpO1xuXG4gICAgICAgICAgdmFyIG1jaWQgPSBpbmNpZGVudC5tY2lkO1xuICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSBpbmNpZGVudC5hdHRyaWJ1dGUgfHwgdGhpcy5maXhlZEF0dHJpYnV0ZU5hbWU7XG4gICAgICAgICAgdmFyIGxhbmUgPSBMYW5lc0hhbmRsZXJTYW5kYm94LmdldExhbmUobWNpZCwgYXR0cmlidXRlKTtcbiAgICAgICAgICB2YXIgbGFuZUF0dHJzID0ge1xuICAgICAgICAgICAgbWNpZDogbWNpZCxcbiAgICAgICAgICAgIGF0dHJpYnV0ZTogYXR0cmlidXRlXG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgdGVzdER1cmF0aW9uID0gaW5jaWRlbnRzW19pM10uZW5kIC0gaW5jaWRlbnRzW19pM10uc3RhcnQ7IC8vIGNoZWNrIGZvciBjb25mbGljdHMgYW5kIGVkaXQgbGFuZSBpdGVtcyBtaWxsaXNlY29uZFxuXG4gICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBsYW5lLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICBpZiAobGFuZVtrXS5pZCA9PT0gaW5jaWRlbnRzW19pM10uaWQpIHtcblxuICAgICAgICAgICAgICBpZiAoZnVsbENoYW5uZWxSZXNpemUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFmZmVjdGVkQW5pbSA9IGxhbmVba107XG4gICAgICAgICAgICAgICAgdmFyIHRlc3RMYW5lRWxlbWVudCA9IExhbmVzSGFuZGxlclNhbmRib3guZ2V0TGFuZUVsZW1lbnRzQ2xvbmUoYWZmZWN0ZWRBbmltKTtcbiAgICAgICAgICAgICAgICB0ZXN0TGFuZUVsZW1lbnQubWlsbGlzZWNvbmQgKz0gaW5jaWRlbnRzW19pM10uc3RhcnREZWx0YTtcbiAgICAgICAgICAgICAgICB0ZXN0TGFuZUVsZW1lbnQuaW5jaWRlbnQgPSBMYW5lc0hhbmRsZXJTYW5kYm94LmluY2lkZW50c0J5SWQuX2dldCh0ZXN0TGFuZUVsZW1lbnQuaWQpO1xuICAgICAgICAgICAgICAgIHZhciBvdmVybGFwcGluZ0FuaW1zID0gTGFuZXNIYW5kbGVyU2FuZGJveC5nZXRPdmVybGFwcGluZ0FuaW1zKHRlc3RMYW5lRWxlbWVudCwgbGFuZUF0dHJzLm1jaWQsIGxhbmVBdHRycy5hdHRyaWJ1dGUsIGV4Y2x1ZGVJZHNGcm9tQ2hlY2ssIHRlc3REdXJhdGlvbik7XG5cbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxhcHBpbmdBbmltcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICBjb25mbGljdHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdhbmF1dGhvcmlzZWQgb3ZlcmxhcHBpbmcgYW5pbWF0aW9ucyBvbiB0aGUgc2FtZSBlbGVtZW50JyxcbiAgICAgICAgICAgICAgICAgICAgbWV0YToge1xuICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRfbWNpZDogbGFuZUF0dHJzLm1jaWQsXG4gICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlOiBsYW5lQXR0cnMuYXR0cmlidXRlLFxuICAgICAgICAgICAgICAgICAgICAgIG5ld0FuaW1hdGlvbjogdGVzdExhbmVFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXBwaW5nQW5pbXM6IG92ZXJsYXBwaW5nQW5pbXNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IC8vIGVuZCBvZiBpZiB3ZSBmb3VuZCB0aGUgc3BlY2lmaWMgYW5pbWF0aW9uIG9uIHRoZSBsYW5lJ3Mgc2VxdWVuY2VcblxuICAgICAgICAgIH0gLy8gZW5kIG9mIGVhY2ggbGFuZSdzIGl0ZW1cblxuICAgICAgICB9IC8vIGVuZCBmb3IgZWFjaCBhZmZlY3RlZCBhbmltYXRpb24ncyBpZFxuXG5cbiAgICAgICAgaWYgKGNvbmZsaWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcnM6IGNvbmZsaWN0c1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGV4ZWMgPSBmdW5jdGlvbiBleGVjRnVuY3QoKSB7XG4gICAgICAgICAgLy8gdXBkYXRlTGFuZXMgKG9ubHkgdGhpcyB0aW1lIGFuaW1hdGlvbiBieSBhbmltYXRpb24gYXMgdGhlIG1pbGxpc2Vjb25kcyBkZWx0YSBpcyBub3Qgc3RhbmRhcmQgZm9yIGFsbClcbiAgICAgICAgICAvLyBhcyBzb29uIGFzIHRoZXJlIGFyZSBubyBjb25mbGljdHMgdGhlIExhbmVzIEhhbmRsZXIgYXBwbGllcyB0aGUgY2hhbmdlcyBiZWZvcmUgc2VuZGluZyBvdmVyIHRoZVxuICAgICAgICAgIC8vIHN1Y2Nlc3MgbWVzc2FnZVxuICAgICAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IGluY2lkZW50cy5sZW5ndGg7IF9pNCsrKSB7XG4gICAgICAgICAgICB0aGF0LkxhbmVzSGFuZGxlci51cGRhdGVMYW5lKFtpbmNpZGVudHNbX2k0XS5pZF0sIGluY2lkZW50c1tfaTRdLnN0YXJ0RGVsdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGV4ZWN1dGU6IGV4ZWMsXG4gICAgICAgICAgcmVzdWx0OiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjaGVja0RlbGV0ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrRGVsZXRlKHJlbW92ZWRBbmltYXRpb25zKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgICAgdmFyIHJlbW92ZWRBbmltYXRpb25JZHMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbW92ZWRBbmltYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgcmVtb3ZlZEFuaW1hdGlvbklkcy5wdXNoKHJlbW92ZWRBbmltYXRpb25zW2ldLmlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICB2YXIgZXhlYyA9IGZ1bmN0aW9uIGV4ZWNGdW5jdCgpIHtcbiAgICAgICAgICB0aGF0LkxhbmVzSGFuZGxlci5kZWxldGVBbmltYXRpb25zKHJlbW92ZWRBbmltYXRpb25JZHMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzdWx0OiB0cnVlLFxuICAgICAgICAgIGV4ZWN1dGU6IGV4ZWNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBtZXRob2QgaXMgcmVzcG9uc2libGUgZm9yIHJlY2FsY3VsYXRpbmcgdGhlIHNjcmF0Y2ggdmFsdWVzIG9mIHRoZSBmaXJzdFxuICAgICAgICogSW5jaWRlbnQgb2YgZWFjaCBvZiB0aGUgbGFuZXMgb2YgdGhlIExhbmVzSGFuZGxlciBhY2NvcmRpbmcgdG8gdGhlIHByb3ZpZGVkXG4gICAgICAgKiBjb250ZXh0IGlkXG4gICAgICAgKiAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInJlY2FsY1NjcmF0Y2hWYWx1ZXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWNhbGNTY3JhdGNoVmFsdWVzKGNvbnRleHRJZCkge1xuICAgICAgICB0aGlzLkxhbmVzSGFuZGxlci5yZWNhbGNTY3JhdGNoVmFsdWVzKGNvbnRleHRJZCk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFNsaXBzIHRvIGp1c3Qgb25lIGxhbmUgZm9yd2FyZHNcbiAgICAgICAqIEBwYXJhbSB7YXJyYXl9IGxhbmUgLSB0aGUgbGFuZSB0byBzbGlwIGludG9cbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBsYW5lRGF0YSAtIGFuIG9iamVjdCB3aXRoIGtleXM6IGF0dHJpYnV0ZSAmIG1jaWRcbiAgICAgICAqIEBwYXJhbSB7aW50fSBjdXJyZW50TWlsbGlzZWNvbmQgLSB0aGUgbWlsbGlzZWNvbmQgdGhlIHNsaXAgc3RhcnRzIGZyb21cbiAgICAgICAqIEBwYXJhbSB7aW50fSBtaWxsaXNlY29uZCAtIHRoZSB0YXJnZXQgbWlsbGlzZWNvbmQgb2YgdGhlIHNsaXBcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZXh0SWQgLSB0aGUgY29udGV4dElkIG9mIHRoZSBJbmNpZGVudHMgdG8gc2xpcFxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2xpcEludG9MYW5lRm9yd2FyZHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzbGlwSW50b0xhbmVGb3J3YXJkcyhsYW5lLCBsYW5lRGF0YSwgY3VycmVudE1pbGxpc2Vjb25kLCBtaWxsaXNlY29uZCwgY29udGV4dElkKSB7XG4gICAgICAgIHZhciBmb3JjZVJlc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiBmYWxzZTtcbiAgICAgICAgLy8gY29uc29sZS5sb2cobGFuZSwgY3VycmVudE1pbGxpc2Vjb25kLCBtaWxsaXNlY29uZCk7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICB2YXIgcGFydGljaXBhdGluZ0FuaW1zID0gbG9kYXNoX2ZpbHRlcihsYW5lLCBmdW5jdGlvbiAobGFuZUl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gKC8vIGl0IGVuZHMgYWZ0ZXIgY3VycmVudE1pbGxpc2Vjb25kIGFuZCBiZWZvcmUgdGFyZ2V0IG1pbGxpc2Vjb25kXG4gICAgICAgICAgICAvLyBvciBpdCBlbmRzIGFmdGVyIHRoZSB0YXJnZXQgbWlsbGlzZWNvbmQgYnV0IGFsc28gc3RhcnRzIGJlZm9yZSBpdFxuICAgICAgICAgICAgbGFuZUl0ZW0ubWlsbGlzZWNvbmQgKyB0aGF0LmluY2lkZW50c0J5SWQuX2dldChsYW5lSXRlbS5pZCkuZHVyYXRpb24gPj0gY3VycmVudE1pbGxpc2Vjb25kICYmIGxhbmVJdGVtLm1pbGxpc2Vjb25kICsgdGhhdC5pbmNpZGVudHNCeUlkLl9nZXQobGFuZUl0ZW0uaWQpLmR1cmF0aW9uIDw9IG1pbGxpc2Vjb25kIHx8IHRoYXQuaW5jaWRlbnRzQnlJZC5fZ2V0KGxhbmVJdGVtLmlkKS5kdXJhdGlvbiArIGxhbmVJdGVtLm1pbGxpc2Vjb25kID49IG1pbGxpc2Vjb25kICYmIGxhbmVJdGVtLm1pbGxpc2Vjb25kIDw9IG1pbGxpc2Vjb25kXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHBhcnRpY2lwYXRpbmdBbmltcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAvLyB0aGVyZSBhcmUgdHdvIGNhc2VzIGZvcmNlUmVzZXQgY2FuIGJlIHVzZWQ6IGEpIHdoZW4gd2UgYXJlIGZsYXNoaW5nIHRoZSBDbGlwXG4gICAgICAgICAgLy8gZ29pbmcgZnJvbSAwIHRvIG1pbGxpc2Vjb25kIHZpYSBmbGFzaCBtZXRob2Qgb2YgRXh0ZW5kYWJsZUNsaXAgb3Igd2hlblxuICAgICAgICAgIC8vIHdlIHdhbnQgdG8gc2VlayB0aGUgQ2xpcCB3aXRob3V0IGV4ZWN1dGluZyBpdCAobGlrZSBpdCB3YXMgaW4gdHJhbnNpdGlvbmFsIHN0YXRlKVxuICAgICAgICAgIC8vIHdlIGRpZmVyZW50aWF0ZSB0aGUgdHdvIGJ5IHRoZSBjdXJyZW50TWlsbGlzZWNvbmQgdmFsdWUgd2hpY2ggaW4gY2FzZSAoYSkgaXMgYWx3YXlzIDBcbiAgICAgICAgICBpZiAoZm9yY2VSZXNldCA9PT0gdHJ1ZSAmJiBjdXJyZW50TWlsbGlzZWNvbmQgPT09IDApIHtcbiAgICAgICAgICAgIHZhciBmaXJzdEluY2lkZW50ID0gdGhpcy5pbmNpZGVudHNCeUlkLl9nZXQobGFuZVswXS5pZCk7XG5cbiAgICAgICAgICAgIGZpcnN0SW5jaWRlbnQub25Qcm9ncmVzcygwLCAwLCBjb250ZXh0SWQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFydGljaXBhdGluZ0FuaW1zID0gbG9kYXNoX3NvcnRieShwYXJ0aWNpcGF0aW5nQW5pbXMsIFtmdW5jdGlvbiAobGFuZUl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gbGFuZUl0ZW0ubWlsbGlzZWNvbmQ7XG4gICAgICAgIH1dKTsgLy8gV2Ugb25seSBjYXJlIGFib3V0IHRoZSBsYXN0IChpbiBjaHJvbm9sb2dpY2FsIG9yZGVyKSBJbmNpZGVudCwgYXMgdGhpc1xuICAgICAgICAvLyB3aWxsIGRlZmluZSB0aGUgZmluYWwgdmFsdWVcblxuICAgICAgICB2YXIgbGFzdEluZGV4ID0gcGFydGljaXBhdGluZ0FuaW1zLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgdmFyIHBhcnRpY2lwYXRpbmdBbmltID0gdGhpcy5pbmNpZGVudHNCeUlkLl9nZXQocGFydGljaXBhdGluZ0FuaW1zW2xhc3RJbmRleF0uaWQpO1xuXG4gICAgICAgIHZhciBzdGFydE1pbGxpc2Vjb25kID0gcGFydGljaXBhdGluZ0FuaW1zW2xhc3RJbmRleF0ubWlsbGlzZWNvbmQ7IC8vIGlmIHRoZSBhbmltYXRpb24gZW5kcyBiZWZvcmUgdGhlIHRhcmdldCBtaWxsaXNlY29uZFxuXG4gICAgICAgIGlmIChwYXJ0aWNpcGF0aW5nQW5pbS5kdXJhdGlvbiArIHN0YXJ0TWlsbGlzZWNvbmQgPD0gbWlsbGlzZWNvbmQpIHtcbiAgICAgICAgICAvLyBhbmQgaXQncyB0aGUgbGFzdCBvbmUgb24gdGhlIHJvd1xuICAgICAgICAgIHBhcnRpY2lwYXRpbmdBbmltLm9uUHJvZ3Jlc3MoMSwgcGFydGljaXBhdGluZ0FuaW0uZHVyYXRpb24sIGNvbnRleHRJZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gc2xpcCBmb3IgdGhlIHNwZWNpZmljIGVsZW1lbnQgYW5kIHRoZSBzcGVjaWZpYyBhdHRyaWJ1dGUuIFNldCB0aGUgQW5pbWF0aW9uIGFzIHBhdXNlZCBvciBwbGF5aW5nIGFcbiAgICAgICAgICAvLyBhbmQgc3RvcmUgdGhpcyBpbmZvIHNvbWV3aGVyZVxuICAgICAgICAgIHZhciBwZXJjZW50YWdlQ29tcGxldGUgPSAobWlsbGlzZWNvbmQgLSBzdGFydE1pbGxpc2Vjb25kKSAvIHBhcnRpY2lwYXRpbmdBbmltLmR1cmF0aW9uO1xuICAgICAgICAgIHBhcnRpY2lwYXRpbmdBbmltLm9uUHJvZ3Jlc3MocGVyY2VudGFnZUNvbXBsZXRlLCBtaWxsaXNlY29uZCAtIHN0YXJ0TWlsbGlzZWNvbmQsIGNvbnRleHRJZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogU2xpcHMgdG8ganVzdCBvbmUgbGFuZSBiYWNrd2FyZHNcbiAgICAgICAqIEBwYXJhbSB7YXJyYXl9IGxhbmUgLSB0aGUgbGFuZSB0byBzbGlwIGludG9cbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBsYW5lRGF0YSAtIGFuIG9iamVjdCB3aXRoIGtleXM6IGF0dHJpYnV0ZSAmIG1jaWRcbiAgICAgICAqIEBwYXJhbSB7aW50fSBjdXJyZW50TWlsbGlzZWNvbmQgLSB0aGUgbWlsbGlzZWNvbmQgdGhlIHNsaXAgc3RhcnRzIGZyb21cbiAgICAgICAqIEBwYXJhbSB7aW50fSBtaWxsaXNlY29uZCAtIHRoZSB0YXJnZXQgbWlsbGlzZWNvbmQgb2YgdGhlIHNsaXBcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZXh0SWQgLSB0aGUgY29udGV4dElkIG9mIHRoZSBJbmNpZGVudHMgdG8gc2xpcFxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2xpcFRvTGFuZUJhY2t3YXJkc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNsaXBUb0xhbmVCYWNrd2FyZHMobGFuZSwgbGFuZURhdGEsIGN1cnJlbnRNaWxsaXNlY29uZCwgbWlsbGlzZWNvbmQsIGNvbnRleHRJZCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICAgIC8vIHdlIHRha2UgYWxsIEFuaW1hdGlvbnMgdGhhdCBhcmUgZWl0aGVyIGN1cnJlbnRseSBydW5uaW5nIG9yXG4gICAgICAgIC8vIHRoZXkgZW5kIGFmdGVyIHRoZSBkZXN0aW5hdGlvbiBwb2ludFxuICAgICAgICAvLyBoZWxwZXIubG9nKCc8LS0tLS0tJyk7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICB2YXIgcGFydGljaXBhdGluZ0FuaW1zID0gbG9kYXNoX2ZpbHRlcihsYW5lLCBmdW5jdGlvbiAobGFuZUl0ZW0pIHtcbiAgICAgICAgICB2YXIgbGFuZUl0ZW1FbmQgPSB0aGF0LmluY2lkZW50c0J5SWQuX2dldChsYW5lSXRlbS5pZCkuZHVyYXRpb24gKyBsYW5lSXRlbS5taWxsaXNlY29uZDtcbiAgICAgICAgICByZXR1cm4gbGFuZUl0ZW1FbmQgPD0gbWlsbGlzZWNvbmQgJiYgbGFuZUl0ZW1FbmQgPj0gY3VycmVudE1pbGxpc2Vjb25kIHx8IC8vIHRoZXkgZW5kIGluIHRoZSBob3QgYXJlYVxuICAgICAgICAgIGxhbmVJdGVtLm1pbGxpc2Vjb25kID49IGN1cnJlbnRNaWxsaXNlY29uZCAmJiBsYW5lSXRlbS5taWxsaXNlY29uZCA8PSBtaWxsaXNlY29uZCB8fCAvLyB0aGV5IHN0YXJ0IGluIHRoZSBob3QgYXJlYVxuICAgICAgICAgIGxhbmVJdGVtLm1pbGxpc2Vjb25kIDwgY3VycmVudE1pbGxpc2Vjb25kICYmIGxhbmVJdGVtRW5kID4gbWlsbGlzZWNvbmQ7IC8vIHRoZXkgb3ZlcmxhcCB0aGUgaG90IGFyZWFcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHBhcnRpY2lwYXRpbmdBbmltcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnRpY2lwYXRpbmdBbmltcyA9IGxvZGFzaF9zb3J0YnkocGFydGljaXBhdGluZ0FuaW1zLCBbZnVuY3Rpb24gKGxhbmVJdGVtKSB7XG4gICAgICAgICAgcmV0dXJuIGxhbmVJdGVtLm1pbGxpc2Vjb25kO1xuICAgICAgICB9XSk7IC8vIFdlIG9ubHkgY2FyZSBhYm91dCB0aGUgZmlyc3QgKGluIGNocm9ub2xvZ2ljYWwgb3JkZXIpIEluY2lkZW50LCBhcyB0aGlzXG4gICAgICAgIC8vIHdpbGwgZGVmaW5lIHRoZSBmaW5hbCB2YWx1ZSBvZiB0aGUgYmFja3dhcmRzIG1vdmVcblxuICAgICAgICB2YXIgbGFzdEluZGV4ID0gMDtcblxuICAgICAgICB2YXIgcGFydGljaXBhdGluZ0FuaW0gPSB0aGlzLmluY2lkZW50c0J5SWQuX2dldChwYXJ0aWNpcGF0aW5nQW5pbXNbbGFzdEluZGV4XS5pZCk7XG5cbiAgICAgICAgdmFyIHN0YXJ0TWlsbGlzZWNvbmQgPSBwYXJ0aWNpcGF0aW5nQW5pbXNbbGFzdEluZGV4XS5taWxsaXNlY29uZDsgLy8gaWYgdGhlIGFuaW1hdGlvbiBzdGFydHMgYWZ0ZXIgdGhlIHRhcmdldCBtaWxsaXNlY29uZFxuXG4gICAgICAgIGlmIChzdGFydE1pbGxpc2Vjb25kID49IG1pbGxpc2Vjb25kKSB7XG4gICAgICAgICAgcGFydGljaXBhdGluZ0FuaW0ub25Qcm9ncmVzcygwLCAwLCBjb250ZXh0SWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHNsaXAgZm9yIHRoZSBzcGVjaWZpYyBlbGVtZW50IGFuZCB0aGUgc3BlY2lmaWMgYXR0cmlidXRlLiBTZXQgdGhlIEFuaW1hdGlvbiBhcyBwYXVzZWQgb3IgcGxheWluZyBhXG4gICAgICAgICAgLy8gYW5kIHN0b3JlIHRoaXMgaW5mbyBzb21ld2hlcmVcbiAgICAgICAgICB2YXIgcGVyY2VudGFnZUNvbXBsZXRlID0gKG1pbGxpc2Vjb25kIC0gc3RhcnRNaWxsaXNlY29uZCkgLyBwYXJ0aWNpcGF0aW5nQW5pbS5kdXJhdGlvbjtcbiAgICAgICAgICBwYXJ0aWNpcGF0aW5nQW5pbS5vblByb2dyZXNzKHBlcmNlbnRhZ2VDb21wbGV0ZSwgbWlsbGlzZWNvbmQgLSBzdGFydE1pbGxpc2Vjb25kLCBjb250ZXh0SWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAgIEBwYXJhbSB7aW50fSBmcm9tIC0gdGhlIG1pbGxpc2Vjb25kIHRvIHN0YXJ0IGZyb21cbiAgICAgICAgIEBwYXJhbSB7aW50fSB0byAtIHRoZSBtaWxsaXNlY29uZCB0byBnbyB0b1xuICAgICAgICAgQHBhcmFtIHtzcmluZ30gY29udGV4dElkIC0gdGhlIGNvbnRleHQgaWQgdG8gXCJtb3ZlXCJcbiAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gZm9yY2VSZXNldCAtIHNldCB0byB0cnVlIGlmIHN0YXR1cyByZWNhbGMgaXMgbmVlZGVkIGFmdGVyIGVkaXRcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibW92ZVRvXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZVRvKGZyb20sIHRvLCBjb250ZXh0SWQpIHtcbiAgICAgICAgdmFyIGZvcmNlUmVzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xuXG4gICAgICAgIC8vIHN0ZXAgMTogaXRlcmF0ZSB0aHJvdWdoIGFsbCBsYW5lc1xuICAgICAgICB2YXIgbGFuZUtleXMgPSB0aGlzLmxhbmVzLl9rZXlzKCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYW5lS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBsYW5laWQgPSBsYW5lS2V5c1tpXTtcblxuICAgICAgICAgIHZhciBsYW5lID0gdGhpcy5sYW5lcy5fZ2V0KGxhbmVpZCk7XG5cbiAgICAgICAgICB2YXIgbGFuZURhdGEgPSBnZXRNQ0lEYW5kQXR0ck91dE9mTGFuZUtleShsYW5laWQpO1xuXG4gICAgICAgICAgaWYgKGZyb20gPD0gdG8pIHtcbiAgICAgICAgICAgIHRoaXMuc2xpcEludG9MYW5lRm9yd2FyZHMobGFuZSwgbGFuZURhdGEsIGZyb20sIHRvLCBjb250ZXh0SWQsIGZvcmNlUmVzZXQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZnJvbSA+IHRvKSB7XG4gICAgICAgICAgICB0aGlzLnNsaXBUb0xhbmVCYWNrd2FyZHMobGFuZSwgbGFuZURhdGEsIGZyb20sIHRvLCBjb250ZXh0SWQsIGZvcmNlUmVzZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJsYW5lc1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkxhbmVzSGFuZGxlci5sYW5lcztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaW5jaWRlbnRzQnlJZFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkxhbmVzSGFuZGxlci5pbmNpZGVudHNCeUlkO1xuICAgICAgfVxuICAgIH1dLCBbe1xuICAgICAga2V5OiBcInR5cGVcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gJ2F0dHJpYnV0ZXMnO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBBdHRyaWJ1dGVDaGFubmVsO1xuICB9KENoYW5uZWwpO1xuXG4gIHZhciBDb250ZXh0SGFuZGxlciA9XG4gIC8qI19fUFVSRV9fKi9cbiAgZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbnRleHRIYW5kbGVyKCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbnRleHRIYW5kbGVyKTtcblxuICAgICAgdGhpcy5jdXN0b21FbnRpdGllcyA9IHt9O1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhDb250ZXh0SGFuZGxlciwgW3tcbiAgICAgIGtleTogXCJnZXRFbGVtZW50QnlNQ0lEXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWxlbWVudEJ5TUNJRChtY2lkKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5jdXN0b21FbnRpdGllcywgbWNpZCkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jdXN0b21FbnRpdGllc1ttY2lkXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5lbGVtZW50c0J5TUNJRCwgbWNpZCkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50c0J5TUNJRFttY2lkXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5jb250ZXh0LnJvb3RFbGVtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5nZXRFbGVtZW50U2VsZWN0b3JCeU1DSUQobWNpZCkpO1xuICAgICAgICB0aGlzLmVsZW1lbnRzQnlNQ0lEW21jaWRdID0gZWxlbWVudDtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldEVsZW1lbnRzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWxlbWVudHMoc2VsZWN0b3IpIHtcbiAgICAgICAgaWYgKHNlbGVjdG9yLmNoYXJBdCgwKSA9PT0gJyEnKSB7XG4gICAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5zdWJzdHIoMSk7XG5cbiAgICAgICAgICBpZiAoc2VsZWN0b3IuY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy5jdXN0b21FbnRpdGllc1tzZWxlY3Rvci5zdWJzdHIoMSldXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VsZWN0b3IuY2hhckF0KDApID09PSAnLicpIHtcbiAgICAgICAgICAgIHZhciB0b1JldHVybiA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5jdXN0b21FbnRpdGllcykge1xuICAgICAgICAgICAgICB2YXIgZW50aXR5ID0gdGhpcy5jdXN0b21FbnRpdGllc1trZXldO1xuXG4gICAgICAgICAgICAgIGlmIChlbnRpdHkuY2xhc3Nlcy5pbmRleE9mKHNlbGVjdG9yLnN1YnN0cigxKSkgPiAtMSkge1xuICAgICAgICAgICAgICAgIHRvUmV0dXJuLnB1c2goZW50aXR5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdG9SZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5jb250ZXh0LnJvb3RFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0TUNJRFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1DSUQoZWxlbWVudCkge1xuICAgICAgICBpZiAoZWxlbWVudC5jdXN0b21FbnRpdHkgPT09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm4gZWxlbWVudC5pZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZShlbGVtZW50c19kYXRhX2F0dHJpYnV0ZV9uYW1lKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0TUNJRFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE1DSUQoZWxlbWVudCwgbWNpZCkge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShlbGVtZW50c19kYXRhX2F0dHJpYnV0ZV9uYW1lLCBtY2lkKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0RWxlbWVudFNlbGVjdG9yQnlNQ0lEXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWxlbWVudFNlbGVjdG9yQnlNQ0lEKG1jaWQpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmN1c3RvbUVudGl0aWVzLCBtY2lkKSkge1xuICAgICAgICAgIHJldHVybiBcIiEjXCIuY29uY2F0KG1jaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFwiW1wiLmNvbmNhdChlbGVtZW50c19kYXRhX2F0dHJpYnV0ZV9uYW1lLCBcIj1cXFwiXCIpLmNvbmNhdChtY2lkLCBcIlxcXCJdXCIpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzZXRDdXN0b21FbnRpdHlcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDdXN0b21FbnRpdHkoaWQsIGVudGl0eSkge1xuICAgICAgICB2YXIgY2xhc3NlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogW107XG5cbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmN1c3RvbUVudGl0aWVzLCBpZCkpIHtcbiAgICAgICAgICBoZWxwZXIuZXJyb3IoXCJDbGlwIFwiLmNvbmNhdCh0aGlzLmlkLCBcIiBhbHJlYWR5IGhhcyBjdXN0b20gRW50aXR5IHdpdGggaWQ6IFwiKS5jb25jYXQoaWQpKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmN1c3RvbUVudGl0aWVzW2lkXSA9IHtcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgZW50aXR5OiBlbnRpdHksXG4gICAgICAgICAgY2xhc3NlczogY2xhc3NlcyxcbiAgICAgICAgICBjdXN0b21FbnRpdHk6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIENvbnRleHRIYW5kbGVyO1xuICB9KCk7XG5cbiAgdmFyIElmcmFtZUNvbnRleHRIYW5kbGVyID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoX0NvbnRleHRIYW5kbGVyKSB7XG4gICAgX2luaGVyaXRzKElmcmFtZUNvbnRleHRIYW5kbGVyLCBfQ29udGV4dEhhbmRsZXIpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHByb3BzIC0gYW4gb2JqZWN0IHRoYXQgc2hvdWxkIGNvbnRhaW4gYWxsIG9mIHRoZSBmb2xsb3dpbmcga2V5czpcbiAgICAgKiAtIGh0bWwgKHRoZSBodG1sIHRlbXBsYXRlIHRvIHJlbmRlcilcbiAgICAgKiAtIGNzcyAodGhlIGNzcyB0ZW1wbGF0ZSBvZiB0aGUgaXNvbGF0ZWQgdHJlZSlcbiAgICAgKiAtIGluaXRQYXJhbXMgKG9wdGlvbmFsIC8gdGhlIGluaXRpYWxpc2F0aW9uIHBhcmFtZXRlcmVzIHRoYXQgd2lsbCBiZSBwYXNzZWQgYm90aCBvbiB0aGUgY3NzIGFuZCB0aGUgaHRtbCB0ZW1wbGF0ZXMgaW4gb3JkZXIgdG8gcmVuZGVyKVxuICAgICAqIC0gaG9zdCAoYW4gRWxlbWVudCBvYmplY3QgdGhhdCB3aWxsIGhvc3QgdGhlIGlzb2xhdGVkIHRyZWUpXG4gICAgICogLSBjb250YWluZXJQYXJhbXMgKGFuIG9iamVjdCB0aGF0IGhvbGRzIHBhcmFtZXRlcnMgdG8gYWZmZWN0IHRoZSBjb250YWluZXIgb2YgdGhlIGlzb2xhdGVkIHRyZWUsIGUuZy4gd2lkdGgsIGhlaWdodCBldGMpXG4gICAgICovXG4gICAgZnVuY3Rpb24gSWZyYW1lQ29udGV4dEhhbmRsZXIoKSB7XG4gICAgICB2YXIgX3RoaXM7XG5cbiAgICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJZnJhbWVDb250ZXh0SGFuZGxlcik7XG5cbiAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKElmcmFtZUNvbnRleHRIYW5kbGVyKS5jYWxsKHRoaXMpKTtcblxuICAgICAgaWYgKCFpc09iamVjdChwcm9wcykpIHtcbiAgICAgICAgaGVscGVyLmVycm9yKFwiQ29udGV4dEhhbmRsZXIgZXhwZWN0cyBhbiBvYmplY3Qgb24gaXRzIGNvbnN0cnVjdG9yLiBcIi5jb25jYXQoX3R5cGVvZihwcm9wcyksIFwiIHBhc3NlZFwiKSk7XG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgJ2h0bWwnKSkge1xuICAgICAgICBoZWxwZXIuZXJyb3IoJ0NvbnRleHRIYW5kbGVyIGV4cGVjdHMgdGhlIGh0bWwga2V5IG9uIGl0cyBjb25zdHJ1Y3RvciBwcm9wZXJ0aWVzIHdoaWNoIGlzIG1pc3NpbmcnKTtcbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAnY3NzJykpIHtcbiAgICAgICAgaGVscGVyLmVycm9yKCdDb250ZXh0SGFuZGxlciBleHBlY3RzIHRoZSBjc3Mga2V5IG9uIGl0cyBjb25zdHJ1Y3RvciBwcm9wZXJ0aWVzIHdoaWNoIGlzIG1pc3NpbmcnKTtcbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAnaW5pdFBhcmFtcycpKSB7XG4gICAgICAgIGhlbHBlci5pbmZvKCdDb250ZXh0SGFuZGxlciBnb3QgbnVsbCBpbml0UGFyYW1zJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAnaG9zdCcpKSB7XG4gICAgICAgIGhlbHBlci5lcnJvcignQ29udGV4dEhhbmRsZXIgZXhwZWN0cyB0aGUgaG9zdCBrZXkgb24gaXRzIGNvbnN0cnVjdG9yIHByb3BlcnRpZXMgd2hpY2ggaXMgbWlzc2luZycpO1xuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuaXNET00gPSB0cnVlO1xuICAgICAgdmFyIG93bmVyRG9jdW1lbnQgPSBwcm9wcy5ob3N0Lm93bmVyRG9jdW1lbnQ7XG5cbiAgICAgIGlmICghb3duZXJEb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9pZnJhbWVDb250ZXh0SGFuZGxlci9jc3MnKSkge1xuICAgICAgICB2YXIgc2VhbWxlc3NDU1MgPSBcIlxcbiAgICAgICAgICAgIGlmcmFtZVtzZWFtbGVzc117XFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICAgICAgICAgICAgICBib3JkZXI6IDBweCBub25lIHRyYW5zcGFyZW50O1xcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAwcHg7XFxuICAgICAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIFwiO1xuICAgICAgICB2YXIgaWZyYW1lc0NTUyA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgaWZyYW1lc0NTUy5pZCA9ICdAa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2lmcmFtZUNvbnRleHRIYW5kbGVyL2Nzcyc7XG4gICAgICAgIGlmcmFtZXNDU1MudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gICAgICAgIHZhciBIZWFkID0gb3duZXJEb2N1bWVudC5oZWFkIHx8IG93bmVyRG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcblxuICAgICAgICBpZiAoaWZyYW1lc0NTUy5zdHlsZVNoZWV0KSB7XG4gICAgICAgICAgaWZyYW1lc0NTUy5zdHlsZVNoZWV0LmNzc1RleHQgPSBzZWFtbGVzc0NTUztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZnJhbWVzQ1NTLmFwcGVuZENoaWxkKG93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoc2VhbWxlc3NDU1MpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIEhlYWQuYXBwZW5kQ2hpbGQoaWZyYW1lc0NTUyk7XG4gICAgICB9IC8vIENyZWF0ZSBhbiBpZnJhbWU6XG5cblxuICAgICAgdmFyIGlmcmFtZSA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICBwcm9wcy5ob3N0LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCdzZWFtbGVzcycsICdzZWFtbGVzcycpO1xuXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAnY29udGFpbmVyUGFyYW1zJykpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcy5jb250YWluZXJQYXJhbXMsICd3aWR0aCcpKSB7XG4gICAgICAgICAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBwcm9wcy5jb250YWluZXJQYXJhbXMud2lkdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcy5jb250YWluZXJQYXJhbXMsICdoZWlnaHQnKSkge1xuICAgICAgICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHByb3BzLmNvbnRhaW5lclBhcmFtcy5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9IC8vIEluaXRpYWxpc2UgdGhlIGlmcmFtZVxuXG5cbiAgICAgIGlmcmFtZS5zcmMgPSAnJzsgLy8gUHV0IGl0IGluIHRoZSBkb2N1bWVudCAoYnV0IGhpZGRlbik6XG5cbiAgICAgIHZhciBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93IHx8IGlmcmFtZS5jb250ZW50RG9jdW1lbnQ7XG5cbiAgICAgIGlmIChpZnJhbWVEb2N1bWVudC5kb2N1bWVudCkge1xuICAgICAgICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZURvY3VtZW50LmRvY3VtZW50O1xuICAgICAgfVxuXG4gICAgICBpZnJhbWVEb2N1bWVudC53cml0ZShyZW5kZXJUZW1wbGF0ZShwcm9wcy5odG1sLCB7XG4gICAgICAgIHBhcmFtczogcHJvcHMuaW5pdFBhcmFtc1xuICAgICAgfSkpO1xuICAgICAgdmFyIGJvZHlGaXhDU1MgPSBcIlxcbiAgICAgICAgYm9keXtcXG4gICAgICAgICAgICBwYWRkaW5nOjA7XFxuICAgICAgICAgICAgbWFyZ2luOjA7XFxuICAgICAgICB9XFxuICAgICAgICBcIjtcbiAgICAgIHZhciBzdHlsZVRhZyA9IGlmcmFtZURvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICBzdHlsZVRhZy50eXBlID0gJ3RleHQvY3NzJztcblxuICAgICAgaWYgKHN0eWxlVGFnLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgc3R5bGVUYWcuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVuZGVyVGVtcGxhdGUocHJvcHMuY3NzLCB7XG4gICAgICAgICAgcGFyYW1zOiBwcm9wcy5pbml0UGFyYW1zXG4gICAgICAgIH0pICsgYm9keUZpeENTUztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlVGFnLmFwcGVuZENoaWxkKG93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocHJvcHMuY3NzICsgYm9keUZpeENTUykpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaGVhZCA9IGlmcmFtZURvY3VtZW50LmhlYWQgfHwgaWZyYW1lRG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVUYWcpO1xuXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAnZm9udHMnKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmZvbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHRoZUZvbnQgPSBwcm9wcy5mb250c1tpXTtcblxuICAgICAgICAgIGlmICh0aGVGb250LnR5cGUgPT09ICdnb29nbGUtZm9udCcpIHtcbiAgICAgICAgICAgIHZhciBmb250VGFnID0gaWZyYW1lRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpO1xuICAgICAgICAgICAgZm9udFRhZy5zZXRBdHRyaWJ1dGUoJ3JlbCcsICdzdHlsZXNoZWV0Jyk7XG4gICAgICAgICAgICBmb250VGFnLnNldEF0dHJpYnV0ZSgnaHJlZicsIHRoZUZvbnQuc3JjKTtcbiAgICAgICAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoZm9udFRhZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnJvb3RFbGVtZW50ID0gaWZyYW1lO1xuICAgICAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgICAgIF90aGlzLmNvbnRleHQgPSB7XG4gICAgICAgIGRvY3VtZW50OiBpZnJhbWVEb2N1bWVudCxcbiAgICAgICAgd2luZG93OiBpZnJhbWUuY29udGVudFdpbmRvdyB8fCBpZnJhbWUsXG4gICAgICAgIGNsaXBDb250YWluZXI6IGlmcmFtZSxcbiAgICAgICAgcm9vdEVsZW1lbnQ6IGlmcmFtZURvY3VtZW50LmJvZHksXG4gICAgICAgIHVubW91bnQ6IGZ1bmN0aW9uIHVubW91bnQoKSB7XG4gICAgICAgICAgcHJvcHMuaG9zdC5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRFbGVtZW50czogX3RoaXMuZ2V0RWxlbWVudHMuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSksXG4gICAgICAgIGdldE1DSUQ6IF90aGlzLmdldE1DSUQuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSksXG4gICAgICAgIHNldE1DSUQ6IF90aGlzLnNldE1DSUQuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSksXG4gICAgICAgIGdldEVsZW1lbnRTZWxlY3RvckJ5TUNJRDogX3RoaXMuZ2V0RWxlbWVudFNlbGVjdG9yQnlNQ0lELmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLFxuICAgICAgICBnZXRFbGVtZW50QnlNQ0lEOiBfdGhpcy5nZXRFbGVtZW50QnlNQ0lELmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLFxuICAgICAgICBzZXRDdXN0b21FbnRpdHk6IF90aGlzLnNldEN1c3RvbUVudGl0eS5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKVxuICAgICAgfTtcbiAgICAgIF90aGlzLmVsZW1lbnRzQnlNQ0lEID0ge307XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIElmcmFtZUNvbnRleHRIYW5kbGVyO1xuICB9KENvbnRleHRIYW5kbGVyKTtcblxuICB2YXIgV2ViQ29tcG9uZW50Q29udGV4dEhhbmRsZXIgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uIChfQ29udGV4dEhhbmRsZXIpIHtcbiAgICBfaW5oZXJpdHMoV2ViQ29tcG9uZW50Q29udGV4dEhhbmRsZXIsIF9Db250ZXh0SGFuZGxlcik7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgLSBhbiBvYmplY3QgdGhhdCBzaG91bGQgY29udGFpbiBhbGwgb2YgdGhlIGZvbGxvd2luZyBrZXlzOlxuICAgICAqIC0gaHRtbCAodGhlIGh0bWwgdGVtcGxhdGUgdG8gcmVuZGVyKVxuICAgICAqIC0gY3NzICh0aGUgY3NzIHRlbXBsYXRlIG9mIHRoZSBpc29sYXRlZCB0cmVlKVxuICAgICAqIC0gaW5pdFBhcmFtcyAob3B0aW9uYWwgLyB0aGUgaW5pdGlhbGlzYXRpb24gcGFyYW1ldGVyZXMgdGhhdCB3aWxsIGJlIHBhc3NlZCBib3RoIG9uIHRoZSBjc3MgYW5kIHRoZSBodG1sIHRlbXBsYXRlcyBpbiBvcmRlciB0byByZW5kZXIpXG4gICAgICogLSBob3N0IChhbiBFbGVtZW50IG9iamVjdCB0aGF0IHdpbGwgaG9zdCB0aGUgaXNvbGF0ZWQgdHJlZSlcbiAgICAgKiAtIGNvbnRhaW5lclBhcmFtcyAoYW4gb2JqZWN0IHRoYXQgaG9sZHMgcGFyYW1ldGVycyB0byBhZmZlY3QgdGhlIGNvbnRhaW5lciBvZiB0aGUgaXNvbGF0ZWQgdHJlZSwgZS5nLiB3aWR0aCwgaGVpZ2h0IGV0YylcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBXZWJDb21wb25lbnRDb250ZXh0SGFuZGxlcigpIHtcbiAgICAgIHZhciBfdGhpcztcblxuICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdlYkNvbXBvbmVudENvbnRleHRIYW5kbGVyKTtcblxuICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoV2ViQ29tcG9uZW50Q29udGV4dEhhbmRsZXIpLmNhbGwodGhpcykpO1xuXG4gICAgICBpZiAoIWlzT2JqZWN0KHByb3BzKSkge1xuICAgICAgICBoZWxwZXIuZXJyb3IoXCJDb250ZXh0SGFuZGxlciBleHBlY3RzIGFuIG9iamVjdCBvbiBpdHMgY29uc3RydWN0b3IuIFwiLmNvbmNhdChfdHlwZW9mKHByb3BzKSwgXCIgcGFzc2VkXCIpKTtcbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAnaHRtbCcpKSB7XG4gICAgICAgIGhlbHBlci5lcnJvcignQ29udGV4dEhhbmRsZXIgZXhwZWN0cyB0aGUgaHRtbCBrZXkgb24gaXRzIGNvbnN0cnVjdG9yIHByb3BlcnRpZXMgd2hpY2ggaXMgbWlzc2luZycpO1xuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvcHMsICdjc3MnKSkge1xuICAgICAgICBoZWxwZXIuZXJyb3IoJ0NvbnRleHRIYW5kbGVyIGV4cGVjdHMgdGhlIGNzcyBrZXkgb24gaXRzIGNvbnN0cnVjdG9yIHByb3BlcnRpZXMgd2hpY2ggaXMgbWlzc2luZycpO1xuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvcHMsICdob3N0JykpIHtcbiAgICAgICAgaGVscGVyLmVycm9yKCdDb250ZXh0SGFuZGxlciBleHBlY3RzIHRoZSBob3N0IGtleSBvbiBpdHMgY29uc3RydWN0b3IgcHJvcGVydGllcyB3aGljaCBpcyBtaXNzaW5nJyk7XG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5pc0RPTSA9IHRydWU7XG4gICAgICB2YXIgc2hhZG93ID0gcHJvcHMuaG9zdC5hdHRhY2hTaGFkb3coe1xuICAgICAgICBtb2RlOiAnY2xvc2VkJ1xuICAgICAgfSk7XG4gICAgICB2YXIgd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAnY29udGFpbmVyUGFyYW1zJykpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcy5jb250YWluZXJQYXJhbXMsICd3aWR0aCcpKSB7XG4gICAgICAgICAgd3JhcHBlci5zdHlsZS53aWR0aCA9IHByb3BzLmNvbnRhaW5lclBhcmFtcy53aWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvcHMuY29udGFpbmVyUGFyYW1zLCAnaGVpZ2h0JykpIHtcbiAgICAgICAgICB3cmFwcGVyLnN0eWxlLmhlaWdodCA9IHByb3BzLmNvbnRhaW5lclBhcmFtcy5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgd3JhcHBlci5pbm5lckhUTUwgPSByZW5kZXJUZW1wbGF0ZShcIlwiLmNvbmNhdChwcm9wcy5odG1sLCBcIjxzbG90Pjwvc2xvdD5cIiksIHtcbiAgICAgICAgcGFyYW1zOiBwcm9wcy5pbml0UGFyYW1zXG4gICAgICB9KTtcbiAgICAgIHNoYWRvdy5hcHBlbmRDaGlsZCh3cmFwcGVyKTtcbiAgICAgIHZhciBzdHlsZVRhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICBzdHlsZVRhZy50eXBlID0gJ3RleHQvY3NzJztcblxuICAgICAgaWYgKHN0eWxlVGFnLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgc3R5bGVUYWcuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVuZGVyVGVtcGxhdGUocHJvcHMuY3NzLCB7XG4gICAgICAgICAgcGFyYW1zOiBwcm9wcy5pbml0UGFyYW1zXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGVUYWcuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocHJvcHMuY3NzKSk7XG4gICAgICB9XG5cbiAgICAgIHNoYWRvdy5hcHBlbmRDaGlsZChzdHlsZVRhZyk7XG4gICAgICBfdGhpcy5mb250VGFncyA9IFtdO1xuXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAnZm9udHMnKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmZvbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHRoZUZvbnQgPSBwcm9wcy5mb250c1tpXTtcblxuICAgICAgICAgIGlmICh0aGVGb250LnR5cGUgPT09ICdnb29nbGUtZm9udCcpIHtcbiAgICAgICAgICAgIHZhciBmb250VGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpO1xuICAgICAgICAgICAgZm9udFRhZy5zZXRBdHRyaWJ1dGUoJ3JlbCcsICdzdHlsZXNoZWV0Jyk7XG4gICAgICAgICAgICBmb250VGFnLnNldEF0dHJpYnV0ZSgnaHJlZicsIHRoZUZvbnQuc3JjKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQoZm9udFRhZyk7XG5cbiAgICAgICAgICAgIF90aGlzLmZvbnRUYWdzLnB1c2goZm9udFRhZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHdyYXBwZXIuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgIF90aGlzLnJvb3RFbGVtZW50ID0gd3JhcHBlcjtcbiAgICAgIF90aGlzLmNvbnRleHQgPSB7XG4gICAgICAgIGRvY3VtZW50OiBkb2N1bWVudCxcbiAgICAgICAgd2luZG93OiB3aW5kb3csXG4gICAgICAgIGNsaXBDb250YWluZXI6IF90aGlzLnJvb3RFbGVtZW50LFxuICAgICAgICByb290RWxlbWVudDogd3JhcHBlcixcbiAgICAgICAgdW5tb3VudDogZnVuY3Rpb24gdW5tb3VudCgpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcHJvcHMuaG9zdC5yZW1vdmVDaGlsZChzaGFkb3cpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdGhpcy5mb250VGFncy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5yZW1vdmVDaGlsZCh0aGlzLmZvbnRUYWdzW19pXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgICAgIGhlbHBlci53YXJuaW5nKCdUaGUgZWxlbWVudCBvZiB0aGUgQ2xpcCB0byBiZSByZW1vdmVkIHNlZW1zIG5vdCB0byBleGlzdCBhbnkgbW9yZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0RWxlbWVudHM6IF90aGlzLmdldEVsZW1lbnRzLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLFxuICAgICAgICBnZXRNQ0lEOiBfdGhpcy5nZXRNQ0lELmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLFxuICAgICAgICBzZXRNQ0lEOiBfdGhpcy5zZXRNQ0lELmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLFxuICAgICAgICBnZXRFbGVtZW50U2VsZWN0b3JCeU1DSUQ6IF90aGlzLmdldEVsZW1lbnRTZWxlY3RvckJ5TUNJRC5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSxcbiAgICAgICAgZ2V0RWxlbWVudEJ5TUNJRDogX3RoaXMuZ2V0RWxlbWVudEJ5TUNJRC5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSxcbiAgICAgICAgc2V0Q3VzdG9tRW50aXR5OiBfdGhpcy5zZXRDdXN0b21FbnRpdHkuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSlcbiAgICAgIH07XG4gICAgICBfdGhpcy5lbGVtZW50c0J5TUNJRCA9IHt9O1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBXZWJDb21wb25lbnRDb250ZXh0SGFuZGxlcjtcbiAgfShDb250ZXh0SGFuZGxlcik7XG5cbiAgdmFyIENsaXAkMSA9XG4gIC8qI19fUFVSRV9fKi9cbiAgZnVuY3Rpb24gKF9FeHRlbmRhYmxlQ2xpcCkge1xuICAgIF9pbmhlcml0cyhDbGlwLCBfRXh0ZW5kYWJsZUNsaXApO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHByb3BzIC0gYW4gb2JqZWN0IHRoYXQgc2hvdWxkIGNvbnRhaW4gYWxsIG9mIHRoZSBmb2xsb3dpbmcga2V5czpcbiAgICAgKiAtIGh0bWwgKHRoZSBodG1sIHRlbXBsYXRlIHRvIHJlbmRlcilcbiAgICAgKiAtIGNzcyAodGhlIGNzcyB0ZW1wbGF0ZSBvZiB0aGUgaXNvbGF0ZWQgdHJlZSlcbiAgICAgKiAtIGluaXRQYXJhbXMgKG9wdGlvbmFsIC8gdGhlIGluaXRpYWxpc2F0aW9uIHBhcmFtZXRlcmVzIHRoYXQgd2lsbCBiZSBwYXNzZWQgYm90aCBvbiB0aGUgY3NzIGFuZCB0aGUgaHRtbCB0ZW1wbGF0ZXMgaW4gb3JkZXIgdG8gcmVuZGVyKVxuICAgICAqIC0gaG9zdCAoYW4gRWxlbWVudCBvYmplY3QgdGhhdCB3aWxsIGhvc3QgdGhlIGlzb2xhdGVkIHRyZWUpXG4gICAgICogLSBjb250YWluZXJQYXJhbXMgKGFuIG9iamVjdCB0aGF0IGhvbGRzIHBhcmFtZXRlcnMgdG8gYWZmZWN0IHRoZSBjb250YWluZXIgb2YgdGhlIGlzb2xhdGVkIHRyZWUsIGUuZy4gd2lkdGgsIGhlaWdodCBldGMpXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ2xpcCgpIHtcbiAgICAgIHZhciBfdGhpcztcblxuICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgIHZhciBvbGRQcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcblxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENsaXApO1xuXG4gICAgICB2YXIgYXR0cnNUb1Bhc3M7XG4gICAgICB2YXIgcHJvcHNUb1VzZTtcbiAgICAgIC8qXG4gICAgICAgICAgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIElmIHRoZSB1c2VyIGRvZXNuJ3QgcGFzcyBhIHNlY29uZCBhcmd1bWVudCBvbiB0aGUgY29uc3RydWN0b3IgdGhlbiB0aGlzIGlzXG4gICAgICAgICAgdGhlIG5ldyB3YXkgb2YgaW5pdGlhbGlzaW5nIGEgR3JvdXAgKG9ubHkgcHJvcHMpLlxuICAgICAgICAgICovXG5cbiAgICAgIGlmIChvbGRQcm9wcyA9PT0gbnVsbCkge1xuICAgICAgICBhdHRyc1RvUGFzcyA9IHt9O1xuICAgICAgICBwcm9wc1RvVXNlID0gcHJvcHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBlbHNlLCBpbiBjYXNlIHRoZSB1c2VyIGhhcyBwYXNzZWQgdHdvIGFyZ3VtZW50cyB0aGVuIGJvdGggc2hvdWxkIGJlIHVzZWRcbiAgICAgICAgYXR0cnNUb1Bhc3MgPSBwcm9wcztcbiAgICAgICAgcHJvcHNUb1VzZSA9IG9sZFByb3BzO1xuICAgICAgfVxuXG4gICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihDbGlwKS5jYWxsKHRoaXMsIGF0dHJzVG9QYXNzLCBwcm9wc1RvVXNlKSk7XG4gICAgICBwcm9wc1RvVXNlID0gX29iamVjdFNwcmVhZDIoe30sIHByb3BzVG9Vc2UsIHtcbiAgICAgICAgaHRtbDogX3RoaXMuaHRtbCAhPT0gJycgPyBfdGhpcy5odG1sIDogcHJvcHNUb1VzZS5odG1sLFxuICAgICAgICBjc3M6IF90aGlzLmNzcyAhPT0gJycgPyBfdGhpcy5jc3MgOiBwcm9wc1RvVXNlLmNzcyxcbiAgICAgICAgZm9udHM6IF90aGlzLmZvbnRzLmxlbmd0aCA+IDAgPyBfdGhpcy5mb250cyA6IHByb3BzVG9Vc2UuZm9udHNcbiAgICAgIH0pOyAvLyB0aGF0IG1lYW5zIHRoZSBDbGlwIGlzIGhvc3RlZCBvciwgaW4gb3RoZXIgd29yZHMgYSBob3N0IGhhcyBiZWVuXG4gICAgICAvLyBwcm92aWRlZCBvbiB0aGUgcHJvcHMgKGFuZCBub3QgYSBzZWxlY3RvcilcbiAgICAgIC8vIHRoaXMuaXNIb3N0ZWRDbGlwID0gdHJ1ZTtcblxuICAgICAgdmFyIGNsaXBUeXBlID0gc2VsZkNvbnRhaW5lZENvbnRleHRIYW5kbGVyO1xuICAgICAgX3RoaXMuY2xpcFR5cGUgPSBjbGlwVHlwZTtcbiAgICAgIHZhciBDb250ZXh0SGFubGRlciA9IG51bGw7XG5cbiAgICAgIGlmIChkb2N1bWVudC5oZWFkLmNyZWF0ZVNoYWRvd1Jvb3QgfHwgZG9jdW1lbnQuaGVhZC5hdHRhY2hTaGFkb3cpIHtcbiAgICAgICAgQ29udGV4dEhhbmxkZXIgPSBXZWJDb21wb25lbnRDb250ZXh0SGFuZGxlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIENvbnRleHRIYW5sZGVyID0gSWZyYW1lQ29udGV4dEhhbmRsZXI7XG4gICAgICB9IC8vIGNvbnNvbGUubG9nKGB0aGlzLmlkOiAke3RoaXMuaWR9LCBDbGFzczogJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9LCB0aGlzLmh0bWw6ICR7dGhpcy5odG1sfWApXG5cblxuICAgICAgdmFyIGNvbnRleHRIYW5sZGVyID0gbmV3IENvbnRleHRIYW5sZGVyKHByb3BzVG9Vc2UpO1xuICAgICAgX3RoaXMub3duQ29udGV4dCA9IF9vYmplY3RTcHJlYWQyKHt9LCBjb250ZXh0SGFubGRlci5jb250ZXh0LCB7XG4gICAgICAgIGlzSG9zdGVkQ2xpcDogX3RoaXMuaXNIb3N0ZWRDbGlwXG4gICAgICB9KTtcbiAgICAgIF90aGlzLmlmcmFtZSA9IGNvbnRleHRIYW5sZGVyLmlmcmFtZUVsZW1lbnQ7XG4gICAgICBfdGhpcy5mb3JjZUV4cG9ydEluY2lkZW50cyA9IHRydWU7XG5cbiAgICAgIF90aGlzLm9uQWZ0ZXJSZW5kZXIoKTtcblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhDbGlwLCBbe1xuICAgICAga2V5OiBcIm9uQWZ0ZXJSZW5kZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkFmdGVyUmVuZGVyKCkgey8vIGltcGxlbWVudCBoZXJlXG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImV4cG9ydENvbnN0cnVjdGlvbkFyZ3VtZW50c1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGV4cG9ydENvbnN0cnVjdGlvbkFyZ3VtZW50cygpIHtcbiAgICAgICAgLy8gVE9ETyBhbHNvIGV4cG9ydCBDU1MgYW5kIGZvbnRzIHRha2luZyBpbiBhY2NvdW50IHRoZSBwb3RlbnRpYWwgZXhpc3RhbmNlXG4gICAgICAgIC8vIG9mIHRoZW0gb24gdGhlIGdldCBtZXRob2RzXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYXR0cnM6IHRoaXMuYXR0cnMsXG4gICAgICAgICAgcHJvcHM6IF9vYmplY3RTcHJlYWQyKHt9LCB0aGlzLnByb3BzLCB7XG4gICAgICAgICAgICBob3N0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBodG1sOiB0aGlzLm93bkNvbnRleHQucm9vdEVsZW1lbnQuaW5uZXJIVE1MXG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0Q3VzdG9tRW50aXR5XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q3VzdG9tRW50aXR5KGlkLCBlbnRpdHkpIHtcbiAgICAgICAgdmFyIGNsYXNzZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFtdO1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LnNldEN1c3RvbUVudGl0eShpZCwgZW50aXR5LCBjbGFzc2VzKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaHRtbFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY3NzXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJmb250c1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicm9vdEVsZW1lbnRcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vd25Db250ZXh0LmNsaXBDb250YWluZXI7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIENsaXA7XG4gIH0oRXh0ZW5kYWJsZUNsaXApO1xuXG4gIHZhciBIVE1MRnJhZ21lbnRDb250ZXh0SGFuZGxlciA9XG4gIC8qI19fUFVSRV9fKi9cbiAgZnVuY3Rpb24gKF9Db250ZXh0SGFuZGxlcikge1xuICAgIF9pbmhlcml0cyhIVE1MRnJhZ21lbnRDb250ZXh0SGFuZGxlciwgX0NvbnRleHRIYW5kbGVyKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcyAtIGFuIG9iamVjdCB0aGF0IHNob3VsZCBjb250YWluIGFsbCBvZiB0aGUgZm9sbG93aW5nIGtleXM6XG4gICAgICogLSBodG1sICh0aGUgaHRtbCB0ZW1wbGF0ZSB0byByZW5kZXIpXG4gICAgICogLSBjc3MgKHRoZSBjc3MgdGVtcGxhdGUgb2YgdGhlIGlzb2xhdGVkIHRyZWUpXG4gICAgICogLSBpbml0UGFyYW1zIChvcHRpb25hbCAvIHRoZSBpbml0aWFsaXNhdGlvbiBwYXJhbWV0ZXJlcyB0aGF0IHdpbGwgYmUgcGFzc2VkIGJvdGggb24gdGhlIGNzcyBhbmQgdGhlIGh0bWwgdGVtcGxhdGVzIGluIG9yZGVyIHRvIHJlbmRlcilcbiAgICAgKiAtIGhvc3QgKGFuIEVsZW1lbnQgb2JqZWN0IHRoYXQgd2lsbCBob3N0IHRoZSBpc29sYXRlZCB0cmVlKVxuICAgICAqIC0gY29udGFpbmVyUGFyYW1zIChhbiBvYmplY3QgdGhhdCBob2xkcyBwYXJhbWV0ZXJzIHRvIGFmZmVjdCB0aGUgY29udGFpbmVyIG9mIHRoZSBpc29sYXRlZCB0cmVlLCBlLmcuIHdpZHRoLCBoZWlnaHQgZXRjKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEhUTUxGcmFnbWVudENvbnRleHRIYW5kbGVyKCkge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICB2YXIgb3JpZ2luYWxQcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIVE1MRnJhZ21lbnRDb250ZXh0SGFuZGxlcik7XG5cbiAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEhUTUxGcmFnbWVudENvbnRleHRIYW5kbGVyKS5jYWxsKHRoaXMpKTtcblxuICAgICAgdmFyIHByb3BzID0gX29iamVjdFNwcmVhZDIoe30sIG9yaWdpbmFsUHJvcHMpO1xuXG4gICAgICBpZiAoIWlzT2JqZWN0KHByb3BzKSkge1xuICAgICAgICBoZWxwZXIuZXJyb3IoXCJIVE1MRnJhZ21lbnRDb250ZXh0SGFuZGxlciBleHBlY3RzIGFuIG9iamVjdCBvbiBpdHMgY29uc3RydWN0b3IuIFwiLmNvbmNhdChfdHlwZW9mKHByb3BzKSwgXCIgcGFzc2VkXCIpKTtcbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAnaHRtbCcpKSB7XG4gICAgICAgIHByb3BzLmh0bWwgPSAnJztcbiAgICAgIH1cblxuICAgICAgX3RoaXMuaXNET00gPSB0cnVlO1xuICAgICAgdmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgdmFyIHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgJ2NvbnRhaW5lclBhcmFtcycpKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvcHMsICd3aWR0aCcpKSB7XG4gICAgICAgICAgd3JhcHBlci5zdHlsZS53aWR0aCA9IHByb3BzLmNvbnRhaW5lclBhcmFtcy53aWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvcHMsICdoZWlnaHQnKSkge1xuICAgICAgICAgIHdyYXBwZXIuc3R5bGUuaGVpZ2h0ID0gcHJvcHMuY29udGFpbmVyUGFyYW1zLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB3cmFwcGVyLmlubmVySFRNTCA9IHJlbmRlclRlbXBsYXRlKHByb3BzLmh0bWwsIHtcbiAgICAgICAgcGFyYW1zOiBwcm9wcy5pbml0UGFyYW1zXG4gICAgICB9KTtcbiAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKHdyYXBwZXIpO1xuICAgICAgd3JhcHBlci5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgX3RoaXMucm9vdEVsZW1lbnQgPSB3cmFwcGVyO1xuICAgICAgLyogVE9ETyBtYWtlIHRoZSBjb250ZXh0IGRlZmluaXRpb24gbW9yZSBnZW5lcmljIHNvIGFsd2F5cyB0aGUgc2V0Q3VzdG9tRW50aXR5IGdldHMgc2V0XG4gICAgICAgICAgYWxvbmcgd2l0aCB0aGUgcmVzdCBvZiB0aGUgcmVxdWlyZWQgbWV0aG9kcywgc28gaXQgY2FuIGJlIHVzZWQgb24gdGhlIGFmdGVyUmVuZGVyIG1ldGhvZFxuICAgICAgICAgIG9mIHRoZSBET01DbGlwLlxuICAgICAgICAgIFRoZSBDbGlwIHdpbGwgZXhwb3NlIGEgbWV0aG9kIFwic2V0Q3VzdG9tRW50aXR5XCIgdGhhdCB3aWxsIHNldCBjdXN0b20gZW50aXRpZXMuXG4gICAgICAgICAgVEVTVFxuICAgICAgICAgICovXG5cbiAgICAgIF90aGlzLmNvbnRleHQgPSB7XG4gICAgICAgIGRvY3VtZW50OiBkb2N1bWVudCxcbiAgICAgICAgd2luZG93OiB3aW5kb3csXG4gICAgICAgIGNsaXBDb250YWluZXI6IF90aGlzLnJvb3RFbGVtZW50LFxuICAgICAgICByb290RWxlbWVudDogd3JhcHBlcixcbiAgICAgICAgdW5tb3VudDogZnVuY3Rpb24gdW5tb3VudCgpIHtcbiAgICAgICAgICBwcm9wcy5ob3N0LnJlbW92ZUNoaWxkKGZyYWdtZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0RWxlbWVudHM6IF90aGlzLmdldEVsZW1lbnRzLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLFxuICAgICAgICBnZXRNQ0lEOiBfdGhpcy5nZXRNQ0lELmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLFxuICAgICAgICBzZXRNQ0lEOiBfdGhpcy5zZXRNQ0lELmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLFxuICAgICAgICBnZXRFbGVtZW50U2VsZWN0b3JCeU1DSUQ6IF90aGlzLmdldEVsZW1lbnRTZWxlY3RvckJ5TUNJRC5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSxcbiAgICAgICAgZ2V0RWxlbWVudEJ5TUNJRDogX3RoaXMuZ2V0RWxlbWVudEJ5TUNJRC5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSxcbiAgICAgICAgc2V0Q3VzdG9tRW50aXR5OiBfdGhpcy5zZXRDdXN0b21FbnRpdHkuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSksXG4gICAgICAgIGZyYWdtZW50OiB0cnVlXG4gICAgICB9O1xuICAgICAgX3RoaXMuZWxlbWVudHNCeU1DSUQgPSB7fTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gSFRNTEZyYWdtZW50Q29udGV4dEhhbmRsZXI7XG4gIH0oQ29udGV4dEhhbmRsZXIpO1xuXG4gIHZhciBGcmFnbWVudGVkQ2xpcCA9XG4gIC8qI19fUFVSRV9fKi9cbiAgZnVuY3Rpb24gKF9FeHRlbmRhYmxlQ2xpcCkge1xuICAgIF9pbmhlcml0cyhGcmFnbWVudGVkQ2xpcCwgX0V4dGVuZGFibGVDbGlwKTtcblxuICAgIGZ1bmN0aW9uIEZyYWdtZW50ZWRDbGlwKCkge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgdmFyIG9sZFByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRnJhZ21lbnRlZENsaXApO1xuXG4gICAgICB2YXIgYXR0cnNUb1Bhc3M7XG4gICAgICB2YXIgcHJvcHNUb1VzZTtcbiAgICAgIC8qXG4gICAgICAgICAgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIElmIHRoZSB1c2VyIGRvZXNuJ3QgcGFzcyBhIHNlY29uZCBhcmd1bWVudCBvbiB0aGUgY29uc3RydWN0b3IgdGhlbiB0aGlzIGlzXG4gICAgICAgICAgdGhlIG5ldyB3YXkgb2YgaW5pdGlhbGlzaW5nIGEgR3JvdXAgKG9ubHkgcHJvcHMpLlxuICAgICAgICAgICovXG5cbiAgICAgIGlmIChvbGRQcm9wcyA9PT0gbnVsbCkge1xuICAgICAgICBhdHRyc1RvUGFzcyA9IHt9O1xuICAgICAgICBwcm9wc1RvVXNlID0gcHJvcHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBlbHNlLCBpbiBjYXNlIHRoZSB1c2VyIGhhcyBwYXNzZWQgdHdvIGFyZ3VtZW50cyB0aGVuIGJvdGggc2hvdWxkIGJlIHVzZWRcbiAgICAgICAgYXR0cnNUb1Bhc3MgPSBwcm9wcztcbiAgICAgICAgcHJvcHNUb1VzZSA9IG9sZFByb3BzO1xuICAgICAgfVxuXG4gICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihGcmFnbWVudGVkQ2xpcCkuY2FsbCh0aGlzLCBhdHRyc1RvUGFzcywgcHJvcHNUb1VzZSkpO1xuICAgICAgdmFyIGNvbnRleHRIYW5sZGVyID0gbmV3IEhUTUxGcmFnbWVudENvbnRleHRIYW5kbGVyKF9vYmplY3RTcHJlYWQyKHt9LCBwcm9wc1RvVXNlLCB7XG4gICAgICAgIGh0bWw6IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm9wc1RvVXNlLCAnaHRtbCcpID8gcHJvcHNUb1VzZS5odG1sIDogX3RoaXMuaHRtbCxcbiAgICAgICAgY3NzOiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvcHNUb1VzZSwgJ2NzcycpID8gcHJvcHNUb1VzZS5jc3MgOiBfdGhpcy5jc3MsXG4gICAgICAgIGZvbnRzOiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvcHNUb1VzZSwgJ2ZvbnRzJykgPyBwcm9wc1RvVXNlLmZvbnRzIDogX3RoaXMuZm9udHNcbiAgICAgIH0pKTtcbiAgICAgIF90aGlzLm93bkNvbnRleHQgPSBfb2JqZWN0U3ByZWFkMih7fSwgY29udGV4dEhhbmxkZXIuY29udGV4dCwge1xuICAgICAgICBpc0hvc3RlZENsaXA6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIF90aGlzLmlmcmFtZSA9IGNvbnRleHRIYW5sZGVyLmlmcmFtZUVsZW1lbnQ7XG4gICAgICBfdGhpcy5mb3JjZUV4cG9ydEluY2lkZW50cyA9IHRydWU7XG5cbiAgICAgIF90aGlzLm9uRE9NQ0xpcEluaXRpYWxpc2UoKTsgLy8gYXMgc29vbiBhcyBhIEZyYWdtZW50ZWQgQ2xpcCBpcyBiZWVuIGludGlhbGlzZWQgdGhhdCBtZWFucyB0aGUgRGVzY3JpcHRpdmVcbiAgICAgIC8vIENsaXAgaGFzIGEgc2VsZWN0b3IgYW5kIG5vdCBhIGhvc3QuIFRodXMgaXMgbm90IGEgaG9zdGVkIGNsaXBcbiAgICAgIC8vIHRoaXMuaXNIb3N0ZWRDbGlwID0gZmFsc2U7XG5cblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhGcmFnbWVudGVkQ2xpcCwgW3tcbiAgICAgIGtleTogXCJleHBvcnRDb25zdHJ1Y3Rpb25Bcmd1bWVudHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBleHBvcnRDb25zdHJ1Y3Rpb25Bcmd1bWVudHMoKSB7XG4gICAgICAgIC8vIFRPRE8gYWxzbyBleHBvcnQgQ1NTIGFuZCBmb250cyB0YWtpbmcgaW4gYWNjb3VudCB0aGUgcG90ZW50aWFsIGV4aXN0YW5jZVxuICAgICAgICAvLyBvZiB0aGVtIG9uIHRoZSBnZXQgbWV0aG9kc1xuICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLm93bkNvbnRleHQucm9vdEVsZW1lbnQuaW5uZXJIVE1MKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhdHRyczogdGhpcy5hdHRycyxcbiAgICAgICAgICBwcm9wczogX29iamVjdFNwcmVhZDIoe30sIHRoaXMucHJvcHMsIHtcbiAgICAgICAgICAgIGh0bWw6IHRoaXMub3duQ29udGV4dC5yb290RWxlbWVudC5pbm5lckhUTUxcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJvbkRPTUNMaXBJbml0aWFsaXNlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gb25ET01DTGlwSW5pdGlhbGlzZSgpIHsvLyBpbXBsZW1lbnQgaGVyZVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyb290RWxlbWVudFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm93bkNvbnRleHQuY2xpcENvbnRhaW5lcjtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gRnJhZ21lbnRlZENsaXA7XG4gIH0oRXh0ZW5kYWJsZUNsaXApO1xuXG4gIHZhciBOdWxsQ2xpcCA9XG4gIC8qI19fUFVSRV9fKi9cbiAgZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE51bGxDbGlwKCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE51bGxDbGlwKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoTnVsbENsaXAsIFt7XG4gICAgICBrZXk6IFwiYWRkSW5jaWRlbnRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRJbmNpZGVudCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXN1bHQ6IHRydWUsXG4gICAgICAgICAgZXhlY3V0ZTogZnVuY3Rpb24gZXhlY3V0ZSgpIHt9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIm1vdmVJbmNpZGVudFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmVJbmNpZGVudCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXN1bHQ6IHRydWUsXG4gICAgICAgICAgZXhlY3V0ZTogZnVuY3Rpb24gZXhlY3V0ZSgpIHt9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInJlbW92ZUluY2lkZW50XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlSW5jaWRlbnQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzdWx0OiB0cnVlLFxuICAgICAgICAgIGV4ZWN1dGU6IGZ1bmN0aW9uIGV4ZWN1dGUoKSB7fVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZXNpemVJbmNpZGVudFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZUluY2lkZW50KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc3VsdDogdHJ1ZSxcbiAgICAgICAgICBleGVjdXRlOiBmdW5jdGlvbiBleGVjdXRlKCkge31cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0SW5jaWRlbnRzQnlDaGFubmVsXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5jaWRlbnRzQnlDaGFubmVsKCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImZsYXNoXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZmxhc2goKSB7fVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfcmVzaXplXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc2l6ZSgpIHt9XG4gICAgfSwge1xuICAgICAga2V5OiBcIm9uUHJvZ3Jlc3NcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBvblByb2dyZXNzKCkge31cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZHVyYXRpb25cIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gTnVsbENsaXA7XG4gIH0oKTtcblxuICB2YXIgZWFzaW5nUnVsZSA9IFt7XG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgb3B0aW9uYWw6IHRydWUsXG4gICAgZGVmYXVsdDogJ2xpbmVhcicsXG4gICAgZW51bTogWydsaW5lYXInLCAnZWFzZUluUXVhZCcsICdlYXNlT3V0UXVhZCcsICdlYXNlSW5PdXRRdWFkJywgJ2Vhc2VJbkN1YmljJywgJ2Vhc2VPdXRDdWJpYycsICdlYXNlSW5PdXRDdWJpYycsICdlYXNlSW5RdWFydCcsICdlYXNlT3V0UXVhcnQnLCAnZWFzZUluT3V0UXVhcnQnLCAnZWFzZUluUXVpbnQnLCAnZWFzZU91dFF1aW50JywgJ2Vhc2VJbk91dFF1aW50JywgJ2Vhc2VJblNpbmUnLCAnZWFzZU91dFNpbmUnLCAnZWFzZUluT3V0U2luZScsICdlYXNlSW5FeHBvJywgJ2Vhc2VPdXRFeHBvJywgJ2Vhc2VJbk91dEV4cG8nLCAnZWFzZUluQ2lyYycsICdlYXNlT3V0Q2lyYycsICdlYXNlSW5PdXRDaXJjJywgJ2Vhc2VJbkVsYXN0aWMnLCAnZWFzZU91dEVsYXN0aWMnLCAnZWFzZUluT3V0RWxhc3RpYycsICdlYXNlSW5CYWNrJywgJ2Vhc2VPdXRCYWNrJywgJ2Vhc2VJbk91dEJhY2snLCAnZWFzZUluQm91bmNlJywgJ2Vhc2VPdXRCb3VuY2UnLCAnZWFzZUluT3V0Qm91bmNlJ11cbiAgfSwge1xuICAgIHR5cGU6ICdhcnJheScsXG4gICAgb3B0aW9uYWw6IHRydWUsXG4gICAgbGVuZ3RoOiA0LFxuICAgIGl0ZW1zOiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJ1xuICAgIH1cbiAgfV07XG4gIHZhciBpZFJ1bGUgPSB7XG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfTtcbiAgdmFyIHNlbGVjdG9yUnVsZSA9IHtcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICBvcHRpb25hbDogZmFsc2VcbiAgfTtcbiAgdmFyIGhvc3RSdWxlID0ge1xuICAgIHR5cGU6ICdhbnknLFxuICAgIG9wdGlvbmFsOiBmYWxzZVxuICB9O1xuICB2YXIgZHVyYXRpb25SdWxlID0ge1xuICAgIHR5cGU6ICdudW1iZXInLFxuICAgIG9wdGlvbmFsOiBmYWxzZSxcbiAgICBpbnRlZ2VyOiB0cnVlLFxuICAgIHBvc2l0aXZlOiB0cnVlXG4gIH07XG4gIHZhciBvcHRpb25hbFN0cmluZ1J1bGUgPSB7XG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfTtcbiAgdmFyIGZvbnRzUnVsZSA9IHtcbiAgICB0eXBlOiAnYXJyYXknLFxuICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgIGl0YW1zOiB7XG4gICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICB1cmw6ICdzdHJpbmcnXG4gICAgICB9XG4gICAgfVxuICB9O1xuICB2YXIgYXVkaW9Tb3VyY2VzUnVsZSA9IHtcbiAgICB0eXBlOiAnYXJyYXknLFxuICAgIGl0ZW1zOiB7XG4gICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgIHN0cmljdDogdHJ1ZSxcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIHNyYzogJ3N0cmluZycsXG4gICAgICAgIGlkOiAnc3RyaW5nJyxcbiAgICAgICAgbWNpZDoge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIGNsYXNzZXM6IHtcbiAgICAgICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICAgIGl0ZW1zOiAnc3RyaW5nJ1xuICAgICAgICB9LFxuICAgICAgICBiYXNlNjQ6IHtcbiAgICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfTtcbiAgdmFyIGluY2lkZW50UHJvcHNSdWxlID0ge1xuICAgIHByb3BzOiB7XG4gICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGlkOiBpZFJ1bGUsXG4gICAgICAgIHNlbGVjdG9yOiBfb2JqZWN0U3ByZWFkMih7fSwgc2VsZWN0b3JSdWxlLCB7XG4gICAgICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICAgICAgfSksXG4gICAgICAgIC8vIGNhbiBoYXZlIG5vIHNlbGVjdG9yIGFzIGl0IG1pZ2h0IGluaGVyaXQgaXQgZnJvbSBHcm91cFxuICAgICAgICBlYXNpbmc6IGVhc2luZ1J1bGUsXG4gICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvblJ1bGUsXG4gICAgICAgIHN0YXJ0RnJvbToge1xuICAgICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICAgIGludGVnZXI6IHRydWUsXG4gICAgICAgICAgbWluOiAwLFxuICAgICAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIHJlcGVhdHM6IHtcbiAgICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgICBpbnRlZ2VyOiB0cnVlLFxuICAgICAgICAgIG1pbjogMSxcbiAgICAgICAgICBvcHRpb25hbDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBoaWF0dXM6IHtcbiAgICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgICBpbnRlZ2VyOiB0cnVlLFxuICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICBvcHRpb25hbDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBkZWxheToge1xuICAgICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICAgIGludGVnZXI6IHRydWUsXG4gICAgICAgICAgbWluOiAwLFxuICAgICAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHZhciBjb250YWluZXJQYXJhbXNSdWxlID0ge1xuICAgIHR5cGU6ICdvYmplY3QnLFxuICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgIHByb3BzOiB7XG4gICAgICB3aWR0aDoge1xuICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICAgIH0sXG4gICAgICBoZWlnaHQ6IHtcbiAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9O1xuICB2YXIgYXVkaW9PbkNsaXBzUnVsZSA9IHtcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICBlbnVtOiBbJ29uJywgJ29mZiddLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH07XG4gIHZhciBjbGlwUHJvcHNSdWxlID0ge1xuICAgIHByb3BzOiBbe1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBzdHJpY3Q6IHRydWUsXG4gICAgICBwcm9wczoge1xuICAgICAgICBpZDogaWRSdWxlLFxuICAgICAgICBzZWxlY3RvcjogX29iamVjdFNwcmVhZDIoe30sIHNlbGVjdG9yUnVsZSwge1xuICAgICAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgICAgIH0pLFxuICAgICAgICBlYXNpbmc6IGVhc2luZ1J1bGUsXG4gICAgICAgIGh0bWw6IG9wdGlvbmFsU3RyaW5nUnVsZSxcbiAgICAgICAgY3NzOiBvcHRpb25hbFN0cmluZ1J1bGUsXG4gICAgICAgIGF1ZGlvU291cmNlczogYXVkaW9Tb3VyY2VzUnVsZSxcbiAgICAgICAgYXVkaW86IGF1ZGlvT25DbGlwc1J1bGUsXG4gICAgICAgIGNvbnRhaW5lclBhcmFtczogY29udGFpbmVyUGFyYW1zUnVsZSxcbiAgICAgICAgZm9udHM6IGZvbnRzUnVsZVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgc3RyaWN0OiB0cnVlLFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgaWQ6IGlkUnVsZSxcbiAgICAgICAgaG9zdDogaG9zdFJ1bGUsXG4gICAgICAgIGh0bWw6IG9wdGlvbmFsU3RyaW5nUnVsZSxcbiAgICAgICAgY3NzOiBvcHRpb25hbFN0cmluZ1J1bGUsXG4gICAgICAgIGF1ZGlvU291cmNlczogYXVkaW9Tb3VyY2VzUnVsZSxcbiAgICAgICAgYXVkaW86IGF1ZGlvT25DbGlwc1J1bGUsXG4gICAgICAgIGNvbnRhaW5lclBhcmFtczogY29udGFpbmVyUGFyYW1zUnVsZSxcbiAgICAgICAgZm9udHM6IGZvbnRzUnVsZVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgc3RyaWN0OiB0cnVlLFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgcm9vdDoge1xuICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICBvcHRpb25hbDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBpZDogaWRSdWxlLFxuICAgICAgICBhdWRpb1NvdXJjZXM6IGF1ZGlvU291cmNlc1J1bGUsXG4gICAgICAgIGF1ZGlvOiBfb2JqZWN0U3ByZWFkMih7fSwgYXVkaW9PbkNsaXBzUnVsZSwge1xuICAgICAgICAgIGVudW06IFsnb24nXVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1dXG4gIH07XG4gIHZhciBncm91cFByb3BzUnVsZSA9IHtcbiAgICBzZWxlY3RvcjogX29iamVjdFNwcmVhZDIoe30sIHNlbGVjdG9yUnVsZSwge1xuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICBzdHJpY3Q6IHRydWVcbiAgICB9KVxuICB9O1xuXG4gIHZhciBfVEFSR0VUVFlQRVMgPSB7XG4gICAgX0RFQ0lTSU9OQVVUSE9SSVRZOiAnbWMuZGVzY3JpcHRpdmUuZGVjaXNpb25BdXRob3JpdHknXG4gIH07XG5cbiAgZnVuY3Rpb24gZWRpdEF0dHJpYnV0ZXMocGF5bG9hZCkge1xuICAgIHBheWxvYWQuZGVzY3JpcHRvci52YWx1ZSA9IGZ1bmN0aW9uIGVkaXRBdHRyaWJ1dGVzRnVuY3QobmV3QXR0cnMpIHtcbiAgICAgIHZhciBjaGVja0lmQmVsb25nc1RvQ2xpcCA9IHRoaXMucHV0TWVzc2FnZU9uUGlwZSgnY2hlY2tGb3JDbGlwJywge30sIF9UQVJHRVRUWVBFUy5fREVDSVNJT05BVVRIT1JJVFksIHtcbiAgICAgICAgc2VsZkV4ZWN1dGU6IHRydWUsXG4gICAgICAgIGRpcmVjdGlvbjogX0RJUkVDVElPTlMuX1VQXG4gICAgICB9KTtcblxuICAgICAgaWYgKGNoZWNrSWZCZWxvbmdzVG9DbGlwLnJlc3BvbnNlID09PSB0cnVlKSB7XG4gICAgICAgIC8vIGlmIHRoZSBHcm91cCBiZWxvbmdzIG9uIGEgQ2xpcFxuICAgICAgICByZXR1cm4gdGhpcy5tYW5hZ2VFZGl0QXR0clByb3BzKG5ld0F0dHJzLCAnYXR0cnMnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hdHRycyA9IG5ld0F0dHJzO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0OiB0cnVlXG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBlZGl0UHJvcGVydGllcyhwYXlsb2FkKSB7XG4gICAgcGF5bG9hZC5kZXNjcmlwdG9yLnZhbHVlID0gZnVuY3Rpb24gZWRpdFByb3BlcnRpZXNGdW5jdChuZXdQcm9wcykge1xuICAgICAgdmFyIHZhbGl0YXRpb24gPSBoZWxwZXIudmFsaWRhdGVQcm9wcyh7XG4gICAgICAgIHByb3BzOiBuZXdQcm9wc1xuICAgICAgfSwgdGhpcy5wcm9wc1ZhbGlkYXRpb25SdWxlcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG5cbiAgICAgIGlmICghdmFsaXRhdGlvbi5yZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHZhbGl0YXRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGVja0lmQmVsb25nc1RvQ2xpcCA9IHRoaXMucHV0TWVzc2FnZU9uUGlwZSgnY2hlY2tGb3JDbGlwJywge30sIF9UQVJHRVRUWVBFUy5fREVDSVNJT05BVVRIT1JJVFksIHtcbiAgICAgICAgc2VsZkV4ZWN1dGU6IHRydWUsXG4gICAgICAgIGRpcmVjdGlvbjogX0RJUkVDVElPTlMuX1VQXG4gICAgICB9KTtcblxuICAgICAgaWYgKGNoZWNrSWZCZWxvbmdzVG9DbGlwLnJlc3BvbnNlID09PSB0cnVlKSB7XG4gICAgICAgIC8vIGlmIHRoZSBHcm91cCBiZWxvbmdzIG9uIGEgQ2xpcFxuICAgICAgICByZXR1cm4gdGhpcy5tYW5hZ2VFZGl0QXR0clByb3BzKG5ld1Byb3BzLCAncHJvcHMnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcm9wcyA9IG5ld1Byb3BzO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0OiB0cnVlXG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRFbGVtZW50cyhwYXlsb2FkKSB7XG4gICAgcGF5bG9hZC5kZXNjcmlwdG9yLnZhbHVlID0gZnVuY3Rpb24gZ2V0RWxlbWVudHNGdW5jdCgpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLmhvc3QgIT09IG51bGwgJiYgdGhpcy5wcm9wcy5ob3N0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLnByb3BzLmhvc3RdO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuaGFzUGFyZW50KSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNoZWNrSWZCZWxvbmdzVG9DbGlwID0gdGhpcy5wdXRNZXNzYWdlT25QaXBlKCdjaGVja0ZvckNsaXAnLCB7fSwgX1RBUkdFVFRZUEVTLl9ERUNJU0lPTkFVVEhPUklUWSwge1xuICAgICAgICBzZWxmRXhlY3V0ZTogdHJ1ZSxcbiAgICAgICAgZGlyZWN0aW9uOiBfRElSRUNUSU9OUy5fVVBcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoY2hlY2tJZkJlbG9uZ3NUb0NsaXAucmVzcG9uc2UgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZW1lbnRzUmVzcG9uc2UgPSB0aGlzLnB1dE1lc3NhZ2VPblBpcGUoJ2dldEVsZW1lbnRzJywge1xuICAgICAgICBzZWxlY3RvcjogdGhpcy5zZWxlY3RvcigpXG4gICAgICB9LCBfVEFSR0VUVFlQRVMuX0RFQ0lTSU9OQVVUSE9SSVRZLCB7XG4gICAgICAgIHNlbGZFeGVjdXRlOiBmYWxzZSxcbiAgICAgICAgZGlyZWN0aW9uOiBfRElSRUNUSU9OUy5fVVBcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGVsZW1lbnRzUmVzcG9uc2UucmVzcG9uc2U7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZXNpemUgbWV0aG9kIHJlc2l6ZXMgdGhlIEluY2lkZW50IGJ5IG1haW50YWluaW5nIHByb3BvcnRpb25zIGJldHdlZW4gZGVsYXksIGR1cmFpdG9uIGFuZCBoaWF0dXMuXG4gICAqIGFsc28sIHRoZSBuZXcgZHVyYXRpb24gd2lsbCBiZSB0aGUgZnVsbCBuZXcgZHVyYXRpb24gb2YgdGhlIEluY2lkZW50IHRha2luZyBpbiBjb25zaWRyYXRpb25cbiAgICogYWxsIGRlbGF5LCBkdXJhdGlvbiBhbmQgaGlhdHVzIGFsb25nIHdpdGggcmVwZWF0c1xuICAgKiAqL1xuXG4gIGZ1bmN0aW9uIHJlc2l6ZShwYXlsb2FkKSB7XG4gICAgcGF5bG9hZC5kZXNjcmlwdG9yLnZhbHVlID0gZnVuY3Rpb24gcmVzaXplRnVuY3QobmV3U2l6ZSkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHtcbiAgICAgICAgY2hlY2s6IHRydWVcbiAgICAgIH07XG5cbiAgICAgIGlmIChuZXdTaXplID09PSB0aGlzLmR1cmF0aW9uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzdWx0OiB0cnVlLFxuICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgIHVucHJvY2Vzc2VkOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAobmV3U2l6ZSA8PSAwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzdWx0OiBmYWxzZSxcbiAgICAgICAgICByZWFzb246ICdTaXplIG11c3QgYWx3YXlzIGJlID4gMCdcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuY2hlY2sgPT09IHRydWUgJiYgdGhpcy5oYXNQYXJlbnQpIHtcbiAgICAgICAgdmFyIG1jQ2hlY2sgPSB0aGlzLnB1dE1lc3NhZ2VPblBpcGUoJ2NoZWNrUmVzaXplJywge1xuICAgICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICAgIG5ld1NpemU6IG5ld1NpemUsXG4gICAgICAgICAgZnJhY3Rpb246IG5ld1NpemUgLyB0aGlzLmR1cmF0aW9uXG4gICAgICAgIH0sIF9UQVJHRVRUWVBFUy5fREVDSVNJT05BVVRIT1JJVFksIHtcbiAgICAgICAgICBzZWxmRXhlY3V0ZTogZmFsc2UsXG4gICAgICAgICAgZGlyZWN0aW9uOiBfRElSRUNUSU9OUy5fVVBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG1jQ2hlY2sucmVzcG9uc2UucmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBtY0NoZWNrLnJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0TmV3RHVyYXRpb24obmV3U2l6ZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXN1bHQ6IHRydWVcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdG9yKHBheWxvYWQpIHtcbiAgICBwYXlsb2FkLmRlc2NyaXB0b3IudmFsdWUgPSBmdW5jdGlvbiBzZWxlY3RvckZ1bmN0KCkge1xuICAgICAgaWYgKHRoaXMuaW5oZXJpdGVkU2VsZWN0b3IgPT09IG51bGwpIHtcbiAgICAgICAgLy8gaWYgdGhlIEluY2lkZW50IGhhcyBubyBwYXJlbnQgc2VsZWN0b3IgaW5oZXJpdGVkXG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMucHJvcHMsICdzZWxlY3RvcicpKSB7XG4gICAgICAgICAgLy8gYW5kIGRvZXMgbm90IGhhdmUgYSBzZWxlY3RvciBuZWl0aGVyXG4gICAgICAgICAgcmV0dXJuIG51bGw7IC8vIHRoZW4gaXRzIHNlbGVjdG9yIGlzIG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLnNlbGVjdG9yOyAvLyBlbHNlLCBpZiBpdCBoYXMgYSBzZWxlY3RvciB0aGF0J3MgaXRzIGZpbmFsIHNlbGVjdG9yXG4gICAgICB9IC8vIGVsc2UgaWYgdGhlcmUgaXMgYW4gaW5oZXJpdGVkIHNlbGVjdG9yXG5cblxuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5wcm9wcywgJ3NlbGVjdG9yJykpIHtcbiAgICAgICAgLy8gYW5kIGRvZXMgbm90IGhhdmUgYSBzZWxlY3RvciBvZiBpdHMgb3duXG4gICAgICAgIHJldHVybiB0aGlzLmluaGVyaXRlZFNlbGVjdG9yOyAvLyB0aGVuIGl0cyBzZWxlY3RvciBpcyBlcXVhbCB0byB0aGUgaW5oZXJpdGVkIHNlbGVjdG9yXG4gICAgICB9IC8vIGVsc2UsIGlmIGl0IGJvdGggaGFzIGFuIGluaGVyaXRlZCBhbmQgYW4gb3duIHNlbGVjdG9yXG5cblxuICAgICAgaWYgKHRoaXMucHJvcHMuc2VsZWN0b3IuY2hhckF0KDApID09PSAnJicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5oZXJpdGVkU2VsZWN0b3IgKyB0aGlzLnByb3BzLnNlbGVjdG9yLnN1YnN0cmluZygxKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHRoaXMuaW5oZXJpdGVkU2VsZWN0b3IsIFwiIFwiKS5jb25jYXQodGhpcy5wcm9wcy5zZWxlY3Rvcik7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBEZXNjcmlwdGl2ZUdyb3VwID0gX2RlY29yYXRlKG51bGwsIGZ1bmN0aW9uIChfaW5pdGlhbGl6ZSwgX05vZGUpIHtcbiAgICB2YXIgRGVzY3JpcHRpdmVHcm91cCA9XG4gICAgLyojX19QVVJFX18qL1xuICAgIGZ1bmN0aW9uIChfTm9kZTIpIHtcbiAgICAgIF9pbmhlcml0cyhEZXNjcmlwdGl2ZUdyb3VwLCBfTm9kZTIpO1xuXG4gICAgICBmdW5jdGlvbiBEZXNjcmlwdGl2ZUdyb3VwKCkge1xuICAgICAgICB2YXIgX3RoaXM7XG5cbiAgICAgICAgdmFyIGF0dHJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuXG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEZXNjcmlwdGl2ZUdyb3VwKTtcblxuICAgICAgICBpZiAocHJvcHMgPT09IG51bGwpIHtcbiAgICAgICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihEZXNjcmlwdGl2ZUdyb3VwKS5jYWxsKHRoaXMsIGF0dHJzKSk7XG5cbiAgICAgICAgICBfaW5pdGlhbGl6ZShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICAgICAgICBfdGhpcy5hdHRycyA9IHt9O1xuICAgICAgICAgIF90aGlzLnByb3BzID0gYXR0cnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoRGVzY3JpcHRpdmVHcm91cCkuY2FsbCh0aGlzLCBwcm9wcykpO1xuXG4gICAgICAgICAgX2luaXRpYWxpemUoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgICAgICAgX3RoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgICBfdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByb3BzVmFsaWRhdGlvbiA9IGhlbHBlci52YWxpZGF0ZVByb3BzKF90aGlzLnByb3BzLCBncm91cFByb3BzUnVsZSwgX3RoaXMuY29uc3RydWN0b3IpO1xuXG4gICAgICAgIGlmIChwcm9wc1ZhbGlkYXRpb24ucmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgcHJvcHNWYWxpZGF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLmF0dHJzVmFsaWRhdGlvblJ1bGVzID0ge307XG4gICAgICAgIF90aGlzLnByb3BzVmFsaWRhdGlvblJ1bGVzID0gZ3JvdXBQcm9wc1J1bGU7XG4gICAgICAgIF90aGlzLl9pbmhlcml0ZWRTZWxlY3RvciA9IG51bGw7IC8vIHBhc3NpdmVBZGRpdGlvbiBpcyBhIGZsYWcgcHJvcGVydHkgaW5kaWNhdGluZyB0aGF0IGFueSBJbmNpZGVudCB0byBiZVxuICAgICAgICAvLyBhZGRlZCB0byB0aGUgQ2xpcCB3aWxsIGJlIHBhc3NpdmUuIEl0IGluaXRpYWxpc2VzIHdpdGggdmFsdWUgPSBmYWxzZVxuICAgICAgICAvLyBvbiBEZXNjcmlwdGl2ZUdyb3VwIHdoZXJlIGl0J3Mgb3JpZ2luYWx5IGRlZmluZWQuXG4gICAgICAgIC8vIEhlcmUgd2UgY2hhbmdlIGl0cyB2YWx1ZSBqdXN0IGJlZm9yZSB0aGUgYnVpbGRUcmVlIG1ldGhvZCBleGVjdXRpb25cbiAgICAgICAgLy8gc28gYWxsIEluY2lkZW50cyBhZGRlZCBvbiBpdCBnZXQgdGhlIFwicGFzc2l2ZVwiIGZsYWcgYW5kIGRvbid0IGdldFxuICAgICAgICAvLyBleHBvcnRlZCBvbiB0aGUgZXhwb3J0RGVmaW5pdGlvbiBtZXRob2QuIE9uY2UgdGhlIGJ1aWxkVHJlZSBtZXRob2RcbiAgICAgICAgLy8gZmluaXNoZXMgd2Ugc2V0IGl0IGJhY2sgdG8gaXRzIG9yaWdpbmFsIHZhbHVlIChmYWxzZSlcblxuICAgICAgICBfdGhpcy5wYXNzaXZlQWRkaXRpb24gPSB0cnVlO1xuXG4gICAgICAgIF90aGlzLl9idWlsZFRyZWUoKTtcblxuICAgICAgICBfdGhpcy5wYXNzaXZlQWRkaXRpb24gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIERlc2NyaXB0aXZlR3JvdXA7XG4gICAgfShfTm9kZSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgRjogRGVzY3JpcHRpdmVHcm91cCxcbiAgICAgIGQ6IFt7XG4gICAgICAgIGtpbmQ6IFwiZmllbGRcIixcbiAgICAgICAgc3RhdGljOiB0cnVlLFxuICAgICAgICBrZXk6IFwiSW5jaWRlbnRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgICAgIHJldHVybiBHcm91cDtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBraW5kOiBcImZpZWxkXCIsXG4gICAgICAgIHN0YXRpYzogdHJ1ZSxcbiAgICAgICAga2V5OiBcInBsdWdpbl9ucG1fbmFtZVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICAgICAgcmV0dXJuICdtb3Rvci1jb3J0ZXgtanMnO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwiZmllbGRcIixcbiAgICAgICAgc3RhdGljOiB0cnVlLFxuICAgICAgICBrZXk6IFwiQ2hhbm5lbFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICAgICAgcmV0dXJuIENoYW5uZWw7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJmaWVsZFwiLFxuICAgICAgICBzdGF0aWM6IHRydWUsXG4gICAgICAgIGtleTogXCJDbGFzc05hbWVcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgICAgIHJldHVybiAnR3JvdXAnO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwiZmllbGRcIixcbiAgICAgICAgc3RhdGljOiB0cnVlLFxuICAgICAgICBrZXk6IFwiaXNHcm91cFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgICAgZGVjb3JhdG9yczogW2VkaXRBdHRyaWJ1dGVzXSxcbiAgICAgICAga2V5OiBcImVkaXRBdHRyaWJ1dGVzXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBlZGl0QXR0cmlidXRlcygpIHt9XG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICAgIGRlY29yYXRvcnM6IFtlZGl0UHJvcGVydGllc10sXG4gICAgICAgIGtleTogXCJlZGl0UHJvcGVydGllc1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZWRpdFByb3BlcnRpZXMoKSB7fVxuICAgICAgfSwge1xuICAgICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAgICBkZWNvcmF0b3JzOiBbcmVzaXplXSxcbiAgICAgICAga2V5OiBcInJlc2l6ZVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKCkge31cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgICAgZGVjb3JhdG9yczogW3NlbGVjdG9yXSxcbiAgICAgICAga2V5OiBcInNlbGVjdG9yXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3RvcigpIHt9XG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICAgIGRlY29yYXRvcnM6IFtnZXRFbGVtZW50c10sXG4gICAgICAgIGtleTogXCJnZXRFbGVtZW50c1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWxlbWVudHMoKSB7fVxuICAgICAgfSwge1xuICAgICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAgICBrZXk6IFwiX2J1aWxkVHJlZVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2J1aWxkVHJlZSgpIHtcbiAgICAgICAgICB0aGlzLmJ1aWxkVHJlZSgpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICAgIGtleTogXCJfcmVidWlsZFRyZWVcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWJ1aWxkVHJlZSgpIHtcbiAgICAgICAgICAvLyByZW1vdmUgYWxsIGRpcmVjdCBwYXNzaXZlIGluY2lkZW50cyBhcyB0aGV5IG1pZ2h0IGJlIGRlcGVuZGVudCBvbiB0aGUgZWRpdGVkIGF0dHJzL3Byb3BzXG4gICAgICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgdmFyIHRoZUNoaWxkID0gdGhpcy5jaGlsZHJlbltpZF07XG5cbiAgICAgICAgICAgIGlmICh0aGVDaGlsZC5sZWFmLnBhc3NpdmUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgdGhpcy5yZW1vdmVJbmNpZGVudCh0aGVDaGlsZC5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBydW4gYnVpbGRUcmVlIGFnYWluXG5cblxuICAgICAgICAgIHRoaXMucGFzc2l2ZUFkZGl0aW9uID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmJ1aWxkVHJlZSgpO1xuICAgICAgICAgIHRoaXMucGFzc2l2ZUFkZGl0aW9uID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgICAga2V5OiBcImJ1aWxkVHJlZVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGRUcmVlKCkge31cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgICAga2V5OiBcIm1hbmFnZUVkaXRBdHRyUHJvcHNcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1hbmFnZUVkaXRBdHRyUHJvcHMobmV3QXR0cnMsIHR5cGUpIHtcbiAgICAgICAgICAvLyBnZXQgYSBwZXJtYW5lbnQgcmVmZXJlbmNlIHRvIGl0cyBwYXJlbnQgbm9kZVxuICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gdGhpcy5wYXJlbnROb2RlOyAvLyBnZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBJbmNpZGVudCB3aXRoaW4gaXRzIHBhcmVudFxuXG4gICAgICAgICAgdmFyIHBvc2l0aW9uID0gcGFyZW50Tm9kZS5nZXRMZWFmUG9zaXRpb24odGhpcy5pZCk7IC8vIGtlZXAgYSBiYWNrdXAgb2YgdGhlIGN1cnJlbnQgYXR0cnMgLyBwcm9wc1xuXG4gICAgICAgICAgdmFyIG9sZEF0dHJzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzW3R5cGVdKSk7XG4gICAgICAgICAgdGhpc1t0eXBlXSA9IG5ld0F0dHJzOyAvLyBmaXJzdCBkZXRhY2ggdGhlIEluY2lkZW50IGZyb20gaXRzIHBhcmVudFxuXG4gICAgICAgICAgcGFyZW50Tm9kZS5yZW1vdmVJbmNpZGVudCh0aGlzLmlkKTsgLy8gcmVtb3ZlIGFsbCBkaXJlY3QgcGFzc2l2ZSBpbmNpZGVudHMgYXMgdGhleSBtaWdodCBiZSBkZXBlbmRlbnQgb24gdGhlIGVkaXRlZCBhdHRycy9wcm9wc1xuXG4gICAgICAgICAgdGhpcy5fcmVidWlsZFRyZWUoKTsgLy8gdHJ5IHRvIGFkZCB0aGUgYWx0ZXJlZCBHcm91cFxuXG5cbiAgICAgICAgICB2YXIgcmVzID0gcGFyZW50Tm9kZS5hZGRJbmNpZGVudCh0aGlzLCBwb3NpdGlvbik7XG5cbiAgICAgICAgICBpZiAocmVzLnJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXNbdHlwZV0gPSBvbGRBdHRycztcblxuICAgICAgICAgICAgdGhpcy5fcmVidWlsZFRyZWUoKTtcblxuICAgICAgICAgICAgcGFyZW50Tm9kZS5hZGRJbmNpZGVudCh0aGlzLCBwb3NpdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgICAga2V5OiBcImRldGFjaEZyb21QYXJlbnRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRldGFjaEZyb21QYXJlbnQoKSB7XG4gICAgICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoRGVzY3JpcHRpdmVHcm91cC5wcm90b3R5cGUpLCBcImRldGFjaEZyb21QYXJlbnRcIiwgdGhpcykuY2FsbCh0aGlzKTtcblxuICAgICAgICAgIHRoaXMuaW5oZXJpdGVkU2VsZWN0b3IgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwiZ2V0XCIsXG4gICAgICAgIGtleTogXCJpbmhlcml0ZWRTZWxlY3RvclwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaW5oZXJpdGVkU2VsZWN0b3IoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2luaGVyaXRlZFNlbGVjdG9yO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwic2V0XCIsXG4gICAgICAgIGtleTogXCJpbmhlcml0ZWRTZWxlY3RvclwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaW5oZXJpdGVkU2VsZWN0b3IodmFsdWUpIHtcbiAgICAgICAgICB0aGlzLl9pbmhlcml0ZWRTZWxlY3RvciA9IHZhbHVlO1xuXG4gICAgICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgdmFyIHRoZUNoaWxkID0gdGhpcy5jaGlsZHJlbltpZF0ubGVhZjtcbiAgICAgICAgICAgIHRoZUNoaWxkLmluaGVyaXRlZFNlbGVjdG9yID0gdGhpcy5zZWxlY3RvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBraW5kOiBcImdldFwiLFxuICAgICAgICBrZXk6IFwic2VsZWN0b3JUb1Bhc3NUb0NoaWxkcmVuXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3RvclRvUGFzc1RvQ2hpbGRyZW4oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0b3IoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG8gZXhwb3J0IGEgcG9ydGFibGUgZGVmaW5pdGlvbiB0aGF0IGNhbiBiZVxuICAgICAgICAgKiBsYXRlciB1c2VkIGluIG9yZGVyIHRvIHJlYnVpbGQgdGhlIEluaWNkZW50IGF0IGFueSB0aW1lXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICAgIGtleTogXCJleHBvcnREZWZpbml0aW9uXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBleHBvcnREZWZpbml0aW9uKCkge1xuICAgICAgICAgIHZhciB0b1JldHVybiA9IHtcbiAgICAgICAgICAgIENsYXNzTmFtZTogdGhpcy5jb25zdHJ1Y3Rvci5DbGFzc05hbWUsXG4gICAgICAgICAgICBwbHVnaW5fbnBtX25hbWU6IHRoaXMuY29uc3RydWN0b3IucGx1Z2luX25wbV9uYW1lLFxuICAgICAgICAgICAgYXR0cnM6IHRoaXMuYXR0cnMsXG4gICAgICAgICAgICBwcm9wczogdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIGluY2lkZW50czoge30sXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvblxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICB2YXIgdGhlQ2hpbGQgPSB0aGlzLmNoaWxkcmVuW2lkXTtcblxuICAgICAgICAgICAgaWYgKHRoZUNoaWxkLmxlYWYucGFzc2l2ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG9SZXR1cm4uaW5jaWRlbnRzW2lkXSA9IHtcbiAgICAgICAgICAgICAgaWQ6IHRoZUNoaWxkLmlkLFxuICAgICAgICAgICAgICBwb3NpdGlvbjogdGhlQ2hpbGQucG9zaXRpb24sXG4gICAgICAgICAgICAgIGxlYWY6IHRoZUNoaWxkLmxlYWYuZXhwb3J0RGVmaW5pdGlvbigpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0b1JldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG8gZXhwb3J0IGFuIG9iamVjdCB3aXRoIFwibGl2ZVwiIC8gcmVhbCByZWZlcmVuY2VcbiAgICAgICAgICogdG8gdGhlIENsYXNzIG9mIHRoZSBJbmNpZGVudCBzbyBpdCBjYW4gZGlyZWN0bHkgYnkgdXNlZCBmb3IgQ2xpcCBjcmVhdGlvblxuICAgICAgICAgKiAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICAgIGtleTogXCJleHBvcnRMaXZlRGVmaW5pdGlvblwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZXhwb3J0TGl2ZURlZmluaXRpb24oKSB7XG4gICAgICAgICAgdmFyIHRvUmV0dXJuID0ge1xuICAgICAgICAgICAgQ2xhc3M6IHRoaXMuY29uc3RydWN0b3IsXG4gICAgICAgICAgICBhdHRyczogSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLmF0dHJzKSksXG4gICAgICAgICAgICBwcm9wczogSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLnByb3BzKSksXG4gICAgICAgICAgICBpbmNpZGVudHM6IHt9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGZvciAodmFyIGlkIGluIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHZhciB0aGVDaGlsZCA9IHRoaXMuY2hpbGRyZW5baWRdO1xuXG4gICAgICAgICAgICBpZiAodGhlQ2hpbGQubGVhZi5wYXNzaXZlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0b1JldHVybi5pbmNpZGVudHNbaWRdID0ge1xuICAgICAgICAgICAgICBpZDogdGhlQ2hpbGQuaWQsXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiB0aGVDaGlsZC5wb3NpdGlvbixcbiAgICAgICAgICAgICAgbGVhZjogdGhlQ2hpbGQubGVhZi5leHBvcnRMaXZlRGVmaW5pdGlvbigpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0b1JldHVybjtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAgICBrZXk6IFwiYWRkSW5jaWRlbnRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEluY2lkZW50KGRlc2NyaXB0aXZlSW5jaWRlbnQsIHBvc2l0aW9uKSB7XG4gICAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHtcbiAgICAgICAgICAgIGNoZWNrOiB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgICBkZXNjcmlwdGl2ZUluY2lkZW50LmluaGVyaXRlZFNlbGVjdG9yID0gdGhpcy5zZWxlY3RvclRvUGFzc1RvQ2hpbGRyZW47XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5jaGVjayA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIGluaXRpYWxDaGVjayA9IF9nZXQoX2dldFByb3RvdHlwZU9mKERlc2NyaXB0aXZlR3JvdXAucHJvdG90eXBlKSwgXCJjaGVja0FkZGl0aW9uXCIsIHRoaXMpLmNhbGwodGhpcywgZGVzY3JpcHRpdmVJbmNpZGVudCwgcG9zaXRpb24pO1xuXG4gICAgICAgICAgICBpZiAoaW5pdGlhbENoZWNrLnJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgZGVzY3JpcHRpdmVJbmNpZGVudC5pbmhlcml0ZWRTZWxlY3RvciA9IG51bGw7XG4gICAgICAgICAgICAgIHJldHVybiBpbml0aWFsQ2hlY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBDaGVjayBmb3IgbnVsbCBvciByZWxhdGl2ZSBzZWxlY3RvciBJbmNpZGVudHMgd2l0aCBubyBpbmhlcml0ZWQgc2VsZWN0b3IgKi9cblxuXG4gICAgICAgICAgICB2YXIgY2hlY2tJZkJlbG9uZ3NUb0NsaXAgPSB0aGlzLnB1dE1lc3NhZ2VPblBpcGUoJ2NoZWNrRm9yQ2xpcCcsIHt9LCBfVEFSR0VUVFlQRVMuX0RFQ0lTSU9OQVVUSE9SSVRZLCB7XG4gICAgICAgICAgICAgIHNlbGZFeGVjdXRlOiB0cnVlLFxuICAgICAgICAgICAgICBkaXJlY3Rpb246IF9ESVJFQ1RJT05TLl9VUFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChjaGVja0lmQmVsb25nc1RvQ2xpcC5yZXNwb25zZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAvLyBpZiB0aGUgR3JvdXAgYmVsb25ncyBvbiBhIENsaXBcbiAgICAgICAgICAgICAgdmFyIHNlbGVjdG9yc0NoZWNrID0gZGVzY3JpcHRpdmVJbmNpZGVudC5wdXRNZXNzYWdlT25QaXBlKCdjaGVja0ZvckludmFsaWRTZWxlY3RvcnMnLCB7fSwgbnVsbCwge1xuICAgICAgICAgICAgICAgIHNlbGZFeGVjdXRlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogX0RJUkVDVElPTlMuX0RPV05cbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yc0NoZWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3JzID0gW107XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdG9yc0NoZWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChzZWxlY3RvcnNDaGVja1tpXS5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICBlcnJvcnM6IGVycm9yc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gLy8gc2VuZHMgdGhlIGNoZWNrIHJlcXVlc3QgdG8gaXRzIHJvb3QsIGVpdGhlciBhIGhlYWRsZXNzIHJvb3Qgb3IgYSBEZXNjcmlwdGl2ZSBDbGlwXG5cblxuICAgICAgICAgICAgdmFyIG1jQ2hlY2sgPSB0aGlzLnB1dE1lc3NhZ2VPblBpcGUoJ2NoZWNrQWRkaXRpb24nLCB7XG4gICAgICAgICAgICAgIGluY2lkZW50OiBkZXNjcmlwdGl2ZUluY2lkZW50LFxuICAgICAgICAgICAgICBtaWxsaXNlY29uZDogcG9zaXRpb24sXG4gICAgICAgICAgICAgIHBhcmVudEdyb3VwSWQ6IHRoaXMuaWRcbiAgICAgICAgICAgIH0sIF9UQVJHRVRUWVBFUy5fREVDSVNJT05BVVRIT1JJVFksIHtcbiAgICAgICAgICAgICAgc2VsZkV4ZWN1dGU6IHRydWUsXG4gICAgICAgICAgICAgIGRpcmVjdGlvbjogX0RJUkVDVElPTlMuX1VQXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKG1jQ2hlY2sucmVzcG9uc2UucmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICBkZXNjcmlwdGl2ZUluY2lkZW50LmluaGVyaXRlZFNlbGVjdG9yID0gbnVsbDtcbiAgICAgICAgICAgICAgcmV0dXJuIG1jQ2hlY2sucmVzcG9uc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBpZiB0aGUgcGFzc2l2ZUFkZGl0aW9uIGZsYWcgaXMgdHJ1ZSB3ZSBzZXQgdGhlIHBhc3NpdmUgZmxhZyBvZiB0aGUgSW5jaWRlbnRcbiAgICAgICAgICAvLyB0byB0cnVlIGJlZm9yZSBhZGRpbmcgaXQgdG8gb3VyIEdyb3VwXG5cblxuICAgICAgICAgIGlmICh0aGlzLnBhc3NpdmVBZGRpdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgZGVzY3JpcHRpdmVJbmNpZGVudC5wYXNzaXZlID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmVzID0gdGhpcy5hZGRDaGlsZChkZXNjcmlwdGl2ZUluY2lkZW50LCBwb3NpdGlvbik7XG5cbiAgICAgICAgICBpZiAocmVzLnJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aXZlSW5jaWRlbnQuaW5oZXJpdGVkU2VsZWN0b3IgPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBpbnB1dCAtIGNhbiBlaXRoZXIgYmUgb2JqZWN0IG9yIGlkXG4gICAgICAgICAqICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgICAga2V5OiBcIm1vdmVJbmNpZGVudFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZUluY2lkZW50KGlucHV0LCBwb3NpdGlvbikge1xuICAgICAgICAgIHZhciBpZCA9IGlucHV0O1xuXG4gICAgICAgICAgaWYgKF90eXBlb2YoaW5wdXQpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWQgPSBpbnB1dC5pZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaW5pdGlhbENoZWNrID0gX2dldChfZ2V0UHJvdG90eXBlT2YoRGVzY3JpcHRpdmVHcm91cC5wcm90b3R5cGUpLCBcImNoZWNrRWRpdFBvc2l0aW9uXCIsIHRoaXMpLmNhbGwodGhpcywgaWQsIHBvc2l0aW9uKTtcblxuICAgICAgICAgIGlmIChpbml0aWFsQ2hlY2sucmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGluaXRpYWxDaGVjaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgb3JpZ2luYWxQb3NpdGlvbiA9IHRoaXMuZ2V0TGVhZlBvc2l0aW9uKGlkKTtcbiAgICAgICAgICB2YXIgcG9zaXRpb25EZWx0YSA9IHBvc2l0aW9uIC0gb3JpZ2luYWxQb3NpdGlvbjtcblxuICAgICAgICAgIGlmIChwb3NpdGlvbkRlbHRhID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICByZXN1bHQ6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG1jQ2hlY2sgPSB0aGlzLnB1dE1lc3NhZ2VPblBpcGUoJ2NoZWNrTW92ZScsIHtcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kOiBwb3NpdGlvbixcbiAgICAgICAgICAgIHBvc2l0aW9uRGVsdGE6IHBvc2l0aW9uRGVsdGEsXG4gICAgICAgICAgICBwYXJlbnRHcm91cElkOiB0aGlzLmlkXG4gICAgICAgICAgfSwgX1RBUkdFVFRZUEVTLl9ERUNJU0lPTkFVVEhPUklUWSwge1xuICAgICAgICAgICAgc2VsZkV4ZWN1dGU6IHRydWUsXG4gICAgICAgICAgICBkaXJlY3Rpb246IF9ESVJFQ1RJT05TLl9VUFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKG1jQ2hlY2sucmVzcG9uc2UucmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIG1jQ2hlY2sucmVzcG9uc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHJlcyA9IHRoaXMuZWRpdFBvc2l0aW9uKGlkLCBwb3NpdGlvbik7XG4gICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAgICBrZXk6IFwicmVtb3ZlSW5jaWRlbnRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUluY2lkZW50KGlucHV0KSB7XG4gICAgICAgICAgdmFyIGlkID0gaW5wdXQ7XG5cbiAgICAgICAgICBpZiAoX3R5cGVvZihpbnB1dCkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZCA9IGlucHV0LmlkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBpbml0aWFsQ2hlY2sgPSBfZ2V0KF9nZXRQcm90b3R5cGVPZihEZXNjcmlwdGl2ZUdyb3VwLnByb3RvdHlwZSksIFwiY2hlY2tSZW1vdmVDaGlsZFwiLCB0aGlzKS5jYWxsKHRoaXMsIGlkKTtcblxuICAgICAgICAgIGlmIChpbml0aWFsQ2hlY2sucmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGluaXRpYWxDaGVjaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbWNDaGVjayA9IHRoaXMucHV0TWVzc2FnZU9uUGlwZSgnY2hlY2tEZWxldGlvbicsIHtcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIHBhcmVudEdyb3VwSWQ6IHRoaXMuaWRcbiAgICAgICAgICB9LCBfVEFSR0VUVFlQRVMuX0RFQ0lTSU9OQVVUSE9SSVRZLCB7XG4gICAgICAgICAgICBzZWxmRXhlY3V0ZTogdHJ1ZSxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogX0RJUkVDVElPTlMuX1VQXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAobWNDaGVjay5yZXNwb25zZS5yZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gbWNDaGVjay5yZXNwb25zZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmVzID0gdGhpcy5yZW1vdmVDaGlsZChpZCk7XG4gICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICAvKiogKioqKioqKioqKioqKioqKioqKioqKioqKiBIQU5ETElORyBNRVRIT0RTICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAgICAgfSwge1xuICAgICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAgICBrZXk6IFwiaGFuZGxlQ2hlY2tGb3JDbGlwXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVDaGVja0ZvckNsaXAodGFyZ2V0LCBwYXlsb2FkKSB7XG4gICAgICAgICAgaWYgKHRoaXMuaGFzUGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ieXBhc3MoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgICAga2V5OiBcImhhbmRsZUNoZWNrQWRkaXRpb25cIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUNoZWNrQWRkaXRpb24odGFyZ2V0LCBwYXlsb2FkKSB7XG4gICAgICAgICAgLypcbiAgICAgICAgICAgICAgVGhlIERlc2NyaXB0aXZlR3JvdXAgaGFuZGxlcyB0aGUgY2hlY2tBZGRpdGlvbiBjb21tYW5kIHdoaWNoIGhhcyB0aGUgVVBcbiAgICAgICAgICAgICAgZGlyZWN0aW9uLiBJZiB0aGUgREcgaGFzIGEgcGFyZW50IGl0IGZvcndhcmRzIHRoZSBjb21tYW5kIHRvIGl0LiBJZiBub3RcbiAgICAgICAgICAgICAgaXQganVzdCByZXR1cm5zIHRydWUsIGFzIGl0IGlzIGEgZGVhZGxlc3MgdHJlZVxuICAgICAgICAgICAgICAqL1xuICAgICAgICAgIGlmICh0aGlzLmhhc1BhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnlwYXNzKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3VsdDogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgICAga2V5OiBcImhhbmRsZUNoZWNrTW92ZVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlQ2hlY2tNb3ZlKHRhcmdldCwgcGF5bG9hZCkge1xuICAgICAgICAgIGlmICh0aGlzLmhhc1BhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnlwYXNzKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3VsdDogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgICAga2V5OiBcImhhbmRsZUNoZWNrRGVsZXRpb25cIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUNoZWNrRGVsZXRpb24odGFyZ2V0LCBwYXlsb2FkKSB7XG4gICAgICAgICAgaWYgKHRoaXMuaGFzUGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ieXBhc3MoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdWx0OiB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAgICAgfSwge1xuICAgICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAgICBrZXk6IFwiaGFuZGxlQ2hlY2tSZXNpemVcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUNoZWNrUmVzaXplKHRhcmdldCwgcGF5bG9hZCkge1xuICAgICAgICAgIGlmICh0aGlzLmhhc1BhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnlwYXNzKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3VsdDogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1dXG4gICAgfTtcbiAgfSwgTm9kZSk7XG5cbiAgdmFyIFBsYXlhYmxlID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoX0Rlc2NyaXB0aXZlR3JvdXApIHtcbiAgICBfaW5oZXJpdHMoUGxheWFibGUsIF9EZXNjcmlwdGl2ZUdyb3VwKTtcblxuICAgIGZ1bmN0aW9uIFBsYXlhYmxlKGF0dHJzLCBwcm9wcykge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGxheWFibGUpO1xuXG4gICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihQbGF5YWJsZSkuY2FsbCh0aGlzLCBhdHRycywgcHJvcHMpKTtcbiAgICAgIF90aGlzLnJ1blRpbWVJbmZvID0ge1xuICAgICAgICBjdXJyZW50TWlsbGlzZWNvbmQ6IDAsXG4gICAgICAgIHN0YXRlOiAnaWRsZScgLy8gc3VwcG9ydGVkIHN0YXRlczogaWRsZSwgcGxheWluZywgcGF1c2VkLCBibG9ja2VkLCBhcm1lZFxuXG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgICAgICBAbWVtYmVyIHtvYmplY3R9IC0gbGlzdGVuZXJzIGFyZSBmdW5jdGlvbnMgdG8gYmUgZXhlY3V0ZWQgb24gdGltZSBjaGFuZ2Ugb2YgdGhlIENsaXAuXG4gICAgICAgICAgICBJdCBoYXMgdGhlIGZvbGxvd2luZyBmb3JtYXQ6XG4gICAgICAgICAgIGxpc3RlbmVyczoge1xuICAgICAgICAgICAgICBsaXN0ZW5lcl9pZDoge1xuICAgICAgICAgICAgICAgICAgICAgICBmdW5jdCA6IHRoZSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZFxuICAgICAgICAgICAgICAgICAgICAgICB0aHJlc2hvbGQgOiB0aGUgdGhyZXNob2xkIG9mIGRlbHRhXG4gICAgICAgICAgICAgICAgICAgICAgIHJvdW5kVG8gOiByb3VuZCBtaWxsaXNlY29uZFxuICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgbGlzdGVuZXJfaWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgZnVuY3QgOiB0aGUgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgdGhyZXNob2xkIDogdGhlIHRocmVzaG9sZCBvZiBkZWx0YVxuICAgICAgICAgICAgICAgICAgICAgICByb3VuZFRvIDogcm91bmQgbWlsbGlzZWNvbmRcbiAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgIC4uLlxuICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAqL1xuXG4gICAgICBfdGhpcy5saXN0ZW5lcnMgPSB7fTsgLy8gcHJldmlvdXNUaW1lU3RhbXAgaXMgYSBwcm9wZXJ0eSBob2xkaW5nIHRoZSBsYXN0IHRpbWVzdGFtcCB0aGF0IHRoZVxuICAgICAgLy8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHJhblxuXG4gICAgICBfdGhpcy5wcmV2aW91c1RpbWVTdGFtcCA9IC0xO1xuICAgICAgX3RoaXMuc3BlZWQgPSAxO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKiogKioqKioqKioqKioqKioqKioqKioqIGV4ZWN1dGlvbiBtZXRob2RzICAqKioqKioqKioqKioqKioqKioqKipcbiAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhQbGF5YWJsZSwgW3tcbiAgICAgIGtleTogXCJfc2V0U3RhdGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0U3RhdGUobmV3U3RhdGUpIHtcbiAgICAgICAgaWYgKG5ld1N0YXRlICE9PSB0aGlzLnJ1blRpbWVJbmZvLnN0YXRlKSB7XG4gICAgICAgICAgdGhpcy5ydW5UaW1lSW5mby5zdGF0ZSA9IG5ld1N0YXRlOyAvLyB0aGUgb25seSB0aW1lciBhbmQgdGhlIG9ubHkgcmVzcG9uc2libGUgZm9yIENsaXAgZXhlY3V0aW9uIGlzIHRoZSBDbGlwXG4gICAgICAgICAgLy8gQWxsIEluY2lkZW50cyBjb250YWluZWQgb24gYSBDbGlwIGFyZSBiZWVuIGV4ZWN1dGVkIGJ5IHRoZSBDbGlwIGl0c2VsZiB2aWEgaXRzIGNoYW5uZWxzLlxuICAgICAgICAgIC8vIFRodXMsIHRoZSBvbmx5IEluY2lkZW50cyB0aGF0IG5lZWQgdG8ga25vdyBhYm91dCB0aGUgc3RhdGUgb2YgdGhlIHJvb3QgQ2xpcFxuICAgICAgICAgIC8vIGF0IGFueSB0aW1lIGFyZSBvbmx5IHRoZSBDbGlwc1xuXG4gICAgICAgICAgdGhpcy5wdXRNZXNzYWdlT25QaXBlKCdzZXRTdGF0ZScsIG5ld1N0YXRlLCAnQ2xpcHMnLCB7XG4gICAgICAgICAgICBzZWxmRXhlY3V0ZTogZmFsc2UsXG4gICAgICAgICAgICBkaXJlY3Rpb246IF9ESVJFQ1RJT05TLl9ET1dOXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHZhciBsaXN0bmVyID0gdGhpcy5saXN0ZW5lcnNba2V5XTtcbiAgICAgICAgICAgIGxpc3RuZXIuZnVuY3QodGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQsIG5ld1N0YXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaGFuZGxlU2V0U3RhdGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVTZXRTdGF0ZSh0YXJnZXQsIHBheWxvYWQpIHtcbiAgICAgICAgdGhpcy5fc2V0U3RhdGUocGF5bG9hZCk7XG4gICAgICB9IC8vIGV4ZWN1dGlvbiBtZXRob2RzXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicGxheVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHBsYXkoKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG5cbiAgICAgICAgaWYgKHRoaXMucnVuVGltZUluZm8uc3RhdGUgPT09ICdpZGxlJyB8fCB0aGlzLnJ1blRpbWVJbmZvLnN0YXRlID09PSAncGF1c2VkJyB8fCB0aGlzLnJ1blRpbWVJbmZvLnN0YXRlID09PSAnYXJtZWQnIHx8IHRoaXMucnVuVGltZUluZm8uc3RhdGUgPT09ICd0cmFuc2l0aW9uYWwnIHx8IHRoaXMucnVuVGltZUluZm8uc3RhdGUgPT09ICdibG9ja2VkJykge1xuICAgICAgICAgIGlmICh0aGlzLnJ1blRpbWVJbmZvLnN0YXRlID09PSAncGF1c2VkJykge1xuICAgICAgICAgICAgdmFyIGRlbHRhID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLnBhdXNlTW9tZW50O1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91c1RpbWVTdGFtcCArPSBkZWx0YTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9zZXRTdGF0ZSgncGxheWluZycpO1xuXG4gICAgICAgICAgdGhpcy5vblBsYXkoKTtcblxuICAgICAgICAgIGlmIChkZWJ1ZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKHRpbWVzdGFtcCkge1xuICAgICAgICAgICAgICBfdGhpczIuc3RlcCh0aW1lc3RhbXApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInBhdXNlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgICAgIGlmICh0aGlzLnJ1blRpbWVJbmZvLnN0YXRlID09PSAncGxheWluZycpIHtcbiAgICAgICAgICB0aGlzLl9zZXRTdGF0ZSgncGF1c2VkJyk7XG5cbiAgICAgICAgICB0aGlzLnBhdXNlTW9tZW50ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgdGhpcy5vbldhaXQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyogYXJtZWQgc3RhdGUgbWVhbnMgdGhlIENsaXAgaXMgb24gcGF1c2VkIHN0YXRlIGFmdGVyIHRyYW5zaXRpb24gKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJhcm1cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhcm0oKSB7XG4gICAgICAgIGlmICh0aGlzLnJ1blRpbWVJbmZvLnN0YXRlID09PSAndHJhbnNpdGlvbmFsJykge1xuICAgICAgICAgIHRoaXMuX3NldFN0YXRlKCdhcm1lZCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNvbXBsZXRlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGxldGUoKSB7XG4gICAgICAgIHRoaXMuX3NldFN0YXRlKCdpZGxlJyk7XG5cbiAgICAgICAgdGhpcy5wcmV2aW91c1RpbWVTdGFtcCA9IC0xO1xuICAgICAgfVxuICAgICAgLyogaW4gb3JkZXIgdG8gc3RhcnQgYSBqb3VybmV5IHZpYSB0aGUgVGltZUNhcHN1bGUgdGhlIFBsYXlhYmxlIG5lZWRzIGZpcnN0IHRvIHN0b3AgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzdG9wXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgdGhpcy5fc2V0U3RhdGUoJ3RyYW5zaXRpb25hbCcpO1xuXG4gICAgICAgIHRoaXMucHJldmlvdXNUaW1lU3RhbXAgPSAtMTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYmxvY2tcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBibG9jaygpIHtcbiAgICAgICAgdGhpcy5fc2V0U3RhdGUoJ2Jsb2NrZWQnKTtcblxuICAgICAgICB0aGlzLnByZXZpb3VzVGltZVN0YW1wID0gLTE7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIm9uUGxheVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uUGxheSgpIHt9XG4gICAgfSwge1xuICAgICAga2V5OiBcIm9uV2FpdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uV2FpdCgpIHt9XG4gICAgfSwge1xuICAgICAga2V5OiBcInBsYXlhYmxlUHJvZ3Jlc3NcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwbGF5YWJsZVByb2dyZXNzKGZyYWN0aW9uLCBtaWxsaXNlY29uZCkge1xuICAgICAgICBpZiAodGhpcy5pc1RoZVJvb3RDbGlwKSB7XG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMubGlzdGVuZXJzKSB7XG4gICAgICAgICAgICB2YXIgbGlzdG5lciA9IHRoaXMubGlzdGVuZXJzW2tleV07IC8vIGlmIHRoZSBsaXN0ZW5lciBpcyBvbmx5IGZvciBzdGF0ZSBjaGFuZ2UgY29udGludWVcblxuICAgICAgICAgICAgaWYgKGxpc3RuZXIub25seU9uU3RhdGVDaGFuZ2UgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IC8vIGNvbnNvbGUubG9nKGBNYXRoLmFicygke21pbGxpc2Vjb25kc30gKyAke2xpc3RuZXIuY2F2YURlbHRhfSAtICR7dGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmR9KSA+ICR7bGlzdG5lci50aHJlc2hvbGR9YCk7XG5cblxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKG1pbGxpc2Vjb25kICsgbGlzdG5lci5jYXZhRGVsdGEgLSB0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCkgPiBsaXN0bmVyLnRocmVzaG9sZCkge1xuICAgICAgICAgICAgICBsaXN0bmVyLmZ1bmN0KHJvdW5kTnVtYmVyVG8obWlsbGlzZWNvbmQsIGxpc3RuZXIucm91bmRUbyksIHRoaXMucnVuVGltZUluZm8uc3RhdGUpO1xuICAgICAgICAgICAgICBsaXN0bmVyLmNhdmFEZWx0YSA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsaXN0bmVyLmNhdmFEZWx0YSArPSBNYXRoLmFicyhtaWxsaXNlY29uZCAtIHRoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLm9uUHJvZ3Jlc3MoZnJhY3Rpb24sIG1pbGxpc2Vjb25kKTtcbiAgICAgICAgICB0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCA9IG1pbGxpc2Vjb25kO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzdGVwXCIsXG4gICAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAvLyBTVEVQIEZVTkNUSU9OXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc3RlcCh0aW1lc3RhbXApIHtcbiAgICAgICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgICAgICBpZiAodGhpcy5ydW5UaW1lSW5mby5zdGF0ZSAhPT0gJ3BsYXlpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgIGlmICh0aGlzLnByZXZpb3VzVGltZVN0YW1wID09PSAtMSkge1xuICAgICAgICAgIHRoaXMucHJldmlvdXNUaW1lU3RhbXAgPSB0aW1lc3RhbXA7XG4gICAgICAgIH0gLy8gcHJvZ3Jlc3NTdGVwIGlzIHRoZSBwcm9ncmVzcyBtYWRlIGZyb20gcHJldmlvdXNUaW1lU3RhbXAgYm90aCBpbiBtaWxsaXNlY29uZHMgYW5kIGluIGZyYWN0aW9uIFswIHRvIDFdXG5cblxuICAgICAgICB2YXIgcHJvZ3Jlc3MgPSB7XG4gICAgICAgICAgbWlsbGlzZWNvbmRzOiBNYXRoLnJvdW5kKHRoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kICsgKHRpbWVzdGFtcCAtIHRoaXMucHJldmlvdXNUaW1lU3RhbXApICogdGhpcy5zcGVlZCksXG4gICAgICAgICAgZnJhY3Rpb246ICh0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCArICh0aW1lc3RhbXAgLSB0aGlzLnByZXZpb3VzVGltZVN0YW1wKSAqIHRoaXMuc3BlZWQpIC8gdGhpcy5kdXJhdGlvblxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChwcm9ncmVzcy5mcmFjdGlvbiA+PSAxKSB7XG4gICAgICAgICAgdGhpcy5wbGF5YWJsZVByb2dyZXNzKDEsIHRoaXMuZHVyYXRpb24pO1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvZ3Jlc3MuZnJhY3Rpb24gPCAwKSB7XG4gICAgICAgICAgdGhpcy5wbGF5YWJsZVByb2dyZXNzKDAsIDApO1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoKTsgLy8gdGhpcy5icm9hZGNhc3RFdmVudCgnc3RhdGUtY2hhbmdlJywgeyBvbGRTdGF0ZTogXCJwbGF5aW5nXCIsIG5ld1N0YXRlOiBcImlkbGVcIiB9KTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucGxheWFibGVQcm9ncmVzcyhwcm9ncmVzcy5mcmFjdGlvbiwgcHJvZ3Jlc3MubWlsbGlzZWNvbmRzKTtcbiAgICAgICAgdGhpcy5wcmV2aW91c1RpbWVTdGFtcCA9IHRpbWVzdGFtcDtcblxuICAgICAgICBpZiAoZGVidWcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGF0LnN0ZXAuYmluZCh0aGF0KSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gKioqKioqKioqKioqIFBVQiBTVUIgKioqKioqKioqKioqKioqKioqKipcbiAgICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgICAgIC8qKlxuICAgICAgICAgIEJ5IHN1YnNjcmliaW5nIGEgbW9kdWxlIGNhbiBnZXQgbm90aWZpZWQgYWJvdXQgY2hhbmdlcyBvbiB0aGUgQ2xpcCdzIHRpbWVcbiAgICAgICAgICBzdWJzY3JpYmUgbWV0aG9kIHN1YnNjcmliZXMgYSBmdW5jdGlvbiB0byB0aGUgdGltZSBjaGFuZ2UgZGlzcGF0Y2hlci4gQXMgQ2xpcCB1c2VzIHJlcXVlc3RBbmltYXRpb25GcmFtZSBmb3IgaXRzIHRpbWluZ1xuICAgICAgICAgIGVhY2ggY3lyY2xlIC8gc3RlcCBnZXRzIHRoZSBjdXJyZW50IHRpbWUgYW5kIHN1YnRyYWN0cyB0aGUgcHJldmlvdXMgdGltZSBzbyBpdCBrbm93IGhvdyBtYW55IG1pbGxpc2Vjb25kcyBoYXMgZWxhcHNlZFxuICAgICAgICAgIHNpbmNlIGxhc3Qgc3RlcC4gU3Vic2NyaWJlcnMgY2FuIHNldCB0byBnZXQgaW5mb3JtZWQgYWJvdXQgdGltZSBjaGFuZ2VzIG9ubHkgaWYgdGhlIGRlbHRhIGlzIGdyZWF0ZXIgdGhhbiBhIGdpdmVuXG4gICAgICAgICAgbnVtYmVyIChlLmcuIGdyZWF0ZXIgdGhhbiAzMDBtcykuIFRoYXQgcHJvcGVydHkgaXMgcGFzc2VkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgXCJ0aHJlc2hvbGRcIi5cbiAgICAgICAgICBGaW5hbGx5IGlmIGFueSBvZiB0aGUgc3Vic2NyaWJlcnMgd2FudCB0aGUgU2NlbmUgdG8gcHJvdmlkZSBiYWNrIGEgcm91bmRlZCBudW1iZXIgb2YgdGhlIG1pbGxpc2Vjb25kcy4gT3B0aW9uczpcbiAgICAgICAgICAgIC0gMSAocm91bmQgaXQgb24gaXRzIGFjdHVhbCB1bml0c1xuICAgICAgICAgICAtIDEwIChyb3VuZCBpdCBvbiB0ZW50aHMpXG4gICAgICAgICAgIC0gMTAwIChyb3VuZCBpdCBvbiBodW5kcmVkcylcbiAgICAgICAgICAgLSAxMDAwIChyb3VuZCBpdCBvbiB0aG91c2FuZHMpXG4gICAgICAgICAgdGhlIGZpcnN0IGFyZ3VtZW50IHByb3ZpZGVzIGFuIGlkIHRvIHRoZSBsaXN0ZW5lciBmb3IgZnV0dXJlIHJlZmVyZW5jZSAoZGVsZXRpb24gZXRjKVxuICAgICAgICAgIHRoZSBzZWNvbmQgYXJndW1lbnQgaXMgYSBmdW5jdGlvbiB0aGF0IHRha2VzIHR3byBhcmd1bWVudHM6IG1pbGxpc2Vjb25kLCBzdGF0ZSAoY3VycmVudCBtaWxsaXNlY29uZCBvZiB0aGUgU2NlbmVcbiAgICAgICAgICBhbmQgdGhlIHN0YXRlIG9mIGl0ICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInN1YnNjcmliZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN1YnNjcmliZShpZCwgZnVuY3QsIHRocmVzaG9sZCwgcm91bmRUbykge1xuICAgICAgICB2YXIgb25seU9uU3RhdGVDaGFuZ2UgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IGZhbHNlO1xuXG4gICAgICAgIGlmICghdGhyZXNob2xkKSB7XG4gICAgICAgICAgdGhyZXNob2xkID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcm91bmRUbykge1xuICAgICAgICAgIHJvdW5kVG8gPSAxOyAvLyByb3VuZCBzZWNvbmQgdG8gaXRzIHVuaXRzLCBtZWFuaW5nIGxlYXZlIGl0IGFzIGl0IGlzXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxpc3RlbmVyc1tpZF0gPSB7XG4gICAgICAgICAgZnVuY3Q6IGZ1bmN0LFxuICAgICAgICAgIHRocmVzaG9sZDogdGhyZXNob2xkLFxuICAgICAgICAgIHJvdW5kVG86IHJvdW5kVG8sXG4gICAgICAgICAgY2F2YURlbHRhOiAwLFxuICAgICAgICAgIG9ubHlPblN0YXRlQ2hhbmdlOiBvbmx5T25TdGF0ZUNoYW5nZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJ1bnN1YnNjcmliZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVuc3Vic2NyaWJlKGlkKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5saXN0ZW5lcnMsIGlkKSkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLmxpc3RlbmVyc1tpZF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic3Vic2NyaWJlVG9EdXJhdGlvbkNoYW5nZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN1YnNjcmliZVRvRHVyYXRpb25DaGFuZ2UoZnVuY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNUaGVSb290Q2xpcCkge1xuICAgICAgICAgIHRoaXMucmVhbENsaXAuc3Vic2NyaWJlVG9EdXJhdGlvbkNoYW5nZShmdW5jdCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImV4ZWN1dGlvblNwZWVkXCIsXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChzcGVlZCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNUaGVSb290Q2xpcCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3BlZWQgPSBwYXJzZUZsb2F0KHNwZWVkKTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gUGxheWFibGU7XG4gIH0oRGVzY3JpcHRpdmVHcm91cCk7XG5cbiAgLypcbiAgZG5hOiB7XG4gICAgICBob3N0XG4gICAgICBkZXNjcmlwdGl2ZUluY2lkZW50XG4gIH1cbiAgKi9cblxuICB2YXIgQ2xpcENsb25lID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2xpcENsb25lKGRuYSkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENsaXBDbG9uZSk7XG5cbiAgICAgIHRoaXMucnVuVGltZUluZm8gPSB7XG4gICAgICAgIGN1cnJlbnRNaWxsaXNlY29uZDogMCxcbiAgICAgICAgc3RhdGU6ICd0cmFuc2l0aW9uYWwnXG4gICAgICB9O1xuICAgICAgdGhpcy5pZCA9IGdldEFuSWQoKTtcbiAgICAgIHRoaXMucmVhbENsaXAgPSBkbmEuZGVzY3JpcHRpdmVJbmNpZGVudC5yZWFsQ2xpcDsgLy8gSW4gb3JkZXIgdG8gcmVuZGVyIGl0c2VsZiBvbiB0aGUgZ2l2ZW4gZWxlbWVudCBmaXJzdCBpdCBuZWVkcyB0aGUgcHJvcHMgKGluY2x1ZGluZyBodG1sIGFuZCBjc3MpXG4gICAgICAvLyBmcm9tIHRoZSByZWFsIENsaXAgaXQgY29waWVzXG5cbiAgICAgIHZhciBjb25zdHJ1Y3Rpb25BcmdzID0gZG5hLmRlc2NyaXB0aXZlSW5jaWRlbnQucmVhbENsaXAuZXhwb3J0Q29uc3RydWN0aW9uQXJndW1lbnRzKCk7IC8vIGl0IHByb3Blcmx5IHNldHMgaXRzIG93biBob3N0IG9uIHRoZSBwcm9wcyB0byB1c2UgdG8gaW5pdGlhbGlzZSBpdHMgb3duIGNsaXBcblxuICAgICAgdmFyIGhvc3RlZFByb3BzID0gX29iamVjdFNwcmVhZDIoe30sIGNvbnN0cnVjdGlvbkFyZ3MucHJvcHMsIHtcbiAgICAgICAgc2VsZWN0b3I6IHVuZGVmaW5lZCxcbiAgICAgICAgaG9zdDogZG5hLmhvc3QsXG4gICAgICAgIGlkOiB0aGlzLmlkXG4gICAgICB9KTsgLy8gd2UgY3JlYXRlIGEgY2xpcCBiZWNhdXNlIENsaXBzIG9uIGNyZWF0aW9uIHJlbmRlciBhbmQgdGh1cyBoYXZlIHRoZWlyIG93biBjb250ZXh0XG5cblxuICAgICAgdGhpcy5vd25DbGlwID0gbmV3IGRuYS5kZXNjcmlwdGl2ZUluY2lkZW50LmNvbnN0cnVjdG9yLkluY2lkZW50KGNvbnN0cnVjdGlvbkFyZ3MuYXR0cnMsIGhvc3RlZFByb3BzKTsgLy8gZmx1c2hlcyB0aGUgcmVhbENsaXAgd2l0aCBpdHMgb3duQ2xpcCdzIGNvbnRleHRcblxuICAgICAgZG5hLmRlc2NyaXB0aXZlSW5jaWRlbnQucmVhbENsaXAuYWRkQ29udGV4dCh7XG4gICAgICAgIGNsaXBJZDogdGhpcy5pZCxcbiAgICAgICAgY29udGV4dDogdGhpcy5vd25DbGlwLm93bkNvbnRleHQsXG4gICAgICAgIHN5bmNocm9uaXplOiBkbmEuc3luY2hyb25pemUsXG4gICAgICAgIHJ1blRpbWVJbmZvOiB0aGlzLnJ1blRpbWVJbmZvXG4gICAgICB9LCB0cnVlKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoQ2xpcENsb25lLCBbe1xuICAgICAga2V5OiBcIm9uUHJvZ3Jlc3NcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBvblByb2dyZXNzKGZyYWN0aW9uLCBtaWxsaXNlY29uZHMpIHtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5yZWFsQ2xpcC5pbnN0YW50aWF0ZWRDaGFubmVscykge1xuICAgICAgICAgIHZhciBjaGFubmVsID0gdGhpcy5yZWFsQ2xpcC5pbnN0YW50aWF0ZWRDaGFubmVsc1trZXldO1xuICAgICAgICAgIGNoYW5uZWwubW92ZVRvKHRoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kLCBtaWxsaXNlY29uZHMsIHRoaXMuaWQsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQgPSBtaWxsaXNlY29uZHM7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIENsaXBDbG9uZTtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiBBbG9uZyB3aXRoIHRoZSBleHBlY3RlZCBwcm9wcyBmb3IgdGhlIENsaXAgb24gdGhlIHByb3BzIHN1cHBvcnQgdGhlIGF1ZGlvIGtleS5cbiAgICogVGhlIGF1ZGlvIGNhbiB0YWtlIG9uZSBvZiB0aGUgMyBmb2xsb3dpbmcgdmFsdWVzOlxuICAgKiAtIFwib25cIjogVGhlIENsaXAgaGFzIGF1ZGlvIGVuYWJsZWRcbiAgICogLSBcIm9mZlwiOiBUaGUgQ2xpcCBoYXMgYXVkaW8gZGlzYWJsZWRcbiAgICogLSBcIm9ubHlcIjogVGhlIENsaXAgaXMgb25seSBhdWRpb1xuICAgKlxuICAgKiBBbHNvLCBpbiB0aGUgY2FzZSBhdWRpbyBpcyBvbiBvciBvbmx5IHRoZSB1c2VyIHNob3VsZCBwYXNzIHRoZSBcImF1ZGlvU291cmNlc1wiXG4gICAqIGtleSBjb250YWluaW5nIGFsbCB0aGUgYXVkaW8gc291cmNlcyB0aGV5IHdhbnQgdG8gcGFzcyBvbiB0aGUgQXVkaW8gQ29udGV4dFxuICAgKiBvZiB0aGVpciBjbGlwLiBQbGVhc2UgY2hlY2sgQXVkaW9DbGlwIGZvciBkZXRhaWxzIG9uIHRoZSBleHBlY3RlZCBmb3JtYXRcbiAgICogKi9cblxuICB2YXIgRGVzY3JpcHRpdmVDbGlwID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoX1BsYXlhYmxlKSB7XG4gICAgX2luaGVyaXRzKERlc2NyaXB0aXZlQ2xpcCwgX1BsYXlhYmxlKTtcblxuICAgIGZ1bmN0aW9uIERlc2NyaXB0aXZlQ2xpcChhdHRycykge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEZXNjcmlwdGl2ZUNsaXApO1xuXG4gICAgICB2YXIgYXR0cnNUb1Bhc3M7XG4gICAgICB2YXIgcHJvcHNUb1VzZTtcblxuICAgICAgaWYgKHByb3BzID09PSBudWxsKSB7XG4gICAgICAgIGF0dHJzVG9QYXNzID0ge307XG4gICAgICAgIHByb3BzVG9Vc2UgPSBhdHRycztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGVsc2UsIGluIGNhc2UgdGhlIHVzZXIgaGFzIHBhc3NlZCB0d28gYXJndW1lbnRzIHRoZW4gYm90aCBzaG91bGQgYmUgdXNlZFxuICAgICAgICBhdHRyc1RvUGFzcyA9IGF0dHJzO1xuICAgICAgICBwcm9wc1RvVXNlID0gcHJvcHM7XG4gICAgICB9XG5cbiAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKERlc2NyaXB0aXZlQ2xpcCkuY2FsbCh0aGlzLCBhdHRyc1RvUGFzcywgcHJvcHNUb1VzZSkpO1xuXG4gICAgICB2YXIgcHJvcHNWYWxpZGF0aW9uID0gX3RoaXMuX3ZhbGlkYXRlUHJvcHMoKTtcblxuICAgICAgaWYgKHByb3BzVmFsaWRhdGlvbi5yZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgcHJvcHNWYWxpZGF0aW9uKTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuYXR0cnNWYWxpZGF0aW9uUnVsZXMgPSB7fTtcbiAgICAgIF90aGlzLnByb3BzVmFsaWRhdGlvblJ1bGVzID0gY2xpcFByb3BzUnVsZTsgLy8gaXNUaGVSb290Q2xpcCBkZWZpbmVzIHdoZXRoZXIgdGhlIENsaXAgaXMgdGhlIHJvb3Qgb3Igbm90LiBJdCBkZXBlbmRzIG9uXG4gICAgICAvLyB0aGUgaG9zdCBvciBzZWxlY3RvciBwYXJhbWV0ZXIgcGFzc2VkIG9uIHByb3BzIChpZiBob3N0IGlzIHByZXNlbnQgdGhlblxuICAgICAgLy8gdGhlIENsaXAgaXMgdGhlIHJvb3QgQ2xpcCB3aGlsZSBpZiB0aGUgQ2xpcCBnZXRzIGluaXRpYWxpc2VkIGJ5IGEgc2VsZWN0b3JcbiAgICAgIC8vIGlzIG5vdClcblxuICAgICAgX3RoaXMuaXNUaGVSb290Q2xpcCA9IGZhbHNlOyAvLyBjaGVjayBpZlxuXG4gICAgICB2YXIgaW5ncmVkaWVudHMgPSB7XG4gICAgICAgIGlkOiBfdGhpcy5pZCxcbiAgICAgICAgYXR0cnM6IGF0dHJzVG9QYXNzLFxuICAgICAgICBwcm9wczogX29iamVjdFNwcmVhZDIoe30sIHByb3BzVG9Vc2UsIHtcbiAgICAgICAgICBodG1sOiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvcHNUb1VzZSwgJ2h0bWwnKSA/IHByb3BzVG9Vc2UuaHRtbCA6IF90aGlzLmh0bWwsXG4gICAgICAgICAgY3NzOiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvcHNUb1VzZSwgJ2NzcycpID8gcHJvcHNUb1VzZS5jc3MgOiBfdGhpcy5jc3MsXG4gICAgICAgICAgZm9udHM6IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm9wc1RvVXNlLCAnZm9udHMnKSA/IHByb3BzVG9Vc2UuZm9udHMgOiBfdGhpcy5mb250cyxcbiAgICAgICAgICBydW5UaW1lSW5mbzogX3RoaXMucnVuVGltZUluZm8sXG4gICAgICAgICAgc3Vic2NyaWJlOiBfdGhpcy5zdWJzY3JpYmUuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSlcbiAgICAgICAgfSksXG4gICAgICAgIHBsdWdpbl9ucG1fbmFtZTogX3RoaXMuY29uc3RydWN0b3IucGx1Z2luX25wbV9uYW1lLFxuICAgICAgICBDaGFubmVsOiBfdGhpcy5jb25zdHJ1Y3Rvci5DaGFubmVsLFxuICAgICAgICBEZXNjcmlwdGl2ZUluY2lkZW50OiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKVxuICAgICAgfTsgLy8gRGVjaWRlIHdoYXQga2luZCBvZiBhdWRpbyAob3Igbm9uLWF1ZGlvKSBDbGlwIHdlIGFyZSBkZWFsaW5nIHdpdGhcblxuICAgICAgX3RoaXMuYXVkaW8gPSAnb24nO1xuXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF90aGlzLmNvbnN0cnVjdG9yLCAnYXVkaW8nKSkge1xuICAgICAgICBfdGhpcy5hdWRpbyA9IF90aGlzLmNvbnN0cnVjdG9yLmF1ZGlvO1xuICAgICAgfVxuXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzVG9Vc2UsICdhdWRpbycpKSB7XG4gICAgICAgIF90aGlzLmF1ZGlvID0gcHJvcHNUb1VzZS5hdWRpbztcbiAgICAgIH0gLy8gZGVjaWRlIGlmIHRoaXMgaXMgdGhlIHJvb3QgY2xpcFxuXG5cbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvcHNUb1VzZSwgJ3NlbGVjdG9yJykgJiYgcHJvcHNUb1VzZS5zZWxlY3RvciAhPT0gdW5kZWZpbmVkICYmIF90aGlzLmNvbnN0cnVjdG9yLmN1c3RvbUNsaXAgIT09IHRydWUpIHtcbiAgICAgICAgaW5ncmVkaWVudHMuSW5jaWRlbnQgPSBGcmFnbWVudGVkQ2xpcDsgLy8gVE9ETyBpdCBkb2Vzbid0IHRha2UgaW4gYWNjb3VudCB0aGUgZ2V0IGh0bWwgYW5kIGdldCBjc3Mgb2YgdGhlIERlc2NyaXB0aXZlIENsaXBcbiAgICAgIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzVG9Vc2UsICdzZWxlY3RvcicpICYmIHByb3BzVG9Vc2Uuc2VsZWN0b3IgIT09IHVuZGVmaW5lZCAmJiBfdGhpcy5jb25zdHJ1Y3Rvci5jdXN0b21DbGlwID09PSB0cnVlKSB7XG4gICAgICAgIGRlbGV0ZSBpbmdyZWRpZW50cy5wcm9wcy5zZWxlY3RvcjtcbiAgICAgICAgdmFyIEZyYWdtZW50V3JhcHBlciA9IG5ldyBGcmFnbWVudGVkQ2xpcCh7XG4gICAgICAgICAgaHRtbDogJzxkaXYgaWQ9XCJjbGlwLWNvbnRhaW5lclwiPjwvZGl2PidcbiAgICAgICAgfSk7XG4gICAgICAgIGluZ3JlZGllbnRzLnByb3BzLmhvc3QgPSBGcmFnbWVudFdyYXBwZXIucm9vdEVsZW1lbnQ7XG4gICAgICAgIGluZ3JlZGllbnRzLkluY2lkZW50ID0gX3RoaXMuY29uc3RydWN0b3IuSW5jaWRlbnQ7XG4gICAgICB9IGVsc2UgaWYgKF90aGlzLmF1ZGlvID09PSAnb25seScgJiYgX3RoaXMucHJvcHMucm9vdCAhPT0gdHJ1ZSkge1xuICAgICAgICAvLyBhdWRpb0NsaXBzIGNhbiBuZXZlciBiZSB0aGUgcm9vdFxuICAgICAgICBfdGhpcy5pc1RoZVJvb3RDbGlwID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy5pc1RoZVJvb3RDbGlwID0gdHJ1ZTtcbiAgICAgICAgLypcbiAgICAgICAgICAgICAgYmxvY2tpbmdXYWl0aW5ncyBhcmUgYmVlbiB0cmlnZ2VyZWQgYnkgSW5jaWRlbnRzIHdoZW4gdGhlcmUgaXMgdGhlXG4gICAgICAgICAgICAgIG5lZWQgdG8gaGFsdCB0aGUgQ2xpcCdzIGV4ZWN1dGlvbiBhbmQgd2FpdC4gQXMgYW4gZXhhbXBsZSBhIGJsb2NraW5nXG4gICAgICAgICAgICAgIHdhaXRpbmcgY2FuIGJlIHNldCBieSBhbiBBdWRpbyBQbGF5YmFjayBJbmNpZGVudCB3aGVuIHRoZSBhdWRpbyBoYXNcbiAgICAgICAgICAgICAgbm90IGJlZW4gbG9hZGVkIHlldC5cbiAgICAgICAgICAgICAgRWFjaCBibG9ja2luZyB3YWl0aW5nIGhhcyBhbiBpZCBhbmQgdmlhIHRoZSBzYW1lIGlkIHRoZSB3YWl0aW5nIGNhbiBiZVxuICAgICAgICAgICAgICB1bmJsb2NrZWQuXG4gICAgICAgICAgICAgIFRoZSBibG9ja2luZ1dhaXRpbmdzIHByb3BlcnR5IG9mIHRoZSByb290IENsaXAgaXMgYSBjb2xsZWN0aW9uIHdpdGhcbiAgICAgICAgICAgICAga2V5cyB0aGUgYmxvY2tpbmcgd2FpdGluZ3MgaWRzIGFuZCB2YWx1ZXMgdGhlIGRlc2NyaXB0aW9uIG9mIGVhY2ggd2FpdGluZ1xuICAgICAgICAgICAgICB3aGljaCBjb25zaXN0cyBvZjpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWRcbiAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgICBpbmNpZGVudElkXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgVGhlIGJsb2NraW5nIHdhaXRpbmdzIGFyZSB0cmlnZ2VyZWQgYnkgcmVhbCBJbmNpZGVudHMgbGl2aW5nIG9uIHRoZSByZWFsXG4gICAgICAgICAgICAgIENsaXBzIG9mIHRoZSBEZXNjcmlwdGl2ZSBDbGlwIChlaXRoZXIgdGhlIGF1ZGlvQ2xpcCBvciB0aGUgcmVhbENsaXApLlxuICAgICAgICAgICAgICBUaGUgcm9vdCB0aGF0IGEgd2FpdGluZyBzZXQgb3IgdW5zZXQgZm9sbG93cyBpcyBmcm9tIGFueSByZWFsIGluY2lkZW50XG4gICAgICAgICAgICAgIHVwIHRvIGl0cyBDb250ZXh0QXdhcmUgSW5jaWRlbnQgYW5kIGZyb20gdGhlcmVcbiAgICAgICAgICAgICAgdXAgdG8gdGhlIHJlYWwgQ2xpcCBhbmQgZnJvbSB0aHJlIHRvIGl0cyBEZXNjcmlwdGl2ZVRyZWUgYW5kIGZyb20gdGhlcmVcbiAgICAgICAgICAgICAgYWxsIHRoZSB3YXkgdXAgdG8gdGhlIHJvb3QgRGVzY3JpcHRpdmUgQ2xpcC5cbiAgICAgICAgICAgICAgQmxvY2tpbmcgd2FpdGluZ3MgbXVzdCBhbHdheXMgYmUgdHJpZ2dlcmVkIG9uIHRoZSBcIm9uUHJvZ3Jlc3NcIiBvciBvblxuICAgICAgICAgICAgICB0aGUgXCJwbGF5XCIgbWV0aG9kcyBvZiBJbmNpZGVudHMuIFNldHRpbmcgYSBibG9ja2luZyB3YWl0aW5nIGZyb20gYW55d2hlcmVcbiAgICAgICAgICAgICAgZWxzZSBpcyBhbiBlcnJvclxuICAgICAgICAgICAgICAqL1xuXG4gICAgICAgIF90aGlzLmJsb2NraW5nV2FpdGluZ3MgPSB7fTtcbiAgICAgICAgaW5ncmVkaWVudHMuSW5jaWRlbnQgPSBfdGhpcy5jb25zdHJ1Y3Rvci5JbmNpZGVudDtcbiAgICAgIH0gLy8gd2UgaW5pdGlhbGlzZSByZWFsIGFuZCBhdWRpbyBjbGlwcyBvZiB0aGUgQ2xpcCBieSBjaGVja2luZyB0aGUgc3RhdGljIGF1ZGlvXG4gICAgICAvLyBwcm9wZXJ0eVxuICAgICAgLy8gdGhlIHByb3BlcnR5IHRoaXMuYXVkaW8gaGVscHMgaW5jaWRlbnRGcm9tRGVzY3JpcHRpb24gaWRlbnRpZnkgaWYgdGhlIEluY2lkZW50XG4gICAgICAvLyBwYXJ0aWNpcGF0ZXMgb3Igbm90IG9uIHRoZSBhdWRpb0NsaXAuIEJ5IGRlZmF1bHQgaXMgXCJvblwiIGJ1dCBpZiB0aGUgcHJvcHMuYXVkaW8gaXMgc2V0IHRvIG9mZlxuICAgICAgLy8gaXQgdHVybnMgdG8gXCJvZmZcIiBzbyB0aGUgREMgZ2V0cyB0b3RhbGx5IGlnbm9yZWQgb24gdGhlIGFkZGl0aW9uIHByb2Nlc3Mgb24gYXVkaW8gY2xpcFxuXG4gICAgICAvKiBUaGUgYXVkaW8gdmFsdWUgaXMgc2V0IGluIHRoZSBmb2xsb3dpbmcgbWFubmVyXG4gICAgICAgICAgICAgIC0gZmlyc3Qgd2UgY2hlY2sgaWYgdGhlIENsYXNzIGhhcyBhIHN0YXRpYyBhdWRpbyBwYXJhbWV0ZXIgYW5kIGlmIHllcyB3ZSBrZWVwIGl0XG4gICAgICAgICAgICAgIC0gdGhlbiB3ZSBjaGVjayBpZiB0aGlzLnByb3BzIGhhcyB0aGUgYXVkaW8ga2V5IGFuZCBpZiB5ZXMgd2Uga2VlcCB0aGlzIG9uZVxuICAgICAgICAgICAgICAtIG90aGVyd2lzZSB3ZSB1c2UgdGhlIGRlZmF1bHQgKFwib25cIilcbiAgICAgICAgICAqL1xuXG5cbiAgICAgIGlmIChfdGhpcy5hdWRpbyA9PT0gJ29uJyB8fCBfdGhpcy5hdWRpbyA9PT0gJ29mZicpIHtcbiAgICAgICAgX3RoaXMucmVhbENsaXAgPSBpbmNpZGVudEZyb21JbmdyZWRpZW50cyhpbmdyZWRpZW50cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy5yZWFsQ2xpcCA9IG5ldyBOdWxsQ2xpcCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoX3RoaXMuYXVkaW8gPT09ICdvbicgfHwgX3RoaXMuYXVkaW8gPT09ICdvbmx5Jykge1xuICAgICAgICB2YXIgYXVkaW9JbmdyZWRpZW50cyA9IHtcbiAgICAgICAgICBpZDogX3RoaXMuaWQsXG4gICAgICAgICAgYXR0cnM6IHt9LFxuICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBhdWRpb1NvdXJjZXM6IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm9wc1RvVXNlLCAnYXVkaW9Tb3VyY2VzJykgPyBwcm9wc1RvVXNlLmF1ZGlvU291cmNlcyA6IF90aGlzLmF1ZGlvU291cmNlcyxcbiAgICAgICAgICAgIHJ1blRpbWVJbmZvOiBfdGhpcy5ydW5UaW1lSW5mbyxcbiAgICAgICAgICAgIHN1YnNjcmliZTogX3RoaXMuc3Vic2NyaWJlLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwbHVnaW5fbnBtX25hbWU6IF90aGlzLmNvbnN0cnVjdG9yLnBsdWdpbl9ucG1fbmFtZSxcbiAgICAgICAgICBDaGFubmVsOiBfdGhpcy5jb25zdHJ1Y3Rvci5DaGFubmVsLFxuICAgICAgICAgIEluY2lkZW50OiBBdWRpb0NsaXAsXG4gICAgICAgICAgRGVzY3JpcHRpdmVJbmNpZGVudDogX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcylcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuYXVkaW9DbGlwID0gaW5jaWRlbnRGcm9tSW5ncmVkaWVudHMoYXVkaW9JbmdyZWRpZW50cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy5hdWRpbyA9ICdvZmYnO1xuICAgICAgICBfdGhpcy5hdWRpb0NsaXAgPSBuZXcgTnVsbENsaXAoKTtcbiAgICAgIH0gLy8gcGFzc2l2ZUFkZGl0aW9uIGlzIGEgZmxhZyBwcm9wZXJ0eSBpbmRpY2F0aW5nIHRoYXQgYW55IEluY2lkZW50IHRvIGJlXG4gICAgICAvLyBhZGRlZCB0byB0aGUgQ2xpcCB3aWxsIGJlIHBhc3NpdmUuIEl0IGluaXRpYWxpc2VzIHdpdGggdmFsdWUgPSBmYWxzZVxuICAgICAgLy8gb24gRGVzY3JpcHRpdmVHcm91cCB3aGVyZSBpdCdzIG9yaWdpbmFseSBkZWZpbmVkLlxuICAgICAgLy8gSGVyZSB3ZSBjaGFuZ2UgaXRzIHZhbHVlIGp1c3QgYmVmb3JlIHRoZSBidWlsZFRyZWUgbWV0aG9kIGV4ZWN1dGlvblxuICAgICAgLy8gc28gYWxsIEluY2lkZW50cyBhZGRlZCBvbiBpdCBnZXQgdGhlIFwicGFzc2l2ZVwiIGZsYWcgYW5kIGRvbid0IGdldFxuICAgICAgLy8gZXhwb3J0ZWQgb24gdGhlIGV4cG9ydERlZmluaXRpb24gbWV0aG9kLiBPbmNlIHRoZSBidWlsZFRyZWUgbWV0aG9kXG4gICAgICAvLyBmaW5pc2hlcyB3ZSBzZXQgaXQgYmFjayB0byBpdHMgb3JpZ2luYWwgdmFsdWUgKGZhbHNlKVxuXG5cbiAgICAgIF90aGlzLnBhc3NpdmVBZGRpdGlvbiA9IHRydWU7XG5cbiAgICAgIF90aGlzLl9idWlsZFRyZWUoKTtcblxuICAgICAgX3RoaXMucGFzc2l2ZUFkZGl0aW9uID0gZmFsc2U7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKERlc2NyaXB0aXZlQ2xpcCwgW3tcbiAgICAgIGtleTogXCJfdmFsaWRhdGVQcm9wc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF92YWxpZGF0ZVByb3BzKCkge1xuICAgICAgICByZXR1cm4gaGVscGVyLnZhbGlkYXRlUHJvcHMoe1xuICAgICAgICAgIHByb3BzOiB0aGlzLnByb3BzXG4gICAgICAgIH0sIGNsaXBQcm9wc1J1bGUsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfYnVpbGRUcmVlXCIsXG5cbiAgICAgIC8qXG4gICAgICAgIHRoZSBfYnVpbGRUcmVlIG1ldGhvZCBhY3RzIGFzIGEgcHJveHkgdG8gdGhlIGJ1aWxkVHJlZSBtZXRob2QgZGVmaW5lZCBieSB0aGVcbiAgICAgICAgZGV2ZWxvcGVycy4gVGhlIHJlYXNvbiBmb3IgdGhpcyBpcyB0aGF0IHRoZSBhY3R1YWwgYnVpbGRUcmVlIG1ldGhvZCBzaG91bGRcbiAgICAgICAgYmUgZXhlY3V0ZWQgaW4gZGlmZmVyZW50IG9yZGVyIG9uIEdyb3VwcyBhbmQgb24gQ2xpcHMgKHRoYXQgZXh0ZW5kIEdyb3VwcykuXG4gICAgICAgIENhbGxpbmcgdGhlIHN1cGVyIG9uIGNvbnN0cnVjdG9yIGZpcmVzIHRoZSBfYnVpbGRUcmVlIGV4ZWN1dGlvbiBvbiB0aGVcbiAgICAgICAgR3JvdXAncyBjb25zdHJ1Y3RvciBidXQgdGhpcyBicmVha3Mgb24gQ2xpcCBhcyB0aGUgcmVhbENsaXAgaGFzIG5vdCBiZWVuXG4gICAgICAgIGluaXRpYWxpc2VkIHlldC5cbiAgICAgICAgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYnVpbGRUcmVlKCkge1xuICAgICAgICBpZiAodGhpcy5yZWFsQ2xpcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5idWlsZFRyZWUoKTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogV2hlbiB0aGUgcmVzaXplIGNvbW1hbmQgaXMgZ2l2ZW4gZGlyZWN0bHkgdG8gYSBEZXNjcmlwdGl2ZUNsaXAgbm8gY2hlY2tzXG4gICAgICAgKiBuZWVkIHRvIGJlIHBlcmZvcm1lZC5cbiAgICAgICAqIERlc2NyaXB0aXZlQ2xpcCBkaXJlY3RseSBpbnZva2VzIHRoZSBfcmVzaXplIG1ldGhvZCBvZiBFeHRlbmRhYmxlQ2xpcCB3aGljaFxuICAgICAgICogcmVzaXplcyB0aGUgZnVsbCBjbGlwXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZXNpemVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUobmV3U2l6ZSkge1xuICAgICAgICB0aGlzLnJlYWxDbGlwLl9yZXNpemUobmV3U2l6ZSAvIHRoaXMuZHVyYXRpb24pO1xuXG4gICAgICAgIHRoaXMuYXVkaW9DbGlwLl9yZXNpemUobmV3U2l6ZSAvIHRoaXMuZHVyYXRpb24pO1xuXG4gICAgICAgIHRoaXMuZHVyYXRpb24gPSBuZXdTaXplO1xuICAgICAgICB0aGlzLnB1dE1lc3NhZ2VPblBpcGUoJ3JlY2FsY0R1cmF0aW9uJywge30sICdHcm91cHMnLCB7XG4gICAgICAgICAgc2VsZkV4ZWN1dGU6IGZhbHNlLFxuICAgICAgICAgIGRpcmVjdGlvbjogX0RJUkVDVElPTlMuX1VQXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnB1dE1lc3NhZ2VPblBpcGUoJ2ZsYXNoJywge30sICdSb290Q2xpcCcsIHtcbiAgICAgICAgICBzZWxmRXhlY3V0ZTogdHJ1ZSxcbiAgICAgICAgICBkaXJlY3Rpb246IF9ESVJFQ1RJT05TLl9VUFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXN1bHQ6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIC8qKiAqKioqKioqKioqKioqKioqKioqKioqKioqIEhBTkRMSU5HIE1FVEhPRFMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJoYW5kbGVDaGVja0ZvckNsaXBcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVDaGVja0ZvckNsaXAodGFyZ2V0LCBwYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJoYW5kbGVHZXRFbGVtZW50c1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUdldEVsZW1lbnRzKHRhcmdldCwgcGF5bG9hZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFsQ2xpcC5nZXRFbGVtZW50cyhwYXlsb2FkLnNlbGVjdG9yKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaGFuZGxlQ2hlY2tBZGRpdGlvblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUNoZWNrQWRkaXRpb24odGFyZ2V0LCBwYXlsb2FkKSB7XG4gICAgICAgIC8qIElzIHRoZSByZXNwb25zaWJpbGl0eSBvZiB0aGUgRGVzY3JpcHRpdmVDbGlwIHRvIHBhc3MgdGhlIGFkZGl0aW9uIHJlcXVlc3RcbiAgICAgICAgICAgIHRvIGl0cyByZWFsIGNsaXAgYW5kIGV4cGVjdCBmb3IgYSByZXNwb25zZS4gKi9cbiAgICAgICAgdmFyIHJlcyA9IHRoaXMucmVhbENsaXAuYWRkSW5jaWRlbnQocGF5bG9hZCk7XG4gICAgICAgIHZhciBhdWRpb1JlcyA9IHRoaXMuYXVkaW9DbGlwLmFkZEluY2lkZW50KHBheWxvYWQpO1xuXG4gICAgICAgIGlmIChyZXMucmVzdWx0ID09PSB0cnVlICYmIGF1ZGlvUmVzLnJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHJlcy5leGVjdXRlKCk7XG4gICAgICAgICAgYXVkaW9SZXMuZXhlY3V0ZSgpO1xuICAgICAgICAgIHRoaXMucHV0TWVzc2FnZU9uUGlwZSgnZmxhc2gnLCB7fSwgJ1Jvb3RDbGlwJywge1xuICAgICAgICAgICAgc2VsZkV4ZWN1dGU6IHRydWUsXG4gICAgICAgICAgICBkaXJlY3Rpb246IF9ESVJFQ1RJT05TLl9VUFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN1bHQ6IHRydWVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaGFuZGxlQ2hlY2tNb3ZlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlQ2hlY2tNb3ZlKHRhcmdldCwgcGF5bG9hZCkge1xuICAgICAgICB2YXIgcmVzID0gdGhpcy5yZWFsQ2xpcC5tb3ZlSW5jaWRlbnQocGF5bG9hZCk7XG4gICAgICAgIHZhciBhdWRpb1JlcyA9IHRoaXMuYXVkaW9DbGlwLm1vdmVJbmNpZGVudChwYXlsb2FkKTtcblxuICAgICAgICBpZiAocmVzLnJlc3VsdCA9PT0gdHJ1ZSAmJiBhdWRpb1Jlcy5yZXN1bHQgPT09IHRydWUpIHtcbiAgICAgICAgICByZXMuZXhlY3V0ZSgpO1xuICAgICAgICAgIGF1ZGlvUmVzLmV4ZWN1dGUoKTtcbiAgICAgICAgICB0aGlzLnB1dE1lc3NhZ2VPblBpcGUoJ2ZsYXNoJywge30sICdSb290Q2xpcCcsIHtcbiAgICAgICAgICAgIHNlbGZFeGVjdXRlOiB0cnVlLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBfRElSRUNUSU9OUy5fVVBcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdWx0OiB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImhhbmRsZUNoZWNrRGVsZXRpb25cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVDaGVja0RlbGV0aW9uKHRhcmdldCwgcGF5bG9hZCkge1xuICAgICAgICB2YXIgcmVzID0gdGhpcy5yZWFsQ2xpcC5yZW1vdmVJbmNpZGVudChwYXlsb2FkKTtcbiAgICAgICAgdmFyIGF1ZGlvUmVzID0gdGhpcy5hdWRpb0NsaXAucmVtb3ZlSW5jaWRlbnQocGF5bG9hZCk7XG5cbiAgICAgICAgaWYgKHJlcy5yZXN1bHQgPT09IHRydWUgJiYgYXVkaW9SZXMucmVzdWx0ID09PSB0cnVlKSB7XG4gICAgICAgICAgcmVzLmV4ZWN1dGUoKTtcbiAgICAgICAgICBhdWRpb1Jlcy5leGVjdXRlKCk7XG4gICAgICAgICAgdGhpcy5wdXRNZXNzYWdlT25QaXBlKCdmbGFzaCcsIHt9LCAnUm9vdENsaXAnLCB7XG4gICAgICAgICAgICBzZWxmRXhlY3V0ZTogdHJ1ZSxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogX0RJUkVDVElPTlMuX1VQXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3VsdDogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJoYW5kbGVDaGVja1Jlc2l6ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUNoZWNrUmVzaXplKHRhcmdldCwgcGF5bG9hZCkge1xuICAgICAgICB2YXIgcmVzID0gdGhpcy5yZWFsQ2xpcC5yZXNpemVJbmNpZGVudChwYXlsb2FkKTtcbiAgICAgICAgdmFyIGF1ZGlvUmVzID0gdGhpcy5hdWRpb0NsaXAucmVzaXplSW5jaWRlbnQocGF5bG9hZCk7XG5cbiAgICAgICAgaWYgKHJlcy5yZXN1bHQgPT09IHRydWUgJiYgYXVkaW9SZXMucmVzdWx0ID09PSB0cnVlKSB7XG4gICAgICAgICAgcmVzLmV4ZWN1dGUoKTtcbiAgICAgICAgICBhdWRpb1Jlcy5leGVjdXRlKCk7XG4gICAgICAgICAgdGhpcy5wdXRNZXNzYWdlT25QaXBlKCdmbGFzaCcsIHt9LCAnUm9vdENsaXAnLCB7XG4gICAgICAgICAgICBzZWxmRXhlY3V0ZTogdHJ1ZSxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogX0RJUkVDVElPTlMuX1VQXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3VsdDogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJoYW5kbGVGbGFzaFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUZsYXNoKHRhcmdldCwgcGF5bG9hZCkge1xuICAgICAgICBpZiAodGhpcy5pc1RoZVJvb3RDbGlwKSB7XG4gICAgICAgICAgdGhpcy5mbGFzaCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLmJ5cGFzcygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKiogKioqKioqKioqKioqKioqKiBCTE9DS0lORyBXQUlUSU5HUyBIQU5ETElORyAqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cbiAgICAgIC8qKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImhhbmRsZVNldEJsb2NrXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlU2V0QmxvY2sodGFyZ2V0LCBwYXlsb2FkKSB7XG4gICAgICAgIC8vIG9ubHkgYWNjZXB0cyBibG9ja3MgaWYgaXMgdGhlIHJvb3QgY2xpcCBhbmQgaWYgaXQncyBwbGF5aW5nXG4gICAgICAgIGlmICh0aGlzLmlzVGhlUm9vdENsaXApIHtcbiAgICAgICAgICBpZiAodGhpcy5ydW5UaW1lSW5mby5zdGF0ZSA9PT0gJ3RyYW5zaXRpb25hbCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5ydW5UaW1lSW5mby5zdGF0ZSAhPT0gJ2Jsb2NrZWQnKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXR1c0JlZm9yZUJsb2NrID0gdGhpcy5ydW5UaW1lSW5mby5zdGF0ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmJsb2NraW5nV2FpdGluZ3NbcGF5bG9hZC5pZF0gPSBwYXlsb2FkO1xuICAgICAgICAgIHRoaXMuYmxvY2soKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5ieXBhc3MoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJoYW5kbGVVbkJsb2NrXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlVW5CbG9jayh0YXJnZXQsIHBheWxvYWQpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNUaGVSb290Q2xpcCkge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5ibG9ja2luZ1dhaXRpbmdzLCBwYXlsb2FkLmlkKSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuYmxvY2tpbmdXYWl0aW5nc1twYXlsb2FkLmlkXTtcblxuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuYmxvY2tpbmdXYWl0aW5ncykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1c0JlZm9yZUJsb2NrID09PSAncGxheWluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzVGltZVN0YW1wID0gLTE7XG4gICAgICAgICAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcm0oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5ieXBhc3MoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyogZW1wdHkgYmxvY2tpbmcgd2FpdGluZ3Mgb24gdHJhbnNpdGlvbiBzdGFydCAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInN0b3BcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihEZXNjcmlwdGl2ZUNsaXAucHJvdG90eXBlKSwgXCJzdG9wXCIsIHRoaXMpLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdGhpcy5ibG9ja2luZ1dhaXRpbmdzID0ge307XG4gICAgICB9XG4gICAgICAvKiogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuICAgICAgLyoqICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwib25Qcm9ncmVzc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uUHJvZ3Jlc3MoZnJhY3Rpb24sIG1pbGxpc2Vjb25kKSB7XG4gICAgICAgIHRoaXMucmVhbENsaXAub25Qcm9ncmVzcyhmcmFjdGlvbiwgbWlsbGlzZWNvbmQpO1xuICAgICAgICB0aGlzLmF1ZGlvQ2xpcC5vblByb2dyZXNzKGZyYWN0aW9uLCBtaWxsaXNlY29uZCk7XG4gICAgICB9XG4gICAgICAvKiogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInBhc3RlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcGFzdGUoaG9zdCkge1xuICAgICAgICBpZiAodGhpcy5pc1RoZVJvb3RDbGlwKSB7XG4gICAgICAgICAgdmFyIGNsaXBDbG9uZSA9IG5ldyBDbGlwQ2xvbmUoe1xuICAgICAgICAgICAgaG9zdDogaG9zdCxcbiAgICAgICAgICAgIGRlc2NyaXB0aXZlSW5jaWRlbnQ6IHRoaXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gY2xpcENsb25lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImZsYXNoXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZmxhc2goKSB7XG4gICAgICAgIHRoaXMucmVhbENsaXAuZmxhc2goKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0Vm9sdW1lXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Vm9sdW1lKHZvbCkge1xuICAgICAgICBpZiAodm9sIDwgMCB8fCB2b2wgPiAxKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcnM6IFt7XG4gICAgICAgICAgICAgIHR5cGU6ICdpbnZhbGlkIHZvbHVtZSBudW1iZXInXG4gICAgICAgICAgICB9XVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5hdWRpbyA9PT0gJ29mZicpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdWx0OiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yczogW3tcbiAgICAgICAgICAgICAgdHlwZTogJ2NhbiBub3Qgc2V0IHZvbHVtZSBvZiBDbGlwIHdpdGggYXVkaW8gb2ZmJ1xuICAgICAgICAgICAgfV1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hdWRpb0NsaXAuc2V0Vm9sdW1lKHZvbCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzdWx0OiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNlbGVjdG9yVG9QYXNzVG9DaGlsZHJlblwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBudWxsOyAvLyB0aGUgQ2xpcCAoYW55IENsaXApIHJlc2V0cyB0aGUgc2VsZWN0aW9uIGNhc2NhZGluZ1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJpbmhlcml0ZWRTZWxlY3RvclwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbmhlcml0ZWRTZWxlY3RvcjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9pbmhlcml0ZWRTZWxlY3RvciA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJodG1sXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjc3NcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImZvbnRzXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJhdWRpb1NvdXJjZXNcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIERlc2NyaXB0aXZlQ2xpcDtcbiAgfShQbGF5YWJsZSk7XG5cbiAgX2RlZmluZVByb3BlcnR5KERlc2NyaXB0aXZlQ2xpcCwgXCJpc0NsaXBcIiwgdHJ1ZSk7XG5cbiAgX2RlZmluZVByb3BlcnR5KERlc2NyaXB0aXZlQ2xpcCwgXCJJbmNpZGVudFwiLCBDbGlwJDEpO1xuXG4gIF9kZWZpbmVQcm9wZXJ0eShEZXNjcmlwdGl2ZUNsaXAsIFwicGx1Z2luX25wbV9uYW1lXCIsICdAa2lzc215YnV0dG9uL3NlbGYtY29udGFpbmVkLWluY2lkZW50cycpO1xuXG4gIF9kZWZpbmVQcm9wZXJ0eShEZXNjcmlwdGl2ZUNsaXAsIFwiQ2hhbm5lbFwiLCBDbGlwQ2hhbm5lbCk7XG5cbiAgX2RlZmluZVByb3BlcnR5KERlc2NyaXB0aXZlQ2xpcCwgXCJDbGFzc05hbWVcIiwgJ0NsaXAnKTtcblxuICB2YXIgRGVzY3JpcHRpdmVBdWRpb0NsaXAgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uIChfRGVzY3JpcHRpdmVDbGlwKSB7XG4gICAgX2luaGVyaXRzKERlc2NyaXB0aXZlQXVkaW9DbGlwLCBfRGVzY3JpcHRpdmVDbGlwKTtcblxuICAgIGZ1bmN0aW9uIERlc2NyaXB0aXZlQXVkaW9DbGlwKGF1ZGlvU291cmNlcykge1xuICAgICAgdmFyIGlkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGVzY3JpcHRpdmVBdWRpb0NsaXApO1xuXG4gICAgICB2YXIgcHJvcHNUb1Bhc3MgPSB7XG4gICAgICAgIGF1ZGlvOiAnb25seScsXG4gICAgICAgIGF1ZGlvU291cmNlczogYXVkaW9Tb3VyY2VzXG4gICAgICB9O1xuXG4gICAgICBpZiAoaWQgIT09IG51bGwpIHtcbiAgICAgICAgcHJvcHNUb1Bhc3MuaWQgPSBpZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihEZXNjcmlwdGl2ZUF1ZGlvQ2xpcCkuY2FsbCh0aGlzLCBwcm9wc1RvUGFzcykpO1xuICAgIH1cblxuICAgIHJldHVybiBEZXNjcmlwdGl2ZUF1ZGlvQ2xpcDtcbiAgfShEZXNjcmlwdGl2ZUNsaXApO1xuXG4gIHZhciBEZXNjcmlwdGl2ZUluY2lkZW50ID0gX2RlY29yYXRlKG51bGwsIGZ1bmN0aW9uIChfaW5pdGlhbGl6ZSwgX0xlYWYpIHtcbiAgICB2YXIgRGVzY3JpcHRpdmVJbmNpZGVudCA9XG4gICAgLyojX19QVVJFX18qL1xuICAgIGZ1bmN0aW9uIChfTGVhZjIpIHtcbiAgICAgIF9pbmhlcml0cyhEZXNjcmlwdGl2ZUluY2lkZW50LCBfTGVhZjIpO1xuXG4gICAgICBmdW5jdGlvbiBEZXNjcmlwdGl2ZUluY2lkZW50KGF0dHJzLCBwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXM7XG5cbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERlc2NyaXB0aXZlSW5jaWRlbnQpO1xuXG4gICAgICAgIGlmIChwcm9wcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHMgPSBhdHRycztcbiAgICAgICAgICBhdHRycyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoRGVzY3JpcHRpdmVJbmNpZGVudCkuY2FsbCh0aGlzLCBwcm9wcykpO1xuXG4gICAgICAgIF9pbml0aWFsaXplKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgICAgICB2YXIgcHJvcHNWYWxpZGF0aW9uID0gaGVscGVyLnZhbGlkYXRlUHJvcHMoe1xuICAgICAgICAgIHByb3BzOiBwcm9wc1xuICAgICAgICB9LCBpbmNpZGVudFByb3BzUnVsZSwgX3RoaXMuY29uc3RydWN0b3IpO1xuXG4gICAgICAgIGlmIChwcm9wc1ZhbGlkYXRpb24ucmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgcHJvcHNWYWxpZGF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLmluaGVyaXRlZFNlbGVjdG9yID0gbnVsbDtcbiAgICAgICAgX3RoaXMuYXR0cnMgPSBhdHRycztcblxuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgJ2R1cmF0aW9uJykpIHtcbiAgICAgICAgICBwcm9wcy5kdXJhdGlvbiA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgICBfdGhpcy5hdHRyc1ZhbGlkYXRpb25SdWxlcyA9IHt9O1xuICAgICAgICBfdGhpcy5wcm9wc1ZhbGlkYXRpb25SdWxlcyA9IGluY2lkZW50UHJvcHNSdWxlOyAvLyB0aGUgcGFzc2l2ZSBmbGFnICh3aGVuIHRydWUpIGluZGljYXRlcyB0aGF0IHRoZSBEZXNjcmlwdGl2ZSBHcm91cCBoYXMgYmVlbiBjcmVhdGVkXG4gICAgICAgIC8vIGFuZCBwYXNzaXZlbHkgYWRkZWQgdG8gYSBDbGlwIG9yIGEgQ29tYm8gdmlhIGJ1aWxkVHJlZSBtZXRob2QuXG4gICAgICAgIC8vIERlZmF1bHRzIHRvIGZhbHNlXG5cbiAgICAgICAgX3RoaXMucGFzc2l2ZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBEZXNjcmlwdGl2ZUluY2lkZW50O1xuICAgIH0oX0xlYWYpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIEY6IERlc2NyaXB0aXZlSW5jaWRlbnQsXG4gICAgICBkOiBbe1xuICAgICAgICBraW5kOiBcImZpZWxkXCIsXG4gICAgICAgIHN0YXRpYzogdHJ1ZSxcbiAgICAgICAga2V5OiBcIkluY2lkZW50XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgICAgICByZXR1cm4gTW9ub0luY2lkZW50O1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwiZmllbGRcIixcbiAgICAgICAgc3RhdGljOiB0cnVlLFxuICAgICAgICBrZXk6IFwicGx1Z2luX25wbV9uYW1lXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgICAgICByZXR1cm4gJ21vdG9yLWNvcnRleC1qcy1hdHRyaWJ1dGUnO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwiZmllbGRcIixcbiAgICAgICAgc3RhdGljOiB0cnVlLFxuICAgICAgICBrZXk6IFwiQ2hhbm5lbFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICAgICAgcmV0dXJuIEF0dHJpYnV0ZUNoYW5uZWw7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJmaWVsZFwiLFxuICAgICAgICBzdGF0aWM6IHRydWUsXG4gICAgICAgIGtleTogXCJDbGFzc05hbWVcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgICAgIHJldHVybiAnSW5jaWRlbnQnO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICAgIGRlY29yYXRvcnM6IFtlZGl0QXR0cmlidXRlc10sXG4gICAgICAgIGtleTogXCJlZGl0QXR0cmlidXRlc1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZWRpdEF0dHJpYnV0ZXMoKSB7fVxuICAgICAgfSwge1xuICAgICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAgICBkZWNvcmF0b3JzOiBbZWRpdFByb3BlcnRpZXNdLFxuICAgICAgICBrZXk6IFwiZWRpdFByb3BlcnRpZXNcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVkaXRQcm9wZXJ0aWVzKCkge31cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgICAgZGVjb3JhdG9yczogW3Jlc2l6ZV0sXG4gICAgICAgIGtleTogXCJyZXNpemVcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZSgpIHt9XG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICAgIGRlY29yYXRvcnM6IFtzZWxlY3Rvcl0sXG4gICAgICAgIGtleTogXCJzZWxlY3RvclwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0b3IoKSB7fVxuICAgICAgfSwge1xuICAgICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAgICBkZWNvcmF0b3JzOiBbZ2V0RWxlbWVudHNdLFxuICAgICAgICBrZXk6IFwiZ2V0RWxlbWVudHNcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVsZW1lbnRzKCkge31cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgICAga2V5OiBcIm1hbmFnZUVkaXRBdHRyUHJvcHNcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1hbmFnZUVkaXRBdHRyUHJvcHMobmV3QXR0cnMsIHR5cGUpIHtcbiAgICAgICAgICAvLyBnZXQgYSBwZXJtYW5lbnQgcmVmZXJlbmNlIHRvIGl0cyBwYXJlbnQgbm9kZVxuICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gdGhpcy5wYXJlbnROb2RlOyAvLyBnZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBJbmNpZGVudCB3aXRoaW4gaXRzIHBhcmVudFxuXG4gICAgICAgICAgdmFyIHBvc2l0aW9uID0gcGFyZW50Tm9kZS5nZXRMZWFmUG9zaXRpb24odGhpcy5pZCk7IC8vIGZpcnN0IGRldGFjaCB0aGUgSW5jaWRlbnQgZnJvbSBpdHMgcGFyZW50XG5cbiAgICAgICAgICBwYXJlbnROb2RlLnJlbW92ZUluY2lkZW50KHRoaXMuaWQpOyAvLyBrZWVwIGEgYmFja3VwIG9mIHRoZSBjdXJyZW50IGF0dHJzL3Byb3BzXG5cbiAgICAgICAgICB2YXIgb2xkQXR0cnMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXNbdHlwZV0pKTtcbiAgICAgICAgICB0aGlzW3R5cGVdID0gbmV3QXR0cnM7XG4gICAgICAgICAgdmFyIHJlcyA9IHBhcmVudE5vZGUuYWRkSW5jaWRlbnQodGhpcywgcG9zaXRpb24pO1xuXG4gICAgICAgICAgaWYgKHJlcy5yZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBwYXJlbnROb2RlLnJlbW92ZUluY2lkZW50KHRoaXMuaWQpO1xuICAgICAgICAgICAgdGhpc1t0eXBlXSA9IG9sZEF0dHJzO1xuICAgICAgICAgICAgcGFyZW50Tm9kZS5hZGRJbmNpZGVudCh0aGlzLCBwb3NpdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2luZDogXCJtZXRob2RcIixcbiAgICAgICAga2V5OiBcImRldGFjaEZyb21QYXJlbnRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRldGFjaEZyb21QYXJlbnQoKSB7XG4gICAgICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoRGVzY3JpcHRpdmVJbmNpZGVudC5wcm90b3R5cGUpLCBcImRldGFjaEZyb21QYXJlbnRcIiwgdGhpcykuY2FsbCh0aGlzKTtcblxuICAgICAgICAgIHRoaXMuaW5oZXJpdGVkU2VsZWN0b3IgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICAgIGtleTogXCJoYW5kbGVDaGVja0ZvckludmFsaWRTZWxlY3RvcnNcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUNoZWNrRm9ySW52YWxpZFNlbGVjdG9ycygpIHtcbiAgICAgICAgICB2YXIgc2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yKCk7XG5cbiAgICAgICAgICBpZiAoc2VsZWN0b3IgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICAgICAgICBDbGFzc05hbWU6IHRoaXMuY29uc3RydWN0b3IuQ2xhc3NOYW1lLFxuICAgICAgICAgICAgICBwbHVnaW5fbnBtX25hbWU6IHRoaXMuY29uc3RydWN0b3IucGx1Z2luX25wbV9uYW1lLFxuICAgICAgICAgICAgICBlcnJvcjogJ251bGwgc2VsZWN0b3InXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWxlY3Rvci5jaGFyQXQoMCkgPT09ICcmJykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICAgIENsYXNzTmFtZTogdGhpcy5jb25zdHJ1Y3Rvci5DbGFzc05hbWUsXG4gICAgICAgICAgICAgIHBsdWdpbl9ucG1fbmFtZTogdGhpcy5jb25zdHJ1Y3Rvci5wbHVnaW5fbnBtX25hbWUsXG4gICAgICAgICAgICAgIGVycm9yOiAncmVsYXRpdmUgc2VsZWN0b3Igd2l0aCBubyBpbmhlcml0ZWQgc2VsZWN0b3InLFxuICAgICAgICAgICAgICBzZWxlY3Rvcjogc2VsZWN0b3JcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRoaXMuYnlwYXNzKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIGV4cG9ydCBhIHBvcnRhYmxlIGRlZmluaXRpb24gdGhhdCBjYW4gYmVcbiAgICAgICAgICogbGF0ZXIgdXNlZCBpbiBvcmRlciB0byByZWJ1aWxkIHRoZSBJbmljZGVudCBhdCBhbnkgdGltZVxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBraW5kOiBcIm1ldGhvZFwiLFxuICAgICAgICBrZXk6IFwiZXhwb3J0RGVmaW5pdGlvblwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZXhwb3J0RGVmaW5pdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgQ2xhc3NOYW1lOiB0aGlzLmNvbnN0cnVjdG9yLkNsYXNzTmFtZSxcbiAgICAgICAgICAgIHBsdWdpbl9ucG1fbmFtZTogdGhpcy5jb25zdHJ1Y3Rvci5wbHVnaW5fbnBtX25hbWUsXG4gICAgICAgICAgICBhdHRyczogdGhpcy5hdHRycyxcbiAgICAgICAgICAgIHByb3BzOiB0aGlzLnByb3BzXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG8gZXhwb3J0IGFuIG9iamVjdCB3aXRoIFwibGl2ZVwiIC8gcmVhbCByZWZlcmVuY2VcbiAgICAgICAgICogdG8gdGhlIENsYXNzIG9mIHRoZSBJbmNpZGVudCBzbyBpdCBjYW4gZGlyZWN0bHkgYnkgdXNlZCBmb3IgQ2xpcCBjcmVhdGlvblxuICAgICAgICAgKiAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtpbmQ6IFwibWV0aG9kXCIsXG4gICAgICAgIGtleTogXCJleHBvcnRMaXZlRGVmaW5pdGlvblwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZXhwb3J0TGl2ZURlZmluaXRpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIENsYXNzOiB0aGlzLmNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgYXR0cnM6IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5hdHRycykpLFxuICAgICAgICAgICAgcHJvcHM6IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5wcm9wcykpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfV1cbiAgICB9O1xuICB9LCBMZWFmKTtcblxuICAvKlxuICBkZWZpbml0aW9uOiB7XG4gICAgICBDbGFzczogPFRoZSBDbGFzcz4sXG4gICAgICBhdHRyczogPGF0dHJzPixcbiAgICAgIHByb3BzOiA8cHJvcHM+LFxuICAgICAgaW5jaWRlbnRzOiB7IC8vIHRoaXMgZXhpc3RzIG9ubHkgaW4gdGhlIGNhc2Ugb2YgYSBHcm91cCBvciBhIENsaXBcbiAgICAgICAgICBpZDogPGlkPixcbiAgICAgICAgICBwb3NpdGlvbj4gPHBvc2l0aW9uPixcbiAgICAgICAgICBsZWFmOiA8ZGVmaW5pdGlvbj5cbiAgICAgIH1cbiAgfVxuICAqL1xuICBmdW5jdGlvbiBjb25zdHJ1Y3RJbmNpZGVudChkZWZpbml0aW9uKSB7XG4gICAgdmFyIFRoZUluY2lkZW50ID0gbmV3IGRlZmluaXRpb24uQ2xhc3MoZGVmaW5pdGlvbi5hdHRycywgZGVmaW5pdGlvbi5wcm9wcyk7XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRlZmluaXRpb24sICdpbmNpZGVudHMnKSkge1xuICAgICAgZm9yICh2YXIga2V5IGluIGRlZmluaXRpb24uaW5jaWRlbnRzKSB7XG4gICAgICAgIHZhciBpbmNpZGVudERlZmluaXRpb24gPSBkZWZpbml0aW9uLmluY2lkZW50c1trZXldO1xuICAgICAgICB2YXIgaW5jaWRlbnQgPSBjb25zdHJ1Y3RJbmNpZGVudChpbmNpZGVudERlZmluaXRpb24ubGVhZik7XG4gICAgICAgIFRoZUluY2lkZW50LmFkZEluY2lkZW50KGluY2lkZW50LCBpbmNpZGVudERlZmluaXRpb24ucG9zaXRpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBUaGVJbmNpZGVudDtcbiAgfVxuXG4gIHZhciBjb2xvclJlZ2V4cCA9IG5ldyBSZWdFeHAoL14jKFtcXGRhLWZdezN9KXsxLDJ9JHxeIyhbXFxkYS1mXXs0fSl7MSwyfSR8KHJnYnxoc2wpYT9cXCgoXFxzKi0/XFxkKyU/XFxzKiwpezJ9KFxccyotP1xcZCslP1xccyosP1xccypcXCk/KSgsXFxzKigwP1xcLlxcZCspP3wxKT9cXCkvLCAnZ2knKTtcbiAgdmFyIGludFJlZ2V4cCA9IG5ldyBSZWdFeHAoL15bLStdP1xcZCskLyk7XG4gIHZhciBjcmVhdGVWYWxpZGF0b3IgPSBmdW5jdGlvbiBjcmVhdGVWYWxpZGF0b3IoKSB7XG4gICAgdmFyIHYgPSBuZXcgaW5kZXhfbWluKHtcbiAgICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgIGNvbG9yOiBcIlRoZSAne2ZpZWxkfScgZmllbGQgbXVzdCBiZSBhbiBhIHZhbGlkIGNvbG9yISBBY3R1YWw6IHthY3R1YWx9XCIsXG4gICAgICAgIG1lYXN1cmVtZW50OiBcIlRoZSAne2ZpZWxkfScgbXVzdCBiZSBhIG1lYXN1cmVtZW50IHdpdGggc3BlY3MgdGhhdCBhcmUgbm90IG1ldC4gUGxlYXNlIGNoZWNrIHNjaGVtYSBkZWZpbml0aW9uLiBBY3R1YWw6IHthY3R1YWx9XCJcbiAgICAgIH1cbiAgICB9KTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgICB2LmFkZCgnbWVhc3VyZW1lbnQnLCBmdW5jdGlvbiAoX3JlZiwgcGF0aCwgY29udGV4dCkge1xuICAgICAgdmFyIHNjaGVtYSA9IF9yZWYuc2NoZW1hLFxuICAgICAgICAgIG1lc3NhZ2VzID0gX3JlZi5tZXNzYWdlcztcbiAgICAgIHZhciBtZWFzdXJlbWVudFJlZ2V4cCA9IG5ldyBSZWdFeHAoJ15bKy1dPyhbMC05XSsoWy5dWzAtOV0qKT98Wy5dWzAtOV0rKSgnICsgc2NoZW1hLnVuaXRzLmpvaW4oJ3wnKSArICcpJCcsICdnaScpO1xuICAgICAgdmFyIG51bWJlclBhcnRSZWdleHAgPSBuZXcgUmVnRXhwKCdeWystXT8oWzAtOV0rKFsuXVswLTldKik/fFsuXVswLTldKyknLCAnZ2knKTtcbiAgICAgIHZhciB1bml0c0ZsYXR0ZW5lZCA9IHNjaGVtYS51bml0cy5qb2luKCcsICcpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlOiBcIlxcbiAgICAgICAgaWYodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyAmJiAhKHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nKSl7XFxuICAgICAgICAgIFwiLmNvbmNhdCh0aGlzLm1ha2VFcnJvcih7XG4gICAgICAgICAgdHlwZTogJ21lYXN1cmVtZW50JyxcbiAgICAgICAgICBhY3R1YWw6ICd2YWx1ZScsXG4gICAgICAgICAgdW5pdHM6IHVuaXRzRmxhdHRlbmVkLFxuICAgICAgICAgIG1lc3NhZ2VzOiBtZXNzYWdlc1xuICAgICAgICB9KSwgXCJcXG4gICAgICAgICAgcmV0dXJuIDtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmKCF2YWx1ZS5tYXRjaChcIikuY29uY2F0KG1lYXN1cmVtZW50UmVnZXhwLCBcIikpe1xcbiAgICAgICAgICBcIikuY29uY2F0KHRoaXMubWFrZUVycm9yKHtcbiAgICAgICAgICB0eXBlOiAnbWVhc3VyZW1lbnQnLFxuICAgICAgICAgIGFjdHVhbDogJ3ZhbHVlJyxcbiAgICAgICAgICB1bml0czogdW5pdHNGbGF0dGVuZWQsXG4gICAgICAgICAgbWVzc2FnZXM6IG1lc3NhZ2VzXG4gICAgICAgIH0pLCBcIlxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdmFyIG51bWJlclBhcnQgPSB2YWx1ZS5tYXRjaChcIikuY29uY2F0KG51bWJlclBhcnRSZWdleHAsIFwiKVswXTtcXG4gICAgICAgICAgaWYoXCIpLmNvbmNhdChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2NoZW1hLCAnbWluJyksIFwiKXtcXG4gICAgICAgICAgICBpZihcIikuY29uY2F0KHNjaGVtYS5taW4sIFwiID4gbnVtYmVyUGFydCl7XFxuICAgICAgICAgICAgICBcIikuY29uY2F0KHRoaXMubWFrZUVycm9yKHtcbiAgICAgICAgICB0eXBlOiAnbWVhc3VyZW1lbnQnLFxuICAgICAgICAgIGFjdHVhbDogJ3ZhbHVlJyxcbiAgICAgICAgICB1bml0czogdW5pdHNGbGF0dGVuZWQsXG4gICAgICAgICAgbWVzc2FnZXM6IG1lc3NhZ2VzXG4gICAgICAgIH0pLCBcIlxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZihcIikuY29uY2F0KE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzY2hlbWEsICdtYXgnKSwgXCIpe1xcbiAgICAgICAgICAgIGlmKFwiKS5jb25jYXQoc2NoZW1hLm1heCwgXCIgPCBudW1iZXJQYXJ0KXtcXG4gICAgICAgICAgICAgIFwiKS5jb25jYXQodGhpcy5tYWtlRXJyb3Ioe1xuICAgICAgICAgIHR5cGU6ICdtZWFzdXJlbWVudCcsXG4gICAgICAgICAgYWN0dWFsOiAndmFsdWUnLFxuICAgICAgICAgIHVuaXRzOiB1bml0c0ZsYXR0ZW5lZCxcbiAgICAgICAgICBtZXNzYWdlczogbWVzc2FnZXNcbiAgICAgICAgfSksIFwiXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgICBpZihcIikuY29uY2F0KE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzY2hlbWEsICdpbnRlZ2VyJyksIFwiKXtcXG4gICAgICAgICAgICBpZighbnVtYmVyUGFydC5tYXRjaChcIikuY29uY2F0KGludFJlZ2V4cCwgXCIpKXtcXG4gICAgICAgICAgICAgIFwiKS5jb25jYXQodGhpcy5tYWtlRXJyb3Ioe1xuICAgICAgICAgIHR5cGU6ICdtZWFzdXJlbWVudCcsXG4gICAgICAgICAgYWN0dWFsOiAndmFsdWUnLFxuICAgICAgICAgIHVuaXRzOiB1bml0c0ZsYXR0ZW5lZCxcbiAgICAgICAgICBtZXNzYWdlczogbWVzc2FnZXNcbiAgICAgICAgfSksIFwiXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgXCIpXG4gICAgICB9O1xuICAgIH0pOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAgIHYuYWRkKCdjb2xvcicsIGZ1bmN0aW9uIChfcmVmMiwgcGF0aCwgY29udGV4dCkge1xuICAgICAgdmFyIHNjaGVtYSA9IF9yZWYyLnNjaGVtYSxcbiAgICAgICAgICBtZXNzYWdlcyA9IF9yZWYyLm1lc3NhZ2VzO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlOiBcIlxcbiAgICAgICAgaWYodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyAmJiAhKHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nKSl7XFxuICAgICAgICAgIFwiLmNvbmNhdCh0aGlzLm1ha2VFcnJvcih7XG4gICAgICAgICAgdHlwZTogJ21lYXN1cmVtZW50JyxcbiAgICAgICAgICBhY3R1YWw6ICd2YWx1ZScsXG4gICAgICAgICAgbWVzc2FnZXM6IG1lc3NhZ2VzXG4gICAgICAgIH0pLCBcIlxcbiAgICAgICAgICByZXR1cm4gO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYoIXZhbHVlLm1hdGNoKFwiKS5jb25jYXQoY29sb3JSZWdleHAsIFwiKSAmJiBbXFxuICAgICAgICAgICAgXFxcImFsaWNlYmx1ZVxcXCIsXFxuICAgICAgICAgICAgXFxcImFudGlxdWV3aGl0ZVxcXCIsXFxuICAgICAgICAgICAgXFxcImFxdWFcXFwiLFxcbiAgICAgICAgICAgIFxcXCJhcXVhbWFyaW5lXFxcIixcXG4gICAgICAgICAgICBcXFwiYXp1cmVcXFwiLFxcbiAgICAgICAgICAgIFxcXCJiZWlnZVxcXCIsXFxuICAgICAgICAgICAgXFxcImJpc3F1ZVxcXCIsXFxuICAgICAgICAgICAgXFxcImJsYWNrXFxcIixcXG4gICAgICAgICAgICBcXFwiYmxhbmNoZWRhbG1vbmRcXFwiLFxcbiAgICAgICAgICAgIFxcXCJibHVlXFxcIixcXG4gICAgICAgICAgICBcXFwiYmx1ZXZpb2xldFxcXCIsXFxuICAgICAgICAgICAgXFxcImJyb3duXFxcIixcXG4gICAgICAgICAgICBcXFwiYnVybHl3b29kXFxcIixcXG4gICAgICAgICAgICBcXFwiY2FkZXRibHVlXFxcIixcXG4gICAgICAgICAgICBcXFwiY2hhcnRyZXVzZVxcXCIsXFxuICAgICAgICAgICAgXFxcImNob2NvbGF0ZVxcXCIsXFxuICAgICAgICAgICAgXFxcImNvcmFsXFxcIixcXG4gICAgICAgICAgICBcXFwiY29ybmZsb3dlcmJsdWVcXFwiLFxcbiAgICAgICAgICAgIFxcXCJjb3Juc2lsa1xcXCIsXFxuICAgICAgICAgICAgXFxcImNyaW1zb25cXFwiLFxcbiAgICAgICAgICAgIFxcXCJjeWFuXFxcIixcXG4gICAgICAgICAgICBcXFwiZGFya2JsdWVcXFwiLFxcbiAgICAgICAgICAgIFxcXCJkYXJrY3lhblxcXCIsXFxuICAgICAgICAgICAgXFxcImRhcmtnb2xkZW5yb2RcXFwiLFxcbiAgICAgICAgICAgIFxcXCJkYXJrZ3JheVxcXCIsXFxuICAgICAgICAgICAgXFxcImRhcmtncmV5XFxcIixcXG4gICAgICAgICAgICBcXFwiZGFya2dyZWVuXFxcIixcXG4gICAgICAgICAgICBcXFwiZGFya2toYWtpXFxcIixcXG4gICAgICAgICAgICBcXFwiZGFya21hZ2VudGFcXFwiLFxcbiAgICAgICAgICAgIFxcXCJkYXJrb2xpdmVncmVlblxcXCIsXFxuICAgICAgICAgICAgXFxcImRhcmtvcmFuZ2VcXFwiLFxcbiAgICAgICAgICAgIFxcXCJkYXJrb3JjaGlkXFxcIixcXG4gICAgICAgICAgICBcXFwiZGFya3JlZFxcXCIsXFxuICAgICAgICAgICAgXFxcImRhcmtzYWxtb25cXFwiLFxcbiAgICAgICAgICAgIFxcXCJkYXJrc2VhZ3JlZW5cXFwiLFxcbiAgICAgICAgICAgIFxcXCJkYXJrc2xhdGVibHVlXFxcIixcXG4gICAgICAgICAgICBcXFwiZGFya3NsYXRlZ3JheVxcXCIsXFxuICAgICAgICAgICAgXFxcImRhcmtzbGF0ZWdyZXlcXFwiLFxcbiAgICAgICAgICAgIFxcXCJkYXJrdHVycXVvaXNlXFxcIixcXG4gICAgICAgICAgICBcXFwiZGFya3Zpb2xldFxcXCIsXFxuICAgICAgICAgICAgXFxcImRlZXBwaW5rXFxcIixcXG4gICAgICAgICAgICBcXFwiZGVlcHNreWJsdWVcXFwiLFxcbiAgICAgICAgICAgIFxcXCJkaW1ncmF5XFxcIixcXG4gICAgICAgICAgICBcXFwiZGltZ3JleVxcXCIsXFxuICAgICAgICAgICAgXFxcImRvZGdlcmJsdWVcXFwiLFxcbiAgICAgICAgICAgIFxcXCJmaXJlYnJpY2tcXFwiLFxcbiAgICAgICAgICAgIFxcXCJmbG9yYWx3aGl0ZVxcXCIsXFxuICAgICAgICAgICAgXFxcImZvcmVzdGdyZWVuXFxcIixcXG4gICAgICAgICAgICBcXFwiZnVjaHNpYVxcXCIsXFxuICAgICAgICAgICAgXFxcImdhaW5zYm9yb1xcXCIsXFxuICAgICAgICAgICAgXFxcImdob3N0d2hpdGVcXFwiLFxcbiAgICAgICAgICAgIFxcXCJnb2xkXFxcIixcXG4gICAgICAgICAgICBcXFwiZ29sZGVucm9kXFxcIixcXG4gICAgICAgICAgICBcXFwiZ3JheVxcXCIsXFxuICAgICAgICAgICAgXFxcImdyZXlcXFwiLFxcbiAgICAgICAgICAgIFxcXCJncmVlblxcXCIsXFxuICAgICAgICAgICAgXFxcImdyZWVueWVsbG93XFxcIixcXG4gICAgICAgICAgICBcXFwiaG9uZXlkZXdcXFwiLFxcbiAgICAgICAgICAgIFxcXCJob3RwaW5rXFxcIixcXG4gICAgICAgICAgICBcXFwiaW5kaWFucmVkXFxcIixcXG4gICAgICAgICAgICBcXFwiaW5kaWdvXFxcIixcXG4gICAgICAgICAgICBcXFwiaXZvcnlcXFwiLFxcbiAgICAgICAgICAgIFxcXCJraGFraVxcXCIsXFxuICAgICAgICAgICAgXFxcImxhdmVuZGVyXFxcIixcXG4gICAgICAgICAgICBcXFwibGF2ZW5kZXJibHVzaFxcXCIsXFxuICAgICAgICAgICAgXFxcImxhd25ncmVlblxcXCIsXFxuICAgICAgICAgICAgXFxcImxlbW9uY2hpZmZvblxcXCIsXFxuICAgICAgICAgICAgXFxcImxpZ2h0Ymx1ZVxcXCIsXFxuICAgICAgICAgICAgXFxcImxpZ2h0Y29yYWxcXFwiLFxcbiAgICAgICAgICAgIFxcXCJsaWdodGN5YW5cXFwiLFxcbiAgICAgICAgICAgIFxcXCJsaWdodGdvbGRlbnJvZHllbGxvd1xcXCIsXFxuICAgICAgICAgICAgXFxcImxpZ2h0Z3JheVxcXCIsXFxuICAgICAgICAgICAgXFxcImxpZ2h0Z3JleVxcXCIsXFxuICAgICAgICAgICAgXFxcImxpZ2h0Z3JlZW5cXFwiLFxcbiAgICAgICAgICAgIFxcXCJsaWdodHBpbmtcXFwiLFxcbiAgICAgICAgICAgIFxcXCJsaWdodHNhbG1vblxcXCIsXFxuICAgICAgICAgICAgXFxcImxpZ2h0c2VhZ3JlZW5cXFwiLFxcbiAgICAgICAgICAgIFxcXCJsaWdodHNreWJsdWVcXFwiLFxcbiAgICAgICAgICAgIFxcXCJsaWdodHNsYXRlZ3JheVxcXCIsXFxuICAgICAgICAgICAgXFxcImxpZ2h0c2xhdGVncmV5XFxcIixcXG4gICAgICAgICAgICBcXFwibGlnaHRzdGVlbGJsdWVcXFwiLFxcbiAgICAgICAgICAgIFxcXCJsaWdodHllbGxvd1xcXCIsXFxuICAgICAgICAgICAgXFxcImxpbWVcXFwiLFxcbiAgICAgICAgICAgIFxcXCJsaW1lZ3JlZW5cXFwiLFxcbiAgICAgICAgICAgIFxcXCJsaW5lblxcXCIsXFxuICAgICAgICAgICAgXFxcIm1hZ2VudGFcXFwiLFxcbiAgICAgICAgICAgIFxcXCJtYXJvb25cXFwiLFxcbiAgICAgICAgICAgIFxcXCJtZWRpdW1hcXVhbWFyaW5lXFxcIixcXG4gICAgICAgICAgICBcXFwibWVkaXVtYmx1ZVxcXCIsXFxuICAgICAgICAgICAgXFxcIm1lZGl1bW9yY2hpZFxcXCIsXFxuICAgICAgICAgICAgXFxcIm1lZGl1bXB1cnBsZVxcXCIsXFxuICAgICAgICAgICAgXFxcIm1lZGl1bXNlYWdyZWVuXFxcIixcXG4gICAgICAgICAgICBcXFwibWVkaXVtc2xhdGVibHVlXFxcIixcXG4gICAgICAgICAgICBcXFwibWVkaXVtc3ByaW5nZ3JlZW5cXFwiLFxcbiAgICAgICAgICAgIFxcXCJtZWRpdW10dXJxdW9pc2VcXFwiLFxcbiAgICAgICAgICAgIFxcXCJtZWRpdW12aW9sZXRyZWRcXFwiLFxcbiAgICAgICAgICAgIFxcXCJtaWRuaWdodGJsdWVcXFwiLFxcbiAgICAgICAgICAgIFxcXCJtaW50Y3JlYW1cXFwiLFxcbiAgICAgICAgICAgIFxcXCJtaXN0eXJvc2VcXFwiLFxcbiAgICAgICAgICAgIFxcXCJtb2NjYXNpblxcXCIsXFxuICAgICAgICAgICAgXFxcIm5hdmFqb3doaXRlXFxcIixcXG4gICAgICAgICAgICBcXFwibmF2eVxcXCIsXFxuICAgICAgICAgICAgXFxcIm9sZGxhY2VcXFwiLFxcbiAgICAgICAgICAgIFxcXCJvbGl2ZVxcXCIsXFxuICAgICAgICAgICAgXFxcIm9saXZlZHJhYlxcXCIsXFxuICAgICAgICAgICAgXFxcIm9yYW5nZVxcXCIsXFxuICAgICAgICAgICAgXFxcIm9yYW5nZXJlZFxcXCIsXFxuICAgICAgICAgICAgXFxcIm9yY2hpZFxcXCIsXFxuICAgICAgICAgICAgXFxcInBhbGVnb2xkZW5yb2RcXFwiLFxcbiAgICAgICAgICAgIFxcXCJwYWxlZ3JlZW5cXFwiLFxcbiAgICAgICAgICAgIFxcXCJwYWxldHVycXVvaXNlXFxcIixcXG4gICAgICAgICAgICBcXFwicGFsZXZpb2xldHJlZFxcXCIsXFxuICAgICAgICAgICAgXFxcInBhcGF5YXdoaXBcXFwiLFxcbiAgICAgICAgICAgIFxcXCJwZWFjaHB1ZmZcXFwiLFxcbiAgICAgICAgICAgIFxcXCJwZXJ1XFxcIixcXG4gICAgICAgICAgICBcXFwicGlua1xcXCIsXFxuICAgICAgICAgICAgXFxcInBsdW1cXFwiLFxcbiAgICAgICAgICAgIFxcXCJwb3dkZXJibHVlXFxcIixcXG4gICAgICAgICAgICBcXFwicHVycGxlXFxcIixcXG4gICAgICAgICAgICBcXFwicmViZWNjYXB1cnBsZVxcXCIsXFxuICAgICAgICAgICAgXFxcInJlZFxcXCIsXFxuICAgICAgICAgICAgXFxcInJvc3licm93blxcXCIsXFxuICAgICAgICAgICAgXFxcInJveWFsYmx1ZVxcXCIsXFxuICAgICAgICAgICAgXFxcInNhZGRsZWJyb3duXFxcIixcXG4gICAgICAgICAgICBcXFwic2FsbW9uXFxcIixcXG4gICAgICAgICAgICBcXFwic2FuZHlicm93blxcXCIsXFxuICAgICAgICAgICAgXFxcInNlYWdyZWVuXFxcIixcXG4gICAgICAgICAgICBcXFwic2Vhc2hlbGxcXFwiLFxcbiAgICAgICAgICAgIFxcXCJzaWVubmFcXFwiLFxcbiAgICAgICAgICAgIFxcXCJzaWx2ZXJcXFwiLFxcbiAgICAgICAgICAgIFxcXCJza3libHVlXFxcIixcXG4gICAgICAgICAgICBcXFwic2xhdGVibHVlXFxcIixcXG4gICAgICAgICAgICBcXFwic2xhdGVncmF5XFxcIixcXG4gICAgICAgICAgICBcXFwic2xhdGVncmV5XFxcIixcXG4gICAgICAgICAgICBcXFwic25vd1xcXCIsXFxuICAgICAgICAgICAgXFxcInNwcmluZ2dyZWVuXFxcIixcXG4gICAgICAgICAgICBcXFwic3RlZWxibHVlXFxcIixcXG4gICAgICAgICAgICBcXFwidGFuXFxcIixcXG4gICAgICAgICAgICBcXFwidGVhbFxcXCIsXFxuICAgICAgICAgICAgXFxcInRoaXN0bGVcXFwiLFxcbiAgICAgICAgICAgIFxcXCJ0b21hdG9cXFwiLFxcbiAgICAgICAgICAgIFxcXCJ0dXJxdW9pc2VcXFwiLFxcbiAgICAgICAgICAgIFxcXCJ2aW9sZXRcXFwiLFxcbiAgICAgICAgICAgIFxcXCJ3aGVhdFxcXCIsXFxuICAgICAgICAgICAgXFxcIndoaXRlXFxcIixcXG4gICAgICAgICAgICBcXFwid2hpdGVzbW9rZVxcXCIsXFxuICAgICAgICAgICAgXFxcInllbGxvd1xcXCIsXFxuICAgICAgICAgICAgXFxcInllbGxvd2dyZWVuXFxcIixcXG4gICAgICAgICAgXS5pbmRleE9mKHZhbHVlLnRvTG93ZXJDYXNlKCkpIDwgMCl7XFxuICAgICAgICAgIFwiKS5jb25jYXQodGhpcy5tYWtlRXJyb3Ioe1xuICAgICAgICAgIHR5cGU6ICdjb2xvcicsXG4gICAgICAgICAgYWN0dWFsOiAndmFsdWUnLFxuICAgICAgICAgIG1lc3NhZ2VzOiBtZXNzYWdlc1xuICAgICAgICB9KSwgXCJcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgICBcIilcbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIHY7XG4gIH07XG5cbiAgdmFyIEpvdXJuZXkgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBKb3VybmV5KHByb3BzKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSm91cm5leSk7XG5cbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAnaW5jaWRlbnQnKSkge1xuICAgICAgICBoZWxwZXIuZXJyb3IoJ0pvdXJuZXkgY29uc3RydWN0b3IgZXhwZWN0cyBhbiBJbmNpZGVudCBvbiBpdHMgcHJvcGVydGllcyBvbiB0aGUga2V5IFwiaW5jaWRlbnRcIicpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWVtb3J5ID0gcHJvcHMuY2FscHVsZU1lbW9yeTtcbiAgICAgIHRoaXMuc3RhdGlvbnMgPSBbXTtcbiAgICAgIHRoaXMuaW5jaWRlbnQgPSBwcm9wcy5pbmNpZGVudDtcbiAgICAgIHRoaXMuc3RhcnRNaWxsaXNlY29uZCA9IHRoaXMuaW5jaWRlbnQucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kICogMTtcbiAgICAgIHRoaXMuc3RhcnRTdGF0ZSA9IFwiXCIuY29uY2F0KHRoaXMuaW5jaWRlbnQucnVuVGltZUluZm8uc3RhdGUpO1xuICAgICAgdGhpcy5pbmNpZGVudC5zdG9wKCk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEpvdXJuZXksIFt7XG4gICAgICBrZXk6IFwic3RhdGlvblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXRpb24obWlsbGlzZWNvbmQpIHtcbiAgICAgICAgdmFyIHByb3BzID0ge307XG5cbiAgICAgICAgaWYgKHRoaXMuc3RhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHByb3BzLnByZXZpb3VzU3RvcCA9IHRoaXMuc3RhdGlvbnNbdGhpcy5zdGF0aW9ucy5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhdGlvbnMucHVzaChtaWxsaXNlY29uZCk7IC8vIGhlbHBlci5sb2coYENBUFNVTEUgcGFzc2VzIGFzIHByZXZpb3VzU3RvcDogJHtwcm9wcy5wcmV2aW91c1N0b3B9YCk7XG4gICAgICAgIC8vIGhlbHBlci5sb2codGhpcy5zdGF0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5pbmNpZGVudC5wbGF5YWJsZVByb2dyZXNzKG1pbGxpc2Vjb25kIC8gdGhpcy5pbmNpZGVudC5kdXJhdGlvbiwgbWlsbGlzZWNvbmQpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkZXN0aW5hdGlvblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3RpbmF0aW9uKCkge1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG5cbiAgICAgICAgaWYgKG1pbGxpc2Vjb25kICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnN0YXRpb24obWlsbGlzZWNvbmQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1pbGxpc2Vjb25kID0gdGhpcy5zdGF0aW9uc1t0aGlzLnN0YXRpb25zLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbmNpZGVudC5wbGF5YWJsZVByb2dyZXNzKG1pbGxpc2Vjb25kIC8gdGhpcy5pbmNpZGVudC5kdXJhdGlvbiwgbWlsbGlzZWNvbmQpOyAvLyBpZiB0aGUgY2xpcCB3YXMgcGxheWluZyBzdGFydCBpdCBhZ2FpblxuXG4gICAgICAgIGlmICh0aGlzLnN0YXJ0U3RhdGUgPT09ICdwbGF5aW5nJyB8fCB0aGlzLnN0YXJ0U3RhdGUgPT09ICdibG9ja2VkJyAmJiB0aGlzLmluY2lkZW50LnN0YXR1c0JlZm9yZUJsb2NrID09PSAncGxheWluZycpIHtcbiAgICAgICAgICB0aGlzLmluY2lkZW50LnBsYXkoKTtcbiAgICAgICAgfSBlbHNlIGlmIChtaWxsaXNlY29uZCA+PSB0aGlzLmluY2lkZW50LmR1cmF0aW9uKSB7XG4gICAgICAgICAgdGhpcy5pbmNpZGVudC5jb21wbGV0ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuaW5jaWRlbnQuYXJtKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1lbW9yeS5wdXNoKHRoaXMuZXhwb3J0Sm91cm5leUxvZyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImV4cG9ydEpvdXJuZXlMb2dcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBleHBvcnRKb3VybmV5TG9nKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXJ0TWlsbGlzZWNvbmQ6IHRoaXMuc3RhcnRNaWxsaXNlY29uZCxcbiAgICAgICAgICBzdGFydFN0YXRlOiB0aGlzLnN0YXJ0U3RhdGUsXG4gICAgICAgICAgc3RhdGlvbnM6IHRoaXMuc3RhdGlvbnNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gSm91cm5leTtcbiAgfSgpO1xuXG4gIHZhciBUaW1lQ2Fwc3VsZSA9XG4gIC8qI19fUFVSRV9fKi9cbiAgZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRpbWVDYXBzdWxlKCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRpbWVDYXBzdWxlKTtcblxuICAgICAgdGhpcy5tZW1vcnkgPSBbXTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoVGltZUNhcHN1bGUsIFt7XG4gICAgICBrZXk6IFwic3RhcnRKb3VybmV5XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnRKb3VybmV5KGluY2lkZW50KSB7XG4gICAgICAgIGlmICghaW5jaWRlbnQpIHtcbiAgICAgICAgICBoZWxwZXIuZXJyb3IoJ3N0YXJ0Sm91cm5leSBleHBlY3RzIGFuIEluY2lkZW50IGFzIGFuIGFyZ3VtZW50Jyk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBKb3VybmV5KHtcbiAgICAgICAgICBpbmNpZGVudDogaW5jaWRlbnQsXG4gICAgICAgICAgY2FscHVsZU1lbW9yeTogdGhpcy5tZW1vcnlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFRpbWVDYXBzdWxlO1xuICB9KCk7XG5cbiAgdmFyIHYgPSBjcmVhdGVWYWxpZGF0b3IoKTtcbiAgdmFyIGhlbHBlciQxID0gbmV3IEhlbHBlcih7XG4gICAgbG9nTGV2ZWw6IDBcbiAgfSk7XG5cbiAgZnVuY3Rpb24gY2hlY2tQbHVnaW4obWFpbikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFpbiwgJ2RlZmF1bHQnKSkge1xuICAgICAgbWFpbiA9IG1haW4uZGVmYXVsdDtcbiAgICB9XG5cbiAgICB2YXIgcGx1Z2luX25hbWUgPSBtYWluLm5wbV9uYW1lO1xuICAgIHZhciBjaGVjayA9IHRydWU7XG5cbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYWluLCAnbmFtZScpKSB7XG4gICAgICBoZWxwZXIkMS5lcnJvcihcIldhcm5pbmcgb24gcGx1Z2luIFwiLmNvbmNhdChwbHVnaW5fbmFtZSwgXCIuIEEgcGx1Z2luIGlzIGFsd2F5cyBnb29kIHRvIGhhdmUgaXRzIG5hbWUgb25cXG4gICAgICAgIGl0cyBtYWluLmpzIGZpbGUsIHVuZGVyIHRoZSBrZXkgXFxcIm5hbWVcXFwiLiBJdCdzIG1pc3NpbmcgZnJvbSB0aGlzIHBsdWdpblwiKSk7XG4gICAgfVxuXG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFpbiwgJ2luY2lkZW50cycpICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFpbiwgJ0NsaXAnKSkge1xuICAgICAgaGVscGVyJDEuZXJyb3IoXCJFcnJvciBvbiBwbHVnaW4gXCIuY29uY2F0KHBsdWdpbl9uYW1lLCBcIi4gQSBwbHVnaW4gbXVzdCBleHBvc2UgYXQgbGVhc3Qgb25lIEluY2lkZW50IG9yIGEgQ2xpcC5cXG4gICAgICAgIEV4cG9zZWQgcGx1Z2luIEluY2lkZW50cyBzaG91bGQgYmUgZGVmaW5lZCBvbiB0aGUgXFxcImluY2lkZW50c1xcXCIga2V5IG9mIHRoZSBtYWluLmpzIGZpbGUgd2hpbGUgQ2xpcHMgb24gdGhlIFxcXCJDbGlwXFxcIi5cIikpO1xuICAgICAgY2hlY2sgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1haW4sICdpbmNpZGVudHMnKSAmJiAhQXJyYXkuaXNBcnJheShtYWluLmluY2lkZW50cykpIHtcbiAgICAgIGhlbHBlciQxLmVycm9yKFwiRXJyb3Igb24gcGx1Z2luIFwiLmNvbmNhdChwbHVnaW5fbmFtZSwgXCIuIHRoZVBsdWdpbiBleHBvc2VkIEluY2lkZW50cyBhcmUgZGVmaW5lZCBvbiB0aGUgXFxcImluY2lkZW50c1xcXCIga2V5IG9mIHRoZSBtYWluLmpzIGZpbGUgaW4gYXJyYXkgZm9ybWF0LlxcbiAgICAgICAgUGxlYXNlIHJlZmVyIHRvIHRoZSBkb2N1bWVudGF0aW9uXCIpKTtcbiAgICAgIGNoZWNrID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFpbiwgJ2luY2lkZW50cycpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1haW4uaW5jaWRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBleHBvc2VkSW5jaWRlbnREZWZpbml0aW9uID0gbWFpbi5pbmNpZGVudHNbaV07XG5cbiAgICAgICAgaWYgKF90eXBlb2YoZXhwb3NlZEluY2lkZW50RGVmaW5pdGlvbi5leHBvcnRhYmxlKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9zZWRJbmNpZGVudERlZmluaXRpb24uZXhwb3J0YWJsZSwgJ2RlZmF1bHQnKSkge1xuICAgICAgICAgICAgZXhwb3NlZEluY2lkZW50RGVmaW5pdGlvbi5leHBvcnRhYmxlID0gZXhwb3NlZEluY2lkZW50RGVmaW5pdGlvbi5leHBvcnRhYmxlLmRlZmF1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEoZXhwb3NlZEluY2lkZW50RGVmaW5pdGlvbi5leHBvcnRhYmxlLnByb3RvdHlwZSBpbnN0YW5jZW9mIERlc2NyaXB0aXZlR3JvdXApICYmICEoZXhwb3NlZEluY2lkZW50RGVmaW5pdGlvbi5leHBvcnRhYmxlLnByb3RvdHlwZSBpbnN0YW5jZW9mIERlc2NyaXB0aXZlQ2xpcCkgJiYgIShleHBvc2VkSW5jaWRlbnREZWZpbml0aW9uLmV4cG9ydGFibGUucHJvdG90eXBlIGluc3RhbmNlb2YgTW9ub0luY2lkZW50KSAmJiAhKGV4cG9zZWRJbmNpZGVudERlZmluaXRpb24uZXhwb3J0YWJsZS5wcm90b3R5cGUgaW5zdGFuY2VvZiBNZWRpYVBsYXkpKSB7XG4gICAgICAgICAgaGVscGVyJDEuZXJyb3IoXCJFcnJvciBvbiBwbHVnaW4gXCIuY29uY2F0KHBsdWdpbl9uYW1lLCBcIi4gRXhwb3J0YWJsZSBJbmNpZGVudHMgYnkgYW55IHBsdWdpbiBtdXN0IGV4dGVuZCBvbmUgb2YgdGhlIGJhc2UgY2xhc3NlcyBwcm92aWRlZCBieSBNb3RvckNvcnRleC5cXG4gICAgICAgICAgICAgICAgXCIpLmNvbmNhdChleHBvc2VkSW5jaWRlbnREZWZpbml0aW9uLmV4cG9ydGFibGUuY29uc3RydWN0b3IubmFtZSwgXCIgZG9lc24ndC5cXG4gICAgICAgICAgICAgICAgUGxlYXNlIHJlZmVyIHRvIGRvY3VtZW50YXRpb25cIikpO1xuICAgICAgICAgIGNoZWNrID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvc2VkSW5jaWRlbnREZWZpbml0aW9uLCAnbmFtZScpKSB7XG4gICAgICAgICAgaGVscGVyJDEuZXJyb3IoXCJFcnJvciBvbiBwbHVnaW4gXCIuY29uY2F0KHBsdWdpbl9uYW1lLCBcIi4gRXhwb3J0YWJsZSBJbmNpZGVudHMgYnkgYW55IHBsdWdpbiBtdXN0IGhhdmUgdGhlIFxcXCJuYW1lXFxcIiBrZXkgd2hpY2ggZGVmaW5lcyB0aGUgbmFtZSBvZiB0aGUgZXhwb3J0ZWQgSW5jaWRlbnQuXFxuICAgICAgICAgICAgICAgIFBsZWFzZSByZWZlciB0byBkb2N1bWVudGF0aW9uXCIpKTtcbiAgICAgICAgICBjaGVjayA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3NlZEluY2lkZW50RGVmaW5pdGlvbiwgJ3Byb3BUeXBlcycpKSB7XG4gICAgICAgICAgaGVscGVyJDEubG9nKFwiV2FybmluZyBvbiBwbHVnaW4gXCIuY29uY2F0KHBsdWdpbl9uYW1lLCBcIi5cXG4gICAgICAgICAgICAgICAgSXQncyBhbHdheXMgZ29vZCBmb3IgcGx1Z2lucyB0byBkZWZpbmUgdGhlIHN1cHBvcnRlZCBwcm9wVHlwZXMgb2YgdGhlaXIgZXhwb3NlZCBJbmNpZGVudHMnIHN1cHBvcnRlZCBwcm9wZXJ0aWVzLlxcbiAgICAgICAgICAgICAgICBcIikuY29uY2F0KGV4cG9zZWRJbmNpZGVudERlZmluaXRpb24uZXhwb3J0YWJsZS5jb25zdHJ1Y3Rvci5uYW1lLCBcIiBkb2Vzbid0LlxcbiAgICAgICAgICAgICAgICBQbGVhc2UgcmVmZXIgdG8gZG9jdW1lbnRhdGlvblwiKSwgJ3dhcm5pbmcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjaGVjaztcbiAgfSAvLyBwbHVnaW5fbmFtZSBpcyB0aGUgdW5pcXVlIG5hbWUgb2YgdGhlIHBsdWdpblxuXG5cbiAgZnVuY3Rpb24gbG9hZFBsdWdpbihwbHVnaW4pIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBsdWdpbiwgJ2RlZmF1bHQnKSkge1xuICAgICAgcGx1Z2luID0gcGx1Z2luLmRlZmF1bHQ7XG4gICAgfVxuXG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGx1Z2luLCAnbnBtX25hbWUnKSkge1xuICAgICAgcGx1Z2luLm5wbV9uYW1lID0gXCJwbHVnaW5fXCIuY29uY2F0KG5ldyBEYXRlKCkuZ2V0VGltZSgpKTtcbiAgICB9XG5cbiAgICBpZiAoIWNoZWNrUGx1Z2luKHBsdWdpbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIHRoZVBsdWdpbiBpcyB0aGUgcGx1Z2luIG9iamVjdCB3aGljaCB3aWxsIGhvbGQgb24gaXRzIGtleXNcbiAgICAvLyB0aGUgbmFtZXMgb2YgdGhlIGV4cG9zZWQgSW5jaWRlbnRzIG9mIGl0cy4gVGhlIGtleXMgb2YgdGhpcyBvYmplY3RcbiAgICAvLyBhcmUgZ29pbmcgdG8gYmUgaWRlbnRpY2FsIHdpdGggdGhlIG5hbWVzIG9mIHRoZSBjbGFzc2VzIGV4cG9zZWRcblxuXG4gICAgdmFyIHRoZVBsdWdpbiA9IHt9O1xuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwbHVnaW4sICdDbGlwJykpIHtcbiAgICAgIHZhciBfY2xhc3MsIF90ZW1wO1xuXG4gICAgICB2YXIgRHluYW1pY0Rlc2NyaXB0aXZlQ2xpcCA9IChfdGVtcCA9IF9jbGFzcyA9XG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBmdW5jdGlvbiAoX0Rlc2NyaXB0aXZlQ2xpcCkge1xuICAgICAgICBfaW5oZXJpdHMoRHluYW1pY0Rlc2NyaXB0aXZlQ2xpcCwgX0Rlc2NyaXB0aXZlQ2xpcCk7XG5cbiAgICAgICAgZnVuY3Rpb24gRHluYW1pY0Rlc2NyaXB0aXZlQ2xpcCgpIHtcbiAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRHluYW1pY0Rlc2NyaXB0aXZlQ2xpcCk7XG5cbiAgICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKER5bmFtaWNEZXNjcmlwdGl2ZUNsaXApLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIER5bmFtaWNEZXNjcmlwdGl2ZUNsaXA7XG4gICAgICB9KERlc2NyaXB0aXZlQ2xpcCksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3MsIFwiSW5jaWRlbnRcIiwgcGx1Z2luLkNsaXApLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzLCBcImF1ZGlvXCIsIHBsdWdpbi5hdWRpbyA/IHBsdWdpbi5hdWRpbyA6ICdvZmYnKSwgX2RlZmluZVByb3BlcnR5KF9jbGFzcywgXCJjdXN0b21DbGlwXCIsIHRydWUpLCBfdGVtcCk7XG4gICAgICB0aGVQbHVnaW4uQ2xpcCA9IER5bmFtaWNEZXNjcmlwdGl2ZUNsaXA7XG4gICAgfSAvLyBpZiB0aGUgcGx1Z2luIGRlZmluaXRpb24gaGFzIGNvbXBvc2l0ZUF0dHJpYnV0ZXMgdGhlbiB3ZSBkeW5hbWljYWxseVxuICAgIC8vIGNyZWF0ZSBhIG5ldyBDaGFubmVsIGNsYXNzIGV4dGVuZGluZyBBdHRyaWJ1dGVDaGFubmVsIHNldHRpbmcgdGhlXG4gICAgLy8gY29tcG9zaXRlIEF0dHJpYnV0ZXMgb24gdGhlIGZseS4gV2UgY2FuIHRoZW4gdXNlIHRoaXMgQ2hhbm5lbCBjbGFzc1xuICAgIC8vIGZvciBhbGwgSW5jaWRlbnRzIGV4cG9zZWQgYnkgdGhlIHBsdWdpblxuXG5cbiAgICB2YXIgQXR0cmlidXRlQ2hhbm5lbFRvVXNlID0gQXR0cmlidXRlQ2hhbm5lbDtcblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGx1Z2luLCAnY29tcG9zaXRlQXR0cmlidXRlcycpKSB7XG4gICAgICBBdHRyaWJ1dGVDaGFubmVsVG9Vc2UgPVxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgZnVuY3Rpb24gKF9BdHRyaWJ1dGVDaGFubmVsKSB7XG4gICAgICAgIF9pbmhlcml0cyhBdHRyaWJ1dGVDaGFubmVsVG9Vc2UsIF9BdHRyaWJ1dGVDaGFubmVsKTtcblxuICAgICAgICBmdW5jdGlvbiBBdHRyaWJ1dGVDaGFubmVsVG9Vc2UocHJvcHMpIHtcbiAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXR0cmlidXRlQ2hhbm5lbFRvVXNlKTtcblxuICAgICAgICAgIHByb3BzLmNvbWJvQXR0cmlidXRlcyA9IHBsdWdpbi5jb21wb3NpdGVBdHRyaWJ1dGVzO1xuICAgICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQXR0cmlidXRlQ2hhbm5lbFRvVXNlKS5jYWxsKHRoaXMsIHByb3BzKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gQXR0cmlidXRlQ2hhbm5lbFRvVXNlO1xuICAgICAgfShBdHRyaWJ1dGVDaGFubmVsKTtcbiAgICB9IC8vIGZvciBlYWNoIG9mIHRoZSBleHBvc2VkIEluY2lkZW50c1xuXG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBsdWdpbiwgJ2luY2lkZW50cycpKSB7XG4gICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChpKSB7XG4gICAgICAgIHZhciBpbmNpZGVudENsYXNzID0gcGx1Z2luLmluY2lkZW50c1tpXS5leHBvcnRhYmxlO1xuICAgICAgICB2YXIgRHluYW1pY0Rlc2NyaXB0aXZlSW5jaWRlbnQgPSB2b2lkIDA7IC8vIHRoZSBleHBvcnRhYmxlIEluY2lkZW50IGNhbiBiZSBlaXRoZXIgYSBDbGlwLCBhIENvbXBvIG9yIGFuIEluY2lkZW50XG4gICAgICAgIC8vIGlmIGl0IGlzIGFuIEluY2lkZW50XG5cbiAgICAgICAgaWYgKGluY2lkZW50Q2xhc3MucHJvdG90eXBlIGluc3RhbmNlb2YgTW9ub0luY2lkZW50KSB7XG4gICAgICAgICAgdmFyIF9jbGFzczIsIF90ZW1wMjtcblxuICAgICAgICAgIER5bmFtaWNEZXNjcmlwdGl2ZUluY2lkZW50ID0gKF90ZW1wMiA9IF9jbGFzczIgPVxuICAgICAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgICAgICBmdW5jdGlvbiAoX0Rlc2NyaXB0aXZlSW5jaWRlbnQpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhEeW5hbWljRGVzY3JpcHRpdmVJbmNpZGVudCwgX0Rlc2NyaXB0aXZlSW5jaWRlbnQpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBEeW5hbWljRGVzY3JpcHRpdmVJbmNpZGVudCgpIHtcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIER5bmFtaWNEZXNjcmlwdGl2ZUluY2lkZW50KTtcblxuICAgICAgICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKER5bmFtaWNEZXNjcmlwdGl2ZUluY2lkZW50KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIER5bmFtaWNEZXNjcmlwdGl2ZUluY2lkZW50O1xuICAgICAgICAgIH0oRGVzY3JpcHRpdmVJbmNpZGVudCksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3MyLCBcIkluY2lkZW50XCIsIGluY2lkZW50Q2xhc3MpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzMiwgXCJwbHVnaW5fbnBtX25hbWVcIiwgcGx1Z2luLm5wbV9uYW1lKSwgX2RlZmluZVByb3BlcnR5KF9jbGFzczIsIFwicGx1Z2luXCIsIHBsdWdpbi5uYW1lKSwgX2RlZmluZVByb3BlcnR5KF9jbGFzczIsIFwiQ2xhc3NOYW1lXCIsIHBsdWdpbi5pbmNpZGVudHNbaV0ubmFtZSksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3MyLCBcIkNoYW5uZWxcIiwgQXR0cmlidXRlQ2hhbm5lbFRvVXNlKSwgX2RlZmluZVByb3BlcnR5KF9jbGFzczIsIFwiYXVkaW9cIiwgcGx1Z2luLmF1ZGlvID8gcGx1Z2luLmF1ZGlvIDogJ29mZicpLCBfdGVtcDIpO1xuICAgICAgICB9IGVsc2UgaWYgKGluY2lkZW50Q2xhc3MucHJvdG90eXBlIGluc3RhbmNlb2YgTWVkaWFQbGF5KSB7XG4gICAgICAgICAgdmFyIF9jbGFzczMsIF90ZW1wMztcblxuICAgICAgICAgIER5bmFtaWNEZXNjcmlwdGl2ZUluY2lkZW50ID0gKF90ZW1wMyA9IF9jbGFzczMgPVxuICAgICAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgICAgICBmdW5jdGlvbiAoX0Rlc2NyaXB0aXZlSW5jaWRlbnQyKSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoRHluYW1pY0Rlc2NyaXB0aXZlSW5jaWRlbnQsIF9EZXNjcmlwdGl2ZUluY2lkZW50Mik7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIER5bmFtaWNEZXNjcmlwdGl2ZUluY2lkZW50KCkge1xuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRHluYW1pY0Rlc2NyaXB0aXZlSW5jaWRlbnQpO1xuXG4gICAgICAgICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoRHluYW1pY0Rlc2NyaXB0aXZlSW5jaWRlbnQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gRHluYW1pY0Rlc2NyaXB0aXZlSW5jaWRlbnQ7XG4gICAgICAgICAgfShEZXNjcmlwdGl2ZUluY2lkZW50KSwgX2RlZmluZVByb3BlcnR5KF9jbGFzczMsIFwiSW5jaWRlbnRcIiwgaW5jaWRlbnRDbGFzcyksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3MzLCBcInBsdWdpbl9ucG1fbmFtZVwiLCAnQGtpc3NteWJ1dHRvbi9tZWRpYS1wbGF5YmFjaycpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzMywgXCJwbHVnaW5cIiwgcGx1Z2luLm5hbWUpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzMywgXCJDbGFzc05hbWVcIiwgcGx1Z2luLmluY2lkZW50c1tpXS5uYW1lKSwgX2RlZmluZVByb3BlcnR5KF9jbGFzczMsIFwiQ2hhbm5lbFwiLCBBdWRpb1BsYXliYWNrQ2hhbm5lbCksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3MzLCBcImF1ZGlvXCIsIHBsdWdpbi5hdWRpbyA/IHBsdWdpbi5hdWRpbyA6ICdvZmYnKSwgX3RlbXAzKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbmNpZGVudENsYXNzLnByb3RvdHlwZSBpbnN0YW5jZW9mIERlc2NyaXB0aXZlQ2xpcCkge1xuICAgICAgICAgIHZhciBfY2xhc3M0LCBfdGVtcDQ7XG5cbiAgICAgICAgICBEeW5hbWljRGVzY3JpcHRpdmVJbmNpZGVudCA9IChfdGVtcDQgPSBfY2xhc3M0ID1cbiAgICAgICAgICAvKiNfX1BVUkVfXyovXG4gICAgICAgICAgZnVuY3Rpb24gKF9pbmNpZGVudENsYXNzKSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoRHluYW1pY0Rlc2NyaXB0aXZlSW5jaWRlbnQsIF9pbmNpZGVudENsYXNzKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gRHluYW1pY0Rlc2NyaXB0aXZlSW5jaWRlbnQoKSB7XG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEeW5hbWljRGVzY3JpcHRpdmVJbmNpZGVudCk7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihEeW5hbWljRGVzY3JpcHRpdmVJbmNpZGVudCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBEeW5hbWljRGVzY3JpcHRpdmVJbmNpZGVudDtcbiAgICAgICAgICB9KGluY2lkZW50Q2xhc3MpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzNCwgXCJwbHVnaW5cIiwgcGx1Z2luLm5hbWUpLCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzNCwgXCJDbGFzc05hbWVcIiwgcGx1Z2luLmluY2lkZW50c1tpXS5uYW1lKSwgX2RlZmluZVByb3BlcnR5KF9jbGFzczQsIFwiYXVkaW9cIiwgcGx1Z2luLmF1ZGlvID8gcGx1Z2luLmF1ZGlvIDogJ29uJyksIF90ZW1wNCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5jaWRlbnRDbGFzcy5wcm90b3R5cGUgaW5zdGFuY2VvZiBEZXNjcmlwdGl2ZUdyb3VwKSB7XG4gICAgICAgICAgdmFyIF9jbGFzczUsIF90ZW1wNTtcblxuICAgICAgICAgIER5bmFtaWNEZXNjcmlwdGl2ZUluY2lkZW50ID0gKF90ZW1wNSA9IF9jbGFzczUgPVxuICAgICAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgICAgICBmdW5jdGlvbiAoX2luY2lkZW50Q2xhc3MyKSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoRHluYW1pY0Rlc2NyaXB0aXZlSW5jaWRlbnQsIF9pbmNpZGVudENsYXNzMik7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIER5bmFtaWNEZXNjcmlwdGl2ZUluY2lkZW50KCkge1xuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRHluYW1pY0Rlc2NyaXB0aXZlSW5jaWRlbnQpO1xuXG4gICAgICAgICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoRHluYW1pY0Rlc2NyaXB0aXZlSW5jaWRlbnQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gRHluYW1pY0Rlc2NyaXB0aXZlSW5jaWRlbnQ7XG4gICAgICAgICAgfShpbmNpZGVudENsYXNzKSwgX2RlZmluZVByb3BlcnR5KF9jbGFzczUsIFwicGx1Z2luXCIsIHBsdWdpbi5uYW1lKSwgX2RlZmluZVByb3BlcnR5KF9jbGFzczUsIFwiQ2xhc3NOYW1lXCIsIHBsdWdpbi5pbmNpZGVudHNbaV0ubmFtZSksIF90ZW1wNSk7XG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhlUGx1Z2luLCBwbHVnaW4uaW5jaWRlbnRzW2ldLm5hbWUsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIC8vIHRoZSBnZXR0ZXIgd2lsbCBjb25zdHJ1Y3QgYSB3cmFwcGVyIGNsYXNzIHdoaWNoIG9uIHRoZSBjb25zdHJ1Y3RvciB3aWxsIGluc3RhbnRpYXRlIGFuIG9iamVjdCBvZiB0aGVcbiAgICAgICAgICAgIC8vIGV4cG9zZWQgY2xhc3MsIHNldCB0byBpdCB0aGUgcGx1Z2luIG5hbWUgYW5kIGNoYW5uZWwgY2xhc3MgcGFyYW1ldGVycyBhbmQgcmV0dXJuXG4gICAgICAgICAgICAvLyBpdCBmcm9tIHRoZSBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgdmFyIFdyYXBwZXJDbGFzcyA9IGZ1bmN0aW9uIFdyYXBwZXJDbGFzcyhhdHRycywgcHJvcHMpIHtcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdyYXBwZXJDbGFzcyk7XG5cbiAgICAgICAgICAgICAgdmFyIGluc3RhbnRpYXRlZEluY2lkZW50ID0gbmV3IER5bmFtaWNEZXNjcmlwdGl2ZUluY2lkZW50KGF0dHJzLCBwcm9wcyk7XG5cbiAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwbHVnaW4uaW5jaWRlbnRzW2ldLCAnYXR0cmlidXRlc1ZhbGlkYXRpb25SdWxlcycpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbGlkYXRpb25SZXN1bHQgPSB2LnZhbGlkYXRlKGF0dHJzLCBwbHVnaW4uaW5jaWRlbnRzW2ldLmF0dHJpYnV0ZXNWYWxpZGF0aW9uUnVsZXMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRpb25SZXN1bHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgdmFyIGVycm9yTWVzc2FnZSA9IFwiRXJyb3Igb24gcGx1Z2luJ3MgXFxcIlwiLmNvbmNhdChwbHVnaW4ubnBtX25hbWUsIFwiXFxcIiBcXFwiXCIpLmNvbmNhdChwbHVnaW4uaW5jaWRlbnRzW2ldLm5hbWUsIFwiXFxcIiBpbnN0YW50aWF0aW9uLiBFcnJvcnM6XCIpO1xuXG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbGlkYXRpb25SZXN1bHQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9IFwiXFxuIC0gXCIuY29uY2F0KHZhbGlkYXRpb25SZXN1bHRbal0ubWVzc2FnZSwgXCIuIFwiKS5jb25jYXQodmFsaWRhdGlvblJlc3VsdFtqXS5hY3R1YWwsIFwiIHByb3ZpZGVkXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yTWVzc2FnZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuXG4gICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcnM6IHZhbGlkYXRpb25SZXN1bHRcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGluc3RhbnRpYXRlZEluY2lkZW50LmF0dHJzVmFsaWRhdGlvblJ1bGVzID0gcGx1Z2luLmluY2lkZW50c1tpXS5hdHRyaWJ1dGVzVmFsaWRhdGlvblJ1bGVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBoZWxwZXIkMS53YXJuaW5nKFwiSXQncyBhbHdheXMgZ29vZCB0byBwcm92aWRlIGF0dHJpYnV0ZXNWYWxpZGF0aW9uUnVsZXMgdG8gdGhlIGV4cG9ydGVkIGluY2lkZW50cy4gXCIuY29uY2F0KHBsdWdpbi5ucG1fbmFtZSwgXCIuXCIpLmNvbmNhdChpbnN0YW50aWF0ZWRJbmNpZGVudC5jb25zdHJ1Y3Rvci5uYW1lLCBcIiBkb2Vzbid0IHByb3ZpZGUgaXRcIikpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbnRpYXRlZEluY2lkZW50O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIFdyYXBwZXJDbGFzcztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbHVnaW4uaW5jaWRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIF9sb29wKGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGVQbHVnaW47XG4gIH1cbiAgdmFyIEF1ZGlvUGx1Z2luID0gbG9hZFBsdWdpbihhdWRpb1BsdWdpbk1haW4pO1xuICB2YXIgQ2xpcCQyID0gRGVzY3JpcHRpdmVDbGlwO1xuICB2YXIgR3JvdXAkMSA9IERlc2NyaXB0aXZlR3JvdXA7XG4gIHZhciBBdWRpb0NsaXAkMSA9IEF1ZGlvUGx1Z2luLkNsaXA7XG4gIHZhciBBdWRpb1BsYXliYWNrJDEgPSBBdWRpb1BsdWdpbi5BdWRpb1BsYXliYWNrO1xuICB2YXIgQVBJID0ge1xuICAgIE1vbm9JbmNpZGVudDogTW9ub0luY2lkZW50LFxuICAgIEdyb3VwOiBHcm91cCQxLFxuICAgIENsaXA6IENsaXAkMixcbiAgICBBdWRpb0NsaXA6IERlc2NyaXB0aXZlQXVkaW9DbGlwLFxuICAgIE1lZGlhUGxheWJhY2s6IE1lZGlhUGxheSxcbiAgICBFeHRlbmRhYmxlQ2xpcDogRXh0ZW5kYWJsZUNsaXAsXG4gICAgRE9NQ2xpcDogQ2xpcCQxLFxuICAgIGVhc2luZ3M6IGVhc2luZyxcbiAgICBjbGlwRnJvbURlZmluaXRpb246IGNvbnN0cnVjdEluY2lkZW50XG4gIH07XG4gIHZhciBtYWluID0ge1xuICAgIEFQSTogQVBJLFxuICAgIEdyb3VwOiBHcm91cCQxLFxuICAgIENsaXA6IENsaXAkMixcbiAgICBsb2FkUGx1Z2luOiBsb2FkUGx1Z2luLFxuICAgIEF1ZGlvQ2xpcDogQXVkaW9DbGlwJDEsXG4gICAgQXVkaW9QbGF5YmFjazogQXVkaW9QbGF5YmFjayQxLFxuICAgIEF1ZGlvRWZmZWN0OiBBdWRpb1BsdWdpbi5BdWRpb0VmZmVjdCxcbiAgICBUaW1lQ2Fwc3VsZTogVGltZUNhcHN1bGVcbiAgfTtcblxuICBleHBvcnRzLkFQSSA9IEFQSTtcbiAgZXhwb3J0cy5BdWRpb0NsaXAgPSBBdWRpb0NsaXAkMTtcbiAgZXhwb3J0cy5BdWRpb1BsYXliYWNrID0gQXVkaW9QbGF5YmFjayQxO1xuICBleHBvcnRzLkNsaXAgPSBDbGlwJDI7XG4gIGV4cG9ydHMuR3JvdXAgPSBHcm91cCQxO1xuICBleHBvcnRzLlRpbWVDYXBzdWxlID0gVGltZUNhcHN1bGU7XG4gIGV4cG9ydHMuZGVmYXVsdCA9IG1haW47XG4gIGV4cG9ydHMubG9hZFBsdWdpbiA9IGxvYWRQbHVnaW47XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBLFdBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex/dist/motorcortex.umd.js\n");

/***/ }),

/***/ "../node_modules/es6-promise/dist/es6-promise.js":
/*!*******************************************************!*\
  !*** ../node_modules/es6-promise/dist/es6-promise.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process, global) {/*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE\n * @version   v4.2.8+1e68dce6\n */\n\n(function (global, factory) {\n\t true ? module.exports = factory() :\n\tundefined;\n}(this, (function () { 'use strict';\n\nfunction objectOrFunction(x) {\n  var type = typeof x;\n  return x !== null && (type === 'object' || type === 'function');\n}\n\nfunction isFunction(x) {\n  return typeof x === 'function';\n}\n\n\n\nvar _isArray = void 0;\nif (Array.isArray) {\n  _isArray = Array.isArray;\n} else {\n  _isArray = function (x) {\n    return Object.prototype.toString.call(x) === '[object Array]';\n  };\n}\n\nvar isArray = _isArray;\n\nvar len = 0;\nvar vertxNext = void 0;\nvar customSchedulerFn = void 0;\n\nvar asap = function asap(callback, arg) {\n  queue[len] = callback;\n  queue[len + 1] = arg;\n  len += 2;\n  if (len === 2) {\n    // If len is 2, that means that we need to schedule an async flush.\n    // If additional callbacks are queued before the queue is flushed, they\n    // will be processed by this flush that we are scheduling.\n    if (customSchedulerFn) {\n      customSchedulerFn(flush);\n    } else {\n      scheduleFlush();\n    }\n  }\n};\n\nfunction setScheduler(scheduleFn) {\n  customSchedulerFn = scheduleFn;\n}\n\nfunction setAsap(asapFn) {\n  asap = asapFn;\n}\n\nvar browserWindow = typeof window !== 'undefined' ? window : undefined;\nvar browserGlobal = browserWindow || {};\nvar BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;\nvar isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\n\n// test for web worker but not in IE10\nvar isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';\n\n// node\nfunction useNextTick() {\n  // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n  // see https://github.com/cujojs/when/issues/410 for details\n  return function () {\n    return process.nextTick(flush);\n  };\n}\n\n// vertx\nfunction useVertxTimer() {\n  if (typeof vertxNext !== 'undefined') {\n    return function () {\n      vertxNext(flush);\n    };\n  }\n\n  return useSetTimeout();\n}\n\nfunction useMutationObserver() {\n  var iterations = 0;\n  var observer = new BrowserMutationObserver(flush);\n  var node = document.createTextNode('');\n  observer.observe(node, { characterData: true });\n\n  return function () {\n    node.data = iterations = ++iterations % 2;\n  };\n}\n\n// web worker\nfunction useMessageChannel() {\n  var channel = new MessageChannel();\n  channel.port1.onmessage = flush;\n  return function () {\n    return channel.port2.postMessage(0);\n  };\n}\n\nfunction useSetTimeout() {\n  // Store setTimeout reference so es6-promise will be unaffected by\n  // other code modifying setTimeout (like sinon.useFakeTimers())\n  var globalSetTimeout = setTimeout;\n  return function () {\n    return globalSetTimeout(flush, 1);\n  };\n}\n\nvar queue = new Array(1000);\nfunction flush() {\n  for (var i = 0; i < len; i += 2) {\n    var callback = queue[i];\n    var arg = queue[i + 1];\n\n    callback(arg);\n\n    queue[i] = undefined;\n    queue[i + 1] = undefined;\n  }\n\n  len = 0;\n}\n\nfunction attemptVertx() {\n  try {\n    var vertx = Function('return this')().require('vertx');\n    vertxNext = vertx.runOnLoop || vertx.runOnContext;\n    return useVertxTimer();\n  } catch (e) {\n    return useSetTimeout();\n  }\n}\n\nvar scheduleFlush = void 0;\n// Decide what async method to use to triggering processing of queued callbacks:\nif (isNode) {\n  scheduleFlush = useNextTick();\n} else if (BrowserMutationObserver) {\n  scheduleFlush = useMutationObserver();\n} else if (isWorker) {\n  scheduleFlush = useMessageChannel();\n} else if (browserWindow === undefined && \"function\" === 'function') {\n  scheduleFlush = attemptVertx();\n} else {\n  scheduleFlush = useSetTimeout();\n}\n\nfunction then(onFulfillment, onRejection) {\n  var parent = this;\n\n  var child = new this.constructor(noop);\n\n  if (child[PROMISE_ID] === undefined) {\n    makePromise(child);\n  }\n\n  var _state = parent._state;\n\n\n  if (_state) {\n    var callback = arguments[_state - 1];\n    asap(function () {\n      return invokeCallback(_state, child, callback, parent._result);\n    });\n  } else {\n    subscribe(parent, child, onFulfillment, onRejection);\n  }\n\n  return child;\n}\n\n/**\n  `Promise.resolve` returns a promise that will become resolved with the\n  passed `value`. It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    resolve(1);\n  });\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.resolve(1);\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  @method resolve\n  @static\n  @param {Any} value value that the returned promise will be resolved with\n  Useful for tooling.\n  @return {Promise} a promise that will become fulfilled with the given\n  `value`\n*/\nfunction resolve$1(object) {\n  /*jshint validthis:true */\n  var Constructor = this;\n\n  if (object && typeof object === 'object' && object.constructor === Constructor) {\n    return object;\n  }\n\n  var promise = new Constructor(noop);\n  resolve(promise, object);\n  return promise;\n}\n\nvar PROMISE_ID = Math.random().toString(36).substring(2);\n\nfunction noop() {}\n\nvar PENDING = void 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\n\nfunction selfFulfillment() {\n  return new TypeError(\"You cannot resolve a promise with itself\");\n}\n\nfunction cannotReturnOwn() {\n  return new TypeError('A promises callback cannot return that same promise.');\n}\n\nfunction tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {\n  try {\n    then$$1.call(value, fulfillmentHandler, rejectionHandler);\n  } catch (e) {\n    return e;\n  }\n}\n\nfunction handleForeignThenable(promise, thenable, then$$1) {\n  asap(function (promise) {\n    var sealed = false;\n    var error = tryThen(then$$1, thenable, function (value) {\n      if (sealed) {\n        return;\n      }\n      sealed = true;\n      if (thenable !== value) {\n        resolve(promise, value);\n      } else {\n        fulfill(promise, value);\n      }\n    }, function (reason) {\n      if (sealed) {\n        return;\n      }\n      sealed = true;\n\n      reject(promise, reason);\n    }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n    if (!sealed && error) {\n      sealed = true;\n      reject(promise, error);\n    }\n  }, promise);\n}\n\nfunction handleOwnThenable(promise, thenable) {\n  if (thenable._state === FULFILLED) {\n    fulfill(promise, thenable._result);\n  } else if (thenable._state === REJECTED) {\n    reject(promise, thenable._result);\n  } else {\n    subscribe(thenable, undefined, function (value) {\n      return resolve(promise, value);\n    }, function (reason) {\n      return reject(promise, reason);\n    });\n  }\n}\n\nfunction handleMaybeThenable(promise, maybeThenable, then$$1) {\n  if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {\n    handleOwnThenable(promise, maybeThenable);\n  } else {\n    if (then$$1 === undefined) {\n      fulfill(promise, maybeThenable);\n    } else if (isFunction(then$$1)) {\n      handleForeignThenable(promise, maybeThenable, then$$1);\n    } else {\n      fulfill(promise, maybeThenable);\n    }\n  }\n}\n\nfunction resolve(promise, value) {\n  if (promise === value) {\n    reject(promise, selfFulfillment());\n  } else if (objectOrFunction(value)) {\n    var then$$1 = void 0;\n    try {\n      then$$1 = value.then;\n    } catch (error) {\n      reject(promise, error);\n      return;\n    }\n    handleMaybeThenable(promise, value, then$$1);\n  } else {\n    fulfill(promise, value);\n  }\n}\n\nfunction publishRejection(promise) {\n  if (promise._onerror) {\n    promise._onerror(promise._result);\n  }\n\n  publish(promise);\n}\n\nfunction fulfill(promise, value) {\n  if (promise._state !== PENDING) {\n    return;\n  }\n\n  promise._result = value;\n  promise._state = FULFILLED;\n\n  if (promise._subscribers.length !== 0) {\n    asap(publish, promise);\n  }\n}\n\nfunction reject(promise, reason) {\n  if (promise._state !== PENDING) {\n    return;\n  }\n  promise._state = REJECTED;\n  promise._result = reason;\n\n  asap(publishRejection, promise);\n}\n\nfunction subscribe(parent, child, onFulfillment, onRejection) {\n  var _subscribers = parent._subscribers;\n  var length = _subscribers.length;\n\n\n  parent._onerror = null;\n\n  _subscribers[length] = child;\n  _subscribers[length + FULFILLED] = onFulfillment;\n  _subscribers[length + REJECTED] = onRejection;\n\n  if (length === 0 && parent._state) {\n    asap(publish, parent);\n  }\n}\n\nfunction publish(promise) {\n  var subscribers = promise._subscribers;\n  var settled = promise._state;\n\n  if (subscribers.length === 0) {\n    return;\n  }\n\n  var child = void 0,\n      callback = void 0,\n      detail = promise._result;\n\n  for (var i = 0; i < subscribers.length; i += 3) {\n    child = subscribers[i];\n    callback = subscribers[i + settled];\n\n    if (child) {\n      invokeCallback(settled, child, callback, detail);\n    } else {\n      callback(detail);\n    }\n  }\n\n  promise._subscribers.length = 0;\n}\n\nfunction invokeCallback(settled, promise, callback, detail) {\n  var hasCallback = isFunction(callback),\n      value = void 0,\n      error = void 0,\n      succeeded = true;\n\n  if (hasCallback) {\n    try {\n      value = callback(detail);\n    } catch (e) {\n      succeeded = false;\n      error = e;\n    }\n\n    if (promise === value) {\n      reject(promise, cannotReturnOwn());\n      return;\n    }\n  } else {\n    value = detail;\n  }\n\n  if (promise._state !== PENDING) {\n    // noop\n  } else if (hasCallback && succeeded) {\n    resolve(promise, value);\n  } else if (succeeded === false) {\n    reject(promise, error);\n  } else if (settled === FULFILLED) {\n    fulfill(promise, value);\n  } else if (settled === REJECTED) {\n    reject(promise, value);\n  }\n}\n\nfunction initializePromise(promise, resolver) {\n  try {\n    resolver(function resolvePromise(value) {\n      resolve(promise, value);\n    }, function rejectPromise(reason) {\n      reject(promise, reason);\n    });\n  } catch (e) {\n    reject(promise, e);\n  }\n}\n\nvar id = 0;\nfunction nextId() {\n  return id++;\n}\n\nfunction makePromise(promise) {\n  promise[PROMISE_ID] = id++;\n  promise._state = undefined;\n  promise._result = undefined;\n  promise._subscribers = [];\n}\n\nfunction validationError() {\n  return new Error('Array Methods must be provided an Array');\n}\n\nvar Enumerator = function () {\n  function Enumerator(Constructor, input) {\n    this._instanceConstructor = Constructor;\n    this.promise = new Constructor(noop);\n\n    if (!this.promise[PROMISE_ID]) {\n      makePromise(this.promise);\n    }\n\n    if (isArray(input)) {\n      this.length = input.length;\n      this._remaining = input.length;\n\n      this._result = new Array(this.length);\n\n      if (this.length === 0) {\n        fulfill(this.promise, this._result);\n      } else {\n        this.length = this.length || 0;\n        this._enumerate(input);\n        if (this._remaining === 0) {\n          fulfill(this.promise, this._result);\n        }\n      }\n    } else {\n      reject(this.promise, validationError());\n    }\n  }\n\n  Enumerator.prototype._enumerate = function _enumerate(input) {\n    for (var i = 0; this._state === PENDING && i < input.length; i++) {\n      this._eachEntry(input[i], i);\n    }\n  };\n\n  Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {\n    var c = this._instanceConstructor;\n    var resolve$$1 = c.resolve;\n\n\n    if (resolve$$1 === resolve$1) {\n      var _then = void 0;\n      var error = void 0;\n      var didError = false;\n      try {\n        _then = entry.then;\n      } catch (e) {\n        didError = true;\n        error = e;\n      }\n\n      if (_then === then && entry._state !== PENDING) {\n        this._settledAt(entry._state, i, entry._result);\n      } else if (typeof _then !== 'function') {\n        this._remaining--;\n        this._result[i] = entry;\n      } else if (c === Promise$1) {\n        var promise = new c(noop);\n        if (didError) {\n          reject(promise, error);\n        } else {\n          handleMaybeThenable(promise, entry, _then);\n        }\n        this._willSettleAt(promise, i);\n      } else {\n        this._willSettleAt(new c(function (resolve$$1) {\n          return resolve$$1(entry);\n        }), i);\n      }\n    } else {\n      this._willSettleAt(resolve$$1(entry), i);\n    }\n  };\n\n  Enumerator.prototype._settledAt = function _settledAt(state, i, value) {\n    var promise = this.promise;\n\n\n    if (promise._state === PENDING) {\n      this._remaining--;\n\n      if (state === REJECTED) {\n        reject(promise, value);\n      } else {\n        this._result[i] = value;\n      }\n    }\n\n    if (this._remaining === 0) {\n      fulfill(promise, this._result);\n    }\n  };\n\n  Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {\n    var enumerator = this;\n\n    subscribe(promise, undefined, function (value) {\n      return enumerator._settledAt(FULFILLED, i, value);\n    }, function (reason) {\n      return enumerator._settledAt(REJECTED, i, reason);\n    });\n  };\n\n  return Enumerator;\n}();\n\n/**\n  `Promise.all` accepts an array of promises, and returns a new promise which\n  is fulfilled with an array of fulfillment values for the passed promises, or\n  rejected with the reason of the first passed promise to be rejected. It casts all\n  elements of the passed iterable to promises as it runs this algorithm.\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = resolve(2);\n  let promise3 = resolve(3);\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // The array here would be [ 1, 2, 3 ];\n  });\n  ```\n\n  If any of the `promises` given to `all` are rejected, the first promise\n  that is rejected will be given as an argument to the returned promises's\n  rejection handler. For example:\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = reject(new Error(\"2\"));\n  let promise3 = reject(new Error(\"3\"));\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // Code here never runs because there are rejected promises!\n  }, function(error) {\n    // error.message === \"2\"\n  });\n  ```\n\n  @method all\n  @static\n  @param {Array} entries array of promises\n  @param {String} label optional string for labeling the promise.\n  Useful for tooling.\n  @return {Promise} promise that is fulfilled when all `promises` have been\n  fulfilled, or rejected if any of them become rejected.\n  @static\n*/\nfunction all(entries) {\n  return new Enumerator(this, entries).promise;\n}\n\n/**\n  `Promise.race` returns a new promise which is settled in the same way as the\n  first passed promise to settle.\n\n  Example:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 2');\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // result === 'promise 2' because it was resolved before promise1\n    // was resolved.\n  });\n  ```\n\n  `Promise.race` is deterministic in that only the state of the first\n  settled promise matters. For example, even if other promises given to the\n  `promises` array argument are resolved, but the first settled promise has\n  become rejected before the other promises became fulfilled, the returned\n  promise will become rejected:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      reject(new Error('promise 2'));\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // Code here never runs\n  }, function(reason){\n    // reason.message === 'promise 2' because promise 2 became rejected before\n    // promise 1 became fulfilled\n  });\n  ```\n\n  An example real-world use case is implementing timeouts:\n\n  ```javascript\n  Promise.race([ajax('foo.json'), timeout(5000)])\n  ```\n\n  @method race\n  @static\n  @param {Array} promises array of promises to observe\n  Useful for tooling.\n  @return {Promise} a promise which settles in the same way as the first passed\n  promise to settle.\n*/\nfunction race(entries) {\n  /*jshint validthis:true */\n  var Constructor = this;\n\n  if (!isArray(entries)) {\n    return new Constructor(function (_, reject) {\n      return reject(new TypeError('You must pass an array to race.'));\n    });\n  } else {\n    return new Constructor(function (resolve, reject) {\n      var length = entries.length;\n      for (var i = 0; i < length; i++) {\n        Constructor.resolve(entries[i]).then(resolve, reject);\n      }\n    });\n  }\n}\n\n/**\n  `Promise.reject` returns a promise rejected with the passed `reason`.\n  It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    reject(new Error('WHOOPS'));\n  });\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.reject(new Error('WHOOPS'));\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  @method reject\n  @static\n  @param {Any} reason value that the returned promise will be rejected with.\n  Useful for tooling.\n  @return {Promise} a promise rejected with the given `reason`.\n*/\nfunction reject$1(reason) {\n  /*jshint validthis:true */\n  var Constructor = this;\n  var promise = new Constructor(noop);\n  reject(promise, reason);\n  return promise;\n}\n\nfunction needsResolver() {\n  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n}\n\nfunction needsNew() {\n  throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n}\n\n/**\n  Promise objects represent the eventual result of an asynchronous operation. The\n  primary way of interacting with a promise is through its `then` method, which\n  registers callbacks to receive either a promise's eventual value or the reason\n  why the promise cannot be fulfilled.\n\n  Terminology\n  -----------\n\n  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n  - `thenable` is an object or function that defines a `then` method.\n  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n  - `exception` is a value that is thrown using the throw statement.\n  - `reason` is a value that indicates why a promise was rejected.\n  - `settled` the final resting state of a promise, fulfilled or rejected.\n\n  A promise can be in one of three states: pending, fulfilled, or rejected.\n\n  Promises that are fulfilled have a fulfillment value and are in the fulfilled\n  state.  Promises that are rejected have a rejection reason and are in the\n  rejected state.  A fulfillment value is never a thenable.\n\n  Promises can also be said to *resolve* a value.  If this value is also a\n  promise, then the original promise's settled state will match the value's\n  settled state.  So a promise that *resolves* a promise that rejects will\n  itself reject, and a promise that *resolves* a promise that fulfills will\n  itself fulfill.\n\n\n  Basic Usage:\n  ------------\n\n  ```js\n  let promise = new Promise(function(resolve, reject) {\n    // on success\n    resolve(value);\n\n    // on failure\n    reject(reason);\n  });\n\n  promise.then(function(value) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Advanced Usage:\n  ---------------\n\n  Promises shine when abstracting away asynchronous interactions such as\n  `XMLHttpRequest`s.\n\n  ```js\n  function getJSON(url) {\n    return new Promise(function(resolve, reject){\n      let xhr = new XMLHttpRequest();\n\n      xhr.open('GET', url);\n      xhr.onreadystatechange = handler;\n      xhr.responseType = 'json';\n      xhr.setRequestHeader('Accept', 'application/json');\n      xhr.send();\n\n      function handler() {\n        if (this.readyState === this.DONE) {\n          if (this.status === 200) {\n            resolve(this.response);\n          } else {\n            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n          }\n        }\n      };\n    });\n  }\n\n  getJSON('/posts.json').then(function(json) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Unlike callbacks, promises are great composable primitives.\n\n  ```js\n  Promise.all([\n    getJSON('/posts'),\n    getJSON('/comments')\n  ]).then(function(values){\n    values[0] // => postsJSON\n    values[1] // => commentsJSON\n\n    return values;\n  });\n  ```\n\n  @class Promise\n  @param {Function} resolver\n  Useful for tooling.\n  @constructor\n*/\n\nvar Promise$1 = function () {\n  function Promise(resolver) {\n    this[PROMISE_ID] = nextId();\n    this._result = this._state = undefined;\n    this._subscribers = [];\n\n    if (noop !== resolver) {\n      typeof resolver !== 'function' && needsResolver();\n      this instanceof Promise ? initializePromise(this, resolver) : needsNew();\n    }\n  }\n\n  /**\n  The primary way of interacting with a promise is through its `then` method,\n  which registers callbacks to receive either a promise's eventual value or the\n  reason why the promise cannot be fulfilled.\n   ```js\n  findUser().then(function(user){\n    // user is available\n  }, function(reason){\n    // user is unavailable, and you are given the reason why\n  });\n  ```\n   Chaining\n  --------\n   The return value of `then` is itself a promise.  This second, 'downstream'\n  promise is resolved with the return value of the first promise's fulfillment\n  or rejection handler, or rejected if the handler throws an exception.\n   ```js\n  findUser().then(function (user) {\n    return user.name;\n  }, function (reason) {\n    return 'default name';\n  }).then(function (userName) {\n    // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n    // will be `'default name'`\n  });\n   findUser().then(function (user) {\n    throw new Error('Found user, but still unhappy');\n  }, function (reason) {\n    throw new Error('`findUser` rejected and we're unhappy');\n  }).then(function (value) {\n    // never reached\n  }, function (reason) {\n    // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n    // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n  });\n  ```\n  If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n   ```js\n  findUser().then(function (user) {\n    throw new PedagogicalException('Upstream error');\n  }).then(function (value) {\n    // never reached\n  }).then(function (value) {\n    // never reached\n  }, function (reason) {\n    // The `PedgagocialException` is propagated all the way down to here\n  });\n  ```\n   Assimilation\n  ------------\n   Sometimes the value you want to propagate to a downstream promise can only be\n  retrieved asynchronously. This can be achieved by returning a promise in the\n  fulfillment or rejection handler. The downstream promise will then be pending\n  until the returned promise is settled. This is called *assimilation*.\n   ```js\n  findUser().then(function (user) {\n    return findCommentsByAuthor(user);\n  }).then(function (comments) {\n    // The user's comments are now available\n  });\n  ```\n   If the assimliated promise rejects, then the downstream promise will also reject.\n   ```js\n  findUser().then(function (user) {\n    return findCommentsByAuthor(user);\n  }).then(function (comments) {\n    // If `findCommentsByAuthor` fulfills, we'll have the value here\n  }, function (reason) {\n    // If `findCommentsByAuthor` rejects, we'll have the reason here\n  });\n  ```\n   Simple Example\n  --------------\n   Synchronous Example\n   ```javascript\n  let result;\n   try {\n    result = findResult();\n    // success\n  } catch(reason) {\n    // failure\n  }\n  ```\n   Errback Example\n   ```js\n  findResult(function(result, err){\n    if (err) {\n      // failure\n    } else {\n      // success\n    }\n  });\n  ```\n   Promise Example;\n   ```javascript\n  findResult().then(function(result){\n    // success\n  }, function(reason){\n    // failure\n  });\n  ```\n   Advanced Example\n  --------------\n   Synchronous Example\n   ```javascript\n  let author, books;\n   try {\n    author = findAuthor();\n    books  = findBooksByAuthor(author);\n    // success\n  } catch(reason) {\n    // failure\n  }\n  ```\n   Errback Example\n   ```js\n   function foundBooks(books) {\n   }\n   function failure(reason) {\n   }\n   findAuthor(function(author, err){\n    if (err) {\n      failure(err);\n      // failure\n    } else {\n      try {\n        findBoooksByAuthor(author, function(books, err) {\n          if (err) {\n            failure(err);\n          } else {\n            try {\n              foundBooks(books);\n            } catch(reason) {\n              failure(reason);\n            }\n          }\n        });\n      } catch(error) {\n        failure(err);\n      }\n      // success\n    }\n  });\n  ```\n   Promise Example;\n   ```javascript\n  findAuthor().\n    then(findBooksByAuthor).\n    then(function(books){\n      // found books\n  }).catch(function(reason){\n    // something went wrong\n  });\n  ```\n   @method then\n  @param {Function} onFulfilled\n  @param {Function} onRejected\n  Useful for tooling.\n  @return {Promise}\n  */\n\n  /**\n  `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n  as the catch block of a try/catch statement.\n  ```js\n  function findAuthor(){\n  throw new Error('couldn't find that author');\n  }\n  // synchronous\n  try {\n  findAuthor();\n  } catch(reason) {\n  // something went wrong\n  }\n  // async with promises\n  findAuthor().catch(function(reason){\n  // something went wrong\n  });\n  ```\n  @method catch\n  @param {Function} onRejection\n  Useful for tooling.\n  @return {Promise}\n  */\n\n\n  Promise.prototype.catch = function _catch(onRejection) {\n    return this.then(null, onRejection);\n  };\n\n  /**\n    `finally` will be invoked regardless of the promise's fate just as native\n    try/catch/finally behaves\n  \n    Synchronous example:\n  \n    ```js\n    findAuthor() {\n      if (Math.random() > 0.5) {\n        throw new Error();\n      }\n      return new Author();\n    }\n  \n    try {\n      return findAuthor(); // succeed or fail\n    } catch(error) {\n      return findOtherAuther();\n    } finally {\n      // always runs\n      // doesn't affect the return value\n    }\n    ```\n  \n    Asynchronous example:\n  \n    ```js\n    findAuthor().catch(function(reason){\n      return findOtherAuther();\n    }).finally(function(){\n      // author was either found, or not\n    });\n    ```\n  \n    @method finally\n    @param {Function} callback\n    @return {Promise}\n  */\n\n\n  Promise.prototype.finally = function _finally(callback) {\n    var promise = this;\n    var constructor = promise.constructor;\n\n    if (isFunction(callback)) {\n      return promise.then(function (value) {\n        return constructor.resolve(callback()).then(function () {\n          return value;\n        });\n      }, function (reason) {\n        return constructor.resolve(callback()).then(function () {\n          throw reason;\n        });\n      });\n    }\n\n    return promise.then(callback, callback);\n  };\n\n  return Promise;\n}();\n\nPromise$1.prototype.then = then;\nPromise$1.all = all;\nPromise$1.race = race;\nPromise$1.resolve = resolve$1;\nPromise$1.reject = reject$1;\nPromise$1._setScheduler = setScheduler;\nPromise$1._setAsap = setAsap;\nPromise$1._asap = asap;\n\n/*global self*/\nfunction polyfill() {\n  var local = void 0;\n\n  if (typeof global !== 'undefined') {\n    local = global;\n  } else if (typeof self !== 'undefined') {\n    local = self;\n  } else {\n    try {\n      local = Function('return this')();\n    } catch (e) {\n      throw new Error('polyfill failed because global object is unavailable in this environment');\n    }\n  }\n\n  var P = local.Promise;\n\n  if (P) {\n    var promiseToString = null;\n    try {\n      promiseToString = Object.prototype.toString.call(P.resolve());\n    } catch (e) {\n      // silently ignored\n    }\n\n    if (promiseToString === '[object Promise]' && !P.cast) {\n      return;\n    }\n  }\n\n  local.Promise = Promise$1;\n}\n\n// Strange compat..\nPromise$1.polyfill = polyfill;\nPromise$1.Promise = Promise$1;\n\nreturn Promise$1;\n\n})));\n\n\n\n//# sourceMappingURL=es6-promise.map\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"../node_modules/process/browser.js\"), __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"../node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2VzNi1wcm9taXNlL2Rpc3QvZXM2LXByb21pc2UuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2VzNi1wcm9taXNlL2Rpc3QvZXM2LXByb21pc2UuanM/MTkyMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEBvdmVydmlldyBlczYtcHJvbWlzZSAtIGEgdGlueSBpbXBsZW1lbnRhdGlvbiBvZiBQcm9taXNlcy9BKy5cbiAqIEBjb3B5cmlnaHQgQ29weXJpZ2h0IChjKSAyMDE0IFllaHVkYSBLYXR6LCBUb20gRGFsZSwgU3RlZmFuIFBlbm5lciBhbmQgY29udHJpYnV0b3JzIChDb252ZXJzaW9uIHRvIEVTNiBBUEkgYnkgSmFrZSBBcmNoaWJhbGQpXG4gKiBAbGljZW5zZSAgIExpY2Vuc2VkIHVuZGVyIE1JVCBsaWNlbnNlXG4gKiAgICAgICAgICAgIFNlZSBodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vc3RlZmFucGVubmVyL2VzNi1wcm9taXNlL21hc3Rlci9MSUNFTlNFXG4gKiBAdmVyc2lvbiAgIHY0LjIuOCsxZTY4ZGNlNlxuICovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcblx0KGdsb2JhbC5FUzZQcm9taXNlID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBvYmplY3RPckZ1bmN0aW9uKHgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgeDtcbiAgcmV0dXJuIHggIT09IG51bGwgJiYgKHR5cGUgPT09ICdvYmplY3QnIHx8IHR5cGUgPT09ICdmdW5jdGlvbicpO1xufVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xufVxuXG5cblxudmFyIF9pc0FycmF5ID0gdm9pZCAwO1xuaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xufSBlbHNlIHtcbiAgX2lzQXJyYXkgPSBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gIH07XG59XG5cbnZhciBpc0FycmF5ID0gX2lzQXJyYXk7XG5cbnZhciBsZW4gPSAwO1xudmFyIHZlcnR4TmV4dCA9IHZvaWQgMDtcbnZhciBjdXN0b21TY2hlZHVsZXJGbiA9IHZvaWQgMDtcblxudmFyIGFzYXAgPSBmdW5jdGlvbiBhc2FwKGNhbGxiYWNrLCBhcmcpIHtcbiAgcXVldWVbbGVuXSA9IGNhbGxiYWNrO1xuICBxdWV1ZVtsZW4gKyAxXSA9IGFyZztcbiAgbGVuICs9IDI7XG4gIGlmIChsZW4gPT09IDIpIHtcbiAgICAvLyBJZiBsZW4gaXMgMiwgdGhhdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gc2NoZWR1bGUgYW4gYXN5bmMgZmx1c2guXG4gICAgLy8gSWYgYWRkaXRpb25hbCBjYWxsYmFja3MgYXJlIHF1ZXVlZCBiZWZvcmUgdGhlIHF1ZXVlIGlzIGZsdXNoZWQsIHRoZXlcbiAgICAvLyB3aWxsIGJlIHByb2Nlc3NlZCBieSB0aGlzIGZsdXNoIHRoYXQgd2UgYXJlIHNjaGVkdWxpbmcuXG4gICAgaWYgKGN1c3RvbVNjaGVkdWxlckZuKSB7XG4gICAgICBjdXN0b21TY2hlZHVsZXJGbihmbHVzaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjaGVkdWxlRmx1c2goKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldFNjaGVkdWxlcihzY2hlZHVsZUZuKSB7XG4gIGN1c3RvbVNjaGVkdWxlckZuID0gc2NoZWR1bGVGbjtcbn1cblxuZnVuY3Rpb24gc2V0QXNhcChhc2FwRm4pIHtcbiAgYXNhcCA9IGFzYXBGbjtcbn1cblxudmFyIGJyb3dzZXJXaW5kb3cgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHVuZGVmaW5lZDtcbnZhciBicm93c2VyR2xvYmFsID0gYnJvd3NlcldpbmRvdyB8fCB7fTtcbnZhciBCcm93c2VyTXV0YXRpb25PYnNlcnZlciA9IGJyb3dzZXJHbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBicm93c2VyR2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG52YXIgaXNOb2RlID0gdHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiB7fS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXSc7XG5cbi8vIHRlc3QgZm9yIHdlYiB3b3JrZXIgYnV0IG5vdCBpbiBJRTEwXG52YXIgaXNXb3JrZXIgPSB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBpbXBvcnRTY3JpcHRzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnO1xuXG4vLyBub2RlXG5mdW5jdGlvbiB1c2VOZXh0VGljaygpIHtcbiAgLy8gbm9kZSB2ZXJzaW9uIDAuMTAueCBkaXNwbGF5cyBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgd2hlbiBuZXh0VGljayBpcyB1c2VkIHJlY3Vyc2l2ZWx5XG4gIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vY3Vqb2pzL3doZW4vaXNzdWVzLzQxMCBmb3IgZGV0YWlsc1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgfTtcbn1cblxuLy8gdmVydHhcbmZ1bmN0aW9uIHVzZVZlcnR4VGltZXIoKSB7XG4gIGlmICh0eXBlb2YgdmVydHhOZXh0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2ZXJ0eE5leHQoZmx1c2gpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gdXNlU2V0VGltZW91dCgpO1xufVxuXG5mdW5jdGlvbiB1c2VNdXRhdGlvbk9ic2VydmVyKCkge1xuICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gIHZhciBvYnNlcnZlciA9IG5ldyBCcm93c2VyTXV0YXRpb25PYnNlcnZlcihmbHVzaCk7XG4gIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICBvYnNlcnZlci5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTtcblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIG5vZGUuZGF0YSA9IGl0ZXJhdGlvbnMgPSArK2l0ZXJhdGlvbnMgJSAyO1xuICB9O1xufVxuXG4vLyB3ZWIgd29ya2VyXG5mdW5jdGlvbiB1c2VNZXNzYWdlQ2hhbm5lbCgpIHtcbiAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmbHVzaDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlU2V0VGltZW91dCgpIHtcbiAgLy8gU3RvcmUgc2V0VGltZW91dCByZWZlcmVuY2Ugc28gZXM2LXByb21pc2Ugd2lsbCBiZSB1bmFmZmVjdGVkIGJ5XG4gIC8vIG90aGVyIGNvZGUgbW9kaWZ5aW5nIHNldFRpbWVvdXQgKGxpa2Ugc2lub24udXNlRmFrZVRpbWVycygpKVxuICB2YXIgZ2xvYmFsU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdsb2JhbFNldFRpbWVvdXQoZmx1c2gsIDEpO1xuICB9O1xufVxuXG52YXIgcXVldWUgPSBuZXcgQXJyYXkoMTAwMCk7XG5mdW5jdGlvbiBmbHVzaCgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHZhciBjYWxsYmFjayA9IHF1ZXVlW2ldO1xuICAgIHZhciBhcmcgPSBxdWV1ZVtpICsgMV07XG5cbiAgICBjYWxsYmFjayhhcmcpO1xuXG4gICAgcXVldWVbaV0gPSB1bmRlZmluZWQ7XG4gICAgcXVldWVbaSArIDFdID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gYXR0ZW1wdFZlcnR4KCkge1xuICB0cnkge1xuICAgIHZhciB2ZXJ0eCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCkucmVxdWlyZSgndmVydHgnKTtcbiAgICB2ZXJ0eE5leHQgPSB2ZXJ0eC5ydW5Pbkxvb3AgfHwgdmVydHgucnVuT25Db250ZXh0O1xuICAgIHJldHVybiB1c2VWZXJ0eFRpbWVyKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdXNlU2V0VGltZW91dCgpO1xuICB9XG59XG5cbnZhciBzY2hlZHVsZUZsdXNoID0gdm9pZCAwO1xuLy8gRGVjaWRlIHdoYXQgYXN5bmMgbWV0aG9kIHRvIHVzZSB0byB0cmlnZ2VyaW5nIHByb2Nlc3Npbmcgb2YgcXVldWVkIGNhbGxiYWNrczpcbmlmIChpc05vZGUpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZU5leHRUaWNrKCk7XG59IGVsc2UgaWYgKEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VNdXRhdGlvbk9ic2VydmVyKCk7XG59IGVsc2UgaWYgKGlzV29ya2VyKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VNZXNzYWdlQ2hhbm5lbCgpO1xufSBlbHNlIGlmIChicm93c2VyV2luZG93ID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IGF0dGVtcHRWZXJ0eCgpO1xufSBlbHNlIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZVNldFRpbWVvdXQoKTtcbn1cblxuZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICB2YXIgcGFyZW50ID0gdGhpcztcblxuICB2YXIgY2hpbGQgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcihub29wKTtcblxuICBpZiAoY2hpbGRbUFJPTUlTRV9JRF0gPT09IHVuZGVmaW5lZCkge1xuICAgIG1ha2VQcm9taXNlKGNoaWxkKTtcbiAgfVxuXG4gIHZhciBfc3RhdGUgPSBwYXJlbnQuX3N0YXRlO1xuXG5cbiAgaWYgKF9zdGF0ZSkge1xuICAgIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1tfc3RhdGUgLSAxXTtcbiAgICBhc2FwKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBpbnZva2VDYWxsYmFjayhfc3RhdGUsIGNoaWxkLCBjYWxsYmFjaywgcGFyZW50Ll9yZXN1bHQpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbik7XG4gIH1cblxuICByZXR1cm4gY2hpbGQ7XG59XG5cbi8qKlxuICBgUHJvbWlzZS5yZXNvbHZlYCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmVjb21lIHJlc29sdmVkIHdpdGggdGhlXG4gIHBhc3NlZCBgdmFsdWVgLiBJdCBpcyBzaG9ydGhhbmQgZm9yIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgcmVzb2x2ZSgxKTtcbiAgfSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyB2YWx1ZSA9PT0gMVxuICB9KTtcbiAgYGBgXG5cbiAgSW5zdGVhZCBvZiB3cml0aW5nIHRoZSBhYm92ZSwgeW91ciBjb2RlIG5vdyBzaW1wbHkgYmVjb21lcyB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoMSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyB2YWx1ZSA9PT0gMVxuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCByZXNvbHZlXG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBbnl9IHZhbHVlIHZhbHVlIHRoYXQgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZSByZXNvbHZlZCB3aXRoXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHRoYXQgd2lsbCBiZWNvbWUgZnVsZmlsbGVkIHdpdGggdGhlIGdpdmVuXG4gIGB2YWx1ZWBcbiovXG5mdW5jdGlvbiByZXNvbHZlJDEob2JqZWN0KSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgaWYgKG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QuY29uc3RydWN0b3IgPT09IENvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuXG4gIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuICByZXNvbHZlKHByb21pc2UsIG9iamVjdCk7XG4gIHJldHVybiBwcm9taXNlO1xufVxuXG52YXIgUFJPTUlTRV9JRCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyKTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnZhciBQRU5ESU5HID0gdm9pZCAwO1xudmFyIEZVTEZJTExFRCA9IDE7XG52YXIgUkVKRUNURUQgPSAyO1xuXG5mdW5jdGlvbiBzZWxmRnVsZmlsbG1lbnQoKSB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKFwiWW91IGNhbm5vdCByZXNvbHZlIGEgcHJvbWlzZSB3aXRoIGl0c2VsZlwiKTtcbn1cblxuZnVuY3Rpb24gY2Fubm90UmV0dXJuT3duKCkge1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcignQSBwcm9taXNlcyBjYWxsYmFjayBjYW5ub3QgcmV0dXJuIHRoYXQgc2FtZSBwcm9taXNlLicpO1xufVxuXG5mdW5jdGlvbiB0cnlUaGVuKHRoZW4kJDEsIHZhbHVlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpIHtcbiAgdHJ5IHtcbiAgICB0aGVuJCQxLmNhbGwodmFsdWUsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVGb3JlaWduVGhlbmFibGUocHJvbWlzZSwgdGhlbmFibGUsIHRoZW4kJDEpIHtcbiAgYXNhcChmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgIHZhciBzZWFsZWQgPSBmYWxzZTtcbiAgICB2YXIgZXJyb3IgPSB0cnlUaGVuKHRoZW4kJDEsIHRoZW5hYmxlLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmIChzZWFsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2VhbGVkID0gdHJ1ZTtcbiAgICAgIGlmICh0aGVuYWJsZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBpZiAoc2VhbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlYWxlZCA9IHRydWU7XG5cbiAgICAgIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgIH0sICdTZXR0bGU6ICcgKyAocHJvbWlzZS5fbGFiZWwgfHwgJyB1bmtub3duIHByb21pc2UnKSk7XG5cbiAgICBpZiAoIXNlYWxlZCAmJiBlcnJvcikge1xuICAgICAgc2VhbGVkID0gdHJ1ZTtcbiAgICAgIHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgfVxuICB9LCBwcm9taXNlKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlT3duVGhlbmFibGUocHJvbWlzZSwgdGhlbmFibGUpIHtcbiAgaWYgKHRoZW5hYmxlLl9zdGF0ZSA9PT0gRlVMRklMTEVEKSB7XG4gICAgZnVsZmlsbChwcm9taXNlLCB0aGVuYWJsZS5fcmVzdWx0KTtcbiAgfSBlbHNlIGlmICh0aGVuYWJsZS5fc3RhdGUgPT09IFJFSkVDVEVEKSB7XG4gICAgcmVqZWN0KHByb21pc2UsIHRoZW5hYmxlLl9yZXN1bHQpO1xuICB9IGVsc2Uge1xuICAgIHN1YnNjcmliZSh0aGVuYWJsZSwgdW5kZWZpbmVkLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICByZXR1cm4gcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlLCB0aGVuJCQxKSB7XG4gIGlmIChtYXliZVRoZW5hYmxlLmNvbnN0cnVjdG9yID09PSBwcm9taXNlLmNvbnN0cnVjdG9yICYmIHRoZW4kJDEgPT09IHRoZW4gJiYgbWF5YmVUaGVuYWJsZS5jb25zdHJ1Y3Rvci5yZXNvbHZlID09PSByZXNvbHZlJDEpIHtcbiAgICBoYW5kbGVPd25UaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodGhlbiQkMSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih0aGVuJCQxKSkge1xuICAgICAgaGFuZGxlRm9yZWlnblRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUsIHRoZW4kJDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlKHByb21pc2UsIHZhbHVlKSB7XG4gIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuICAgIHJlamVjdChwcm9taXNlLCBzZWxmRnVsZmlsbG1lbnQoKSk7XG4gIH0gZWxzZSBpZiAob2JqZWN0T3JGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgdGhlbiQkMSA9IHZvaWQgMDtcbiAgICB0cnkge1xuICAgICAgdGhlbiQkMSA9IHZhbHVlLnRoZW47XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgdmFsdWUsIHRoZW4kJDEpO1xuICB9IGVsc2Uge1xuICAgIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1Ymxpc2hSZWplY3Rpb24ocHJvbWlzZSkge1xuICBpZiAocHJvbWlzZS5fb25lcnJvcikge1xuICAgIHByb21pc2UuX29uZXJyb3IocHJvbWlzZS5fcmVzdWx0KTtcbiAgfVxuXG4gIHB1Ymxpc2gocHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpIHtcbiAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcHJvbWlzZS5fcmVzdWx0ID0gdmFsdWU7XG4gIHByb21pc2UuX3N0YXRlID0gRlVMRklMTEVEO1xuXG4gIGlmIChwcm9taXNlLl9zdWJzY3JpYmVycy5sZW5ndGggIT09IDApIHtcbiAgICBhc2FwKHB1Ymxpc2gsIHByb21pc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlamVjdChwcm9taXNlLCByZWFzb24pIHtcbiAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHByb21pc2UuX3N0YXRlID0gUkVKRUNURUQ7XG4gIHByb21pc2UuX3Jlc3VsdCA9IHJlYXNvbjtcblxuICBhc2FwKHB1Ymxpc2hSZWplY3Rpb24sIHByb21pc2UpO1xufVxuXG5mdW5jdGlvbiBzdWJzY3JpYmUocGFyZW50LCBjaGlsZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pIHtcbiAgdmFyIF9zdWJzY3JpYmVycyA9IHBhcmVudC5fc3Vic2NyaWJlcnM7XG4gIHZhciBsZW5ndGggPSBfc3Vic2NyaWJlcnMubGVuZ3RoO1xuXG5cbiAgcGFyZW50Ll9vbmVycm9yID0gbnVsbDtcblxuICBfc3Vic2NyaWJlcnNbbGVuZ3RoXSA9IGNoaWxkO1xuICBfc3Vic2NyaWJlcnNbbGVuZ3RoICsgRlVMRklMTEVEXSA9IG9uRnVsZmlsbG1lbnQ7XG4gIF9zdWJzY3JpYmVyc1tsZW5ndGggKyBSRUpFQ1RFRF0gPSBvblJlamVjdGlvbjtcblxuICBpZiAobGVuZ3RoID09PSAwICYmIHBhcmVudC5fc3RhdGUpIHtcbiAgICBhc2FwKHB1Ymxpc2gsIHBhcmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVibGlzaChwcm9taXNlKSB7XG4gIHZhciBzdWJzY3JpYmVycyA9IHByb21pc2UuX3N1YnNjcmliZXJzO1xuICB2YXIgc2V0dGxlZCA9IHByb21pc2UuX3N0YXRlO1xuXG4gIGlmIChzdWJzY3JpYmVycy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY2hpbGQgPSB2b2lkIDAsXG4gICAgICBjYWxsYmFjayA9IHZvaWQgMCxcbiAgICAgIGRldGFpbCA9IHByb21pc2UuX3Jlc3VsdDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnNjcmliZXJzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgY2hpbGQgPSBzdWJzY3JpYmVyc1tpXTtcbiAgICBjYWxsYmFjayA9IHN1YnNjcmliZXJzW2kgKyBzZXR0bGVkXTtcblxuICAgIGlmIChjaGlsZCkge1xuICAgICAgaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgY2hpbGQsIGNhbGxiYWNrLCBkZXRhaWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayhkZXRhaWwpO1xuICAgIH1cbiAgfVxuXG4gIHByb21pc2UuX3N1YnNjcmliZXJzLmxlbmd0aCA9IDA7XG59XG5cbmZ1bmN0aW9uIGludm9rZUNhbGxiYWNrKHNldHRsZWQsIHByb21pc2UsIGNhbGxiYWNrLCBkZXRhaWwpIHtcbiAgdmFyIGhhc0NhbGxiYWNrID0gaXNGdW5jdGlvbihjYWxsYmFjayksXG4gICAgICB2YWx1ZSA9IHZvaWQgMCxcbiAgICAgIGVycm9yID0gdm9pZCAwLFxuICAgICAgc3VjY2VlZGVkID0gdHJ1ZTtcblxuICBpZiAoaGFzQ2FsbGJhY2spIHtcbiAgICB0cnkge1xuICAgICAgdmFsdWUgPSBjYWxsYmFjayhkZXRhaWwpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHN1Y2NlZWRlZCA9IGZhbHNlO1xuICAgICAgZXJyb3IgPSBlO1xuICAgIH1cblxuICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuICAgICAgcmVqZWN0KHByb21pc2UsIGNhbm5vdFJldHVybk93bigpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBkZXRhaWw7XG4gIH1cblxuICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICAvLyBub29wXG4gIH0gZWxzZSBpZiAoaGFzQ2FsbGJhY2sgJiYgc3VjY2VlZGVkKSB7XG4gICAgcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoc3VjY2VlZGVkID09PSBmYWxzZSkge1xuICAgIHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gIH0gZWxzZSBpZiAoc2V0dGxlZCA9PT0gRlVMRklMTEVEKSB7XG4gICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoc2V0dGxlZCA9PT0gUkVKRUNURUQpIHtcbiAgICByZWplY3QocHJvbWlzZSwgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVQcm9taXNlKHByb21pc2UsIHJlc29sdmVyKSB7XG4gIHRyeSB7XG4gICAgcmVzb2x2ZXIoZnVuY3Rpb24gcmVzb2x2ZVByb21pc2UodmFsdWUpIHtcbiAgICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIHJlamVjdFByb21pc2UocmVhc29uKSB7XG4gICAgICByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJlamVjdChwcm9taXNlLCBlKTtcbiAgfVxufVxuXG52YXIgaWQgPSAwO1xuZnVuY3Rpb24gbmV4dElkKCkge1xuICByZXR1cm4gaWQrKztcbn1cblxuZnVuY3Rpb24gbWFrZVByb21pc2UocHJvbWlzZSkge1xuICBwcm9taXNlW1BST01JU0VfSURdID0gaWQrKztcbiAgcHJvbWlzZS5fc3RhdGUgPSB1bmRlZmluZWQ7XG4gIHByb21pc2UuX3Jlc3VsdCA9IHVuZGVmaW5lZDtcbiAgcHJvbWlzZS5fc3Vic2NyaWJlcnMgPSBbXTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGlvbkVycm9yKCkge1xuICByZXR1cm4gbmV3IEVycm9yKCdBcnJheSBNZXRob2RzIG11c3QgYmUgcHJvdmlkZWQgYW4gQXJyYXknKTtcbn1cblxudmFyIEVudW1lcmF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEVudW1lcmF0b3IoQ29uc3RydWN0b3IsIGlucHV0KSB7XG4gICAgdGhpcy5faW5zdGFuY2VDb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3Rvcihub29wKTtcblxuICAgIGlmICghdGhpcy5wcm9taXNlW1BST01JU0VfSURdKSB7XG4gICAgICBtYWtlUHJvbWlzZSh0aGlzLnByb21pc2UpO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KGlucHV0KSkge1xuICAgICAgdGhpcy5sZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgICB0aGlzLl9yZW1haW5pbmcgPSBpbnB1dC5sZW5ndGg7XG5cbiAgICAgIHRoaXMuX3Jlc3VsdCA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG5cbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBmdWxmaWxsKHRoaXMucHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5sZW5ndGggfHwgMDtcbiAgICAgICAgdGhpcy5fZW51bWVyYXRlKGlucHV0KTtcbiAgICAgICAgaWYgKHRoaXMuX3JlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICAgIGZ1bGZpbGwodGhpcy5wcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlamVjdCh0aGlzLnByb21pc2UsIHZhbGlkYXRpb25FcnJvcigpKTtcbiAgICB9XG4gIH1cblxuICBFbnVtZXJhdG9yLnByb3RvdHlwZS5fZW51bWVyYXRlID0gZnVuY3Rpb24gX2VudW1lcmF0ZShpbnB1dCkge1xuICAgIGZvciAodmFyIGkgPSAwOyB0aGlzLl9zdGF0ZSA9PT0gUEVORElORyAmJiBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX2VhY2hFbnRyeShpbnB1dFtpXSwgaSk7XG4gICAgfVxuICB9O1xuXG4gIEVudW1lcmF0b3IucHJvdG90eXBlLl9lYWNoRW50cnkgPSBmdW5jdGlvbiBfZWFjaEVudHJ5KGVudHJ5LCBpKSB7XG4gICAgdmFyIGMgPSB0aGlzLl9pbnN0YW5jZUNvbnN0cnVjdG9yO1xuICAgIHZhciByZXNvbHZlJCQxID0gYy5yZXNvbHZlO1xuXG5cbiAgICBpZiAocmVzb2x2ZSQkMSA9PT0gcmVzb2x2ZSQxKSB7XG4gICAgICB2YXIgX3RoZW4gPSB2b2lkIDA7XG4gICAgICB2YXIgZXJyb3IgPSB2b2lkIDA7XG4gICAgICB2YXIgZGlkRXJyb3IgPSBmYWxzZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIF90aGVuID0gZW50cnkudGhlbjtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgICBlcnJvciA9IGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChfdGhlbiA9PT0gdGhlbiAmJiBlbnRyeS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICAgICAgdGhpcy5fc2V0dGxlZEF0KGVudHJ5Ll9zdGF0ZSwgaSwgZW50cnkuX3Jlc3VsdCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBfdGhlbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLl9yZW1haW5pbmctLTtcbiAgICAgICAgdGhpcy5fcmVzdWx0W2ldID0gZW50cnk7XG4gICAgICB9IGVsc2UgaWYgKGMgPT09IFByb21pc2UkMSkge1xuICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBjKG5vb3ApO1xuICAgICAgICBpZiAoZGlkRXJyb3IpIHtcbiAgICAgICAgICByZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgZW50cnksIF90aGVuKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93aWxsU2V0dGxlQXQocHJvbWlzZSwgaSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl93aWxsU2V0dGxlQXQobmV3IGMoZnVuY3Rpb24gKHJlc29sdmUkJDEpIHtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZSQkMShlbnRyeSk7XG4gICAgICAgIH0pLCBpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fd2lsbFNldHRsZUF0KHJlc29sdmUkJDEoZW50cnkpLCBpKTtcbiAgICB9XG4gIH07XG5cbiAgRW51bWVyYXRvci5wcm90b3R5cGUuX3NldHRsZWRBdCA9IGZ1bmN0aW9uIF9zZXR0bGVkQXQoc3RhdGUsIGksIHZhbHVlKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzLnByb21pc2U7XG5cblxuICAgIGlmIChwcm9taXNlLl9zdGF0ZSA9PT0gUEVORElORykge1xuICAgICAgdGhpcy5fcmVtYWluaW5nLS07XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gUkVKRUNURUQpIHtcbiAgICAgICAgcmVqZWN0KHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Jlc3VsdFtpXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9yZW1haW5pbmcgPT09IDApIHtcbiAgICAgIGZ1bGZpbGwocHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICB9XG4gIH07XG5cbiAgRW51bWVyYXRvci5wcm90b3R5cGUuX3dpbGxTZXR0bGVBdCA9IGZ1bmN0aW9uIF93aWxsU2V0dGxlQXQocHJvbWlzZSwgaSkge1xuICAgIHZhciBlbnVtZXJhdG9yID0gdGhpcztcblxuICAgIHN1YnNjcmliZShwcm9taXNlLCB1bmRlZmluZWQsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGVudW1lcmF0b3IuX3NldHRsZWRBdChGVUxGSUxMRUQsIGksIHZhbHVlKTtcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICByZXR1cm4gZW51bWVyYXRvci5fc2V0dGxlZEF0KFJFSkVDVEVELCBpLCByZWFzb24pO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBFbnVtZXJhdG9yO1xufSgpO1xuXG4vKipcbiAgYFByb21pc2UuYWxsYCBhY2NlcHRzIGFuIGFycmF5IG9mIHByb21pc2VzLCBhbmQgcmV0dXJucyBhIG5ldyBwcm9taXNlIHdoaWNoXG4gIGlzIGZ1bGZpbGxlZCB3aXRoIGFuIGFycmF5IG9mIGZ1bGZpbGxtZW50IHZhbHVlcyBmb3IgdGhlIHBhc3NlZCBwcm9taXNlcywgb3JcbiAgcmVqZWN0ZWQgd2l0aCB0aGUgcmVhc29uIG9mIHRoZSBmaXJzdCBwYXNzZWQgcHJvbWlzZSB0byBiZSByZWplY3RlZC4gSXQgY2FzdHMgYWxsXG4gIGVsZW1lbnRzIG9mIHRoZSBwYXNzZWQgaXRlcmFibGUgdG8gcHJvbWlzZXMgYXMgaXQgcnVucyB0aGlzIGFsZ29yaXRobS5cblxuICBFeGFtcGxlOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gcmVzb2x2ZSgxKTtcbiAgbGV0IHByb21pc2UyID0gcmVzb2x2ZSgyKTtcbiAgbGV0IHByb21pc2UzID0gcmVzb2x2ZSgzKTtcbiAgbGV0IHByb21pc2VzID0gWyBwcm9taXNlMSwgcHJvbWlzZTIsIHByb21pc2UzIF07XG5cbiAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oYXJyYXkpe1xuICAgIC8vIFRoZSBhcnJheSBoZXJlIHdvdWxkIGJlIFsgMSwgMiwgMyBdO1xuICB9KTtcbiAgYGBgXG5cbiAgSWYgYW55IG9mIHRoZSBgcHJvbWlzZXNgIGdpdmVuIHRvIGBhbGxgIGFyZSByZWplY3RlZCwgdGhlIGZpcnN0IHByb21pc2VcbiAgdGhhdCBpcyByZWplY3RlZCB3aWxsIGJlIGdpdmVuIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSByZXR1cm5lZCBwcm9taXNlcydzXG4gIHJlamVjdGlvbiBoYW5kbGVyLiBGb3IgZXhhbXBsZTpcblxuICBFeGFtcGxlOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gcmVzb2x2ZSgxKTtcbiAgbGV0IHByb21pc2UyID0gcmVqZWN0KG5ldyBFcnJvcihcIjJcIikpO1xuICBsZXQgcHJvbWlzZTMgPSByZWplY3QobmV3IEVycm9yKFwiM1wiKSk7XG4gIGxldCBwcm9taXNlcyA9IFsgcHJvbWlzZTEsIHByb21pc2UyLCBwcm9taXNlMyBdO1xuXG4gIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKGFycmF5KXtcbiAgICAvLyBDb2RlIGhlcmUgbmV2ZXIgcnVucyBiZWNhdXNlIHRoZXJlIGFyZSByZWplY3RlZCBwcm9taXNlcyFcbiAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAvLyBlcnJvci5tZXNzYWdlID09PSBcIjJcIlxuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCBhbGxcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FycmF5fSBlbnRyaWVzIGFycmF5IG9mIHByb21pc2VzXG4gIEBwYXJhbSB7U3RyaW5nfSBsYWJlbCBvcHRpb25hbCBzdHJpbmcgZm9yIGxhYmVsaW5nIHRoZSBwcm9taXNlLlxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgd2hlbiBhbGwgYHByb21pc2VzYCBoYXZlIGJlZW5cbiAgZnVsZmlsbGVkLCBvciByZWplY3RlZCBpZiBhbnkgb2YgdGhlbSBiZWNvbWUgcmVqZWN0ZWQuXG4gIEBzdGF0aWNcbiovXG5mdW5jdGlvbiBhbGwoZW50cmllcykge1xuICByZXR1cm4gbmV3IEVudW1lcmF0b3IodGhpcywgZW50cmllcykucHJvbWlzZTtcbn1cblxuLyoqXG4gIGBQcm9taXNlLnJhY2VgIHJldHVybnMgYSBuZXcgcHJvbWlzZSB3aGljaCBpcyBzZXR0bGVkIGluIHRoZSBzYW1lIHdheSBhcyB0aGVcbiAgZmlyc3QgcGFzc2VkIHByb21pc2UgdG8gc2V0dGxlLlxuXG4gIEV4YW1wbGU6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoJ3Byb21pc2UgMScpO1xuICAgIH0sIDIwMCk7XG4gIH0pO1xuXG4gIGxldCBwcm9taXNlMiA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVzb2x2ZSgncHJvbWlzZSAyJyk7XG4gICAgfSwgMTAwKTtcbiAgfSk7XG5cbiAgUHJvbWlzZS5yYWNlKFtwcm9taXNlMSwgcHJvbWlzZTJdKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgLy8gcmVzdWx0ID09PSAncHJvbWlzZSAyJyBiZWNhdXNlIGl0IHdhcyByZXNvbHZlZCBiZWZvcmUgcHJvbWlzZTFcbiAgICAvLyB3YXMgcmVzb2x2ZWQuXG4gIH0pO1xuICBgYGBcblxuICBgUHJvbWlzZS5yYWNlYCBpcyBkZXRlcm1pbmlzdGljIGluIHRoYXQgb25seSB0aGUgc3RhdGUgb2YgdGhlIGZpcnN0XG4gIHNldHRsZWQgcHJvbWlzZSBtYXR0ZXJzLiBGb3IgZXhhbXBsZSwgZXZlbiBpZiBvdGhlciBwcm9taXNlcyBnaXZlbiB0byB0aGVcbiAgYHByb21pc2VzYCBhcnJheSBhcmd1bWVudCBhcmUgcmVzb2x2ZWQsIGJ1dCB0aGUgZmlyc3Qgc2V0dGxlZCBwcm9taXNlIGhhc1xuICBiZWNvbWUgcmVqZWN0ZWQgYmVmb3JlIHRoZSBvdGhlciBwcm9taXNlcyBiZWNhbWUgZnVsZmlsbGVkLCB0aGUgcmV0dXJuZWRcbiAgcHJvbWlzZSB3aWxsIGJlY29tZSByZWplY3RlZDpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVzb2x2ZSgncHJvbWlzZSAxJyk7XG4gICAgfSwgMjAwKTtcbiAgfSk7XG5cbiAgbGV0IHByb21pc2UyID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZWplY3QobmV3IEVycm9yKCdwcm9taXNlIDInKSk7XG4gICAgfSwgMTAwKTtcbiAgfSk7XG5cbiAgUHJvbWlzZS5yYWNlKFtwcm9taXNlMSwgcHJvbWlzZTJdKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgLy8gQ29kZSBoZXJlIG5ldmVyIHJ1bnNcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyByZWFzb24ubWVzc2FnZSA9PT0gJ3Byb21pc2UgMicgYmVjYXVzZSBwcm9taXNlIDIgYmVjYW1lIHJlamVjdGVkIGJlZm9yZVxuICAgIC8vIHByb21pc2UgMSBiZWNhbWUgZnVsZmlsbGVkXG4gIH0pO1xuICBgYGBcblxuICBBbiBleGFtcGxlIHJlYWwtd29ybGQgdXNlIGNhc2UgaXMgaW1wbGVtZW50aW5nIHRpbWVvdXRzOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgUHJvbWlzZS5yYWNlKFthamF4KCdmb28uanNvbicpLCB0aW1lb3V0KDUwMDApXSlcbiAgYGBgXG5cbiAgQG1ldGhvZCByYWNlXG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBcnJheX0gcHJvbWlzZXMgYXJyYXkgb2YgcHJvbWlzZXMgdG8gb2JzZXJ2ZVxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSB3aGljaCBzZXR0bGVzIGluIHRoZSBzYW1lIHdheSBhcyB0aGUgZmlyc3QgcGFzc2VkXG4gIHByb21pc2UgdG8gc2V0dGxlLlxuKi9cbmZ1bmN0aW9uIHJhY2UoZW50cmllcykge1xuICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gIGlmICghaXNBcnJheShlbnRyaWVzKSkge1xuICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoZnVuY3Rpb24gKF8sIHJlamVjdCkge1xuICAgICAgcmV0dXJuIHJlamVjdChuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGFuIGFycmF5IHRvIHJhY2UuJykpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGVudHJpZXMubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBDb25zdHJ1Y3Rvci5yZXNvbHZlKGVudHJpZXNbaV0pLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAgYFByb21pc2UucmVqZWN0YCByZXR1cm5zIGEgcHJvbWlzZSByZWplY3RlZCB3aXRoIHRoZSBwYXNzZWQgYHJlYXNvbmAuXG4gIEl0IGlzIHNob3J0aGFuZCBmb3IgdGhlIGZvbGxvd2luZzpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICByZWplY3QobmV3IEVycm9yKCdXSE9PUFMnKSk7XG4gIH0pO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgLy8gQ29kZSBoZXJlIGRvZXNuJ3QgcnVuIGJlY2F1c2UgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQhXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gcmVhc29uLm1lc3NhZ2UgPT09ICdXSE9PUFMnXG4gIH0pO1xuICBgYGBcblxuICBJbnN0ZWFkIG9mIHdyaXRpbmcgdGhlIGFib3ZlLCB5b3VyIGNvZGUgbm93IHNpbXBseSBiZWNvbWVzIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignV0hPT1BTJykpO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgLy8gQ29kZSBoZXJlIGRvZXNuJ3QgcnVuIGJlY2F1c2UgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQhXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gcmVhc29uLm1lc3NhZ2UgPT09ICdXSE9PUFMnXG4gIH0pO1xuICBgYGBcblxuICBAbWV0aG9kIHJlamVjdFxuICBAc3RhdGljXG4gIEBwYXJhbSB7QW55fSByZWFzb24gdmFsdWUgdGhhdCB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkIHdpdGguXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHJlamVjdGVkIHdpdGggdGhlIGdpdmVuIGByZWFzb25gLlxuKi9cbmZ1bmN0aW9uIHJlamVjdCQxKHJlYXNvbikge1xuICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuICB2YXIgcHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3Rvcihub29wKTtcbiAgcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gIHJldHVybiBwcm9taXNlO1xufVxuXG5mdW5jdGlvbiBuZWVkc1Jlc29sdmVyKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGEgcmVzb2x2ZXIgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBwcm9taXNlIGNvbnN0cnVjdG9yJyk7XG59XG5cbmZ1bmN0aW9uIG5lZWRzTmV3KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnUHJvbWlzZSc6IFBsZWFzZSB1c2UgdGhlICduZXcnIG9wZXJhdG9yLCB0aGlzIG9iamVjdCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO1xufVxuXG4vKipcbiAgUHJvbWlzZSBvYmplY3RzIHJlcHJlc2VudCB0aGUgZXZlbnR1YWwgcmVzdWx0IG9mIGFuIGFzeW5jaHJvbm91cyBvcGVyYXRpb24uIFRoZVxuICBwcmltYXJ5IHdheSBvZiBpbnRlcmFjdGluZyB3aXRoIGEgcHJvbWlzZSBpcyB0aHJvdWdoIGl0cyBgdGhlbmAgbWV0aG9kLCB3aGljaFxuICByZWdpc3RlcnMgY2FsbGJhY2tzIHRvIHJlY2VpdmUgZWl0aGVyIGEgcHJvbWlzZSdzIGV2ZW50dWFsIHZhbHVlIG9yIHRoZSByZWFzb25cbiAgd2h5IHRoZSBwcm9taXNlIGNhbm5vdCBiZSBmdWxmaWxsZWQuXG5cbiAgVGVybWlub2xvZ3lcbiAgLS0tLS0tLS0tLS1cblxuICAtIGBwcm9taXNlYCBpcyBhbiBvYmplY3Qgb3IgZnVuY3Rpb24gd2l0aCBhIGB0aGVuYCBtZXRob2Qgd2hvc2UgYmVoYXZpb3IgY29uZm9ybXMgdG8gdGhpcyBzcGVjaWZpY2F0aW9uLlxuICAtIGB0aGVuYWJsZWAgaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHRoYXQgZGVmaW5lcyBhIGB0aGVuYCBtZXRob2QuXG4gIC0gYHZhbHVlYCBpcyBhbnkgbGVnYWwgSmF2YVNjcmlwdCB2YWx1ZSAoaW5jbHVkaW5nIHVuZGVmaW5lZCwgYSB0aGVuYWJsZSwgb3IgYSBwcm9taXNlKS5cbiAgLSBgZXhjZXB0aW9uYCBpcyBhIHZhbHVlIHRoYXQgaXMgdGhyb3duIHVzaW5nIHRoZSB0aHJvdyBzdGF0ZW1lbnQuXG4gIC0gYHJlYXNvbmAgaXMgYSB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aHkgYSBwcm9taXNlIHdhcyByZWplY3RlZC5cbiAgLSBgc2V0dGxlZGAgdGhlIGZpbmFsIHJlc3Rpbmcgc3RhdGUgb2YgYSBwcm9taXNlLCBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQuXG5cbiAgQSBwcm9taXNlIGNhbiBiZSBpbiBvbmUgb2YgdGhyZWUgc3RhdGVzOiBwZW5kaW5nLCBmdWxmaWxsZWQsIG9yIHJlamVjdGVkLlxuXG4gIFByb21pc2VzIHRoYXQgYXJlIGZ1bGZpbGxlZCBoYXZlIGEgZnVsZmlsbG1lbnQgdmFsdWUgYW5kIGFyZSBpbiB0aGUgZnVsZmlsbGVkXG4gIHN0YXRlLiAgUHJvbWlzZXMgdGhhdCBhcmUgcmVqZWN0ZWQgaGF2ZSBhIHJlamVjdGlvbiByZWFzb24gYW5kIGFyZSBpbiB0aGVcbiAgcmVqZWN0ZWQgc3RhdGUuICBBIGZ1bGZpbGxtZW50IHZhbHVlIGlzIG5ldmVyIGEgdGhlbmFibGUuXG5cbiAgUHJvbWlzZXMgY2FuIGFsc28gYmUgc2FpZCB0byAqcmVzb2x2ZSogYSB2YWx1ZS4gIElmIHRoaXMgdmFsdWUgaXMgYWxzbyBhXG4gIHByb21pc2UsIHRoZW4gdGhlIG9yaWdpbmFsIHByb21pc2UncyBzZXR0bGVkIHN0YXRlIHdpbGwgbWF0Y2ggdGhlIHZhbHVlJ3NcbiAgc2V0dGxlZCBzdGF0ZS4gIFNvIGEgcHJvbWlzZSB0aGF0ICpyZXNvbHZlcyogYSBwcm9taXNlIHRoYXQgcmVqZWN0cyB3aWxsXG4gIGl0c2VsZiByZWplY3QsIGFuZCBhIHByb21pc2UgdGhhdCAqcmVzb2x2ZXMqIGEgcHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpbGxcbiAgaXRzZWxmIGZ1bGZpbGwuXG5cblxuICBCYXNpYyBVc2FnZTpcbiAgLS0tLS0tLS0tLS0tXG5cbiAgYGBganNcbiAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAvLyBvbiBzdWNjZXNzXG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG5cbiAgICAvLyBvbiBmYWlsdXJlXG4gICAgcmVqZWN0KHJlYXNvbik7XG4gIH0pO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgIC8vIG9uIGZ1bGZpbGxtZW50XG4gIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgIC8vIG9uIHJlamVjdGlvblxuICB9KTtcbiAgYGBgXG5cbiAgQWR2YW5jZWQgVXNhZ2U6XG4gIC0tLS0tLS0tLS0tLS0tLVxuXG4gIFByb21pc2VzIHNoaW5lIHdoZW4gYWJzdHJhY3RpbmcgYXdheSBhc3luY2hyb25vdXMgaW50ZXJhY3Rpb25zIHN1Y2ggYXNcbiAgYFhNTEh0dHBSZXF1ZXN0YHMuXG5cbiAgYGBganNcbiAgZnVuY3Rpb24gZ2V0SlNPTih1cmwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICAgIGxldCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCk7XG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gaGFuZGxlcjtcbiAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnanNvbic7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgIHhoci5zZW5kKCk7XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IHRoaXMuRE9ORSkge1xuICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICByZXNvbHZlKHRoaXMucmVzcG9uc2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdnZXRKU09OOiBgJyArIHVybCArICdgIGZhaWxlZCB3aXRoIHN0YXR1czogWycgKyB0aGlzLnN0YXR1cyArICddJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldEpTT04oJy9wb3N0cy5qc29uJykudGhlbihmdW5jdGlvbihqc29uKSB7XG4gICAgLy8gb24gZnVsZmlsbG1lbnRcbiAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgLy8gb24gcmVqZWN0aW9uXG4gIH0pO1xuICBgYGBcblxuICBVbmxpa2UgY2FsbGJhY2tzLCBwcm9taXNlcyBhcmUgZ3JlYXQgY29tcG9zYWJsZSBwcmltaXRpdmVzLlxuXG4gIGBgYGpzXG4gIFByb21pc2UuYWxsKFtcbiAgICBnZXRKU09OKCcvcG9zdHMnKSxcbiAgICBnZXRKU09OKCcvY29tbWVudHMnKVxuICBdKS50aGVuKGZ1bmN0aW9uKHZhbHVlcyl7XG4gICAgdmFsdWVzWzBdIC8vID0+IHBvc3RzSlNPTlxuICAgIHZhbHVlc1sxXSAvLyA9PiBjb21tZW50c0pTT05cblxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH0pO1xuICBgYGBcblxuICBAY2xhc3MgUHJvbWlzZVxuICBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlclxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEBjb25zdHJ1Y3RvclxuKi9cblxudmFyIFByb21pc2UkMSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUHJvbWlzZShyZXNvbHZlcikge1xuICAgIHRoaXNbUFJPTUlTRV9JRF0gPSBuZXh0SWQoKTtcbiAgICB0aGlzLl9yZXN1bHQgPSB0aGlzLl9zdGF0ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zdWJzY3JpYmVycyA9IFtdO1xuXG4gICAgaWYgKG5vb3AgIT09IHJlc29sdmVyKSB7XG4gICAgICB0eXBlb2YgcmVzb2x2ZXIgIT09ICdmdW5jdGlvbicgJiYgbmVlZHNSZXNvbHZlcigpO1xuICAgICAgdGhpcyBpbnN0YW5jZW9mIFByb21pc2UgPyBpbml0aWFsaXplUHJvbWlzZSh0aGlzLCByZXNvbHZlcikgOiBuZWVkc05ldygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICBUaGUgcHJpbWFyeSB3YXkgb2YgaW50ZXJhY3Rpbmcgd2l0aCBhIHByb21pc2UgaXMgdGhyb3VnaCBpdHMgYHRoZW5gIG1ldGhvZCxcbiAgd2hpY2ggcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2UncyBldmVudHVhbCB2YWx1ZSBvciB0aGVcbiAgcmVhc29uIHdoeSB0aGUgcHJvbWlzZSBjYW5ub3QgYmUgZnVsZmlsbGVkLlxuICAgYGBganNcbiAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uKHVzZXIpe1xuICAgIC8vIHVzZXIgaXMgYXZhaWxhYmxlXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gdXNlciBpcyB1bmF2YWlsYWJsZSwgYW5kIHlvdSBhcmUgZ2l2ZW4gdGhlIHJlYXNvbiB3aHlcbiAgfSk7XG4gIGBgYFxuICAgQ2hhaW5pbmdcbiAgLS0tLS0tLS1cbiAgIFRoZSByZXR1cm4gdmFsdWUgb2YgYHRoZW5gIGlzIGl0c2VsZiBhIHByb21pc2UuICBUaGlzIHNlY29uZCwgJ2Rvd25zdHJlYW0nXG4gIHByb21pc2UgaXMgcmVzb2x2ZWQgd2l0aCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmaXJzdCBwcm9taXNlJ3MgZnVsZmlsbG1lbnRcbiAgb3IgcmVqZWN0aW9uIGhhbmRsZXIsIG9yIHJlamVjdGVkIGlmIHRoZSBoYW5kbGVyIHRocm93cyBhbiBleGNlcHRpb24uXG4gICBgYGBqc1xuICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICByZXR1cm4gdXNlci5uYW1lO1xuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgcmV0dXJuICdkZWZhdWx0IG5hbWUnO1xuICB9KS50aGVuKGZ1bmN0aW9uICh1c2VyTmFtZSkge1xuICAgIC8vIElmIGBmaW5kVXNlcmAgZnVsZmlsbGVkLCBgdXNlck5hbWVgIHdpbGwgYmUgdGhlIHVzZXIncyBuYW1lLCBvdGhlcndpc2UgaXRcbiAgICAvLyB3aWxsIGJlIGAnZGVmYXVsdCBuYW1lJ2BcbiAgfSk7XG4gICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIHVzZXIsIGJ1dCBzdGlsbCB1bmhhcHB5Jyk7XG4gIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2BmaW5kVXNlcmAgcmVqZWN0ZWQgYW5kIHdlJ3JlIHVuaGFwcHknKTtcbiAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyBuZXZlciByZWFjaGVkXG4gIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAvLyBpZiBgZmluZFVzZXJgIGZ1bGZpbGxlZCwgYHJlYXNvbmAgd2lsbCBiZSAnRm91bmQgdXNlciwgYnV0IHN0aWxsIHVuaGFwcHknLlxuICAgIC8vIElmIGBmaW5kVXNlcmAgcmVqZWN0ZWQsIGByZWFzb25gIHdpbGwgYmUgJ2BmaW5kVXNlcmAgcmVqZWN0ZWQgYW5kIHdlJ3JlIHVuaGFwcHknLlxuICB9KTtcbiAgYGBgXG4gIElmIHRoZSBkb3duc3RyZWFtIHByb21pc2UgZG9lcyBub3Qgc3BlY2lmeSBhIHJlamVjdGlvbiBoYW5kbGVyLCByZWplY3Rpb24gcmVhc29ucyB3aWxsIGJlIHByb3BhZ2F0ZWQgZnVydGhlciBkb3duc3RyZWFtLlxuICAgYGBganNcbiAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgdGhyb3cgbmV3IFBlZGFnb2dpY2FsRXhjZXB0aW9uKCdVcHN0cmVhbSBlcnJvcicpO1xuICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyBuZXZlciByZWFjaGVkXG4gIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAvLyBUaGUgYFBlZGdhZ29jaWFsRXhjZXB0aW9uYCBpcyBwcm9wYWdhdGVkIGFsbCB0aGUgd2F5IGRvd24gdG8gaGVyZVxuICB9KTtcbiAgYGBgXG4gICBBc3NpbWlsYXRpb25cbiAgLS0tLS0tLS0tLS0tXG4gICBTb21ldGltZXMgdGhlIHZhbHVlIHlvdSB3YW50IHRvIHByb3BhZ2F0ZSB0byBhIGRvd25zdHJlYW0gcHJvbWlzZSBjYW4gb25seSBiZVxuICByZXRyaWV2ZWQgYXN5bmNocm9ub3VzbHkuIFRoaXMgY2FuIGJlIGFjaGlldmVkIGJ5IHJldHVybmluZyBhIHByb21pc2UgaW4gdGhlXG4gIGZ1bGZpbGxtZW50IG9yIHJlamVjdGlvbiBoYW5kbGVyLiBUaGUgZG93bnN0cmVhbSBwcm9taXNlIHdpbGwgdGhlbiBiZSBwZW5kaW5nXG4gIHVudGlsIHRoZSByZXR1cm5lZCBwcm9taXNlIGlzIHNldHRsZWQuIFRoaXMgaXMgY2FsbGVkICphc3NpbWlsYXRpb24qLlxuICAgYGBganNcbiAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICB9KS50aGVuKGZ1bmN0aW9uIChjb21tZW50cykge1xuICAgIC8vIFRoZSB1c2VyJ3MgY29tbWVudHMgYXJlIG5vdyBhdmFpbGFibGVcbiAgfSk7XG4gIGBgYFxuICAgSWYgdGhlIGFzc2ltbGlhdGVkIHByb21pc2UgcmVqZWN0cywgdGhlbiB0aGUgZG93bnN0cmVhbSBwcm9taXNlIHdpbGwgYWxzbyByZWplY3QuXG4gICBgYGBqc1xuICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICByZXR1cm4gZmluZENvbW1lbnRzQnlBdXRob3IodXNlcik7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKGNvbW1lbnRzKSB7XG4gICAgLy8gSWYgYGZpbmRDb21tZW50c0J5QXV0aG9yYCBmdWxmaWxscywgd2UnbGwgaGF2ZSB0aGUgdmFsdWUgaGVyZVxuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgLy8gSWYgYGZpbmRDb21tZW50c0J5QXV0aG9yYCByZWplY3RzLCB3ZSdsbCBoYXZlIHRoZSByZWFzb24gaGVyZVxuICB9KTtcbiAgYGBgXG4gICBTaW1wbGUgRXhhbXBsZVxuICAtLS0tLS0tLS0tLS0tLVxuICAgU3luY2hyb25vdXMgRXhhbXBsZVxuICAgYGBgamF2YXNjcmlwdFxuICBsZXQgcmVzdWx0O1xuICAgdHJ5IHtcbiAgICByZXN1bHQgPSBmaW5kUmVzdWx0KCk7XG4gICAgLy8gc3VjY2Vzc1xuICB9IGNhdGNoKHJlYXNvbikge1xuICAgIC8vIGZhaWx1cmVcbiAgfVxuICBgYGBcbiAgIEVycmJhY2sgRXhhbXBsZVxuICAgYGBganNcbiAgZmluZFJlc3VsdChmdW5jdGlvbihyZXN1bHQsIGVycil7XG4gICAgaWYgKGVycikge1xuICAgICAgLy8gZmFpbHVyZVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzdWNjZXNzXG4gICAgfVxuICB9KTtcbiAgYGBgXG4gICBQcm9taXNlIEV4YW1wbGU7XG4gICBgYGBqYXZhc2NyaXB0XG4gIGZpbmRSZXN1bHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgLy8gc3VjY2Vzc1xuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIGZhaWx1cmVcbiAgfSk7XG4gIGBgYFxuICAgQWR2YW5jZWQgRXhhbXBsZVxuICAtLS0tLS0tLS0tLS0tLVxuICAgU3luY2hyb25vdXMgRXhhbXBsZVxuICAgYGBgamF2YXNjcmlwdFxuICBsZXQgYXV0aG9yLCBib29rcztcbiAgIHRyeSB7XG4gICAgYXV0aG9yID0gZmluZEF1dGhvcigpO1xuICAgIGJvb2tzICA9IGZpbmRCb29rc0J5QXV0aG9yKGF1dGhvcik7XG4gICAgLy8gc3VjY2Vzc1xuICB9IGNhdGNoKHJlYXNvbikge1xuICAgIC8vIGZhaWx1cmVcbiAgfVxuICBgYGBcbiAgIEVycmJhY2sgRXhhbXBsZVxuICAgYGBganNcbiAgIGZ1bmN0aW9uIGZvdW5kQm9va3MoYm9va3MpIHtcbiAgIH1cbiAgIGZ1bmN0aW9uIGZhaWx1cmUocmVhc29uKSB7XG4gICB9XG4gICBmaW5kQXV0aG9yKGZ1bmN0aW9uKGF1dGhvciwgZXJyKXtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBmYWlsdXJlKGVycik7XG4gICAgICAvLyBmYWlsdXJlXG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZpbmRCb29va3NCeUF1dGhvcihhdXRob3IsIGZ1bmN0aW9uKGJvb2tzLCBlcnIpIHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZvdW5kQm9va3MoYm9va3MpO1xuICAgICAgICAgICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgICAgICAgICAgZmFpbHVyZShyZWFzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgIH1cbiAgICAgIC8vIHN1Y2Nlc3NcbiAgICB9XG4gIH0pO1xuICBgYGBcbiAgIFByb21pc2UgRXhhbXBsZTtcbiAgIGBgYGphdmFzY3JpcHRcbiAgZmluZEF1dGhvcigpLlxuICAgIHRoZW4oZmluZEJvb2tzQnlBdXRob3IpLlxuICAgIHRoZW4oZnVuY3Rpb24oYm9va3Mpe1xuICAgICAgLy8gZm91bmQgYm9va3NcbiAgfSkuY2F0Y2goZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICB9KTtcbiAgYGBgXG4gICBAbWV0aG9kIHRoZW5cbiAgQHBhcmFtIHtGdW5jdGlvbn0gb25GdWxmaWxsZWRcbiAgQHBhcmFtIHtGdW5jdGlvbn0gb25SZWplY3RlZFxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG5cbiAgLyoqXG4gIGBjYXRjaGAgaXMgc2ltcGx5IHN1Z2FyIGZvciBgdGhlbih1bmRlZmluZWQsIG9uUmVqZWN0aW9uKWAgd2hpY2ggbWFrZXMgaXQgdGhlIHNhbWVcbiAgYXMgdGhlIGNhdGNoIGJsb2NrIG9mIGEgdHJ5L2NhdGNoIHN0YXRlbWVudC5cbiAgYGBganNcbiAgZnVuY3Rpb24gZmluZEF1dGhvcigpe1xuICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkbid0IGZpbmQgdGhhdCBhdXRob3InKTtcbiAgfVxuICAvLyBzeW5jaHJvbm91c1xuICB0cnkge1xuICBmaW5kQXV0aG9yKCk7XG4gIH0gY2F0Y2gocmVhc29uKSB7XG4gIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gIH1cbiAgLy8gYXN5bmMgd2l0aCBwcm9taXNlc1xuICBmaW5kQXV0aG9yKCkuY2F0Y2goZnVuY3Rpb24ocmVhc29uKXtcbiAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgfSk7XG4gIGBgYFxuICBAbWV0aG9kIGNhdGNoXG4gIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVqZWN0aW9uXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX1cbiAgKi9cblxuXG4gIFByb21pc2UucHJvdG90eXBlLmNhdGNoID0gZnVuY3Rpb24gX2NhdGNoKG9uUmVqZWN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGlvbik7XG4gIH07XG5cbiAgLyoqXG4gICAgYGZpbmFsbHlgIHdpbGwgYmUgaW52b2tlZCByZWdhcmRsZXNzIG9mIHRoZSBwcm9taXNlJ3MgZmF0ZSBqdXN0IGFzIG5hdGl2ZVxuICAgIHRyeS9jYXRjaC9maW5hbGx5IGJlaGF2ZXNcbiAgXG4gICAgU3luY2hyb25vdXMgZXhhbXBsZTpcbiAgXG4gICAgYGBganNcbiAgICBmaW5kQXV0aG9yKCkge1xuICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPiAwLjUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEF1dGhvcigpO1xuICAgIH1cbiAgXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmaW5kQXV0aG9yKCk7IC8vIHN1Y2NlZWQgb3IgZmFpbFxuICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgIHJldHVybiBmaW5kT3RoZXJBdXRoZXIoKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgLy8gYWx3YXlzIHJ1bnNcbiAgICAgIC8vIGRvZXNuJ3QgYWZmZWN0IHRoZSByZXR1cm4gdmFsdWVcbiAgICB9XG4gICAgYGBgXG4gIFxuICAgIEFzeW5jaHJvbm91cyBleGFtcGxlOlxuICBcbiAgICBgYGBqc1xuICAgIGZpbmRBdXRob3IoKS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuICAgICAgcmV0dXJuIGZpbmRPdGhlckF1dGhlcigpO1xuICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKXtcbiAgICAgIC8vIGF1dGhvciB3YXMgZWl0aGVyIGZvdW5kLCBvciBub3RcbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgQG1ldGhvZCBmaW5hbGx5XG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICBAcmV0dXJuIHtQcm9taXNlfVxuICAqL1xuXG5cbiAgUHJvbWlzZS5wcm90b3R5cGUuZmluYWxseSA9IGZ1bmN0aW9uIF9maW5hbGx5KGNhbGxiYWNrKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IHByb21pc2UuY29uc3RydWN0b3I7XG5cbiAgICBpZiAoaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3Rvci5yZXNvbHZlKGNhbGxiYWNrKCkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3Rvci5yZXNvbHZlKGNhbGxiYWNrKCkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRocm93IHJlYXNvbjtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZS50aGVuKGNhbGxiYWNrLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgcmV0dXJuIFByb21pc2U7XG59KCk7XG5cblByb21pc2UkMS5wcm90b3R5cGUudGhlbiA9IHRoZW47XG5Qcm9taXNlJDEuYWxsID0gYWxsO1xuUHJvbWlzZSQxLnJhY2UgPSByYWNlO1xuUHJvbWlzZSQxLnJlc29sdmUgPSByZXNvbHZlJDE7XG5Qcm9taXNlJDEucmVqZWN0ID0gcmVqZWN0JDE7XG5Qcm9taXNlJDEuX3NldFNjaGVkdWxlciA9IHNldFNjaGVkdWxlcjtcblByb21pc2UkMS5fc2V0QXNhcCA9IHNldEFzYXA7XG5Qcm9taXNlJDEuX2FzYXAgPSBhc2FwO1xuXG4vKmdsb2JhbCBzZWxmKi9cbmZ1bmN0aW9uIHBvbHlmaWxsKCkge1xuICB2YXIgbG9jYWwgPSB2b2lkIDA7XG5cbiAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbG9jYWwgPSBnbG9iYWw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbG9jYWwgPSBzZWxmO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBsb2NhbCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb2x5ZmlsbCBmYWlsZWQgYmVjYXVzZSBnbG9iYWwgb2JqZWN0IGlzIHVuYXZhaWxhYmxlIGluIHRoaXMgZW52aXJvbm1lbnQnKTtcbiAgICB9XG4gIH1cblxuICB2YXIgUCA9IGxvY2FsLlByb21pc2U7XG5cbiAgaWYgKFApIHtcbiAgICB2YXIgcHJvbWlzZVRvU3RyaW5nID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgcHJvbWlzZVRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFAucmVzb2x2ZSgpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBzaWxlbnRseSBpZ25vcmVkXG4gICAgfVxuXG4gICAgaWYgKHByb21pc2VUb1N0cmluZyA9PT0gJ1tvYmplY3QgUHJvbWlzZV0nICYmICFQLmNhc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBsb2NhbC5Qcm9taXNlID0gUHJvbWlzZSQxO1xufVxuXG4vLyBTdHJhbmdlIGNvbXBhdC4uXG5Qcm9taXNlJDEucG9seWZpbGwgPSBwb2x5ZmlsbDtcblByb21pc2UkMS5Qcm9taXNlID0gUHJvbWlzZSQxO1xuXG5yZXR1cm4gUHJvbWlzZSQxO1xuXG59KSkpO1xuXG5cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXM2LXByb21pc2UubWFwXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/es6-promise/dist/es6-promise.js\n");

/***/ }),

/***/ "../node_modules/mc-animejs-core/lib/anime.es.js":
/*!*******************************************************!*\
  !*** ../node_modules/mc-animejs-core/lib/anime.es.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(Promise) {/*\n * anime.js v3.1.0\n * (c) 2019 Julian Garnier\n * Released under the MIT license\n * animejs.com\n */\n\n// Defaults\n\nvar defaultInstanceSettings = {};\n\nvar defaultTweenSettings = {\n  duration: 1000,\n  round: 0\n};\n\nvar validTransforms = ['translateX', 'translateY', 'translateZ', 'rotate', 'rotateX', 'rotateY', 'rotateZ', 'scale', 'scaleX', 'scaleY', 'scaleZ', 'skew', 'skewX', 'skewY', 'perspective'];\n\n// Caching\n\nvar cache = {\n  CSS: {}\n};\n\n// Utils\n\nfunction minMax(val, min, max) {\n  return Math.min(Math.max(val, min), max);\n}\n\nfunction stringContains(str, text) {\n  return str.indexOf(text) > -1;\n}\n\nvar is = {\n  arr: function (a) { return Array.isArray(a); },\n  obj: function (a) { return stringContains(Object.prototype.toString.call(a), 'Object'); },\n  pth: function (a) { return is.obj(a) && a.hasOwnProperty('totalLength'); },\n  svg: function (a) { return a instanceof SVGElement; },\n  inp: function (a) { return a instanceof HTMLInputElement; },\n  dom: function (a) { return a.nodeType || is.svg(a); },\n  str: function (a) { return typeof a === 'string'; },\n  fnc: function (a) { return typeof a === 'function'; },\n  und: function (a) { return typeof a === 'undefined'; },\n  hex: function (a) { return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(a); },\n  rgb: function (a) { return /^rgb/.test(a); },\n  hsl: function (a) { return /^hsl/.test(a); },\n  col: function (a) { return (is.hex(a) || is.rgb(a) || is.hsl(a)); },\n  key: function (a) { return !defaultInstanceSettings.hasOwnProperty(a) && !defaultTweenSettings.hasOwnProperty(a) && a !== 'targets' && a !== 'keyframes'; }\n};\n\nvar penner = (function () {\n\n  // Based on jQuery UI's implemenation of easing equations from Robert Penner (http://www.robertpenner.com/easing)\n\n  var eases = { linear: function () { return function (t) { return t; }; } };\n  return eases;\n\n})();\n\n\n// Strings\n\nfunction selectString(str) {\n  try {\n    var nodes = document.querySelectorAll(str);\n    return nodes;\n  }\n  catch (e) {\n    return;\n  }\n}\n\n// Arrays\n\nfunction filterArray(arr, callback) {\n  var len = arr.length;\n  var thisArg = arguments.length >= 2 ? arguments[1] : void 0;\n  var result = [];\n  for (var i = 0; i < len; i++) {\n    if (i in arr) {\n      var val = arr[i];\n      if (callback.call(thisArg, val, i, arr)) {\n        result.push(val);\n      }\n    }\n  }\n  return result;\n}\n\nfunction flattenArray(arr) {\n  return arr.reduce(function (a, b) { return a.concat(is.arr(b) ? flattenArray(b) : b); }, []);\n}\n\nfunction toArray(o) {\n  if (is.arr(o)) { return o; }\n  if (is.str(o)) { o = selectString(o) || o; }\n  if (o instanceof NodeList || o instanceof HTMLCollection) { return [].slice.call(o); }\n  return [o];\n}\n\nfunction arrayContains(arr, val) {\n  return arr.some(function (a) { return a === val; });\n}\n\n// Objects\n\nfunction cloneObject(o) {\n  var clone = {};\n  for (var p in o) { clone[p] = o[p]; }\n  return clone;\n}\n\nfunction replaceObjectProps(o1, o2) {\n  var o = cloneObject(o1);\n  for (var p in o1) { o[p] = o2.hasOwnProperty(p) ? o2[p] : o1[p]; }\n  return o;\n}\n\nfunction mergeObjects(o1, o2) {\n  var o = cloneObject(o1);\n  for (var p in o2) { o[p] = is.und(o1[p]) ? o2[p] : o1[p]; }\n  return o;\n}\n\n// Colors\n\nfunction rgbToRgba(rgbValue) {\n  var rgb = /rgb\\((\\d+,\\s*[\\d]+,\\s*[\\d]+)\\)/g.exec(rgbValue);\n  return rgb ? (\"rgba(\" + (rgb[1]) + \",1)\") : rgbValue;\n}\n\nfunction hexToRgba(hexValue) {\n  var rgx = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\n  var hex = hexValue.replace(rgx, function (m, r, g, b) { return r + r + g + g + b + b; });\n  var rgb = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n  var r = parseInt(rgb[1], 16);\n  var g = parseInt(rgb[2], 16);\n  var b = parseInt(rgb[3], 16);\n  return (\"rgba(\" + r + \",\" + g + \",\" + b + \",1)\");\n}\n\nfunction hslToRgba(hslValue) {\n  var hsl = /hsl\\((\\d+),\\s*([\\d.]+)%,\\s*([\\d.]+)%\\)/g.exec(hslValue) || /hsla\\((\\d+),\\s*([\\d.]+)%,\\s*([\\d.]+)%,\\s*([\\d.]+)\\)/g.exec(hslValue);\n  var h = parseInt(hsl[1], 10) / 360;\n  var s = parseInt(hsl[2], 10) / 100;\n  var l = parseInt(hsl[3], 10) / 100;\n  var a = hsl[4] || 1;\n\n  function hue2rgb(p, q, t) {\n    if (t < 0) { t += 1; }\n    if (t > 1) { t -= 1; }\n    if (t < 1 / 6) { return p + (q - p) * 6 * t; }\n    if (t < 1 / 2) { return q; }\n    if (t < 2 / 3) { return p + (q - p) * (2 / 3 - t) * 6; }\n    return p;\n  }\n  var r, g, b;\n  if (s == 0) {\n    r = g = b = l;\n  }\n  else {\n    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n    var p = 2 * l - q;\n    r = hue2rgb(p, q, h + 1 / 3);\n    g = hue2rgb(p, q, h);\n    b = hue2rgb(p, q, h - 1 / 3);\n  }\n  return (\"rgba(\" + (r * 255) + \",\" + (g * 255) + \",\" + (b * 255) + \",\" + a + \")\");\n}\n\nfunction colorToRgb(val) {\n  if (is.rgb(val)) { return rgbToRgba(val); }\n  if (is.hex(val)) { return hexToRgba(val); }\n  if (is.hsl(val)) { return hslToRgba(val); }\n}\n\n// Units\n\nfunction getUnit(val) {\n  var split = /[+-]?\\d*\\.?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(val);\n  if (split) { return split[1]; }\n}\n\nfunction getTransformUnit(propName) {\n  if (stringContains(propName, 'translate') || propName === 'perspective') { return 'px'; }\n  if (stringContains(propName, 'rotate') || stringContains(propName, 'skew')) { return 'deg'; }\n}\n\n// Values\n\nfunction getFunctionValue(val, animatable) {\n  if (!is.fnc(val)) { return val; }\n  return val(animatable.target, animatable.id, animatable.total);\n}\n\nfunction getAttribute(el, prop) {\n  return el.getAttribute(prop);\n}\n\nfunction convertPxToUnit(el, value, unit) {\n  var valueUnit = getUnit(value);\n  if (arrayContains([unit, 'deg', 'rad', 'turn'], valueUnit)) { return value; }\n  var cached = cache.CSS[value + unit];\n  if (!is.und(cached)) { return cached; }\n  var baseline = 100;\n  var tempEl = document.createElement(el.tagName);\n  var parentEl = (el.parentNode && (el.parentNode !== document)) ? el.parentNode : document.body;\n  parentEl.appendChild(tempEl);\n  tempEl.style.position = 'absolute';\n  tempEl.style.width = baseline + unit;\n  var factor = baseline / tempEl.offsetWidth;\n  parentEl.removeChild(tempEl);\n  var convertedUnit = factor * parseFloat(value);\n  cache.CSS[value + unit] = convertedUnit;\n  return convertedUnit;\n}\n\nfunction getCSSValue(el, prop, unit) {\n  if (prop in el.style) {\n    var uppercasePropName = prop.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n    var value = el.style[prop] || getComputedStyle(el).getPropertyValue(uppercasePropName) || '0';\n    return unit ? convertPxToUnit(el, value, unit) : value;\n  }\n}\n\nfunction getAnimationType(el, prop) {\n  if (is.dom(el) && !is.inp(el) && (getAttribute(el, prop) || (is.svg(el) && el[prop]))) { return 'attribute'; }\n  if (is.dom(el) && arrayContains(validTransforms, prop)) { return 'transform'; }\n  if (is.dom(el) && (prop !== 'transform' && getCSSValue(el, prop))) { return 'css'; }\n  if (el[prop] != null) { return 'object'; }\n}\n\nfunction getElementTransforms(el) {\n  if (!is.dom(el)) { return; }\n  var str = el.style.transform || '';\n  var reg = /(\\w+)\\(([^)]*)\\)/g;\n  var transforms = new Map();\n  var m;\n  while (m = reg.exec(str)) { transforms.set(m[1], m[2]); }\n  return transforms;\n}\n\nfunction getTransformValue(el, propName, animatable, unit) {\n  var defaultVal = stringContains(propName, 'scale') ? 1 : 0 + getTransformUnit(propName);\n  var value = getElementTransforms(el).get(propName) || defaultVal;\n  if (animatable) {\n    animatable.transforms.list.set(propName, value);\n    animatable.transforms['last'] = propName;\n  }\n  return unit ? convertPxToUnit(el, value, unit) : value;\n}\n\nfunction getOriginalTargetValue(target, propName, unit, animatable) {\n  switch (getAnimationType(target, propName)) {\n    case 'transform':\n      return getTransformValue(target, propName, animatable, unit);\n    case 'css':\n      return getCSSValue(target, propName, unit);\n    case 'attribute':\n      return getAttribute(target, propName);\n    default:\n      return target[propName] || 0;\n  }\n}\n\nfunction getRelativeValue(to, from) {\n  var operator = /^(\\*=|\\+=|-=)/.exec(to);\n  if (!operator) { return to; }\n  var u = getUnit(to) || 0;\n  var x = parseFloat(from);\n  var y = parseFloat(to.replace(operator[0], ''));\n  switch (operator[0][0]) {\n    case '+':\n      return x + y + u;\n    case '-':\n      return x - y + u;\n    case '*':\n      return x * y + u;\n  }\n}\n\nfunction validateValue(val, unit) {\n  if (is.col(val)) { return colorToRgb(val); }\n  if (/\\s/g.test(val)) { return val; }\n  var originalUnit = getUnit(val);\n  var unitLess = originalUnit ? val.substr(0, val.length - originalUnit.length) : val;\n  if (unit) { return unitLess + unit; }\n  return unitLess;\n}\n\n// Decompose value\n\nfunction decomposeValue(val, unit) {\n  // const rgx = /-?\\d*\\.?\\d+/g; // handles basic numbers\n  // const rgx = /[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?/g; // handles exponents notation\n  var rgx = /[+-]?\\d*\\.?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?/g; // handles exponents notation\n  var value = validateValue((is.pth(val) ? val.totalLength : val), unit) + '';\n  return {\n    original: value,\n    numbers: value.match(rgx) ? value.match(rgx).map(Number) : [0],\n    strings: (is.str(val) || unit) ? value.split(rgx) : []\n  }\n}\n\n// Animatables\n\nfunction parseTargets(targets) {\n  var targetsArray = targets ? (flattenArray(is.arr(targets) ? targets.map(toArray) : toArray(targets))) : [];\n  return filterArray(targetsArray, function (item, pos, self) { return self.indexOf(item) === pos; });\n}\n\nfunction getAnimatables(targets) {\n  var parsed = parseTargets(targets);\n  return parsed.map(function (t, i) {\n    return { target: t, id: i, total: parsed.length, transforms: { list: getElementTransforms(t) } };\n  });\n}\n\n// Properties\n\nfunction normalizePropertyTweens(prop, tweenSettings) {\n  var settings = cloneObject(tweenSettings);\n  if (is.arr(prop)) {\n    var l = prop.length;\n    var isFromTo = (l === 2 && !is.obj(prop[0]));\n    if (!isFromTo) {\n      // Duration divided by the number of tweens\n      if (!is.fnc(tweenSettings.duration)) { settings.duration = tweenSettings.duration / l; }\n    }\n    else {\n      // Transform [from, to] values shorthand to a valid tween value\n      prop = { value: prop };\n    }\n  }\n  var propArray = is.arr(prop) ? prop : [prop];\n  return propArray.map(function (v, i) {\n    var obj = (is.obj(v) && !is.pth(v)) ? v : { value: v };\n    return obj;\n  }).map(function (k) { return mergeObjects(k, settings); });\n}\n\nfunction getProperties(tweenSettings, params) {\n  var properties = [];\n  for (var p in params) {\n    if (is.key(p)) {\n      properties.push({\n        name: p,\n        tweens: normalizePropertyTweens(params[p], tweenSettings)\n      });\n    }\n  }\n  return properties;\n}\n\n// Tweens\n\nfunction normalizeTweenValues(tween, animatable) {\n  var t = {};\n  for (var p in tween) {\n    var value = getFunctionValue(tween[p], animatable);\n    if (is.arr(value)) {\n      value = value.map(function (v) { return getFunctionValue(v, animatable); });\n      if (value.length === 1) { value = value[0]; }\n    }\n    t[p] = value;\n  }\n  t.duration = parseFloat(t.duration);\n  return t;\n}\n\nfunction normalizeTweens(prop, animatable) {\n  var previousTween;\n  return prop.tweens.map(function (t) {\n    var tween = normalizeTweenValues(t, animatable);\n    var tweenValue = tween.value;\n    var to = is.arr(tweenValue) ? tweenValue[1] : tweenValue;\n    var toUnit = getUnit(to);\n    var originalValue = getOriginalTargetValue(animatable.target, prop.name, toUnit, animatable);\n    var previousValue = previousTween ? previousTween.to.original : originalValue;\n    var from = is.arr(tweenValue) ? tweenValue[0] : previousValue;\n    var fromUnit = getUnit(from) || getUnit(originalValue);\n    var unit = toUnit || fromUnit;\n    if (is.und(to)) { to = previousValue; }\n    tween.from = decomposeValue(from, unit);\n    tween.to = decomposeValue(getRelativeValue(to, from), unit);\n    tween.start = previousTween ? previousTween.end : 0;\n    tween.end = tween.start + tween.duration;\n    tween.isPath = false;\n    tween.isColor = is.col(tween.from.original);\n    if (tween.isColor) { tween.round = 1; }\n    previousTween = tween;\n    return tween;\n  });\n}\n\n// Tween progress\n\nvar setProgressValue = {\n  css: function (t, p, v) { return t.style[p] = v; },\n  attribute: function (t, p, v) { return t.setAttribute(p, v); },\n  object: function (t, p, v) { return t[p] = v; },\n  transform: function (t, p, v, transforms, manual) {\n    transforms.list.set(p, v);\n    if (p === transforms.last || manual) {\n      var str = '';\n      transforms.list.forEach(function (value, prop) { str += prop + \"(\" + value + \") \"; });\n      t.style.transform = str;\n    }\n  }\n};\n\n// Set Value helper\n\nfunction setTargetsValue(targets, properties) {\n  var animatables = getAnimatables(targets);\n  animatables.forEach(function (animatable) {\n    for (var property in properties) {\n      var value = getFunctionValue(properties[property], animatable);\n      var target = animatable.target;\n      var valueUnit = getUnit(value);\n      var originalValue = getOriginalTargetValue(target, property, valueUnit, animatable);\n      var unit = valueUnit || getUnit(originalValue);\n      var to = getRelativeValue(validateValue(value, unit), originalValue);\n      var animType = getAnimationType(target, property);\n      setProgressValue[animType](target, property, to, animatable.transforms, true);\n    }\n  });\n}\n\n// Animations\n\nfunction createAnimation(animatable, prop) {\n  var animType = getAnimationType(animatable.target, prop.name);\n  if (animType) {\n    var tweens = normalizeTweens(prop, animatable);\n    var lastTween = tweens[tweens.length - 1];\n    return {\n      type: animType,\n      property: prop.name,\n      animatable: animatable,\n      tweens: tweens,\n      duration: lastTween.end\n    }\n  }\n}\n\nfunction getAnimations(animatables, properties) {\n  return filterArray(flattenArray(animatables.map(function (animatable) {\n    return properties.map(function (prop) {\n      return createAnimation(animatable, prop);\n    });\n  })), function (a) { return !is.und(a); });\n}\n\n// Create Instance\n\nfunction getInstanceTimings(animations, tweenSettings) {\n  var animLength = animations.length;\n  var timings = {};\n  timings.duration = animLength ? Math.max.apply(Math, animations.map(function (anim) { return anim.duration; })) : tweenSettings.duration;\n  return timings;\n}\n\nvar instanceID = 0;\n\nfunction createNewInstance(params) {\n  var instanceSettings = replaceObjectProps(defaultInstanceSettings, params);\n  var tweenSettings = replaceObjectProps(defaultTweenSettings, params);\n  var properties = getProperties(tweenSettings, params);\n  var animatables = getAnimatables(params.targets);\n  var animations = getAnimations(animatables, properties);\n  var timings = getInstanceTimings(animations, tweenSettings);\n  var id = instanceID;\n  instanceID++;\n  return mergeObjects(instanceSettings, {\n    id: id,\n    children: [],\n    animatables: animatables,\n    animations: animations,\n    duration: timings.duration\n  });\n}\n\n// Public Instance\n\nfunction anime(params) {\n  if ( params === void 0 ) params = {};\n\n  var children, childrenLength = 0;\n  var resolve = null;\n\n  function makePromise(instance) {\n    var promise = window.Promise && new Promise(function (_resolve) { return resolve = _resolve; });\n    instance.finished = promise;\n    return promise;\n  }\n\n  var instance = createNewInstance(params);\n  var promise = makePromise(instance);\n\n  function seekChild(time, child) {\n    if (child) { child.seek(time); }\n  }\n\n  function syncInstanceChildren(time) {\n    if (!instance.reversePlayback) {\n      for (var i = 0; i < childrenLength; i++) { seekChild(time, children[i]); }\n    }\n    else {\n      for (var i$1 = childrenLength; i$1--;) { seekChild(time, children[i$1]); }\n    }\n  }\n\n  function setAnimationsProgress(insTime) {\n    var i = 0;\n    var animations = instance.animations;\n    var animationsLength = animations.length;\n    while (i < animationsLength) {\n      var anim = animations[i];\n      var animatable = anim.animatable;\n      var tweens = anim.tweens;\n      var tweenLength = tweens.length - 1;\n      var tween = tweens[tweenLength];\n      // Only check for keyframes if there is more than one tween\n      if (tweenLength) { tween = filterArray(tweens, function (t) { return (insTime < t.end); })[0] || tween; }\n      var elapsed = minMax(insTime - tween.start, 0, tween.duration) / tween.duration;\n      var strings = tween.to.strings;\n      var round = tween.round;\n      var numbers = [];\n      var toNumbersLength = tween.to.numbers.length;\n      var progress = (void 0);\n      for (var n = 0; n < toNumbersLength; n++) {\n        var value = (void 0);\n        var toNumber = tween.to.numbers[n];\n        var fromNumber = tween.from.numbers[n] || 0;\n        value = fromNumber + (elapsed * (toNumber - fromNumber));\n\n        if (round) {\n          if (!(tween.isColor && n > 2)) {\n            value = Math.round(value * round) / round;\n          }\n        }\n        numbers.push(value);\n      }\n      // Manual Array.reduce for better performances\n      var stringsLength = strings.length;\n      if (!stringsLength) {\n        progress = numbers[0];\n      }\n      else {\n        progress = strings[0];\n        for (var s = 0; s < stringsLength; s++) {\n          var a = strings[s];\n          var b = strings[s + 1];\n          var n$1 = numbers[s];\n          if (!isNaN(n$1)) {\n            if (!b) {\n              progress += n$1 + ' ';\n            }\n            else {\n              progress += n$1 + b;\n            }\n          }\n        }\n      }\n      setProgressValue[anim.type](animatable.target, anim.property, progress, animatable.transforms);\n      anim.currentValue = progress;\n      i++;\n    }\n  }\n\n  function setInstanceProgress(engineTime) {\n    var insDuration = instance.duration;\n    var insTime = engineTime;\n    instance.progress = minMax((insTime / insDuration) * 100, 0, 100);\n    instance.reversePlayback = insTime < instance.currentTime;\n    if (children) { syncInstanceChildren(insTime); }\n    if (!instance.began && instance.currentTime > 0) {\n      instance.began = true;\n    }\n\n    setAnimationsProgress(insTime);\n\n    instance.currentTime = minMax(insTime, 0, insDuration);\n    if (engineTime >= insDuration) {\n      instance.paused = true;\n      if (!instance.completed) {\n        instance.completed = true;\n        if (!instance.passThrough && 'Promise' in window) {\n          resolve();\n          promise = makePromise(instance);\n        }\n      }\n    }\n  }\n\n  instance.reset = function() {\n    instance.passThrough = false;\n    instance.currentTime = 0;\n    instance.progress = 0;\n    instance.paused = true;\n    instance.began = false;\n    instance.completed = false;\n    instance.reversePlayback = false;\n    children = instance.children;\n    childrenLength = children.length;\n    for (var i = childrenLength; i--;) { instance.children[i].reset(); }\n  };\n\n  // Set Value helper\n\n  instance.set = function(targets, properties) {\n    setTargetsValue(targets, properties);\n    return instance;\n  };\n\n  instance.seek = function(time) {\n    setInstanceProgress(time);\n  };\n\n  instance.reset();\n\n  return instance;\n\n}\n\nanime.version = '3.1.0';\nanime.get = getOriginalTargetValue;\nanime.set = setTargetsValue;\nanime.convertPx = convertPxToUnit;\nanime.penner = penner;\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (anime);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! es6-promise */ \"../node_modules/es6-promise/dist/es6-promise.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL21jLWFuaW1lanMtY29yZS9saWIvYW5pbWUuZXMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL21jLWFuaW1lanMtY29yZS9saWIvYW5pbWUuZXMuanM/NjBhZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogYW5pbWUuanMgdjMuMS4wXG4gKiAoYykgMjAxOSBKdWxpYW4gR2FybmllclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBhbmltZWpzLmNvbVxuICovXG5cbi8vIERlZmF1bHRzXG5cbnZhciBkZWZhdWx0SW5zdGFuY2VTZXR0aW5ncyA9IHt9O1xuXG52YXIgZGVmYXVsdFR3ZWVuU2V0dGluZ3MgPSB7XG4gIGR1cmF0aW9uOiAxMDAwLFxuICByb3VuZDogMFxufTtcblxudmFyIHZhbGlkVHJhbnNmb3JtcyA9IFsndHJhbnNsYXRlWCcsICd0cmFuc2xhdGVZJywgJ3RyYW5zbGF0ZVonLCAncm90YXRlJywgJ3JvdGF0ZVgnLCAncm90YXRlWScsICdyb3RhdGVaJywgJ3NjYWxlJywgJ3NjYWxlWCcsICdzY2FsZVknLCAnc2NhbGVaJywgJ3NrZXcnLCAnc2tld1gnLCAnc2tld1knLCAncGVyc3BlY3RpdmUnXTtcblxuLy8gQ2FjaGluZ1xuXG52YXIgY2FjaGUgPSB7XG4gIENTUzoge31cbn07XG5cbi8vIFV0aWxzXG5cbmZ1bmN0aW9uIG1pbk1heCh2YWwsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2YWwsIG1pbiksIG1heCk7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ0NvbnRhaW5zKHN0ciwgdGV4dCkge1xuICByZXR1cm4gc3RyLmluZGV4T2YodGV4dCkgPiAtMTtcbn1cblxudmFyIGlzID0ge1xuICBhcnI6IGZ1bmN0aW9uIChhKSB7IHJldHVybiBBcnJheS5pc0FycmF5KGEpOyB9LFxuICBvYmo6IGZ1bmN0aW9uIChhKSB7IHJldHVybiBzdHJpbmdDb250YWlucyhPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSksICdPYmplY3QnKTsgfSxcbiAgcHRoOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gaXMub2JqKGEpICYmIGEuaGFzT3duUHJvcGVydHkoJ3RvdGFsTGVuZ3RoJyk7IH0sXG4gIHN2ZzogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEgaW5zdGFuY2VvZiBTVkdFbGVtZW50OyB9LFxuICBpbnA6IGZ1bmN0aW9uIChhKSB7IHJldHVybiBhIGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudDsgfSxcbiAgZG9tOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gYS5ub2RlVHlwZSB8fCBpcy5zdmcoYSk7IH0sXG4gIHN0cjogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIHR5cGVvZiBhID09PSAnc3RyaW5nJzsgfSxcbiAgZm5jOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gdHlwZW9mIGEgPT09ICdmdW5jdGlvbic7IH0sXG4gIHVuZDogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIHR5cGVvZiBhID09PSAndW5kZWZpbmVkJzsgfSxcbiAgaGV4OiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gLyheI1swLTlBLUZdezZ9JCl8KF4jWzAtOUEtRl17M30kKS9pLnRlc3QoYSk7IH0sXG4gIHJnYjogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIC9ecmdiLy50ZXN0KGEpOyB9LFxuICBoc2w6IGZ1bmN0aW9uIChhKSB7IHJldHVybiAvXmhzbC8udGVzdChhKTsgfSxcbiAgY29sOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gKGlzLmhleChhKSB8fCBpcy5yZ2IoYSkgfHwgaXMuaHNsKGEpKTsgfSxcbiAga2V5OiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gIWRlZmF1bHRJbnN0YW5jZVNldHRpbmdzLmhhc093blByb3BlcnR5KGEpICYmICFkZWZhdWx0VHdlZW5TZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eShhKSAmJiBhICE9PSAndGFyZ2V0cycgJiYgYSAhPT0gJ2tleWZyYW1lcyc7IH1cbn07XG5cbnZhciBwZW5uZXIgPSAoZnVuY3Rpb24gKCkge1xuXG4gIC8vIEJhc2VkIG9uIGpRdWVyeSBVSSdzIGltcGxlbWVuYXRpb24gb2YgZWFzaW5nIGVxdWF0aW9ucyBmcm9tIFJvYmVydCBQZW5uZXIgKGh0dHA6Ly93d3cucm9iZXJ0cGVubmVyLmNvbS9lYXNpbmcpXG5cbiAgdmFyIGVhc2VzID0geyBsaW5lYXI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uICh0KSB7IHJldHVybiB0OyB9OyB9IH07XG4gIHJldHVybiBlYXNlcztcblxufSkoKTtcblxuXG4vLyBTdHJpbmdzXG5cbmZ1bmN0aW9uIHNlbGVjdFN0cmluZyhzdHIpIHtcbiAgdHJ5IHtcbiAgICB2YXIgbm9kZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHN0cik7XG4gICAgcmV0dXJuIG5vZGVzO1xuICB9XG4gIGNhdGNoIChlKSB7XG4gICAgcmV0dXJuO1xuICB9XG59XG5cbi8vIEFycmF5c1xuXG5mdW5jdGlvbiBmaWx0ZXJBcnJheShhcnIsIGNhbGxiYWNrKSB7XG4gIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICB2YXIgdGhpc0FyZyA9IGFyZ3VtZW50cy5sZW5ndGggPj0gMiA/IGFyZ3VtZW50c1sxXSA6IHZvaWQgMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGkgaW4gYXJyKSB7XG4gICAgICB2YXIgdmFsID0gYXJyW2ldO1xuICAgICAgaWYgKGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdmFsLCBpLCBhcnIpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW5BcnJheShhcnIpIHtcbiAgcmV0dXJuIGFyci5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuY29uY2F0KGlzLmFycihiKSA/IGZsYXR0ZW5BcnJheShiKSA6IGIpOyB9LCBbXSk7XG59XG5cbmZ1bmN0aW9uIHRvQXJyYXkobykge1xuICBpZiAoaXMuYXJyKG8pKSB7IHJldHVybiBvOyB9XG4gIGlmIChpcy5zdHIobykpIHsgbyA9IHNlbGVjdFN0cmluZyhvKSB8fCBvOyB9XG4gIGlmIChvIGluc3RhbmNlb2YgTm9kZUxpc3QgfHwgbyBpbnN0YW5jZW9mIEhUTUxDb2xsZWN0aW9uKSB7IHJldHVybiBbXS5zbGljZS5jYWxsKG8pOyB9XG4gIHJldHVybiBbb107XG59XG5cbmZ1bmN0aW9uIGFycmF5Q29udGFpbnMoYXJyLCB2YWwpIHtcbiAgcmV0dXJuIGFyci5zb21lKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhID09PSB2YWw7IH0pO1xufVxuXG4vLyBPYmplY3RzXG5cbmZ1bmN0aW9uIGNsb25lT2JqZWN0KG8pIHtcbiAgdmFyIGNsb25lID0ge307XG4gIGZvciAodmFyIHAgaW4gbykgeyBjbG9uZVtwXSA9IG9bcF07IH1cbiAgcmV0dXJuIGNsb25lO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlT2JqZWN0UHJvcHMobzEsIG8yKSB7XG4gIHZhciBvID0gY2xvbmVPYmplY3QobzEpO1xuICBmb3IgKHZhciBwIGluIG8xKSB7IG9bcF0gPSBvMi5oYXNPd25Qcm9wZXJ0eShwKSA/IG8yW3BdIDogbzFbcF07IH1cbiAgcmV0dXJuIG87XG59XG5cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0cyhvMSwgbzIpIHtcbiAgdmFyIG8gPSBjbG9uZU9iamVjdChvMSk7XG4gIGZvciAodmFyIHAgaW4gbzIpIHsgb1twXSA9IGlzLnVuZChvMVtwXSkgPyBvMltwXSA6IG8xW3BdOyB9XG4gIHJldHVybiBvO1xufVxuXG4vLyBDb2xvcnNcblxuZnVuY3Rpb24gcmdiVG9SZ2JhKHJnYlZhbHVlKSB7XG4gIHZhciByZ2IgPSAvcmdiXFwoKFxcZCssXFxzKltcXGRdKyxcXHMqW1xcZF0rKVxcKS9nLmV4ZWMocmdiVmFsdWUpO1xuICByZXR1cm4gcmdiID8gKFwicmdiYShcIiArIChyZ2JbMV0pICsgXCIsMSlcIikgOiByZ2JWYWx1ZTtcbn1cblxuZnVuY3Rpb24gaGV4VG9SZ2JhKGhleFZhbHVlKSB7XG4gIHZhciByZ3ggPSAvXiM/KFthLWZcXGRdKShbYS1mXFxkXSkoW2EtZlxcZF0pJC9pO1xuICB2YXIgaGV4ID0gaGV4VmFsdWUucmVwbGFjZShyZ3gsIGZ1bmN0aW9uIChtLCByLCBnLCBiKSB7IHJldHVybiByICsgciArIGcgKyBnICsgYiArIGI7IH0pO1xuICB2YXIgcmdiID0gL14jPyhbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KSQvaS5leGVjKGhleCk7XG4gIHZhciByID0gcGFyc2VJbnQocmdiWzFdLCAxNik7XG4gIHZhciBnID0gcGFyc2VJbnQocmdiWzJdLCAxNik7XG4gIHZhciBiID0gcGFyc2VJbnQocmdiWzNdLCAxNik7XG4gIHJldHVybiAoXCJyZ2JhKFwiICsgciArIFwiLFwiICsgZyArIFwiLFwiICsgYiArIFwiLDEpXCIpO1xufVxuXG5mdW5jdGlvbiBoc2xUb1JnYmEoaHNsVmFsdWUpIHtcbiAgdmFyIGhzbCA9IC9oc2xcXCgoXFxkKyksXFxzKihbXFxkLl0rKSUsXFxzKihbXFxkLl0rKSVcXCkvZy5leGVjKGhzbFZhbHVlKSB8fCAvaHNsYVxcKChcXGQrKSxcXHMqKFtcXGQuXSspJSxcXHMqKFtcXGQuXSspJSxcXHMqKFtcXGQuXSspXFwpL2cuZXhlYyhoc2xWYWx1ZSk7XG4gIHZhciBoID0gcGFyc2VJbnQoaHNsWzFdLCAxMCkgLyAzNjA7XG4gIHZhciBzID0gcGFyc2VJbnQoaHNsWzJdLCAxMCkgLyAxMDA7XG4gIHZhciBsID0gcGFyc2VJbnQoaHNsWzNdLCAxMCkgLyAxMDA7XG4gIHZhciBhID0gaHNsWzRdIHx8IDE7XG5cbiAgZnVuY3Rpb24gaHVlMnJnYihwLCBxLCB0KSB7XG4gICAgaWYgKHQgPCAwKSB7IHQgKz0gMTsgfVxuICAgIGlmICh0ID4gMSkgeyB0IC09IDE7IH1cbiAgICBpZiAodCA8IDEgLyA2KSB7IHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0OyB9XG4gICAgaWYgKHQgPCAxIC8gMikgeyByZXR1cm4gcTsgfVxuICAgIGlmICh0IDwgMiAvIDMpIHsgcmV0dXJuIHAgKyAocSAtIHApICogKDIgLyAzIC0gdCkgKiA2OyB9XG4gICAgcmV0dXJuIHA7XG4gIH1cbiAgdmFyIHIsIGcsIGI7XG4gIGlmIChzID09IDApIHtcbiAgICByID0gZyA9IGIgPSBsO1xuICB9XG4gIGVsc2Uge1xuICAgIHZhciBxID0gbCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcbiAgICB2YXIgcCA9IDIgKiBsIC0gcTtcbiAgICByID0gaHVlMnJnYihwLCBxLCBoICsgMSAvIDMpO1xuICAgIGcgPSBodWUycmdiKHAsIHEsIGgpO1xuICAgIGIgPSBodWUycmdiKHAsIHEsIGggLSAxIC8gMyk7XG4gIH1cbiAgcmV0dXJuIChcInJnYmEoXCIgKyAociAqIDI1NSkgKyBcIixcIiArIChnICogMjU1KSArIFwiLFwiICsgKGIgKiAyNTUpICsgXCIsXCIgKyBhICsgXCIpXCIpO1xufVxuXG5mdW5jdGlvbiBjb2xvclRvUmdiKHZhbCkge1xuICBpZiAoaXMucmdiKHZhbCkpIHsgcmV0dXJuIHJnYlRvUmdiYSh2YWwpOyB9XG4gIGlmIChpcy5oZXgodmFsKSkgeyByZXR1cm4gaGV4VG9SZ2JhKHZhbCk7IH1cbiAgaWYgKGlzLmhzbCh2YWwpKSB7IHJldHVybiBoc2xUb1JnYmEodmFsKTsgfVxufVxuXG4vLyBVbml0c1xuXG5mdW5jdGlvbiBnZXRVbml0KHZhbCkge1xuICB2YXIgc3BsaXQgPSAvWystXT9cXGQqXFwuP1xcZCsoPzpcXC5cXGQrKT8oPzpbZUVdWystXT9cXGQrKT8oJXxweHxwdHxlbXxyZW18aW58Y218bW18ZXh8Y2h8cGN8dnd8dmh8dm1pbnx2bWF4fGRlZ3xyYWR8dHVybik/JC8uZXhlYyh2YWwpO1xuICBpZiAoc3BsaXQpIHsgcmV0dXJuIHNwbGl0WzFdOyB9XG59XG5cbmZ1bmN0aW9uIGdldFRyYW5zZm9ybVVuaXQocHJvcE5hbWUpIHtcbiAgaWYgKHN0cmluZ0NvbnRhaW5zKHByb3BOYW1lLCAndHJhbnNsYXRlJykgfHwgcHJvcE5hbWUgPT09ICdwZXJzcGVjdGl2ZScpIHsgcmV0dXJuICdweCc7IH1cbiAgaWYgKHN0cmluZ0NvbnRhaW5zKHByb3BOYW1lLCAncm90YXRlJykgfHwgc3RyaW5nQ29udGFpbnMocHJvcE5hbWUsICdza2V3JykpIHsgcmV0dXJuICdkZWcnOyB9XG59XG5cbi8vIFZhbHVlc1xuXG5mdW5jdGlvbiBnZXRGdW5jdGlvblZhbHVlKHZhbCwgYW5pbWF0YWJsZSkge1xuICBpZiAoIWlzLmZuYyh2YWwpKSB7IHJldHVybiB2YWw7IH1cbiAgcmV0dXJuIHZhbChhbmltYXRhYmxlLnRhcmdldCwgYW5pbWF0YWJsZS5pZCwgYW5pbWF0YWJsZS50b3RhbCk7XG59XG5cbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZShlbCwgcHJvcCkge1xuICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKHByb3ApO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0UHhUb1VuaXQoZWwsIHZhbHVlLCB1bml0KSB7XG4gIHZhciB2YWx1ZVVuaXQgPSBnZXRVbml0KHZhbHVlKTtcbiAgaWYgKGFycmF5Q29udGFpbnMoW3VuaXQsICdkZWcnLCAncmFkJywgJ3R1cm4nXSwgdmFsdWVVbml0KSkgeyByZXR1cm4gdmFsdWU7IH1cbiAgdmFyIGNhY2hlZCA9IGNhY2hlLkNTU1t2YWx1ZSArIHVuaXRdO1xuICBpZiAoIWlzLnVuZChjYWNoZWQpKSB7IHJldHVybiBjYWNoZWQ7IH1cbiAgdmFyIGJhc2VsaW5lID0gMTAwO1xuICB2YXIgdGVtcEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlbC50YWdOYW1lKTtcbiAgdmFyIHBhcmVudEVsID0gKGVsLnBhcmVudE5vZGUgJiYgKGVsLnBhcmVudE5vZGUgIT09IGRvY3VtZW50KSkgPyBlbC5wYXJlbnROb2RlIDogZG9jdW1lbnQuYm9keTtcbiAgcGFyZW50RWwuYXBwZW5kQ2hpbGQodGVtcEVsKTtcbiAgdGVtcEVsLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgdGVtcEVsLnN0eWxlLndpZHRoID0gYmFzZWxpbmUgKyB1bml0O1xuICB2YXIgZmFjdG9yID0gYmFzZWxpbmUgLyB0ZW1wRWwub2Zmc2V0V2lkdGg7XG4gIHBhcmVudEVsLnJlbW92ZUNoaWxkKHRlbXBFbCk7XG4gIHZhciBjb252ZXJ0ZWRVbml0ID0gZmFjdG9yICogcGFyc2VGbG9hdCh2YWx1ZSk7XG4gIGNhY2hlLkNTU1t2YWx1ZSArIHVuaXRdID0gY29udmVydGVkVW5pdDtcbiAgcmV0dXJuIGNvbnZlcnRlZFVuaXQ7XG59XG5cbmZ1bmN0aW9uIGdldENTU1ZhbHVlKGVsLCBwcm9wLCB1bml0KSB7XG4gIGlmIChwcm9wIGluIGVsLnN0eWxlKSB7XG4gICAgdmFyIHVwcGVyY2FzZVByb3BOYW1lID0gcHJvcC5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCAnJDEtJDInKS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciB2YWx1ZSA9IGVsLnN0eWxlW3Byb3BdIHx8IGdldENvbXB1dGVkU3R5bGUoZWwpLmdldFByb3BlcnR5VmFsdWUodXBwZXJjYXNlUHJvcE5hbWUpIHx8ICcwJztcbiAgICByZXR1cm4gdW5pdCA/IGNvbnZlcnRQeFRvVW5pdChlbCwgdmFsdWUsIHVuaXQpIDogdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QW5pbWF0aW9uVHlwZShlbCwgcHJvcCkge1xuICBpZiAoaXMuZG9tKGVsKSAmJiAhaXMuaW5wKGVsKSAmJiAoZ2V0QXR0cmlidXRlKGVsLCBwcm9wKSB8fCAoaXMuc3ZnKGVsKSAmJiBlbFtwcm9wXSkpKSB7IHJldHVybiAnYXR0cmlidXRlJzsgfVxuICBpZiAoaXMuZG9tKGVsKSAmJiBhcnJheUNvbnRhaW5zKHZhbGlkVHJhbnNmb3JtcywgcHJvcCkpIHsgcmV0dXJuICd0cmFuc2Zvcm0nOyB9XG4gIGlmIChpcy5kb20oZWwpICYmIChwcm9wICE9PSAndHJhbnNmb3JtJyAmJiBnZXRDU1NWYWx1ZShlbCwgcHJvcCkpKSB7IHJldHVybiAnY3NzJzsgfVxuICBpZiAoZWxbcHJvcF0gIT0gbnVsbCkgeyByZXR1cm4gJ29iamVjdCc7IH1cbn1cblxuZnVuY3Rpb24gZ2V0RWxlbWVudFRyYW5zZm9ybXMoZWwpIHtcbiAgaWYgKCFpcy5kb20oZWwpKSB7IHJldHVybjsgfVxuICB2YXIgc3RyID0gZWwuc3R5bGUudHJhbnNmb3JtIHx8ICcnO1xuICB2YXIgcmVnID0gLyhcXHcrKVxcKChbXildKilcXCkvZztcbiAgdmFyIHRyYW5zZm9ybXMgPSBuZXcgTWFwKCk7XG4gIHZhciBtO1xuICB3aGlsZSAobSA9IHJlZy5leGVjKHN0cikpIHsgdHJhbnNmb3Jtcy5zZXQobVsxXSwgbVsyXSk7IH1cbiAgcmV0dXJuIHRyYW5zZm9ybXM7XG59XG5cbmZ1bmN0aW9uIGdldFRyYW5zZm9ybVZhbHVlKGVsLCBwcm9wTmFtZSwgYW5pbWF0YWJsZSwgdW5pdCkge1xuICB2YXIgZGVmYXVsdFZhbCA9IHN0cmluZ0NvbnRhaW5zKHByb3BOYW1lLCAnc2NhbGUnKSA/IDEgOiAwICsgZ2V0VHJhbnNmb3JtVW5pdChwcm9wTmFtZSk7XG4gIHZhciB2YWx1ZSA9IGdldEVsZW1lbnRUcmFuc2Zvcm1zKGVsKS5nZXQocHJvcE5hbWUpIHx8IGRlZmF1bHRWYWw7XG4gIGlmIChhbmltYXRhYmxlKSB7XG4gICAgYW5pbWF0YWJsZS50cmFuc2Zvcm1zLmxpc3Quc2V0KHByb3BOYW1lLCB2YWx1ZSk7XG4gICAgYW5pbWF0YWJsZS50cmFuc2Zvcm1zWydsYXN0J10gPSBwcm9wTmFtZTtcbiAgfVxuICByZXR1cm4gdW5pdCA/IGNvbnZlcnRQeFRvVW5pdChlbCwgdmFsdWUsIHVuaXQpIDogdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGdldE9yaWdpbmFsVGFyZ2V0VmFsdWUodGFyZ2V0LCBwcm9wTmFtZSwgdW5pdCwgYW5pbWF0YWJsZSkge1xuICBzd2l0Y2ggKGdldEFuaW1hdGlvblR5cGUodGFyZ2V0LCBwcm9wTmFtZSkpIHtcbiAgICBjYXNlICd0cmFuc2Zvcm0nOlxuICAgICAgcmV0dXJuIGdldFRyYW5zZm9ybVZhbHVlKHRhcmdldCwgcHJvcE5hbWUsIGFuaW1hdGFibGUsIHVuaXQpO1xuICAgIGNhc2UgJ2Nzcyc6XG4gICAgICByZXR1cm4gZ2V0Q1NTVmFsdWUodGFyZ2V0LCBwcm9wTmFtZSwgdW5pdCk7XG4gICAgY2FzZSAnYXR0cmlidXRlJzpcbiAgICAgIHJldHVybiBnZXRBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wTmFtZSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB0YXJnZXRbcHJvcE5hbWVdIHx8IDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UmVsYXRpdmVWYWx1ZSh0bywgZnJvbSkge1xuICB2YXIgb3BlcmF0b3IgPSAvXihcXCo9fFxcKz18LT0pLy5leGVjKHRvKTtcbiAgaWYgKCFvcGVyYXRvcikgeyByZXR1cm4gdG87IH1cbiAgdmFyIHUgPSBnZXRVbml0KHRvKSB8fCAwO1xuICB2YXIgeCA9IHBhcnNlRmxvYXQoZnJvbSk7XG4gIHZhciB5ID0gcGFyc2VGbG9hdCh0by5yZXBsYWNlKG9wZXJhdG9yWzBdLCAnJykpO1xuICBzd2l0Y2ggKG9wZXJhdG9yWzBdWzBdKSB7XG4gICAgY2FzZSAnKyc6XG4gICAgICByZXR1cm4geCArIHkgKyB1O1xuICAgIGNhc2UgJy0nOlxuICAgICAgcmV0dXJuIHggLSB5ICsgdTtcbiAgICBjYXNlICcqJzpcbiAgICAgIHJldHVybiB4ICogeSArIHU7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVWYWx1ZSh2YWwsIHVuaXQpIHtcbiAgaWYgKGlzLmNvbCh2YWwpKSB7IHJldHVybiBjb2xvclRvUmdiKHZhbCk7IH1cbiAgaWYgKC9cXHMvZy50ZXN0KHZhbCkpIHsgcmV0dXJuIHZhbDsgfVxuICB2YXIgb3JpZ2luYWxVbml0ID0gZ2V0VW5pdCh2YWwpO1xuICB2YXIgdW5pdExlc3MgPSBvcmlnaW5hbFVuaXQgPyB2YWwuc3Vic3RyKDAsIHZhbC5sZW5ndGggLSBvcmlnaW5hbFVuaXQubGVuZ3RoKSA6IHZhbDtcbiAgaWYgKHVuaXQpIHsgcmV0dXJuIHVuaXRMZXNzICsgdW5pdDsgfVxuICByZXR1cm4gdW5pdExlc3M7XG59XG5cbi8vIERlY29tcG9zZSB2YWx1ZVxuXG5mdW5jdGlvbiBkZWNvbXBvc2VWYWx1ZSh2YWwsIHVuaXQpIHtcbiAgLy8gY29uc3Qgcmd4ID0gLy0/XFxkKlxcLj9cXGQrL2c7IC8vIGhhbmRsZXMgYmFzaWMgbnVtYmVyc1xuICAvLyBjb25zdCByZ3ggPSAvWystXT9cXGQrKD86XFwuXFxkKyk/KD86W2VFXVsrLV0/XFxkKyk/L2c7IC8vIGhhbmRsZXMgZXhwb25lbnRzIG5vdGF0aW9uXG4gIHZhciByZ3ggPSAvWystXT9cXGQqXFwuP1xcZCsoPzpcXC5cXGQrKT8oPzpbZUVdWystXT9cXGQrKT8vZzsgLy8gaGFuZGxlcyBleHBvbmVudHMgbm90YXRpb25cbiAgdmFyIHZhbHVlID0gdmFsaWRhdGVWYWx1ZSgoaXMucHRoKHZhbCkgPyB2YWwudG90YWxMZW5ndGggOiB2YWwpLCB1bml0KSArICcnO1xuICByZXR1cm4ge1xuICAgIG9yaWdpbmFsOiB2YWx1ZSxcbiAgICBudW1iZXJzOiB2YWx1ZS5tYXRjaChyZ3gpID8gdmFsdWUubWF0Y2gocmd4KS5tYXAoTnVtYmVyKSA6IFswXSxcbiAgICBzdHJpbmdzOiAoaXMuc3RyKHZhbCkgfHwgdW5pdCkgPyB2YWx1ZS5zcGxpdChyZ3gpIDogW11cbiAgfVxufVxuXG4vLyBBbmltYXRhYmxlc1xuXG5mdW5jdGlvbiBwYXJzZVRhcmdldHModGFyZ2V0cykge1xuICB2YXIgdGFyZ2V0c0FycmF5ID0gdGFyZ2V0cyA/IChmbGF0dGVuQXJyYXkoaXMuYXJyKHRhcmdldHMpID8gdGFyZ2V0cy5tYXAodG9BcnJheSkgOiB0b0FycmF5KHRhcmdldHMpKSkgOiBbXTtcbiAgcmV0dXJuIGZpbHRlckFycmF5KHRhcmdldHNBcnJheSwgZnVuY3Rpb24gKGl0ZW0sIHBvcywgc2VsZikgeyByZXR1cm4gc2VsZi5pbmRleE9mKGl0ZW0pID09PSBwb3M7IH0pO1xufVxuXG5mdW5jdGlvbiBnZXRBbmltYXRhYmxlcyh0YXJnZXRzKSB7XG4gIHZhciBwYXJzZWQgPSBwYXJzZVRhcmdldHModGFyZ2V0cyk7XG4gIHJldHVybiBwYXJzZWQubWFwKGZ1bmN0aW9uICh0LCBpKSB7XG4gICAgcmV0dXJuIHsgdGFyZ2V0OiB0LCBpZDogaSwgdG90YWw6IHBhcnNlZC5sZW5ndGgsIHRyYW5zZm9ybXM6IHsgbGlzdDogZ2V0RWxlbWVudFRyYW5zZm9ybXModCkgfSB9O1xuICB9KTtcbn1cblxuLy8gUHJvcGVydGllc1xuXG5mdW5jdGlvbiBub3JtYWxpemVQcm9wZXJ0eVR3ZWVucyhwcm9wLCB0d2VlblNldHRpbmdzKSB7XG4gIHZhciBzZXR0aW5ncyA9IGNsb25lT2JqZWN0KHR3ZWVuU2V0dGluZ3MpO1xuICBpZiAoaXMuYXJyKHByb3ApKSB7XG4gICAgdmFyIGwgPSBwcm9wLmxlbmd0aDtcbiAgICB2YXIgaXNGcm9tVG8gPSAobCA9PT0gMiAmJiAhaXMub2JqKHByb3BbMF0pKTtcbiAgICBpZiAoIWlzRnJvbVRvKSB7XG4gICAgICAvLyBEdXJhdGlvbiBkaXZpZGVkIGJ5IHRoZSBudW1iZXIgb2YgdHdlZW5zXG4gICAgICBpZiAoIWlzLmZuYyh0d2VlblNldHRpbmdzLmR1cmF0aW9uKSkgeyBzZXR0aW5ncy5kdXJhdGlvbiA9IHR3ZWVuU2V0dGluZ3MuZHVyYXRpb24gLyBsOyB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gVHJhbnNmb3JtIFtmcm9tLCB0b10gdmFsdWVzIHNob3J0aGFuZCB0byBhIHZhbGlkIHR3ZWVuIHZhbHVlXG4gICAgICBwcm9wID0geyB2YWx1ZTogcHJvcCB9O1xuICAgIH1cbiAgfVxuICB2YXIgcHJvcEFycmF5ID0gaXMuYXJyKHByb3ApID8gcHJvcCA6IFtwcm9wXTtcbiAgcmV0dXJuIHByb3BBcnJheS5tYXAoZnVuY3Rpb24gKHYsIGkpIHtcbiAgICB2YXIgb2JqID0gKGlzLm9iaih2KSAmJiAhaXMucHRoKHYpKSA/IHYgOiB7IHZhbHVlOiB2IH07XG4gICAgcmV0dXJuIG9iajtcbiAgfSkubWFwKGZ1bmN0aW9uIChrKSB7IHJldHVybiBtZXJnZU9iamVjdHMoaywgc2V0dGluZ3MpOyB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0UHJvcGVydGllcyh0d2VlblNldHRpbmdzLCBwYXJhbXMpIHtcbiAgdmFyIHByb3BlcnRpZXMgPSBbXTtcbiAgZm9yICh2YXIgcCBpbiBwYXJhbXMpIHtcbiAgICBpZiAoaXMua2V5KHApKSB7XG4gICAgICBwcm9wZXJ0aWVzLnB1c2goe1xuICAgICAgICBuYW1lOiBwLFxuICAgICAgICB0d2VlbnM6IG5vcm1hbGl6ZVByb3BlcnR5VHdlZW5zKHBhcmFtc1twXSwgdHdlZW5TZXR0aW5ncylcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcHJvcGVydGllcztcbn1cblxuLy8gVHdlZW5zXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVR3ZWVuVmFsdWVzKHR3ZWVuLCBhbmltYXRhYmxlKSB7XG4gIHZhciB0ID0ge307XG4gIGZvciAodmFyIHAgaW4gdHdlZW4pIHtcbiAgICB2YXIgdmFsdWUgPSBnZXRGdW5jdGlvblZhbHVlKHR3ZWVuW3BdLCBhbmltYXRhYmxlKTtcbiAgICBpZiAoaXMuYXJyKHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGdldEZ1bmN0aW9uVmFsdWUodiwgYW5pbWF0YWJsZSk7IH0pO1xuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMSkgeyB2YWx1ZSA9IHZhbHVlWzBdOyB9XG4gICAgfVxuICAgIHRbcF0gPSB2YWx1ZTtcbiAgfVxuICB0LmR1cmF0aW9uID0gcGFyc2VGbG9hdCh0LmR1cmF0aW9uKTtcbiAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVR3ZWVucyhwcm9wLCBhbmltYXRhYmxlKSB7XG4gIHZhciBwcmV2aW91c1R3ZWVuO1xuICByZXR1cm4gcHJvcC50d2VlbnMubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgdmFyIHR3ZWVuID0gbm9ybWFsaXplVHdlZW5WYWx1ZXModCwgYW5pbWF0YWJsZSk7XG4gICAgdmFyIHR3ZWVuVmFsdWUgPSB0d2Vlbi52YWx1ZTtcbiAgICB2YXIgdG8gPSBpcy5hcnIodHdlZW5WYWx1ZSkgPyB0d2VlblZhbHVlWzFdIDogdHdlZW5WYWx1ZTtcbiAgICB2YXIgdG9Vbml0ID0gZ2V0VW5pdCh0byk7XG4gICAgdmFyIG9yaWdpbmFsVmFsdWUgPSBnZXRPcmlnaW5hbFRhcmdldFZhbHVlKGFuaW1hdGFibGUudGFyZ2V0LCBwcm9wLm5hbWUsIHRvVW5pdCwgYW5pbWF0YWJsZSk7XG4gICAgdmFyIHByZXZpb3VzVmFsdWUgPSBwcmV2aW91c1R3ZWVuID8gcHJldmlvdXNUd2Vlbi50by5vcmlnaW5hbCA6IG9yaWdpbmFsVmFsdWU7XG4gICAgdmFyIGZyb20gPSBpcy5hcnIodHdlZW5WYWx1ZSkgPyB0d2VlblZhbHVlWzBdIDogcHJldmlvdXNWYWx1ZTtcbiAgICB2YXIgZnJvbVVuaXQgPSBnZXRVbml0KGZyb20pIHx8IGdldFVuaXQob3JpZ2luYWxWYWx1ZSk7XG4gICAgdmFyIHVuaXQgPSB0b1VuaXQgfHwgZnJvbVVuaXQ7XG4gICAgaWYgKGlzLnVuZCh0bykpIHsgdG8gPSBwcmV2aW91c1ZhbHVlOyB9XG4gICAgdHdlZW4uZnJvbSA9IGRlY29tcG9zZVZhbHVlKGZyb20sIHVuaXQpO1xuICAgIHR3ZWVuLnRvID0gZGVjb21wb3NlVmFsdWUoZ2V0UmVsYXRpdmVWYWx1ZSh0bywgZnJvbSksIHVuaXQpO1xuICAgIHR3ZWVuLnN0YXJ0ID0gcHJldmlvdXNUd2VlbiA/IHByZXZpb3VzVHdlZW4uZW5kIDogMDtcbiAgICB0d2Vlbi5lbmQgPSB0d2Vlbi5zdGFydCArIHR3ZWVuLmR1cmF0aW9uO1xuICAgIHR3ZWVuLmlzUGF0aCA9IGZhbHNlO1xuICAgIHR3ZWVuLmlzQ29sb3IgPSBpcy5jb2wodHdlZW4uZnJvbS5vcmlnaW5hbCk7XG4gICAgaWYgKHR3ZWVuLmlzQ29sb3IpIHsgdHdlZW4ucm91bmQgPSAxOyB9XG4gICAgcHJldmlvdXNUd2VlbiA9IHR3ZWVuO1xuICAgIHJldHVybiB0d2VlbjtcbiAgfSk7XG59XG5cbi8vIFR3ZWVuIHByb2dyZXNzXG5cbnZhciBzZXRQcm9ncmVzc1ZhbHVlID0ge1xuICBjc3M6IGZ1bmN0aW9uICh0LCBwLCB2KSB7IHJldHVybiB0LnN0eWxlW3BdID0gdjsgfSxcbiAgYXR0cmlidXRlOiBmdW5jdGlvbiAodCwgcCwgdikgeyByZXR1cm4gdC5zZXRBdHRyaWJ1dGUocCwgdik7IH0sXG4gIG9iamVjdDogZnVuY3Rpb24gKHQsIHAsIHYpIHsgcmV0dXJuIHRbcF0gPSB2OyB9LFxuICB0cmFuc2Zvcm06IGZ1bmN0aW9uICh0LCBwLCB2LCB0cmFuc2Zvcm1zLCBtYW51YWwpIHtcbiAgICB0cmFuc2Zvcm1zLmxpc3Quc2V0KHAsIHYpO1xuICAgIGlmIChwID09PSB0cmFuc2Zvcm1zLmxhc3QgfHwgbWFudWFsKSB7XG4gICAgICB2YXIgc3RyID0gJyc7XG4gICAgICB0cmFuc2Zvcm1zLmxpc3QuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIHByb3ApIHsgc3RyICs9IHByb3AgKyBcIihcIiArIHZhbHVlICsgXCIpIFwiOyB9KTtcbiAgICAgIHQuc3R5bGUudHJhbnNmb3JtID0gc3RyO1xuICAgIH1cbiAgfVxufTtcblxuLy8gU2V0IFZhbHVlIGhlbHBlclxuXG5mdW5jdGlvbiBzZXRUYXJnZXRzVmFsdWUodGFyZ2V0cywgcHJvcGVydGllcykge1xuICB2YXIgYW5pbWF0YWJsZXMgPSBnZXRBbmltYXRhYmxlcyh0YXJnZXRzKTtcbiAgYW5pbWF0YWJsZXMuZm9yRWFjaChmdW5jdGlvbiAoYW5pbWF0YWJsZSkge1xuICAgIGZvciAodmFyIHByb3BlcnR5IGluIHByb3BlcnRpZXMpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldEZ1bmN0aW9uVmFsdWUocHJvcGVydGllc1twcm9wZXJ0eV0sIGFuaW1hdGFibGUpO1xuICAgICAgdmFyIHRhcmdldCA9IGFuaW1hdGFibGUudGFyZ2V0O1xuICAgICAgdmFyIHZhbHVlVW5pdCA9IGdldFVuaXQodmFsdWUpO1xuICAgICAgdmFyIG9yaWdpbmFsVmFsdWUgPSBnZXRPcmlnaW5hbFRhcmdldFZhbHVlKHRhcmdldCwgcHJvcGVydHksIHZhbHVlVW5pdCwgYW5pbWF0YWJsZSk7XG4gICAgICB2YXIgdW5pdCA9IHZhbHVlVW5pdCB8fCBnZXRVbml0KG9yaWdpbmFsVmFsdWUpO1xuICAgICAgdmFyIHRvID0gZ2V0UmVsYXRpdmVWYWx1ZSh2YWxpZGF0ZVZhbHVlKHZhbHVlLCB1bml0KSwgb3JpZ2luYWxWYWx1ZSk7XG4gICAgICB2YXIgYW5pbVR5cGUgPSBnZXRBbmltYXRpb25UeXBlKHRhcmdldCwgcHJvcGVydHkpO1xuICAgICAgc2V0UHJvZ3Jlc3NWYWx1ZVthbmltVHlwZV0odGFyZ2V0LCBwcm9wZXJ0eSwgdG8sIGFuaW1hdGFibGUudHJhbnNmb3JtcywgdHJ1ZSk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gQW5pbWF0aW9uc1xuXG5mdW5jdGlvbiBjcmVhdGVBbmltYXRpb24oYW5pbWF0YWJsZSwgcHJvcCkge1xuICB2YXIgYW5pbVR5cGUgPSBnZXRBbmltYXRpb25UeXBlKGFuaW1hdGFibGUudGFyZ2V0LCBwcm9wLm5hbWUpO1xuICBpZiAoYW5pbVR5cGUpIHtcbiAgICB2YXIgdHdlZW5zID0gbm9ybWFsaXplVHdlZW5zKHByb3AsIGFuaW1hdGFibGUpO1xuICAgIHZhciBsYXN0VHdlZW4gPSB0d2VlbnNbdHdlZW5zLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBhbmltVHlwZSxcbiAgICAgIHByb3BlcnR5OiBwcm9wLm5hbWUsXG4gICAgICBhbmltYXRhYmxlOiBhbmltYXRhYmxlLFxuICAgICAgdHdlZW5zOiB0d2VlbnMsXG4gICAgICBkdXJhdGlvbjogbGFzdFR3ZWVuLmVuZFxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRBbmltYXRpb25zKGFuaW1hdGFibGVzLCBwcm9wZXJ0aWVzKSB7XG4gIHJldHVybiBmaWx0ZXJBcnJheShmbGF0dGVuQXJyYXkoYW5pbWF0YWJsZXMubWFwKGZ1bmN0aW9uIChhbmltYXRhYmxlKSB7XG4gICAgcmV0dXJuIHByb3BlcnRpZXMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQW5pbWF0aW9uKGFuaW1hdGFibGUsIHByb3ApO1xuICAgIH0pO1xuICB9KSksIGZ1bmN0aW9uIChhKSB7IHJldHVybiAhaXMudW5kKGEpOyB9KTtcbn1cblxuLy8gQ3JlYXRlIEluc3RhbmNlXG5cbmZ1bmN0aW9uIGdldEluc3RhbmNlVGltaW5ncyhhbmltYXRpb25zLCB0d2VlblNldHRpbmdzKSB7XG4gIHZhciBhbmltTGVuZ3RoID0gYW5pbWF0aW9ucy5sZW5ndGg7XG4gIHZhciB0aW1pbmdzID0ge307XG4gIHRpbWluZ3MuZHVyYXRpb24gPSBhbmltTGVuZ3RoID8gTWF0aC5tYXguYXBwbHkoTWF0aCwgYW5pbWF0aW9ucy5tYXAoZnVuY3Rpb24gKGFuaW0pIHsgcmV0dXJuIGFuaW0uZHVyYXRpb247IH0pKSA6IHR3ZWVuU2V0dGluZ3MuZHVyYXRpb247XG4gIHJldHVybiB0aW1pbmdzO1xufVxuXG52YXIgaW5zdGFuY2VJRCA9IDA7XG5cbmZ1bmN0aW9uIGNyZWF0ZU5ld0luc3RhbmNlKHBhcmFtcykge1xuICB2YXIgaW5zdGFuY2VTZXR0aW5ncyA9IHJlcGxhY2VPYmplY3RQcm9wcyhkZWZhdWx0SW5zdGFuY2VTZXR0aW5ncywgcGFyYW1zKTtcbiAgdmFyIHR3ZWVuU2V0dGluZ3MgPSByZXBsYWNlT2JqZWN0UHJvcHMoZGVmYXVsdFR3ZWVuU2V0dGluZ3MsIHBhcmFtcyk7XG4gIHZhciBwcm9wZXJ0aWVzID0gZ2V0UHJvcGVydGllcyh0d2VlblNldHRpbmdzLCBwYXJhbXMpO1xuICB2YXIgYW5pbWF0YWJsZXMgPSBnZXRBbmltYXRhYmxlcyhwYXJhbXMudGFyZ2V0cyk7XG4gIHZhciBhbmltYXRpb25zID0gZ2V0QW5pbWF0aW9ucyhhbmltYXRhYmxlcywgcHJvcGVydGllcyk7XG4gIHZhciB0aW1pbmdzID0gZ2V0SW5zdGFuY2VUaW1pbmdzKGFuaW1hdGlvbnMsIHR3ZWVuU2V0dGluZ3MpO1xuICB2YXIgaWQgPSBpbnN0YW5jZUlEO1xuICBpbnN0YW5jZUlEKys7XG4gIHJldHVybiBtZXJnZU9iamVjdHMoaW5zdGFuY2VTZXR0aW5ncywge1xuICAgIGlkOiBpZCxcbiAgICBjaGlsZHJlbjogW10sXG4gICAgYW5pbWF0YWJsZXM6IGFuaW1hdGFibGVzLFxuICAgIGFuaW1hdGlvbnM6IGFuaW1hdGlvbnMsXG4gICAgZHVyYXRpb246IHRpbWluZ3MuZHVyYXRpb25cbiAgfSk7XG59XG5cbi8vIFB1YmxpYyBJbnN0YW5jZVxuXG5mdW5jdGlvbiBhbmltZShwYXJhbXMpIHtcbiAgaWYgKCBwYXJhbXMgPT09IHZvaWQgMCApIHBhcmFtcyA9IHt9O1xuXG4gIHZhciBjaGlsZHJlbiwgY2hpbGRyZW5MZW5ndGggPSAwO1xuICB2YXIgcmVzb2x2ZSA9IG51bGw7XG5cbiAgZnVuY3Rpb24gbWFrZVByb21pc2UoaW5zdGFuY2UpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHdpbmRvdy5Qcm9taXNlICYmIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChfcmVzb2x2ZSkgeyByZXR1cm4gcmVzb2x2ZSA9IF9yZXNvbHZlOyB9KTtcbiAgICBpbnN0YW5jZS5maW5pc2hlZCA9IHByb21pc2U7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICB2YXIgaW5zdGFuY2UgPSBjcmVhdGVOZXdJbnN0YW5jZShwYXJhbXMpO1xuICB2YXIgcHJvbWlzZSA9IG1ha2VQcm9taXNlKGluc3RhbmNlKTtcblxuICBmdW5jdGlvbiBzZWVrQ2hpbGQodGltZSwgY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQpIHsgY2hpbGQuc2Vlayh0aW1lKTsgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3luY0luc3RhbmNlQ2hpbGRyZW4odGltZSkge1xuICAgIGlmICghaW5zdGFuY2UucmV2ZXJzZVBsYXliYWNrKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHsgc2Vla0NoaWxkKHRpbWUsIGNoaWxkcmVuW2ldKTsgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkkMSA9IGNoaWxkcmVuTGVuZ3RoOyBpJDEtLTspIHsgc2Vla0NoaWxkKHRpbWUsIGNoaWxkcmVuW2kkMV0pOyB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0QW5pbWF0aW9uc1Byb2dyZXNzKGluc1RpbWUpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGFuaW1hdGlvbnMgPSBpbnN0YW5jZS5hbmltYXRpb25zO1xuICAgIHZhciBhbmltYXRpb25zTGVuZ3RoID0gYW5pbWF0aW9ucy5sZW5ndGg7XG4gICAgd2hpbGUgKGkgPCBhbmltYXRpb25zTGVuZ3RoKSB7XG4gICAgICB2YXIgYW5pbSA9IGFuaW1hdGlvbnNbaV07XG4gICAgICB2YXIgYW5pbWF0YWJsZSA9IGFuaW0uYW5pbWF0YWJsZTtcbiAgICAgIHZhciB0d2VlbnMgPSBhbmltLnR3ZWVucztcbiAgICAgIHZhciB0d2Vlbkxlbmd0aCA9IHR3ZWVucy5sZW5ndGggLSAxO1xuICAgICAgdmFyIHR3ZWVuID0gdHdlZW5zW3R3ZWVuTGVuZ3RoXTtcbiAgICAgIC8vIE9ubHkgY2hlY2sgZm9yIGtleWZyYW1lcyBpZiB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIHR3ZWVuXG4gICAgICBpZiAodHdlZW5MZW5ndGgpIHsgdHdlZW4gPSBmaWx0ZXJBcnJheSh0d2VlbnMsIGZ1bmN0aW9uICh0KSB7IHJldHVybiAoaW5zVGltZSA8IHQuZW5kKTsgfSlbMF0gfHwgdHdlZW47IH1cbiAgICAgIHZhciBlbGFwc2VkID0gbWluTWF4KGluc1RpbWUgLSB0d2Vlbi5zdGFydCwgMCwgdHdlZW4uZHVyYXRpb24pIC8gdHdlZW4uZHVyYXRpb247XG4gICAgICB2YXIgc3RyaW5ncyA9IHR3ZWVuLnRvLnN0cmluZ3M7XG4gICAgICB2YXIgcm91bmQgPSB0d2Vlbi5yb3VuZDtcbiAgICAgIHZhciBudW1iZXJzID0gW107XG4gICAgICB2YXIgdG9OdW1iZXJzTGVuZ3RoID0gdHdlZW4udG8ubnVtYmVycy5sZW5ndGg7XG4gICAgICB2YXIgcHJvZ3Jlc3MgPSAodm9pZCAwKTtcbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgdG9OdW1iZXJzTGVuZ3RoOyBuKyspIHtcbiAgICAgICAgdmFyIHZhbHVlID0gKHZvaWQgMCk7XG4gICAgICAgIHZhciB0b051bWJlciA9IHR3ZWVuLnRvLm51bWJlcnNbbl07XG4gICAgICAgIHZhciBmcm9tTnVtYmVyID0gdHdlZW4uZnJvbS5udW1iZXJzW25dIHx8IDA7XG4gICAgICAgIHZhbHVlID0gZnJvbU51bWJlciArIChlbGFwc2VkICogKHRvTnVtYmVyIC0gZnJvbU51bWJlcikpO1xuXG4gICAgICAgIGlmIChyb3VuZCkge1xuICAgICAgICAgIGlmICghKHR3ZWVuLmlzQ29sb3IgJiYgbiA+IDIpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUgKiByb3VuZCkgLyByb3VuZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbnVtYmVycy5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIC8vIE1hbnVhbCBBcnJheS5yZWR1Y2UgZm9yIGJldHRlciBwZXJmb3JtYW5jZXNcbiAgICAgIHZhciBzdHJpbmdzTGVuZ3RoID0gc3RyaW5ncy5sZW5ndGg7XG4gICAgICBpZiAoIXN0cmluZ3NMZW5ndGgpIHtcbiAgICAgICAgcHJvZ3Jlc3MgPSBudW1iZXJzWzBdO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHByb2dyZXNzID0gc3RyaW5nc1swXTtcbiAgICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCBzdHJpbmdzTGVuZ3RoOyBzKyspIHtcbiAgICAgICAgICB2YXIgYSA9IHN0cmluZ3Nbc107XG4gICAgICAgICAgdmFyIGIgPSBzdHJpbmdzW3MgKyAxXTtcbiAgICAgICAgICB2YXIgbiQxID0gbnVtYmVyc1tzXTtcbiAgICAgICAgICBpZiAoIWlzTmFOKG4kMSkpIHtcbiAgICAgICAgICAgIGlmICghYikge1xuICAgICAgICAgICAgICBwcm9ncmVzcyArPSBuJDEgKyAnICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcHJvZ3Jlc3MgKz0gbiQxICsgYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNldFByb2dyZXNzVmFsdWVbYW5pbS50eXBlXShhbmltYXRhYmxlLnRhcmdldCwgYW5pbS5wcm9wZXJ0eSwgcHJvZ3Jlc3MsIGFuaW1hdGFibGUudHJhbnNmb3Jtcyk7XG4gICAgICBhbmltLmN1cnJlbnRWYWx1ZSA9IHByb2dyZXNzO1xuICAgICAgaSsrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEluc3RhbmNlUHJvZ3Jlc3MoZW5naW5lVGltZSkge1xuICAgIHZhciBpbnNEdXJhdGlvbiA9IGluc3RhbmNlLmR1cmF0aW9uO1xuICAgIHZhciBpbnNUaW1lID0gZW5naW5lVGltZTtcbiAgICBpbnN0YW5jZS5wcm9ncmVzcyA9IG1pbk1heCgoaW5zVGltZSAvIGluc0R1cmF0aW9uKSAqIDEwMCwgMCwgMTAwKTtcbiAgICBpbnN0YW5jZS5yZXZlcnNlUGxheWJhY2sgPSBpbnNUaW1lIDwgaW5zdGFuY2UuY3VycmVudFRpbWU7XG4gICAgaWYgKGNoaWxkcmVuKSB7IHN5bmNJbnN0YW5jZUNoaWxkcmVuKGluc1RpbWUpOyB9XG4gICAgaWYgKCFpbnN0YW5jZS5iZWdhbiAmJiBpbnN0YW5jZS5jdXJyZW50VGltZSA+IDApIHtcbiAgICAgIGluc3RhbmNlLmJlZ2FuID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBzZXRBbmltYXRpb25zUHJvZ3Jlc3MoaW5zVGltZSk7XG5cbiAgICBpbnN0YW5jZS5jdXJyZW50VGltZSA9IG1pbk1heChpbnNUaW1lLCAwLCBpbnNEdXJhdGlvbik7XG4gICAgaWYgKGVuZ2luZVRpbWUgPj0gaW5zRHVyYXRpb24pIHtcbiAgICAgIGluc3RhbmNlLnBhdXNlZCA9IHRydWU7XG4gICAgICBpZiAoIWluc3RhbmNlLmNvbXBsZXRlZCkge1xuICAgICAgICBpbnN0YW5jZS5jb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoIWluc3RhbmNlLnBhc3NUaHJvdWdoICYmICdQcm9taXNlJyBpbiB3aW5kb3cpIHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgcHJvbWlzZSA9IG1ha2VQcm9taXNlKGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGluc3RhbmNlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgaW5zdGFuY2UucGFzc1Rocm91Z2ggPSBmYWxzZTtcbiAgICBpbnN0YW5jZS5jdXJyZW50VGltZSA9IDA7XG4gICAgaW5zdGFuY2UucHJvZ3Jlc3MgPSAwO1xuICAgIGluc3RhbmNlLnBhdXNlZCA9IHRydWU7XG4gICAgaW5zdGFuY2UuYmVnYW4gPSBmYWxzZTtcbiAgICBpbnN0YW5jZS5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICBpbnN0YW5jZS5yZXZlcnNlUGxheWJhY2sgPSBmYWxzZTtcbiAgICBjaGlsZHJlbiA9IGluc3RhbmNlLmNoaWxkcmVuO1xuICAgIGNoaWxkcmVuTGVuZ3RoID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSBjaGlsZHJlbkxlbmd0aDsgaS0tOykgeyBpbnN0YW5jZS5jaGlsZHJlbltpXS5yZXNldCgpOyB9XG4gIH07XG5cbiAgLy8gU2V0IFZhbHVlIGhlbHBlclxuXG4gIGluc3RhbmNlLnNldCA9IGZ1bmN0aW9uKHRhcmdldHMsIHByb3BlcnRpZXMpIHtcbiAgICBzZXRUYXJnZXRzVmFsdWUodGFyZ2V0cywgcHJvcGVydGllcyk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xuXG4gIGluc3RhbmNlLnNlZWsgPSBmdW5jdGlvbih0aW1lKSB7XG4gICAgc2V0SW5zdGFuY2VQcm9ncmVzcyh0aW1lKTtcbiAgfTtcblxuICBpbnN0YW5jZS5yZXNldCgpO1xuXG4gIHJldHVybiBpbnN0YW5jZTtcblxufVxuXG5hbmltZS52ZXJzaW9uID0gJzMuMS4wJztcbmFuaW1lLmdldCA9IGdldE9yaWdpbmFsVGFyZ2V0VmFsdWU7XG5hbmltZS5zZXQgPSBzZXRUYXJnZXRzVmFsdWU7XG5hbmltZS5jb252ZXJ0UHggPSBjb252ZXJ0UHhUb1VuaXQ7XG5hbmltZS5wZW5uZXIgPSBwZW5uZXI7XG5cbmV4cG9ydCBkZWZhdWx0IGFuaW1lO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/mc-animejs-core/lib/anime.es.js\n");

/***/ }),

/***/ "../node_modules/process/browser.js":
/*!******************************************!*\
  !*** ../node_modules/process/browser.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzP2U0OGIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/process/browser.js\n");

/***/ }),

/***/ "../node_modules/webpack/buildin/global.js":
/*!*************************************************!*\
  !*** ../node_modules/webpack/buildin/global.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanM/YTQyYiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/webpack/buildin/global.js\n");

/***/ }),

/***/ "../src/Anime.js":
/*!***********************!*\
  !*** ../src/Anime.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Anime; });\n/* harmony import */ var mc_animejs_core_lib_anime_es_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mc-animejs-core/lib/anime.es.js */ \"../node_modules/mc-animejs-core/lib/anime.es.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar MC = __webpack_require__(/*! @kissmybutton/motorcortex */ \"../node_modules/@kissmybutton/motorcortex/dist/motorcortex.umd.js\");\n\n\n\nvar compoAttributes = __webpack_require__(/*! ./compoAttributes */ \"../src/compoAttributes.js\");\n\nvar getMatrix2D = __webpack_require__(/*! ./matrix2d */ \"../src/matrix2d.js\");\n\nvar Anime = /*#__PURE__*/function (_MC$API$MonoIncident) {\n  _inherits(Anime, _MC$API$MonoIncident);\n\n  function Anime() {\n    _classCallCheck(this, Anime);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Anime).apply(this, arguments));\n  }\n\n  _createClass(Anime, [{\n    key: \"onGetContext\",\n    value: function onGetContext() {\n      var options = {};\n      var initialize = {};\n\n      if (compoAttributes.hasOwnProperty(this.attributeKey)) {\n        var compoAttribute = compoAttributes[this.attributeKey];\n\n        for (var i = 0; i < compoAttribute.length; i++) {\n          if (!this.targetValue.hasOwnProperty(compoAttribute[i])) {\n            continue;\n          }\n\n          options[compoAttribute[i]] = [this.getInitialValue()[compoAttribute[i]], this.targetValue[compoAttribute[i]]];\n          initialize[compoAttribute[i]] = [this.getScratchValue(), this.targetValue[compoAttribute[i]]];\n        }\n      } else {\n        options[this.attributeKey] = [this.getInitialValue(), this.targetValue];\n        initialize[this.targetValue] = [this.getScratchValue(), this.targetValue];\n      }\n\n      this.target = Object(mc_animejs_core_lib_anime_es_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(_objectSpread({\n        autoplay: false,\n        duration: this.props.duration,\n        easing: \"linear\",\n        targets: this.element\n      }, (this.attrs || {}).attrs || {}, {}, options)); // handle first render initial values\n    }\n  }, {\n    key: \"getScratchValue\",\n    value: function getScratchValue() {\n      if (this.attributeKey === \"transform\") {\n        var obj = {};\n        var transform = compoAttributes[this.attributeKey];\n        var currentTransform = getMatrix2D(this.context.window, this.element);\n\n        for (var i = 0; i < transform.length; i++) {\n          if (currentTransform.hasOwnProperty(transform[i])) {\n            obj[transform[i]] = currentTransform[transform[i]];\n          } else {\n            obj[transform[i]] = mc_animejs_core_lib_anime_es_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(this.element, transform[i]);\n          }\n        }\n\n        return obj;\n      }\n\n      return mc_animejs_core_lib_anime_es_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(this.element, this.attributeKey);\n    }\n  }, {\n    key: \"onProgress\",\n    value: function onProgress(f) {\n      return this.target.seek(this.target.duration * f);\n    }\n  }]);\n\n  return Anime;\n}(MC.API.MonoIncident);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc3JjL0FuaW1lLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL3NyYy9BbmltZS5qcz8zYjhmIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IE1DID0gcmVxdWlyZShcIkBraXNzbXlidXR0b24vbW90b3Jjb3J0ZXhcIik7XHJcbmltcG9ydCBhbmltZSBmcm9tIFwibWMtYW5pbWVqcy1jb3JlL2xpYi9hbmltZS5lcy5qc1wiO1xyXG5jb25zdCBjb21wb0F0dHJpYnV0ZXMgPSByZXF1aXJlKFwiLi9jb21wb0F0dHJpYnV0ZXNcIik7XHJcbmNvbnN0IGdldE1hdHJpeDJEID0gcmVxdWlyZShcIi4vbWF0cml4MmRcIik7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbmltZSBleHRlbmRzIE1DLkFQSS5Nb25vSW5jaWRlbnQge1xyXG4gIG9uR2V0Q29udGV4dCgpIHtcclxuICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcclxuICAgIGNvbnN0IGluaXRpYWxpemUgPSB7fTtcclxuICAgIGlmIChjb21wb0F0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkodGhpcy5hdHRyaWJ1dGVLZXkpKSB7XHJcbiAgICAgIGNvbnN0IGNvbXBvQXR0cmlidXRlID0gY29tcG9BdHRyaWJ1dGVzW3RoaXMuYXR0cmlidXRlS2V5XTtcclxuXHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29tcG9BdHRyaWJ1dGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoIXRoaXMudGFyZ2V0VmFsdWUuaGFzT3duUHJvcGVydHkoY29tcG9BdHRyaWJ1dGVbaV0pKSB7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgb3B0aW9uc1tjb21wb0F0dHJpYnV0ZVtpXV0gPSBbXHJcbiAgICAgICAgICB0aGlzLmdldEluaXRpYWxWYWx1ZSgpW2NvbXBvQXR0cmlidXRlW2ldXSxcclxuICAgICAgICAgIHRoaXMudGFyZ2V0VmFsdWVbY29tcG9BdHRyaWJ1dGVbaV1dXHJcbiAgICAgICAgXTtcclxuICAgICAgICBpbml0aWFsaXplW2NvbXBvQXR0cmlidXRlW2ldXSA9IFtcclxuICAgICAgICAgIHRoaXMuZ2V0U2NyYXRjaFZhbHVlKCksXHJcbiAgICAgICAgICB0aGlzLnRhcmdldFZhbHVlW2NvbXBvQXR0cmlidXRlW2ldXVxyXG4gICAgICAgIF07XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG9wdGlvbnNbdGhpcy5hdHRyaWJ1dGVLZXldID0gW3RoaXMuZ2V0SW5pdGlhbFZhbHVlKCksIHRoaXMudGFyZ2V0VmFsdWVdO1xyXG4gICAgICBpbml0aWFsaXplW3RoaXMudGFyZ2V0VmFsdWVdID0gW3RoaXMuZ2V0U2NyYXRjaFZhbHVlKCksIHRoaXMudGFyZ2V0VmFsdWVdO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMudGFyZ2V0ID0gYW5pbWUoe1xyXG4gICAgICBhdXRvcGxheTogZmFsc2UsXHJcbiAgICAgIGR1cmF0aW9uOiB0aGlzLnByb3BzLmR1cmF0aW9uLFxyXG4gICAgICBlYXNpbmc6IFwibGluZWFyXCIsXHJcbiAgICAgIHRhcmdldHM6IHRoaXMuZWxlbWVudCxcclxuICAgICAgLi4uKCh0aGlzLmF0dHJzIHx8IHt9KS5hdHRycyB8fCB7fSksXHJcbiAgICAgIC4uLm9wdGlvbnNcclxuICAgIH0pOyAvLyBoYW5kbGUgZmlyc3QgcmVuZGVyIGluaXRpYWwgdmFsdWVzXHJcbiAgfVxyXG5cclxuICBnZXRTY3JhdGNoVmFsdWUoKSB7XHJcbiAgICBpZiAodGhpcy5hdHRyaWJ1dGVLZXkgPT09IFwidHJhbnNmb3JtXCIpIHtcclxuICAgICAgY29uc3Qgb2JqID0ge307XHJcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGNvbXBvQXR0cmlidXRlc1t0aGlzLmF0dHJpYnV0ZUtleV07XHJcbiAgICAgIGNvbnN0IGN1cnJlbnRUcmFuc2Zvcm0gPSBnZXRNYXRyaXgyRCh0aGlzLmNvbnRleHQud2luZG93LCB0aGlzLmVsZW1lbnQpO1xyXG5cclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFuc2Zvcm0ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoY3VycmVudFRyYW5zZm9ybS5oYXNPd25Qcm9wZXJ0eSh0cmFuc2Zvcm1baV0pKSB7XHJcbiAgICAgICAgICBvYmpbdHJhbnNmb3JtW2ldXSA9IGN1cnJlbnRUcmFuc2Zvcm1bdHJhbnNmb3JtW2ldXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgb2JqW3RyYW5zZm9ybVtpXV0gPSBhbmltZS5nZXQodGhpcy5lbGVtZW50LCB0cmFuc2Zvcm1baV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG9iajtcclxuICAgIH1cclxuICAgIHJldHVybiBhbmltZS5nZXQodGhpcy5lbGVtZW50LCB0aGlzLmF0dHJpYnV0ZUtleSk7XHJcbiAgfVxyXG5cclxuICBvblByb2dyZXNzKGYpIHtcclxuICAgIHJldHVybiB0aGlzLnRhcmdldC5zZWVrKHRoaXMudGFyZ2V0LmR1cmF0aW9uICogZik7XHJcbiAgfVxyXG59XHJcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBSUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFRQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7OztBQXhEQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../src/Anime.js\n");

/***/ }),

/***/ "../src/compoAttributes.js":
/*!*********************************!*\
  !*** ../src/compoAttributes.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = {\n  transform: [\"translateX\", \"translateY\", \"translateZ\", \"rotate\", \"rotateX\", \"rotateY\", \"rotateZ\", \"scale\", \"scaleX\", \"scaleY\", \"scaleZ\", \"skewX\", \"skewY\", \"perspective\"]\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc3JjL2NvbXBvQXR0cmlidXRlcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9zcmMvY29tcG9BdHRyaWJ1dGVzLmpzPzdiZjciXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgdHJhbnNmb3JtOiBbXHJcbiAgICBcInRyYW5zbGF0ZVhcIixcclxuICAgIFwidHJhbnNsYXRlWVwiLFxyXG4gICAgXCJ0cmFuc2xhdGVaXCIsXHJcbiAgICBcInJvdGF0ZVwiLFxyXG4gICAgXCJyb3RhdGVYXCIsXHJcbiAgICBcInJvdGF0ZVlcIixcclxuICAgIFwicm90YXRlWlwiLFxyXG4gICAgXCJzY2FsZVwiLFxyXG4gICAgXCJzY2FsZVhcIixcclxuICAgIFwic2NhbGVZXCIsXHJcbiAgICBcInNjYWxlWlwiLFxyXG4gICAgXCJza2V3WFwiLFxyXG4gICAgXCJza2V3WVwiLFxyXG4gICAgXCJwZXJzcGVjdGl2ZVwiXHJcbiAgXVxyXG59O1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFEQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../src/compoAttributes.js\n");

/***/ }),

/***/ "../src/main.js":
/*!**********************!*\
  !*** ../src/main.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Anime = __webpack_require__(/*! ./Anime */ \"../src/Anime.js\");\n\nvar compositeAttributes = __webpack_require__(/*! ./compoAttributes */ \"../src/compoAttributes.js\");\n\nvar validations = __webpack_require__(/*! ./validation */ \"../src/validation.js\");\n\nmodule.exports = {\n  npm_name: \"@kissmybutton/motorcortex-anime\",\n  incidents: [{\n    exportable: Anime,\n    name: \"Anime\",\n    attributesValidationRules: validations\n  }],\n  compositeAttributes: compositeAttributes\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc3JjL21haW4uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL21haW4uanM/ZDNmZSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBBbmltZSA9IHJlcXVpcmUoXCIuL0FuaW1lXCIpO1xyXG5jb25zdCBjb21wb3NpdGVBdHRyaWJ1dGVzID0gcmVxdWlyZShcIi4vY29tcG9BdHRyaWJ1dGVzXCIpO1xyXG5jb25zdCB2YWxpZGF0aW9ucyA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRpb25cIik7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBucG1fbmFtZTogXCJAa2lzc215YnV0dG9uL21vdG9yY29ydGV4LWFuaW1lXCIsXHJcbiAgaW5jaWRlbnRzOiBbXHJcbiAgICB7XHJcbiAgICAgIGV4cG9ydGFibGU6IEFuaW1lLFxyXG4gICAgICBuYW1lOiBcIkFuaW1lXCIsXHJcbiAgICAgIGF0dHJpYnV0ZXNWYWxpZGF0aW9uUnVsZXM6IHZhbGlkYXRpb25zXHJcbiAgICB9XHJcbiAgXSxcclxuICBjb21wb3NpdGVBdHRyaWJ1dGVzXHJcbn07XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQVRBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../src/main.js\n");

/***/ }),

/***/ "../src/matrix2d.js":
/*!**************************!*\
  !*** ../src/matrix2d.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction getMatrix2D(win, element) {\n  var transform = win.getComputedStyle(element).transform;\n\n  if (transform === \"\" || transform === \"none\") {\n    return {};\n  }\n\n  var values = transform.split(\"(\")[1].split(\")\")[0].split(\",\");\n\n  var qrDecompone = function qrDecompone(a) {\n    var angle = Math.atan2(a[1], a[0]),\n        denom = Math.pow(a[0], 2) + Math.pow(a[1], 2),\n        denom2 = Math.pow(a[2], 2) + Math.pow(a[3], 2),\n        scaleX = Math.sqrt(denom),\n        scaleY = (a[0] * a[3] - a[2] * a[1]) / scaleX,\n        skewX = Math.atan2(a[0] * a[2] + a[1] * a[3], denom),\n        skewY = Math.atan2(a[1] * a[3] + a[0] * a[2], denom2);\n    return {\n      rotate: angle / (Math.PI / 180) + \"deg\",\n      // this is rotation angle in degrees\n      scaleX: scaleX,\n      // scaleX factor\n      scaleY: scaleY,\n      // scaleY factor\n      skewX: (denom === 1 ? skewX / (Math.PI / 180) : 0) + \"deg\",\n      // skewX angle degrees\n      skewY: (denom2 === 1 ? skewY / (Math.PI / 180) : 0) + \"deg\",\n      // skewY angle degrees\n      translateX: a[4] + \"px\",\n      // translation point  x\n      translateY: a[5] + \"px\" // translation point  y\n\n    };\n  };\n\n  return qrDecompone(values);\n}\n\nmodule.exports = getMatrix2D;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc3JjL21hdHJpeDJkLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL3NyYy9tYXRyaXgyZC5qcz82NDZhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuZnVuY3Rpb24gZ2V0TWF0cml4MkQod2luLCBlbGVtZW50KSB7XHJcbiAgY29uc3QgdHJhbnNmb3JtID0gd2luLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkudHJhbnNmb3JtO1xyXG5cclxuICBpZiAodHJhbnNmb3JtID09PSBcIlwiIHx8IHRyYW5zZm9ybSA9PT0gXCJub25lXCIpIHtcclxuICAgIHJldHVybiB7fTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHZhbHVlcyA9IHRyYW5zZm9ybVxyXG4gICAgLnNwbGl0KFwiKFwiKVsxXVxyXG4gICAgLnNwbGl0KFwiKVwiKVswXVxyXG4gICAgLnNwbGl0KFwiLFwiKTtcclxuXHJcbiAgY29uc3QgcXJEZWNvbXBvbmUgPSBmdW5jdGlvbiBxckRlY29tcG9uZShhKSB7XHJcbiAgICBjb25zdCBhbmdsZSA9IE1hdGguYXRhbjIoYVsxXSwgYVswXSksXHJcbiAgICAgIGRlbm9tID0gTWF0aC5wb3coYVswXSwgMikgKyBNYXRoLnBvdyhhWzFdLCAyKSxcclxuICAgICAgZGVub20yID0gTWF0aC5wb3coYVsyXSwgMikgKyBNYXRoLnBvdyhhWzNdLCAyKSxcclxuICAgICAgc2NhbGVYID0gTWF0aC5zcXJ0KGRlbm9tKSxcclxuICAgICAgc2NhbGVZID0gKGFbMF0gKiBhWzNdIC0gYVsyXSAqIGFbMV0pIC8gc2NhbGVYLFxyXG4gICAgICBza2V3WCA9IE1hdGguYXRhbjIoYVswXSAqIGFbMl0gKyBhWzFdICogYVszXSwgZGVub20pLFxyXG4gICAgICBza2V3WSA9IE1hdGguYXRhbjIoYVsxXSAqIGFbM10gKyBhWzBdICogYVsyXSwgZGVub20yKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHJvdGF0ZTogYW5nbGUgLyAoTWF0aC5QSSAvIDE4MCkgKyBcImRlZ1wiLFxyXG4gICAgICAvLyB0aGlzIGlzIHJvdGF0aW9uIGFuZ2xlIGluIGRlZ3JlZXNcclxuICAgICAgc2NhbGVYOiBzY2FsZVgsXHJcbiAgICAgIC8vIHNjYWxlWCBmYWN0b3JcclxuICAgICAgc2NhbGVZOiBzY2FsZVksXHJcbiAgICAgIC8vIHNjYWxlWSBmYWN0b3JcclxuICAgICAgc2tld1g6IChkZW5vbSA9PT0gMSA/IHNrZXdYIC8gKE1hdGguUEkgLyAxODApIDogMCkgKyBcImRlZ1wiLFxyXG4gICAgICAvLyBza2V3WCBhbmdsZSBkZWdyZWVzXHJcbiAgICAgIHNrZXdZOiAoZGVub20yID09PSAxID8gc2tld1kgLyAoTWF0aC5QSSAvIDE4MCkgOiAwKSArIFwiZGVnXCIsXHJcbiAgICAgIC8vIHNrZXdZIGFuZ2xlIGRlZ3JlZXNcclxuICAgICAgdHJhbnNsYXRlWDogYVs0XSArIFwicHhcIixcclxuICAgICAgLy8gdHJhbnNsYXRpb24gcG9pbnQgIHhcclxuICAgICAgdHJhbnNsYXRlWTogYVs1XSArIFwicHhcIiAvLyB0cmFuc2xhdGlvbiBwb2ludCAgeVxyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICByZXR1cm4gcXJEZWNvbXBvbmUodmFsdWVzKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnZXRNYXRyaXgyRDtcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWRBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../src/matrix2d.js\n");

/***/ }),

/***/ "../src/validation.js":
/*!****************************!*\
  !*** ../src/validation.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var nu = [\"cm\", \"mm\", \"in\", \"px\", \"pt\", \"pc\", \"em\", \"ex\", \"ch\", \"rem\", \"vw\", \"vh\", \"vmin\", \"vmax\", \"%\"];\nvar ru = [\"deg\", \"rad\", \"grad\", \"turn\"];\nvar _MEASUREMENT = \"measurement\";\nvar _COLOR = \"color\";\nmodule.exports = {\n  animatedAttrs: {\n    type: \"object\",\n    props: {\n      background: {\n        optional: true,\n        type: _COLOR\n      },\n      backgroundColor: {\n        optional: true,\n        type: _COLOR\n      },\n      backgroundPosition: {\n        optional: true,\n        type: \"string\"\n      },\n      backgroundSize: {\n        optional: true,\n        type: \"string\"\n      },\n      border: {\n        optional: true,\n        type: \"string\"\n      },\n      borderBottom: {\n        optional: true,\n        type: \"string\"\n      },\n      borderBottomColor: {\n        optional: true,\n        type: _COLOR\n      },\n      borderBottomLeftRadius: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      borderBottomRightRadius: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      borderBottomWidth: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      borderColor: {\n        optional: true,\n        type: _COLOR\n      },\n      borderEndEndRadius: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      borderEndStartRadius: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      borderImageOutset: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu,\n        min: 0\n      },\n      borderImageSlice: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu,\n        min: 0\n      },\n      borderImageWidth: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu,\n        min: 0\n      },\n      borderLeft: {\n        optional: true,\n        type: \"string\"\n      },\n      borderLeftColor: {\n        optional: true,\n        type: _COLOR\n      },\n      borderLeftWidth: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      borderRadius: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      borderRight: {\n        optional: true,\n        type: \"string\"\n      },\n      borderRightColor: {\n        optional: true,\n        type: _COLOR\n      },\n      borderRightWidth: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      borderStartEndRadius: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      borderStartStartRadius: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      borderTop: {\n        optional: true,\n        type: \"string\"\n      },\n      borderTopColor: {\n        optional: true,\n        type: _COLOR\n      },\n      borderTopLeftRadius: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      borderTopRightRadius: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      borderTopWidth: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      borderWidth: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      bottom: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      boxShadow: {\n        optional: true,\n        type: \"string\"\n      },\n      caretColor: {\n        optional: true,\n        type: _COLOR\n      },\n      color: {\n        optional: true,\n        type: _COLOR\n      },\n      columnCount: {\n        optional: true,\n        type: \"number\",\n        min: 0,\n        integer: true\n      },\n      columnGap: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      columnRule: {\n        optional: true,\n        type: \"string\"\n      },\n      columnRuleColor: {\n        optional: true,\n        type: _COLOR\n      },\n      columnRuleWidth: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      columns: {\n        optional: true,\n        type: \"number\",\n        min: 0,\n        integer: true\n      },\n      columnWidth: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      flex: {\n        optional: true,\n        type: \"number\",\n        min: 0,\n        integer: true\n      },\n      flexBasis: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      flexGrow: {\n        optional: true,\n        type: \"number\",\n        min: 0,\n        integer: true\n      },\n      flexShrink: {\n        optional: true,\n        type: \"number\",\n        min: 0,\n        integer: true\n      },\n      font: {\n        optional: true,\n        type: \"string\"\n      },\n      fontSize: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      fontSizeAdjust: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu,\n        min: 0\n      },\n      fontStretch: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: [\"%\"]\n      },\n      fontWeight: {\n        optional: true,\n        type: \"string\"\n      },\n      gap: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      gridColumnGap: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      gridGap: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      gridRowGap: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      gridTemplateColumns: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      gridTemplateRows: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      height: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu,\n        min: 0\n      },\n      inset: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu,\n        min: 0\n      },\n      insetBlock: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      insetBlockEnd: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      insetBlockStart: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      insetInline: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      insetInlineEnd: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      insetInlineStart: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      left: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      letterSpacing: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      lineClamp: {\n        optional: true,\n        type: \"number\",\n        min: 0,\n        integer: true\n      },\n      lineHeight: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu,\n        min: 0\n      },\n      margin: {\n        optional: true,\n        type: \"string\"\n      },\n      marginBottom: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      marginLeft: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      marginRight: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      marginTop: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      maskBorder: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu,\n        min: 0\n      },\n      maskPosition: {\n        optional: true,\n        type: \"string\"\n      },\n      maskSize: {\n        optional: true,\n        type: \"string\"\n      },\n      maxHeight: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu,\n        min: 0\n      },\n      maxWidth: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu,\n        min: 0\n      },\n      objectPosition: {\n        optional: true,\n        type: \"string\"\n      },\n      offset: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      offsetAnchor: {\n        optional: true,\n        type: \"string\"\n      },\n      offsetDistance: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      offsetPath: {\n        optional: true,\n        type: \"string\"\n      },\n      offsetPosition: {\n        optional: true,\n        type: \"string\"\n      },\n      offsetRotate: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: ru\n      },\n      opacity: {\n        optional: true,\n        type: \"number\",\n        min: 0,\n        max: 1\n      },\n      order: {\n        optional: true,\n        type: \"number\",\n        integer: true\n      },\n      outline: {\n        optional: true,\n        type: \"string\"\n      },\n      outlineColor: {\n        optional: true,\n        type: _COLOR\n      },\n      outlineOffset: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      outlineRadius: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      outlineRadiusBottomleft: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      outlineRadiusBottomright: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      outlineRadiusTopleft: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      outlineRadiusTopright: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      outlineWidth: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      padding: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      paddingBottom: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      paddingLeft: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      paddingRight: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      paddingTop: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      perspective: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      perspectiveOrigin: {\n        optional: true,\n        type: \"string\"\n      },\n      right: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      rotate: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: ru\n      },\n      rowGap: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      scale: {\n        optional: true,\n        type: \"number\",\n        min: 0\n      },\n      scrollbarColor: {\n        optional: true,\n        type: _COLOR\n      },\n      scrollMargin: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      scrollMarginBlock: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      scrollMarginBlockEnd: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      scrollMarginBlockStart: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      scrollMarginBottom: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      scrollMarginInline: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      scrollMarginInlineEnd: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      scrollMarginInlineStart: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      scrollMarginLeft: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      scrollMarginRight: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      scrollMarginTop: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      scrollPadding: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      scrollPaddingBlock: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      scrollPaddingBlockEnd: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      scrollPaddingBlockStart: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      scrollPaddingBottom: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      scrollPaddingInline: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      scrollPaddingInlineEnd: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      scrollPaddingInlineStart: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      scrollPaddingLeft: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      scrollPaddingRight: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      scrollPaddingTop: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      scrollSnapCoordinate: {\n        optional: true,\n        type: \"string\"\n      },\n      scrollSnapDestination: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      shapeImageThreshold: {\n        optional: true,\n        type: \"string\"\n      },\n      shapeMargin: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      shapeOutside: {\n        optional: true,\n        type: \"string\"\n      },\n      tabSize: {\n        optional: true,\n        type: \"string\"\n      },\n      textDecoration: {\n        optional: true,\n        type: \"string\"\n      },\n      textDecorationColor: {\n        optional: true,\n        type: _COLOR\n      },\n      textDecorationThickness: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      textEmphasis: {\n        optional: true,\n        type: \"string\"\n      },\n      textEmphasisColor: {\n        optional: true,\n        type: _COLOR\n      },\n      textFillColor: {\n        optional: true,\n        type: _COLOR\n      },\n      textIndent: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      textShadow: {\n        optional: true,\n        type: \"string\"\n      },\n      textStroke: {\n        optional: true,\n        type: \"string\"\n      },\n      textStrokeColor: {\n        optional: true,\n        type: _COLOR\n      },\n      textUnderlineOffset: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      top: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      transform: {\n        optional: true,\n        type: \"object\",\n        props: {\n          translateX: {\n            type: _MEASUREMENT,\n            units: nu,\n            optional: true\n          },\n          translateY: {\n            type: _MEASUREMENT,\n            units: nu,\n            optional: true\n          },\n          translateZ: {\n            type: _MEASUREMENT,\n            units: nu,\n            optional: true\n          },\n          rotate: {\n            type: _MEASUREMENT,\n            units: ru,\n            optional: true\n          },\n          rotateX: {\n            type: _MEASUREMENT,\n            units: ru,\n            optional: true\n          },\n          rotateY: {\n            type: _MEASUREMENT,\n            units: ru,\n            optional: true\n          },\n          rotateZ: {\n            type: _MEASUREMENT,\n            units: ru,\n            optional: true\n          },\n          scale: {\n            type: \"number\",\n            min: 0,\n            optional: true\n          },\n          scaleX: {\n            type: \"number\",\n            min: 0,\n            optional: true\n          },\n          scaleY: {\n            type: \"number\",\n            min: 0,\n            optional: true\n          },\n          scaleZ: {\n            type: \"number\",\n            min: 0,\n            optional: true\n          },\n          skewX: {\n            type: _MEASUREMENT,\n            units: ru,\n            optional: true\n          },\n          skewY: {\n            type: _MEASUREMENT,\n            units: ru,\n            optional: true\n          },\n          perspective: {\n            type: _MEASUREMENT,\n            units: nu,\n            optional: true\n          }\n        }\n      },\n      transformOrigin: {\n        optional: true,\n        type: \"string\"\n      },\n      verticalAlign: {\n        optional: true,\n        type: \"string\"\n      },\n      visibility: {\n        optional: true,\n        type: \"string\"\n      },\n      width: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      wordSpacing: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: nu\n      },\n      zIndex: {\n        optional: true,\n        type: \"number\",\n        integer: true\n      },\n      zoom: {\n        optional: true,\n        type: _MEASUREMENT,\n        units: [\"%\"],\n        min: 0\n      }\n    }\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc3JjL3ZhbGlkYXRpb24uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL3ZhbGlkYXRpb24uanM/NTg5YSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBudSA9IFtcbiAgXCJjbVwiLFxuICBcIm1tXCIsXG4gIFwiaW5cIixcbiAgXCJweFwiLFxuICBcInB0XCIsXG4gIFwicGNcIixcbiAgXCJlbVwiLFxuICBcImV4XCIsXG4gIFwiY2hcIixcbiAgXCJyZW1cIixcbiAgXCJ2d1wiLFxuICBcInZoXCIsXG4gIFwidm1pblwiLFxuICBcInZtYXhcIixcbiAgXCIlXCJcbl07XG5jb25zdCBydSA9IFtcImRlZ1wiLCBcInJhZFwiLCBcImdyYWRcIiwgXCJ0dXJuXCJdO1xuY29uc3QgX01FQVNVUkVNRU5UID0gXCJtZWFzdXJlbWVudFwiO1xuY29uc3QgX0NPTE9SID0gXCJjb2xvclwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYW5pbWF0ZWRBdHRyczoge1xuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgcHJvcHM6IHtcbiAgICAgIGJhY2tncm91bmQ6IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IF9DT0xPUlxuICAgICAgfSxcbiAgICAgIGJhY2tncm91bmRDb2xvcjoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX0NPTE9SXG4gICAgICB9LFxuICAgICAgYmFja2dyb3VuZFBvc2l0aW9uOiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICB9LFxuICAgICAgYmFja2dyb3VuZFNpemU6IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgIH0sXG4gICAgICBib3JkZXI6IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgIH0sXG4gICAgICBib3JkZXJCb3R0b206IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgIH0sXG4gICAgICBib3JkZXJCb3R0b21Db2xvcjoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX0NPTE9SXG4gICAgICB9LFxuICAgICAgYm9yZGVyQm90dG9tTGVmdFJhZGl1czoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX01FQVNVUkVNRU5ULFxuICAgICAgICB1bml0czogbnVcbiAgICAgIH0sXG4gICAgICBib3JkZXJCb3R0b21SaWdodFJhZGl1czoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX01FQVNVUkVNRU5ULFxuICAgICAgICB1bml0czogbnVcbiAgICAgIH0sXG4gICAgICBib3JkZXJCb3R0b21XaWR0aDoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX01FQVNVUkVNRU5ULFxuICAgICAgICB1bml0czogbnVcbiAgICAgIH0sXG4gICAgICBib3JkZXJDb2xvcjoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX0NPTE9SXG4gICAgICB9LFxuICAgICAgYm9yZGVyRW5kRW5kUmFkaXVzOiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBfTUVBU1VSRU1FTlQsXG4gICAgICAgIHVuaXRzOiBudVxuICAgICAgfSxcbiAgICAgIGJvcmRlckVuZFN0YXJ0UmFkaXVzOiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBfTUVBU1VSRU1FTlQsXG4gICAgICAgIHVuaXRzOiBudVxuICAgICAgfSxcbiAgICAgIGJvcmRlckltYWdlT3V0c2V0OiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBfTUVBU1VSRU1FTlQsXG4gICAgICAgIHVuaXRzOiBudSxcbiAgICAgICAgbWluOiAwXG4gICAgICB9LFxuICAgICAgYm9yZGVySW1hZ2VTbGljZToge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX01FQVNVUkVNRU5ULFxuICAgICAgICB1bml0czogbnUsXG4gICAgICAgIG1pbjogMFxuICAgICAgfSxcbiAgICAgIGJvcmRlckltYWdlV2lkdGg6IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IF9NRUFTVVJFTUVOVCxcbiAgICAgICAgdW5pdHM6IG51LFxuICAgICAgICBtaW46IDBcbiAgICAgIH0sXG4gICAgICBib3JkZXJMZWZ0OiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICB9LFxuICAgICAgYm9yZGVyTGVmdENvbG9yOiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBfQ09MT1JcbiAgICAgIH0sXG4gICAgICBib3JkZXJMZWZ0V2lkdGg6IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IF9NRUFTVVJFTUVOVCxcbiAgICAgICAgdW5pdHM6IG51XG4gICAgICB9LFxuICAgICAgYm9yZGVyUmFkaXVzOiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBfTUVBU1VSRU1FTlQsXG4gICAgICAgIHVuaXRzOiBudVxuICAgICAgfSxcbiAgICAgIGJvcmRlclJpZ2h0OiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICB9LFxuICAgICAgYm9yZGVyUmlnaHRDb2xvcjoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX0NPTE9SXG4gICAgICB9LFxuICAgICAgYm9yZGVyUmlnaHRXaWR0aDoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX01FQVNVUkVNRU5ULFxuICAgICAgICB1bml0czogbnVcbiAgICAgIH0sXG4gICAgICBib3JkZXJTdGFydEVuZFJhZGl1czoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX01FQVNVUkVNRU5ULFxuICAgICAgICB1bml0czogbnVcbiAgICAgIH0sXG4gICAgICBib3JkZXJTdGFydFN0YXJ0UmFkaXVzOiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBfTUVBU1VSRU1FTlQsXG4gICAgICAgIHVuaXRzOiBudVxuICAgICAgfSxcbiAgICAgIGJvcmRlclRvcDoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgICAgfSxcbiAgICAgIGJvcmRlclRvcENvbG9yOiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBfQ09MT1JcbiAgICAgIH0sXG4gICAgICBib3JkZXJUb3BMZWZ0UmFkaXVzOiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBfTUVBU1VSRU1FTlQsXG4gICAgICAgIHVuaXRzOiBudVxuICAgICAgfSxcbiAgICAgIGJvcmRlclRvcFJpZ2h0UmFkaXVzOiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBfTUVBU1VSRU1FTlQsXG4gICAgICAgIHVuaXRzOiBudVxuICAgICAgfSxcbiAgICAgIGJvcmRlclRvcFdpZHRoOiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBfTUVBU1VSRU1FTlQsXG4gICAgICAgIHVuaXRzOiBudVxuICAgICAgfSxcbiAgICAgIGJvcmRlcldpZHRoOiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBfTUVBU1VSRU1FTlQsXG4gICAgICAgIHVuaXRzOiBudVxuICAgICAgfSxcbiAgICAgIGJvdHRvbToge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX01FQVNVUkVNRU5ULFxuICAgICAgICB1bml0czogbnVcbiAgICAgIH0sXG4gICAgICBib3hTaGFkb3c6IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgIH0sXG4gICAgICBjYXJldENvbG9yOiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBfQ09MT1JcbiAgICAgIH0sXG4gICAgICBjb2xvcjoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX0NPTE9SXG4gICAgICB9LFxuICAgICAgY29sdW1uQ291bnQ6IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgaW50ZWdlcjogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGNvbHVtbkdhcDoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX01FQVNVUkVNRU5ULFxuICAgICAgICB1bml0czogbnVcbiAgICAgIH0sXG4gICAgICBjb2x1bW5SdWxlOiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICB9LFxuICAgICAgY29sdW1uUnVsZUNvbG9yOiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBfQ09MT1JcbiAgICAgIH0sXG4gICAgICBjb2x1bW5SdWxlV2lkdGg6IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IF9NRUFTVVJFTUVOVCxcbiAgICAgICAgdW5pdHM6IG51XG4gICAgICB9LFxuICAgICAgY29sdW1uczoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgbWluOiAwLFxuICAgICAgICBpbnRlZ2VyOiB0cnVlXG4gICAgICB9LFxuICAgICAgY29sdW1uV2lkdGg6IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IF9NRUFTVVJFTUVOVCxcbiAgICAgICAgdW5pdHM6IG51XG4gICAgICB9LFxuICAgICAgZmxleDoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgbWluOiAwLFxuICAgICAgICBpbnRlZ2VyOiB0cnVlXG4gICAgICB9LFxuICAgICAgZmxleEJhc2lzOiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBfTUVBU1VSRU1FTlQsXG4gICAgICAgIHVuaXRzOiBudVxuICAgICAgfSxcbiAgICAgIGZsZXhHcm93OiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICBtaW46IDAsXG4gICAgICAgIGludGVnZXI6IHRydWVcbiAgICAgIH0sXG4gICAgICBmbGV4U2hyaW5rOiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICBtaW46IDAsXG4gICAgICAgIGludGVnZXI6IHRydWVcbiAgICAgIH0sXG4gICAgICBmb250OiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICB9LFxuICAgICAgZm9udFNpemU6IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IF9NRUFTVVJFTUVOVCxcbiAgICAgICAgdW5pdHM6IG51XG4gICAgICB9LFxuICAgICAgZm9udFNpemVBZGp1c3Q6IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IF9NRUFTVVJFTUVOVCxcbiAgICAgICAgdW5pdHM6IG51LFxuICAgICAgICBtaW46IDBcbiAgICAgIH0sXG4gICAgICBmb250U3RyZXRjaDoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX01FQVNVUkVNRU5ULFxuICAgICAgICB1bml0czogW1wiJVwiXVxuICAgICAgfSxcbiAgICAgIGZvbnRXZWlnaHQ6IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgIH0sXG4gICAgICBnYXA6IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IF9NRUFTVVJFTUVOVCxcbiAgICAgICAgdW5pdHM6IG51XG4gICAgICB9LFxuICAgICAgZ3JpZENvbHVtbkdhcDoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX01FQVNVUkVNRU5ULFxuICAgICAgICB1bml0czogbnVcbiAgICAgIH0sXG4gICAgICBncmlkR2FwOiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBfTUVBU1VSRU1FTlQsXG4gICAgICAgIHVuaXRzOiBudVxuICAgICAgfSxcbiAgICAgIGdyaWRSb3dHYXA6IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IF9NRUFTVVJFTUVOVCxcbiAgICAgICAgdW5pdHM6IG51XG4gICAgICB9LFxuICAgICAgZ3JpZFRlbXBsYXRlQ29sdW1uczoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX01FQVNVUkVNRU5ULFxuICAgICAgICB1bml0czogbnVcbiAgICAgIH0sXG4gICAgICBncmlkVGVtcGxhdGVSb3dzOiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBfTUVBU1VSRU1FTlQsXG4gICAgICAgIHVuaXRzOiBudVxuICAgICAgfSxcbiAgICAgIGhlaWdodDoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX01FQVNVUkVNRU5ULFxuICAgICAgICB1bml0czogbnUsXG4gICAgICAgIG1pbjogMFxuICAgICAgfSxcbiAgICAgIGluc2V0OiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBfTUVBU1VSRU1FTlQsXG4gICAgICAgIHVuaXRzOiBudSxcbiAgICAgICAgbWluOiAwXG4gICAgICB9LFxuICAgICAgaW5zZXRCbG9jazoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX01FQVNVUkVNRU5ULFxuICAgICAgICB1bml0czogbnVcbiAgICAgIH0sXG4gICAgICBpbnNldEJsb2NrRW5kOiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBfTUVBU1VSRU1FTlQsXG4gICAgICAgIHVuaXRzOiBudVxuICAgICAgfSxcbiAgICAgIGluc2V0QmxvY2tTdGFydDoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX01FQVNVUkVNRU5ULFxuICAgICAgICB1bml0czogbnVcbiAgICAgIH0sXG4gICAgICBpbnNldElubGluZToge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX01FQVNVUkVNRU5ULFxuICAgICAgICB1bml0czogbnVcbiAgICAgIH0sXG4gICAgICBpbnNldElubGluZUVuZDoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX01FQVNVUkVNRU5ULFxuICAgICAgICB1bml0czogbnVcbiAgICAgIH0sXG4gICAgICBpbnNldElubGluZVN0YXJ0OiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBfTUVBU1VSRU1FTlQsXG4gICAgICAgIHVuaXRzOiBudVxuICAgICAgfSxcbiAgICAgIGxlZnQ6IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IF9NRUFTVVJFTUVOVCxcbiAgICAgICAgdW5pdHM6IG51XG4gICAgICB9LFxuICAgICAgbGV0dGVyU3BhY2luZzoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX01FQVNVUkVNRU5ULFxuICAgICAgICB1bml0czogbnVcbiAgICAgIH0sXG4gICAgICBsaW5lQ2xhbXA6IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgaW50ZWdlcjogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGxpbmVIZWlnaHQ6IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IF9NRUFTVVJFTUVOVCxcbiAgICAgICAgdW5pdHM6IG51LFxuICAgICAgICBtaW46IDBcbiAgICAgIH0sXG4gICAgICBtYXJnaW46IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgIH0sXG4gICAgICBtYXJnaW5Cb3R0b206IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IF9NRUFTVVJFTUVOVCxcbiAgICAgICAgdW5pdHM6IG51XG4gICAgICB9LFxuICAgICAgbWFyZ2luTGVmdDoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX01FQVNVUkVNRU5ULFxuICAgICAgICB1bml0czogbnVcbiAgICAgIH0sXG4gICAgICBtYXJnaW5SaWdodDoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX01FQVNVUkVNRU5ULFxuICAgICAgICB1bml0czogbnVcbiAgICAgIH0sXG4gICAgICBtYXJnaW5Ub3A6IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IF9NRUFTVVJFTUVOVCxcbiAgICAgICAgdW5pdHM6IG51XG4gICAgICB9LFxuICAgICAgbWFza0JvcmRlcjoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX01FQVNVUkVNRU5ULFxuICAgICAgICB1bml0czogbnUsXG4gICAgICAgIG1pbjogMFxuICAgICAgfSxcbiAgICAgIG1hc2tQb3NpdGlvbjoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgICAgfSxcbiAgICAgIG1hc2tTaXplOiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICB9LFxuICAgICAgbWF4SGVpZ2h0OiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBfTUVBU1VSRU1FTlQsXG4gICAgICAgIHVuaXRzOiBudSxcbiAgICAgICAgbWluOiAwXG4gICAgICB9LFxuICAgICAgbWF4V2lkdGg6IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IF9NRUFTVVJFTUVOVCxcbiAgICAgICAgdW5pdHM6IG51LFxuICAgICAgICBtaW46IDBcbiAgICAgIH0sXG4gICAgICBvYmplY3RQb3NpdGlvbjoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgICAgfSxcbiAgICAgIG9mZnNldDoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX01FQVNVUkVNRU5ULFxuICAgICAgICB1bml0czogbnVcbiAgICAgIH0sXG4gICAgICBvZmZzZXRBbmNob3I6IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgIH0sXG4gICAgICBvZmZzZXREaXN0YW5jZToge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX01FQVNVUkVNRU5ULFxuICAgICAgICB1bml0czogbnVcbiAgICAgIH0sXG4gICAgICBvZmZzZXRQYXRoOiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICB9LFxuICAgICAgb2Zmc2V0UG9zaXRpb246IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgIH0sXG4gICAgICBvZmZzZXRSb3RhdGU6IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IF9NRUFTVVJFTUVOVCxcbiAgICAgICAgdW5pdHM6IHJ1XG4gICAgICB9LFxuICAgICAgb3BhY2l0eToge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgbWluOiAwLFxuICAgICAgICBtYXg6IDFcbiAgICAgIH0sXG4gICAgICBvcmRlcjoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgaW50ZWdlcjogdHJ1ZVxuICAgICAgfSxcbiAgICAgIG91dGxpbmU6IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgIH0sXG4gICAgICBvdXRsaW5lQ29sb3I6IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IF9DT0xPUlxuICAgICAgfSxcbiAgICAgIG91dGxpbmVPZmZzZXQ6IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IF9NRUFTVVJFTUVOVCxcbiAgICAgICAgdW5pdHM6IG51XG4gICAgICB9LFxuICAgICAgb3V0bGluZVJhZGl1czoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX01FQVNVUkVNRU5ULFxuICAgICAgICB1bml0czogbnVcbiAgICAgIH0sXG4gICAgICBvdXRsaW5lUmFkaXVzQm90dG9tbGVmdDoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX01FQVNVUkVNRU5ULFxuICAgICAgICB1bml0czogbnVcbiAgICAgIH0sXG4gICAgICBvdXRsaW5lUmFkaXVzQm90dG9tcmlnaHQ6IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IF9NRUFTVVJFTUVOVCxcbiAgICAgICAgdW5pdHM6IG51XG4gICAgICB9LFxuICAgICAgb3V0bGluZVJhZGl1c1RvcGxlZnQ6IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IF9NRUFTVVJFTUVOVCxcbiAgICAgICAgdW5pdHM6IG51XG4gICAgICB9LFxuICAgICAgb3V0bGluZVJhZGl1c1RvcHJpZ2h0OiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBfTUVBU1VSRU1FTlQsXG4gICAgICAgIHVuaXRzOiBudVxuICAgICAgfSxcbiAgICAgIG91dGxpbmVXaWR0aDoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX01FQVNVUkVNRU5ULFxuICAgICAgICB1bml0czogbnVcbiAgICAgIH0sXG4gICAgICBwYWRkaW5nOiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBfTUVBU1VSRU1FTlQsXG4gICAgICAgIHVuaXRzOiBudVxuICAgICAgfSxcbiAgICAgIHBhZGRpbmdCb3R0b206IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IF9NRUFTVVJFTUVOVCxcbiAgICAgICAgdW5pdHM6IG51XG4gICAgICB9LFxuICAgICAgcGFkZGluZ0xlZnQ6IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IF9NRUFTVVJFTUVOVCxcbiAgICAgICAgdW5pdHM6IG51XG4gICAgICB9LFxuICAgICAgcGFkZGluZ1JpZ2h0OiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBfTUVBU1VSRU1FTlQsXG4gICAgICAgIHVuaXRzOiBudVxuICAgICAgfSxcbiAgICAgIHBhZGRpbmdUb3A6IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IF9NRUFTVVJFTUVOVCxcbiAgICAgICAgdW5pdHM6IG51XG4gICAgICB9LFxuICAgICAgcGVyc3BlY3RpdmU6IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IF9NRUFTVVJFTUVOVCxcbiAgICAgICAgdW5pdHM6IG51XG4gICAgICB9LFxuICAgICAgcGVyc3BlY3RpdmVPcmlnaW46IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgIH0sXG4gICAgICByaWdodDoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX01FQVNVUkVNRU5ULFxuICAgICAgICB1bml0czogbnVcbiAgICAgIH0sXG4gICAgICByb3RhdGU6IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IF9NRUFTVVJFTUVOVCxcbiAgICAgICAgdW5pdHM6IHJ1XG4gICAgICB9LFxuICAgICAgcm93R2FwOiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBfTUVBU1VSRU1FTlQsXG4gICAgICAgIHVuaXRzOiBudVxuICAgICAgfSxcbiAgICAgIHNjYWxlOiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICBtaW46IDBcbiAgICAgIH0sXG4gICAgICBzY3JvbGxiYXJDb2xvcjoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX0NPTE9SXG4gICAgICB9LFxuXG4gICAgICBzY3JvbGxNYXJnaW46IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IF9NRUFTVVJFTUVOVCxcbiAgICAgICAgdW5pdHM6IG51XG4gICAgICB9LFxuICAgICAgc2Nyb2xsTWFyZ2luQmxvY2s6IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IF9NRUFTVVJFTUVOVCxcbiAgICAgICAgdW5pdHM6IG51XG4gICAgICB9LFxuICAgICAgc2Nyb2xsTWFyZ2luQmxvY2tFbmQ6IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IF9NRUFTVVJFTUVOVCxcbiAgICAgICAgdW5pdHM6IG51XG4gICAgICB9LFxuICAgICAgc2Nyb2xsTWFyZ2luQmxvY2tTdGFydDoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX01FQVNVUkVNRU5ULFxuICAgICAgICB1bml0czogbnVcbiAgICAgIH0sXG4gICAgICBzY3JvbGxNYXJnaW5Cb3R0b206IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IF9NRUFTVVJFTUVOVCxcbiAgICAgICAgdW5pdHM6IG51XG4gICAgICB9LFxuICAgICAgc2Nyb2xsTWFyZ2luSW5saW5lOiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBfTUVBU1VSRU1FTlQsXG4gICAgICAgIHVuaXRzOiBudVxuICAgICAgfSxcbiAgICAgIHNjcm9sbE1hcmdpbklubGluZUVuZDoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX01FQVNVUkVNRU5ULFxuICAgICAgICB1bml0czogbnVcbiAgICAgIH0sXG4gICAgICBzY3JvbGxNYXJnaW5JbmxpbmVTdGFydDoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX01FQVNVUkVNRU5ULFxuICAgICAgICB1bml0czogbnVcbiAgICAgIH0sXG4gICAgICBzY3JvbGxNYXJnaW5MZWZ0OiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBfTUVBU1VSRU1FTlQsXG4gICAgICAgIHVuaXRzOiBudVxuICAgICAgfSxcbiAgICAgIHNjcm9sbE1hcmdpblJpZ2h0OiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBfTUVBU1VSRU1FTlQsXG4gICAgICAgIHVuaXRzOiBudVxuICAgICAgfSxcbiAgICAgIHNjcm9sbE1hcmdpblRvcDoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX01FQVNVUkVNRU5ULFxuICAgICAgICB1bml0czogbnVcbiAgICAgIH0sXG4gICAgICBzY3JvbGxQYWRkaW5nOiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBfTUVBU1VSRU1FTlQsXG4gICAgICAgIHVuaXRzOiBudVxuICAgICAgfSxcbiAgICAgIHNjcm9sbFBhZGRpbmdCbG9jazoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX01FQVNVUkVNRU5ULFxuICAgICAgICB1bml0czogbnVcbiAgICAgIH0sXG4gICAgICBzY3JvbGxQYWRkaW5nQmxvY2tFbmQ6IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IF9NRUFTVVJFTUVOVCxcbiAgICAgICAgdW5pdHM6IG51XG4gICAgICB9LFxuICAgICAgc2Nyb2xsUGFkZGluZ0Jsb2NrU3RhcnQ6IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IF9NRUFTVVJFTUVOVCxcbiAgICAgICAgdW5pdHM6IG51XG4gICAgICB9LFxuICAgICAgc2Nyb2xsUGFkZGluZ0JvdHRvbToge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX01FQVNVUkVNRU5ULFxuICAgICAgICB1bml0czogbnVcbiAgICAgIH0sXG4gICAgICBzY3JvbGxQYWRkaW5nSW5saW5lOiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBfTUVBU1VSRU1FTlQsXG4gICAgICAgIHVuaXRzOiBudVxuICAgICAgfSxcbiAgICAgIHNjcm9sbFBhZGRpbmdJbmxpbmVFbmQ6IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IF9NRUFTVVJFTUVOVCxcbiAgICAgICAgdW5pdHM6IG51XG4gICAgICB9LFxuICAgICAgc2Nyb2xsUGFkZGluZ0lubGluZVN0YXJ0OiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBfTUVBU1VSRU1FTlQsXG4gICAgICAgIHVuaXRzOiBudVxuICAgICAgfSxcbiAgICAgIHNjcm9sbFBhZGRpbmdMZWZ0OiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBfTUVBU1VSRU1FTlQsXG4gICAgICAgIHVuaXRzOiBudVxuICAgICAgfSxcbiAgICAgIHNjcm9sbFBhZGRpbmdSaWdodDoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX01FQVNVUkVNRU5ULFxuICAgICAgICB1bml0czogbnVcbiAgICAgIH0sXG4gICAgICBzY3JvbGxQYWRkaW5nVG9wOiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBfTUVBU1VSRU1FTlQsXG4gICAgICAgIHVuaXRzOiBudVxuICAgICAgfSxcbiAgICAgIHNjcm9sbFNuYXBDb29yZGluYXRlOiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICB9LFxuICAgICAgc2Nyb2xsU25hcERlc3RpbmF0aW9uOiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBfTUVBU1VSRU1FTlQsXG4gICAgICAgIHVuaXRzOiBudVxuICAgICAgfSxcbiAgICAgIHNoYXBlSW1hZ2VUaHJlc2hvbGQ6IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgIH0sXG4gICAgICBzaGFwZU1hcmdpbjoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX01FQVNVUkVNRU5ULFxuICAgICAgICB1bml0czogbnVcbiAgICAgIH0sXG4gICAgICBzaGFwZU91dHNpZGU6IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgIH0sXG4gICAgICB0YWJTaXplOiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICB9LFxuICAgICAgdGV4dERlY29yYXRpb246IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgIH0sXG4gICAgICB0ZXh0RGVjb3JhdGlvbkNvbG9yOiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBfQ09MT1JcbiAgICAgIH0sXG4gICAgICB0ZXh0RGVjb3JhdGlvblRoaWNrbmVzczoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX01FQVNVUkVNRU5ULFxuICAgICAgICB1bml0czogbnVcbiAgICAgIH0sXG4gICAgICB0ZXh0RW1waGFzaXM6IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgIH0sXG4gICAgICB0ZXh0RW1waGFzaXNDb2xvcjoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX0NPTE9SXG4gICAgICB9LFxuICAgICAgdGV4dEZpbGxDb2xvcjoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX0NPTE9SXG4gICAgICB9LFxuICAgICAgdGV4dEluZGVudDoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX01FQVNVUkVNRU5ULFxuICAgICAgICB1bml0czogbnVcbiAgICAgIH0sXG4gICAgICB0ZXh0U2hhZG93OiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICB9LFxuICAgICAgdGV4dFN0cm9rZToge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgICAgfSxcbiAgICAgIHRleHRTdHJva2VDb2xvcjoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX0NPTE9SXG4gICAgICB9LFxuICAgICAgdGV4dFVuZGVybGluZU9mZnNldDoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX01FQVNVUkVNRU5ULFxuICAgICAgICB1bml0czogbnVcbiAgICAgIH0sXG4gICAgICB0b3A6IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IF9NRUFTVVJFTUVOVCxcbiAgICAgICAgdW5pdHM6IG51XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtOiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIHRyYW5zbGF0ZVg6IHsgdHlwZTogX01FQVNVUkVNRU5ULCB1bml0czogbnUsIG9wdGlvbmFsOiB0cnVlIH0sXG4gICAgICAgICAgdHJhbnNsYXRlWTogeyB0eXBlOiBfTUVBU1VSRU1FTlQsIHVuaXRzOiBudSwgb3B0aW9uYWw6IHRydWUgfSxcbiAgICAgICAgICB0cmFuc2xhdGVaOiB7IHR5cGU6IF9NRUFTVVJFTUVOVCwgdW5pdHM6IG51LCBvcHRpb25hbDogdHJ1ZSB9LFxuICAgICAgICAgIHJvdGF0ZTogeyB0eXBlOiBfTUVBU1VSRU1FTlQsIHVuaXRzOiBydSwgb3B0aW9uYWw6IHRydWUgfSxcbiAgICAgICAgICByb3RhdGVYOiB7IHR5cGU6IF9NRUFTVVJFTUVOVCwgdW5pdHM6IHJ1LCBvcHRpb25hbDogdHJ1ZSB9LFxuICAgICAgICAgIHJvdGF0ZVk6IHsgdHlwZTogX01FQVNVUkVNRU5ULCB1bml0czogcnUsIG9wdGlvbmFsOiB0cnVlIH0sXG4gICAgICAgICAgcm90YXRlWjogeyB0eXBlOiBfTUVBU1VSRU1FTlQsIHVuaXRzOiBydSwgb3B0aW9uYWw6IHRydWUgfSxcbiAgICAgICAgICBzY2FsZTogeyB0eXBlOiBcIm51bWJlclwiLCBtaW46IDAsIG9wdGlvbmFsOiB0cnVlIH0sXG4gICAgICAgICAgc2NhbGVYOiB7IHR5cGU6IFwibnVtYmVyXCIsIG1pbjogMCwgb3B0aW9uYWw6IHRydWUgfSxcbiAgICAgICAgICBzY2FsZVk6IHsgdHlwZTogXCJudW1iZXJcIiwgbWluOiAwLCBvcHRpb25hbDogdHJ1ZSB9LFxuICAgICAgICAgIHNjYWxlWjogeyB0eXBlOiBcIm51bWJlclwiLCBtaW46IDAsIG9wdGlvbmFsOiB0cnVlIH0sXG4gICAgICAgICAgc2tld1g6IHsgdHlwZTogX01FQVNVUkVNRU5ULCB1bml0czogcnUsIG9wdGlvbmFsOiB0cnVlIH0sXG4gICAgICAgICAgc2tld1k6IHsgdHlwZTogX01FQVNVUkVNRU5ULCB1bml0czogcnUsIG9wdGlvbmFsOiB0cnVlIH0sXG4gICAgICAgICAgcGVyc3BlY3RpdmU6IHsgdHlwZTogX01FQVNVUkVNRU5ULCB1bml0czogbnUsIG9wdGlvbmFsOiB0cnVlIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybU9yaWdpbjoge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgICAgfSxcbiAgICAgIHZlcnRpY2FsQWxpZ246IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgIH0sXG4gICAgICB2aXNpYmlsaXR5OiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICB9LFxuICAgICAgd2lkdGg6IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IF9NRUFTVVJFTUVOVCxcbiAgICAgICAgdW5pdHM6IG51XG4gICAgICB9LFxuICAgICAgd29yZFNwYWNpbmc6IHtcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIHR5cGU6IF9NRUFTVVJFTUVOVCxcbiAgICAgICAgdW5pdHM6IG51XG4gICAgICB9LFxuICAgICAgekluZGV4OiB7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICBpbnRlZ2VyOiB0cnVlXG4gICAgICB9LFxuICAgICAgem9vbToge1xuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdHlwZTogX01FQVNVUkVNRU5ULFxuICAgICAgICB1bml0czogW1wiJVwiXSxcbiAgICAgICAgbWluOiAwXG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQWlCQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWRBO0FBSEE7QUFvQkE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBL3ZCQTtBQUZBO0FBREEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../src/validation.js\n");

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var MotorCortex = __webpack_require__(/*! @kissmybutton/motorcortex/ */ \"../node_modules/@kissmybutton/motorcortex/dist/motorcortex.umd.js\");\n\nvar Player = __webpack_require__(/*! @kissmybutton/motorcortex-player */ \"../node_modules/@kissmybutton/motorcortex-player/dist/Player.js\"); // const Player = require(\"../../teo-motorcortex-player/src/Player\");\n\n\nvar AnimeDefinition = __webpack_require__(/*! ../src/main */ \"../src/main.js\");\n\nvar Anime = MotorCortex.loadPlugin(AnimeDefinition);\nvar css = \"\\n\\n.wrapper {\\n    background-color: #f7f7f7;\\n    height:100%;\\n    width:100%;\\n    margin:0px;\\n    display: flex;\\n    flex-direction: column;\\n    align-items: center;\\n  }\\n  .container {\\n    \\n    width: 100%;\\n    display: flex;\\n    flex-direction: column;\\n    justify-content: center;\\n    align-items: center;\\n    \\n    overflow: hidden;\\n    color: #252056;\\n    font-family: 'Montserrat', sans-serif;\\n  }\\n  .title {\\n    font-size: 50px;\\n    font-weight: bold;\\n  }\\n  .subTitle {\\n    font-size: 30px;\\n  }\\n  .text{\\n    font-size: 24px;\\n    font-weight: 100;\\n  }\\n  .boxWidth,.boxColor,.boxRotate,.boxMove,.boxBorder {\\n    background: #252056;\\n    width: 250px;\\n    height: 30px;\\n    position: relative;\\n    margin-left: 30px\\n  }\\n  .boxBorder{\\n    width: 30px;\\n    border-radius: 0%;\\n  }\\n  .boxMove{\\n    left:0;\\n    width: 30px;\\n  }\\n\\n  .boxWidth{\\n    width: 30px;\\n  }\\n\\n  .boxColor{\\n    background: rgb(37, 32, 86);\\n  }\\n\\n  .boxRotate{\\n    width:30px;\\n    transform: rotate(0deg);\\n  }\\n\\n  .demo{\\n    margin-top: 5%;\\n    display: flex;\\n    flex-direction: column;\\n    justify-content: center;\\n    align-items: center;\\n    width: 60%;\\n    position: relative;\\n  }\\n  .demoWidth,.demoColor,.demoRotate,.demoMove,.demoBorder{\\n    display: flex;\\n    position: relative;\\n    width: 100%;\\n    justify-content: start;\\n  }\\n  .cls-1{\\n    stroke-dasharray: 6000;\\n    stroke-dashoffset: 6000;\\n  }\\n\";\nvar html = \"\\n<div class=\\\"wrapper\\\">\\n<div class=\\\"container\\\">\\n  <div class=\\\"title\\\">MotorCortex</div>\\n  <div class=\\\"subTitle\\\">Anime plugin</div>\\n  <div class=\\\"text\\\">Demo:</div>\\n  <div class=\\\"demo\\\">\\n    <div class=\\\"demoWidth\\\">\\n      <div class=\\\"text\\\">width :</div>\\n      <div class=\\\"boxWidth\\\"></div>\\n    </div>\\n    <div class=\\\"demoColor\\\">\\n      <div class=\\\"text\\\">background color :</div>\\n      <div class=\\\"boxColor\\\"></div>\\n    </div>\\n    <div class=\\\"demoRotate\\\">\\n      <div class=\\\"text\\\">Rotate :</div>\\n      <div class=\\\"boxRotate\\\"></div>\\n    </div>\\n    <div class=\\\"demoMove\\\">\\n      <div class=\\\"text\\\">Move with easings:</div>\\n      <div class=\\\"boxMove\\\"> </div>\\n    </div>\\n    <div class=\\\"demoBorder\\\">\\n      <div class=\\\"text\\\">Border :</div>\\n      <div class=\\\"boxBorder\\\"> </div>\\n    </div>\\n  </div>\\n \\n  <div class=\\\"subTitle svgText\\\">svg </div>\\n  <div class=\\\"svgBorder\\\"> <svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"300px\\\" viewBox=\\\"0 0 495 464.3\\\"><defs><style>.cls-1{fill:none;stroke:#252056;stroke-miterlimit:10;stroke-width:3px;}.cls-2{fill:none;}</style></defs><title>mc2</title><g id=\\\"Layer_1\\\" data-name=\\\"Layer 1\\\"><path class=\\\"cls-1\\\" d=\\\"M86,368.6V128.8L195.3,253.4,86,368.6ZM496,18.1H419.8L246.4,197.3,86.3,18.1H4V479.3H80.5L299,250.1l119.6-125V370.5l-71.5-74.4a3.9,3.9,0,0,0-5.4-.1l-.2.2L293.2,348,418.6,479.3H496Z\\\" transform=\\\"translate(-2.5 -16.6)\\\"/></g><g id=\\\"Layer_2\\\" data-name=\\\"Layer 2\\\"><path class=\\\"cls-2\\\" d=\\\"M86,368.6V128.8L195.3,253.4,86,368.6ZM496,18.1H419.8L246.4,197.3,86.3,18.1H4V479.3H80.5L299,250.1l119.6-125V370.5l-71.5-74.4a3.9,3.9,0,0,0-5.4-.1l-.2.2L293.2,348,418.6,479.3H496Z\\\" transform=\\\"translate(-2.5 -16.6)\\\"/></g></svg> </div>\\n\\n</div>\\n</div>\";\nvar host = document.getElementById(\"clip\");\nvar containerParams = {\n  width: \"612px\",\n  height: \"671px\"\n};\nvar clip = new MotorCortex.Clip({\n  css: css,\n  html: html,\n  host: host,\n  fonts: [{\n    type: \"google-font\",\n    src: \"https://fonts.googleapis.com/css?family=Montserrat:100,300,400,700,900&display=swap\"\n  }],\n  containerParams: containerParams\n});\nvar boxWidth = new Anime.Anime({\n  animatedAttrs: {\n    width: \"250px\"\n  }\n}, {\n  duration: 1700,\n  selector: \".boxWidth\",\n  easing: \"easeOutQuad\"\n});\nvar boxColor = new Anime.Anime({\n  animatedAttrs: {\n    background: \"rgb(255, 0, 85)\"\n  },\n  initialValues: {\n    background: \"rgb(37, 32, 86)\"\n  }\n}, {\n  duration: 1700,\n  selector: \".boxColor\",\n  easing: \"easeOutQuad\"\n});\nvar boxRotate = new Anime.Anime({\n  animatedAttrs: {\n    transform: {\n      rotate: \"360deg\"\n    }\n  },\n  initialValues: {\n    transform: {\n      rotate: \"0deg\"\n    }\n  }\n}, {\n  duration: 1700,\n  selector: \".boxRotate\",\n  easing: \"easeOutQuad\"\n});\nvar boxMove = new Anime.Anime({\n  animatedAttrs: {\n    left: \"220px\"\n  },\n  initialValues: {\n    left: \"0px\"\n  }\n}, {\n  duration: 1700,\n  selector: \".boxMove\",\n  easing: \"easeOutBounce\"\n});\nvar boxBorder = new Anime.Anime({\n  animatedAttrs: {\n    borderRadius: \"50%\"\n  },\n  initialValues: {\n    borderRadius: \"0%\"\n  }\n}, {\n  duration: 1700,\n  selector: \".boxBorder\"\n});\nvar opacity = new Anime.Anime({\n  animatedAttrs: {\n    opacity: 1\n  },\n  initialValues: {\n    opacity: 0\n  }\n}, {\n  duration: 1000,\n  selector: \".svgText\"\n});\nvar svg = new Anime.Anime({\n  animatedAttrs: {\n    strokeDashoffset: 0\n  },\n  initialValues: {\n    strokeDashoffset: 6000\n  }\n}, {\n  duration: 3000,\n  selector: \".cls-1\"\n}); // const boxWidthBack = new Anime.Anime(\n//   {\n//     animatedAttrs: {\n//       // width: \"30px\",\n//       opacity: 0,\n//       // height: 30\n//     },\n//     initialValues: {\n//       // width: \"250px\"\n//     },\n//   },\n//   {\n//     duration: 1000,\n//     delay:3000,\n//     hiatus:4000,\n//     repeats:3,\n//     selector: \".boxWidth\",\n//     easing: \"easeOutQuad\"\n//   }\n// );\n\nclip.addIncident(boxWidth, 0);\nclip.addIncident(boxColor, 1700);\nclip.addIncident(boxRotate, 3400);\nclip.addIncident(boxMove, 5100);\nclip.addIncident(boxBorder, 6800);\nclip.addIncident(opacity, 8500);\nclip.addIncident(svg, 9500); // clip.addIncident(boxWidthBack, 0); //12500\n\nnew Player({\n  clip: clip,\n  theme: \"mc-blue\",\n  preview: false,\n  pointerEvents: false\n});\nwindow.myclip = clip;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2luZGV4LmpzPzQxZjUiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgTW90b3JDb3J0ZXggPSByZXF1aXJlKFwiQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9cIik7XG5jb25zdCBQbGF5ZXIgPSByZXF1aXJlKFwiQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC1wbGF5ZXJcIik7XG4vLyBjb25zdCBQbGF5ZXIgPSByZXF1aXJlKFwiLi4vLi4vdGVvLW1vdG9yY29ydGV4LXBsYXllci9zcmMvUGxheWVyXCIpO1xuY29uc3QgQW5pbWVEZWZpbml0aW9uID0gcmVxdWlyZShcIi4uL3NyYy9tYWluXCIpO1xuY29uc3QgQW5pbWUgPSBNb3RvckNvcnRleC5sb2FkUGx1Z2luKEFuaW1lRGVmaW5pdGlvbik7XG5cbmNvbnN0IGNzcyA9IGBcblxuLndyYXBwZXIge1xuICAgIGJhY2tncm91bmQtY29sb3I6ICNmN2Y3Zjc7XG4gICAgaGVpZ2h0OjEwMCU7XG4gICAgd2lkdGg6MTAwJTtcbiAgICBtYXJnaW46MHB4O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICB9XG4gIC5jb250YWluZXIge1xuICAgIFxuICAgIHdpZHRoOiAxMDAlO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIFxuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgY29sb3I6ICMyNTIwNTY7XG4gICAgZm9udC1mYW1pbHk6ICdNb250c2VycmF0Jywgc2Fucy1zZXJpZjtcbiAgfVxuICAudGl0bGUge1xuICAgIGZvbnQtc2l6ZTogNTBweDtcbiAgICBmb250LXdlaWdodDogYm9sZDtcbiAgfVxuICAuc3ViVGl0bGUge1xuICAgIGZvbnQtc2l6ZTogMzBweDtcbiAgfVxuICAudGV4dHtcbiAgICBmb250LXNpemU6IDI0cHg7XG4gICAgZm9udC13ZWlnaHQ6IDEwMDtcbiAgfVxuICAuYm94V2lkdGgsLmJveENvbG9yLC5ib3hSb3RhdGUsLmJveE1vdmUsLmJveEJvcmRlciB7XG4gICAgYmFja2dyb3VuZDogIzI1MjA1NjtcbiAgICB3aWR0aDogMjUwcHg7XG4gICAgaGVpZ2h0OiAzMHB4O1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICBtYXJnaW4tbGVmdDogMzBweFxuICB9XG4gIC5ib3hCb3JkZXJ7XG4gICAgd2lkdGg6IDMwcHg7XG4gICAgYm9yZGVyLXJhZGl1czogMCU7XG4gIH1cbiAgLmJveE1vdmV7XG4gICAgbGVmdDowO1xuICAgIHdpZHRoOiAzMHB4O1xuICB9XG5cbiAgLmJveFdpZHRoe1xuICAgIHdpZHRoOiAzMHB4O1xuICB9XG5cbiAgLmJveENvbG9ye1xuICAgIGJhY2tncm91bmQ6IHJnYigzNywgMzIsIDg2KTtcbiAgfVxuXG4gIC5ib3hSb3RhdGV7XG4gICAgd2lkdGg6MzBweDtcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcbiAgfVxuXG4gIC5kZW1ve1xuICAgIG1hcmdpbi10b3A6IDUlO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIHdpZHRoOiA2MCU7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICB9XG4gIC5kZW1vV2lkdGgsLmRlbW9Db2xvciwuZGVtb1JvdGF0ZSwuZGVtb01vdmUsLmRlbW9Cb3JkZXJ7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAganVzdGlmeS1jb250ZW50OiBzdGFydDtcbiAgfVxuICAuY2xzLTF7XG4gICAgc3Ryb2tlLWRhc2hhcnJheTogNjAwMDtcbiAgICBzdHJva2UtZGFzaG9mZnNldDogNjAwMDtcbiAgfVxuYDtcblxuY29uc3QgaHRtbCA9IGBcbjxkaXYgY2xhc3M9XCJ3cmFwcGVyXCI+XG48ZGl2IGNsYXNzPVwiY29udGFpbmVyXCI+XG4gIDxkaXYgY2xhc3M9XCJ0aXRsZVwiPk1vdG9yQ29ydGV4PC9kaXY+XG4gIDxkaXYgY2xhc3M9XCJzdWJUaXRsZVwiPkFuaW1lIHBsdWdpbjwvZGl2PlxuICA8ZGl2IGNsYXNzPVwidGV4dFwiPkRlbW86PC9kaXY+XG4gIDxkaXYgY2xhc3M9XCJkZW1vXCI+XG4gICAgPGRpdiBjbGFzcz1cImRlbW9XaWR0aFwiPlxuICAgICAgPGRpdiBjbGFzcz1cInRleHRcIj53aWR0aCA6PC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwiYm94V2lkdGhcIj48L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiZGVtb0NvbG9yXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwidGV4dFwiPmJhY2tncm91bmQgY29sb3IgOjwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cImJveENvbG9yXCI+PC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImRlbW9Sb3RhdGVcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJ0ZXh0XCI+Um90YXRlIDo8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJib3hSb3RhdGVcIj48L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiZGVtb01vdmVcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJ0ZXh0XCI+TW92ZSB3aXRoIGVhc2luZ3M6PC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwiYm94TW92ZVwiPiA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiZGVtb0JvcmRlclwiPlxuICAgICAgPGRpdiBjbGFzcz1cInRleHRcIj5Cb3JkZXIgOjwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cImJveEJvcmRlclwiPiA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG4gXG4gIDxkaXYgY2xhc3M9XCJzdWJUaXRsZSBzdmdUZXh0XCI+c3ZnIDwvZGl2PlxuICA8ZGl2IGNsYXNzPVwic3ZnQm9yZGVyXCI+IDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMzAwcHhcIiB2aWV3Qm94PVwiMCAwIDQ5NSA0NjQuM1wiPjxkZWZzPjxzdHlsZT4uY2xzLTF7ZmlsbDpub25lO3N0cm9rZTojMjUyMDU2O3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS13aWR0aDozcHg7fS5jbHMtMntmaWxsOm5vbmU7fTwvc3R5bGU+PC9kZWZzPjx0aXRsZT5tYzI8L3RpdGxlPjxnIGlkPVwiTGF5ZXJfMVwiIGRhdGEtbmFtZT1cIkxheWVyIDFcIj48cGF0aCBjbGFzcz1cImNscy0xXCIgZD1cIk04NiwzNjguNlYxMjguOEwxOTUuMywyNTMuNCw4NiwzNjguNlpNNDk2LDE4LjFINDE5LjhMMjQ2LjQsMTk3LjMsODYuMywxOC4xSDRWNDc5LjNIODAuNUwyOTksMjUwLjFsMTE5LjYtMTI1VjM3MC41bC03MS41LTc0LjRhMy45LDMuOSwwLDAsMC01LjQtLjFsLS4yLjJMMjkzLjIsMzQ4LDQxOC42LDQ3OS4zSDQ5NlpcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoLTIuNSAtMTYuNilcIi8+PC9nPjxnIGlkPVwiTGF5ZXJfMlwiIGRhdGEtbmFtZT1cIkxheWVyIDJcIj48cGF0aCBjbGFzcz1cImNscy0yXCIgZD1cIk04NiwzNjguNlYxMjguOEwxOTUuMywyNTMuNCw4NiwzNjguNlpNNDk2LDE4LjFINDE5LjhMMjQ2LjQsMTk3LjMsODYuMywxOC4xSDRWNDc5LjNIODAuNUwyOTksMjUwLjFsMTE5LjYtMTI1VjM3MC41bC03MS41LTc0LjRhMy45LDMuOSwwLDAsMC01LjQtLjFsLS4yLjJMMjkzLjIsMzQ4LDQxOC42LDQ3OS4zSDQ5NlpcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoLTIuNSAtMTYuNilcIi8+PC9nPjwvc3ZnPiA8L2Rpdj5cblxuPC9kaXY+XG48L2Rpdj5gO1xuXG5jb25zdCBob3N0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjbGlwXCIpO1xuXG5jb25zdCBjb250YWluZXJQYXJhbXMgPSB7XG4gIHdpZHRoOiBcIjYxMnB4XCIsXG4gIGhlaWdodDogXCI2NzFweFwiXG59O1xuXG5jb25zdCBjbGlwID0gbmV3IE1vdG9yQ29ydGV4LkNsaXAoe1xuICBjc3MsXG4gIGh0bWwsXG4gIGhvc3QsXG4gIGZvbnRzOiBbXG4gICAge1xuICAgICAgdHlwZTogYGdvb2dsZS1mb250YCxcbiAgICAgIHNyYzogYGh0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzP2ZhbWlseT1Nb250c2VycmF0OjEwMCwzMDAsNDAwLDcwMCw5MDAmZGlzcGxheT1zd2FwYFxuICAgIH1cbiAgXSxcbiAgY29udGFpbmVyUGFyYW1zXG59KTtcblxuY29uc3QgYm94V2lkdGggPSBuZXcgQW5pbWUuQW5pbWUoXG4gIHtcbiAgICBhbmltYXRlZEF0dHJzOiB7XG4gICAgICB3aWR0aDogXCIyNTBweFwiXG4gICAgfVxuICB9LFxuICB7XG4gICAgZHVyYXRpb246IDE3MDAsXG4gICAgc2VsZWN0b3I6IFwiLmJveFdpZHRoXCIsXG4gICAgZWFzaW5nOiBcImVhc2VPdXRRdWFkXCJcbiAgfVxuKTtcblxuY29uc3QgYm94Q29sb3IgPSBuZXcgQW5pbWUuQW5pbWUoXG4gIHtcbiAgICBhbmltYXRlZEF0dHJzOiB7XG4gICAgICBiYWNrZ3JvdW5kOiBcInJnYigyNTUsIDAsIDg1KVwiXG4gICAgfSxcbiAgICBpbml0aWFsVmFsdWVzOiB7XG4gICAgICBiYWNrZ3JvdW5kOiBcInJnYigzNywgMzIsIDg2KVwiXG4gICAgfVxuICB9LFxuICB7XG4gICAgZHVyYXRpb246IDE3MDAsXG4gICAgc2VsZWN0b3I6IFwiLmJveENvbG9yXCIsXG4gICAgZWFzaW5nOiBcImVhc2VPdXRRdWFkXCJcbiAgfVxuKTtcblxuY29uc3QgYm94Um90YXRlID0gbmV3IEFuaW1lLkFuaW1lKFxuICB7XG4gICAgYW5pbWF0ZWRBdHRyczoge1xuICAgICAgdHJhbnNmb3JtOiB7XG4gICAgICAgIHJvdGF0ZTogXCIzNjBkZWdcIlxuICAgICAgfVxuICAgIH0sXG4gICAgaW5pdGlhbFZhbHVlczoge1xuICAgICAgdHJhbnNmb3JtOiB7XG4gICAgICAgIHJvdGF0ZTogXCIwZGVnXCJcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHtcbiAgICBkdXJhdGlvbjogMTcwMCxcbiAgICBzZWxlY3RvcjogXCIuYm94Um90YXRlXCIsXG4gICAgZWFzaW5nOiBcImVhc2VPdXRRdWFkXCJcbiAgfVxuKTtcblxuY29uc3QgYm94TW92ZSA9IG5ldyBBbmltZS5BbmltZShcbiAge1xuICAgIGFuaW1hdGVkQXR0cnM6IHtcbiAgICAgIGxlZnQ6IFwiMjIwcHhcIlxuICAgIH0sXG4gICAgaW5pdGlhbFZhbHVlczoge1xuICAgICAgbGVmdDogXCIwcHhcIlxuICAgIH1cbiAgfSxcbiAge1xuICAgIGR1cmF0aW9uOiAxNzAwLFxuICAgIHNlbGVjdG9yOiBcIi5ib3hNb3ZlXCIsXG4gICAgZWFzaW5nOiBcImVhc2VPdXRCb3VuY2VcIlxuICB9XG4pO1xuXG5jb25zdCBib3hCb3JkZXIgPSBuZXcgQW5pbWUuQW5pbWUoXG4gIHtcbiAgICBhbmltYXRlZEF0dHJzOiB7XG4gICAgICBib3JkZXJSYWRpdXM6IFwiNTAlXCJcbiAgICB9LFxuICAgIGluaXRpYWxWYWx1ZXM6IHtcbiAgICAgIGJvcmRlclJhZGl1czogXCIwJVwiXG4gICAgfVxuICB9LFxuICB7XG4gICAgZHVyYXRpb246IDE3MDAsXG4gICAgc2VsZWN0b3I6IFwiLmJveEJvcmRlclwiXG4gIH1cbik7XG5cbmNvbnN0IG9wYWNpdHkgPSBuZXcgQW5pbWUuQW5pbWUoXG4gIHtcbiAgICBhbmltYXRlZEF0dHJzOiB7XG4gICAgICBvcGFjaXR5OiAxXG4gICAgfSxcbiAgICBpbml0aWFsVmFsdWVzOiB7XG4gICAgICBvcGFjaXR5OiAwXG4gICAgfVxuICB9LFxuICB7XG4gICAgZHVyYXRpb246IDEwMDAsXG4gICAgc2VsZWN0b3I6IFwiLnN2Z1RleHRcIlxuICB9XG4pO1xuXG5jb25zdCBzdmcgPSBuZXcgQW5pbWUuQW5pbWUoXG4gIHtcbiAgICBhbmltYXRlZEF0dHJzOiB7XG4gICAgICBzdHJva2VEYXNob2Zmc2V0OiAwXG4gICAgfSxcbiAgICBpbml0aWFsVmFsdWVzOiB7XG4gICAgICBzdHJva2VEYXNob2Zmc2V0OiA2MDAwXG4gICAgfVxuICB9LFxuICB7XG4gICAgZHVyYXRpb246IDMwMDAsXG4gICAgc2VsZWN0b3I6IFwiLmNscy0xXCJcbiAgfVxuKTtcblxuLy8gY29uc3QgYm94V2lkdGhCYWNrID0gbmV3IEFuaW1lLkFuaW1lKFxuLy8gICB7XG4vLyAgICAgYW5pbWF0ZWRBdHRyczoge1xuLy8gICAgICAgLy8gd2lkdGg6IFwiMzBweFwiLFxuLy8gICAgICAgb3BhY2l0eTogMCxcbi8vICAgICAgIC8vIGhlaWdodDogMzBcbi8vICAgICB9LFxuLy8gICAgIGluaXRpYWxWYWx1ZXM6IHtcbi8vICAgICAgIC8vIHdpZHRoOiBcIjI1MHB4XCJcbi8vICAgICB9LFxuXG4vLyAgIH0sXG4vLyAgIHtcbi8vICAgICBkdXJhdGlvbjogMTAwMCxcbi8vICAgICBkZWxheTozMDAwLFxuLy8gICAgIGhpYXR1czo0MDAwLFxuLy8gICAgIHJlcGVhdHM6Myxcbi8vICAgICBzZWxlY3RvcjogXCIuYm94V2lkdGhcIixcbi8vICAgICBlYXNpbmc6IFwiZWFzZU91dFF1YWRcIlxuLy8gICB9XG4vLyApO1xuXG5jbGlwLmFkZEluY2lkZW50KGJveFdpZHRoLCAwKTtcbmNsaXAuYWRkSW5jaWRlbnQoYm94Q29sb3IsIDE3MDApO1xuY2xpcC5hZGRJbmNpZGVudChib3hSb3RhdGUsIDM0MDApO1xuY2xpcC5hZGRJbmNpZGVudChib3hNb3ZlLCA1MTAwKTtcbmNsaXAuYWRkSW5jaWRlbnQoYm94Qm9yZGVyLCA2ODAwKTtcbmNsaXAuYWRkSW5jaWRlbnQob3BhY2l0eSwgODUwMCk7XG5jbGlwLmFkZEluY2lkZW50KHN2ZywgOTUwMCk7XG4vLyBjbGlwLmFkZEluY2lkZW50KGJveFdpZHRoQmFjaywgMCk7IC8vMTI1MDBcbm5ldyBQbGF5ZXIoe1xuICBjbGlwOiBjbGlwLFxuICB0aGVtZTogXCJtYy1ibHVlXCIsXG4gIHByZXZpZXc6IGZhbHNlLFxuICBwb2ludGVyRXZlbnRzOiBmYWxzZVxufSk7XG5cbndpbmRvdy5teWNsaXAgPSBjbGlwO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFvRkE7QUFtQ0E7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRkE7QUFLQTtBQVZBO0FBYUE7QUFFQTtBQUNBO0FBREE7QUFEQTtBQU1BO0FBQ0E7QUFDQTtBQUhBO0FBT0E7QUFFQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFKQTtBQVNBO0FBQ0E7QUFDQTtBQUhBO0FBT0E7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQU5BO0FBYUE7QUFDQTtBQUNBO0FBSEE7QUFPQTtBQUVBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUpBO0FBU0E7QUFDQTtBQUNBO0FBSEE7QUFPQTtBQUVBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUpBO0FBU0E7QUFDQTtBQUZBO0FBTUE7QUFFQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFKQTtBQVNBO0FBQ0E7QUFGQTtBQU1BO0FBRUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBSkE7QUFTQTtBQUNBO0FBRkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./index.js\n");

/***/ })

/******/ });